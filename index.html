
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureWorks WA - Patio Designer Pro V18</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js"></script>
    <style>
        :root {
            --sw-orange: #F15A29;
            --sw-blue-dark: #293C46;
            --sw-white: #FFFFFF;
            --sw-bg: #F5F5F7;
            --sw-border: #E5E5E5;
            --sw-text: #1D1D1F;
            --sw-text-sec: #86868B;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: var(--sw-bg);
            color: var(--sw-text);
        }
        .header {
            background: var(--sw-white);
            border-bottom: 1px solid var(--sw-border);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo { display: flex; align-items: center; gap: 8px; }
        .logo-icon {
            width: 32px; height: 32px;
            background: var(--sw-orange);
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
        }
        .logo-icon svg { width: 18px; height: 18px; fill: white; }
        .logo-text { font-size: 16px; font-weight: 600; }
        .logo-text span { color: var(--sw-orange); }
        .job-badge { background: var(--sw-bg); padding: 6px 14px; border-radius: 16px; font-size: 13px; }
        .job-badge strong { color: var(--sw-orange); }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }
        .btn-primary { background: var(--sw-orange); color: white; }
        .btn-secondary { background: var(--sw-bg); color: var(--sw-text); border: 1px solid var(--sw-border); }
        .main { max-width: 1400px; margin: 0 auto; padding: 24px; display: flex; gap: 24px; align-items: flex-start; }
        .panel-left { flex: 0 0 45%; min-width: 0; overflow-y: auto; max-height: calc(100vh - 80px); }
        .panel-right { flex: 0 0 calc(55% - 24px); position: sticky; top: 80px; max-height: calc(100vh - 100px); overflow-y: auto; height: fit-content; }
        .main.full-width .panel-left { flex: 0 0 100%; max-height: none; }
        .main.full-width .panel-right { display: none; }
        /* Right panel cards */
        .rp-card { background: var(--sw-white); border-radius: 12px; box-shadow: 0 1px 8px rgba(0,0,0,0.04); overflow: hidden; margin-bottom: 16px; }
        .rp-card-hdr { padding: 12px 16px; border-bottom: 1px solid var(--sw-border); font-size: 14px; font-weight: 600; }
        .rp-card-body { padding: 16px; }
        .rp-summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .rp-summary-item { background: var(--sw-bg); border-radius: 8px; padding: 8px 10px; }
        .rp-summary-label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); }
        .rp-summary-value { font-size: 14px; font-weight: 600; font-family: 'SF Mono', monospace; }
        .rp-est-range { font-size: 20px; font-weight: 700; font-family: 'SF Mono', monospace; text-align: center; padding: 8px 0; }
        .rp-est-label { font-size: 11px; color: var(--sw-text-sec); text-align: center; }
        .rp-est-btn { margin-top: 12px; }
        .rp-est-btn .btn { width: 100%; text-align: center; }
        .section {
            background: var(--sw-white);
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 1px 8px rgba(0,0,0,0.04);
            overflow: hidden;
        }
        .section-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--sw-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .section-title { font-size: 14px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        .section-subtitle { font-size: 12px; color: var(--sw-text-sec); }
        .section-body { padding: 16px; }

        /* Basics section (always expanded) */
        .basics-hdr { padding: 12px 16px; border-bottom: 1px solid var(--sw-border); display: flex; justify-content: space-between; align-items: center; }
        .basics-group { margin-bottom: 0; }
        .basics-group-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .basics-divider { height: 1px; background: var(--sw-border); margin: 14px 0; }
        .basics-grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        .basics-grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .basics-grid-4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 8px; }
        .basics-field label { font-size: 11px; font-weight: 500; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .basics-field input, .basics-field select, .basics-field textarea { width: 100%; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 12px; }
        .basics-field input:focus, .basics-field select:focus { outline: none; border-color: var(--sw-orange); }
        .basics-colours { display: flex; gap: 24px; align-items: flex-start; }
        .basics-colour-block { flex: 1; }
        .basics-colour-label { font-size: 10px; color: var(--sw-text-sec); margin-bottom: 4px; }
        .extras-cost { margin-top: 6px; }
        .extras-cost label { font-size: 10px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .extras-cost input { width: 100%; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 12px; }

        .setup-grid { display: grid; grid-template-columns: 320px 1fr 280px; gap: 20px; }
        .options-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 16px; }
        .setup-card { background: var(--sw-bg); border-radius: 10px; padding: 14px; }
        .setup-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 10px; }
        .field { margin-bottom: 10px; }
        .field-label { display: flex; justify-content: space-between; font-size: 12px; font-weight: 500; margin-bottom: 3px; }
        .field-unit { font-size: 10px; color: var(--sw-text-sec); }
        .field-input { width: 100%; padding: 7px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; }
        .field-input:focus { outline: none; border-color: var(--sw-orange); }
        .field-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .plan-2d { background: #EEF1F4; border-radius: 8px; height: 220px; }
        .plan-2d canvas { width: 100%; height: 100%; }
        .color-chips { display: flex; flex-wrap: wrap; gap: 5px; }
        .color-chip { width: 24px; height: 24px; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
        .color-chip.active { border-color: var(--sw-text); }
        .color-label { font-size: 11px; color: var(--sw-text-sec); margin-top: 6px; }
        .calc-display { background: var(--sw-blue-dark); border-radius: 8px; padding: 10px; margin-top: 10px; color: white; }
        .calc-row { display: flex; justify-content: space-between; font-size: 11px; padding: 3px 0; }
        .calc-label { opacity: 0.7; }
        .calc-value { font-weight: 600; font-family: 'SF Mono', monospace; color: var(--sw-orange); }

        .truss-viewport { background: linear-gradient(180deg, #E8ECF0 0%, #D5DAE0 100%); border-radius: 10px; height: 360px; position: relative; overflow: hidden; }
        .truss-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .truss-viewport canvas:active { cursor: grabbing; }
        .truss-view-btns { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.9); padding: 3px; border-radius: 6px; }
        .truss-view-btn { padding: 5px 10px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .truss-view-btn.active { background: var(--sw-blue-dark); color: white; }
        .truss-panel-vertical { display: flex; flex-direction: column; gap: 12px; margin-top: 12px; }
        .truss-cards-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        .truss-card { background: var(--sw-bg); border-radius: 10px; padding: 12px; }
        .truss-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .spec-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .spec-item { background: white; border-radius: 6px; padding: 8px; text-align: center; }
        .spec-label { font-size: 9px; color: var(--sw-text-sec); }
        .spec-value { font-size: 15px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .spec-value.hl { color: var(--sw-orange); }
        .fab-box { background: var(--sw-blue-dark); border-radius: 10px; padding: 12px; color: white; }
        .fab-box h4 { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; margin-bottom: 8px; }
        .fab-line { font-family: 'SF Mono', monospace; font-size: 11px; padding: 4px 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-bottom: 2px; }
        .truss-config { display: flex; gap: 12px; padding: 8px 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; }
        .truss-config-item { display: flex; align-items: center; gap: 6px; }
        .truss-config-item > label { font-size: 11px; font-weight: 600; color: var(--sw-text); display: flex; align-items: center; gap: 4px; cursor: pointer; white-space: nowrap; }
        .truss-config-item input[type="checkbox"] { accent-color: var(--sw-orange); }
        .truss-opt-fields { display: flex; gap: 6px; align-items: center; }
        .truss-opt-fields label { font-size: 10px; color: var(--sw-text-sec); display: flex; align-items: center; gap: 3px; white-space: nowrap; }
        .truss-opt-fields input[type="number"] { width: 52px; font-size: 11px; padding: 2px 4px; border: 1px solid var(--sw-border); border-radius: 4px; }
        .truss-opt-fields span { font-size: 9px; color: var(--sw-text-sec); }

        .asm-viewport { height: 520px; background: linear-gradient(180deg, #D4D9E0 0%, #BCC4CC 100%); border-radius: 10px; position: relative; }
        .asm-viewport canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        .asm-viewport canvas:active { cursor: grabbing; }
        .asm-viewport.fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100vw; height: 100vh; z-index: 1000; border-radius: 0; }
        .layer-panel { position: absolute; top: 12px; left: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; min-width: 140px; }
        .layer-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .layer-item { display: flex; align-items: center; gap: 6px; padding: 4px 0; cursor: pointer; font-size: 11px; }
        .layer-check { width: 14px; height: 14px; border: 2px solid var(--sw-border); border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 9px; color: white; }
        .layer-item.active .layer-check { background: var(--sw-orange); border-color: var(--sw-orange); }
        .layer-item.active .layer-check::after { content: '✓'; }
        .mat-panel { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; width: 200px; }
        .mat-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .mat-row { display: flex; justify-content: space-between; font-size: 10px; padding: 3px 0; border-bottom: 1px solid var(--sw-border); }
        .mat-row:last-child { border-bottom: none; }
        .mat-qty { font-weight: 600; color: var(--sw-orange); }
        .view-panel { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.95); padding: 3px; border-radius: 6px; }
        .view-btn { padding: 5px 12px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .view-btn.active { background: var(--sw-blue-dark); color: white; }
        .fullscreen-btn { position: absolute; top: 12px; right: 230px; background: rgba(255,255,255,0.95); border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; font-size: 11px; }
        .tooltip { position: absolute; background: rgba(41,60,70,0.95); color: white; padding: 10px 14px; border-radius: 8px; font-size: 11px; pointer-events: none; opacity: 0; transition: opacity 0.15s; z-index: 50; max-width: 240px; }
        .tooltip.visible { opacity: 1; }
        .tooltip-title { font-weight: 600; font-size: 12px; color: var(--sw-orange); margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .tooltip-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .tooltip-label { opacity: 0.7; }
        .tooltip-value { font-weight: 500; font-family: 'SF Mono', monospace; }

        /* Polycarb preview blocks */
        .pc-block { width: 16px; height: 20px; border-radius: 2px; border: 1px solid #ccc; }
        .pc-block.steel { background: #6B7B8D; border-color: #5A6A7C; }
        .pc-block.polycarb { border-color: #8ECAE6; }

        /* Pricing Section - Card Layout */
        .pricing-cards-container { display: flex; flex-direction: column; gap: 24px; }
        .q-card { background: #fff; border-radius: 8px; padding: 20px 24px; box-shadow: 0 1px 4px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04); }
        .q-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .q-card-title { font-size: 15px; font-weight: 600; color: var(--sw-text); display: flex; align-items: center; gap: 8px; }
        .q-card-title .status-ok { color: #34C759; }
        .q-card-title .status-warn { color: #FF9500; }
        .q-card-amount { font-size: 22px; font-weight: 700; font-family: 'SF Mono', monospace; color: var(--sw-text); }
        .q-card-sub { font-size: 13px; color: var(--sw-text-sec); margin-bottom: 0; }
        .q-card-edit { font-size: 13px; color: var(--sw-orange); cursor: pointer; font-weight: 500; background: none; border: none; padding: 0; }
        .q-card-edit:hover { text-decoration: underline; }
        /* Labour inline */
        .labour-inline { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
        .labour-inline .li-input { width: 60px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: center; }
        .labour-inline .li-input:focus { outline: none; border-color: var(--sw-orange); }
        .labour-inline .li-input.wide { width: 80px; }
        .labour-inline .li-label { font-size: 13px; color: var(--sw-text-sec); }
        .labour-inline .li-equals { font-size: 14px; font-weight: 600; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .labour-sell-row { display: flex; align-items: center; gap: 10px; margin-top: 10px; padding-top: 10px; border-top: 1px solid #f0f0f0; }
        .labour-sell-row label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .labour-sell-row input { width: 120px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: right; }
        .labour-sell-row input:focus { outline: none; border-color: var(--sw-orange); }
        /* Extras pills & rows */
        .extras-pills { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
        .extras-pill { padding: 7px 14px; border-radius: 20px; border: 1px solid var(--sw-border); background: #fff; font-size: 13px; cursor: pointer; color: var(--sw-text); transition: all 0.15s; }
        .extras-pill:hover { border-color: var(--sw-orange); color: var(--sw-orange); background: #FFF5F0; }
        .extras-rows { margin-top: 16px; display: flex; flex-direction: column; gap: 8px; }
        .extras-row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #f9f9f9; border-radius: 6px; border: 1px solid #f0f0f0; }
        .extras-row .ex-desc { flex: 1; font-size: 13px; font-weight: 500; color: var(--sw-text); }
        .extras-row .ex-field { display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--sw-text-sec); }
        .extras-row .ex-input { width: 80px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: right; }
        .extras-row .ex-input:focus { outline: none; border-color: var(--sw-orange); }
        .extras-row .ex-input.desc-input { width: 160px; text-align: left; font-family: inherit; }
        .extras-row .ex-remove { background: none; border: none; color: #ccc; cursor: pointer; font-size: 18px; padding: 0 4px; line-height: 1; transition: color 0.15s; }
        .extras-row .ex-remove:hover { color: #FF3B30; }
        /* Total card */
        .total-card { background: #fff; border-radius: 8px; padding: 28px 24px; box-shadow: 0 1px 4px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04); text-align: center; }
        .total-amount { font-size: 32px; font-weight: 800; font-family: 'SF Mono', monospace; color: var(--sw-text); letter-spacing: -0.5px; }
        .total-label { font-size: 13px; color: var(--sw-text-sec); margin-top: 2px; }
        .total-margin { font-size: 14px; font-weight: 600; margin-top: 10px; font-family: 'SF Mono', monospace; }
        .total-margin.margin-green { color: #34C759; }
        .total-margin.margin-orange { color: #FF9500; }
        .total-margin.margin-red { color: #FF3B30; }
        .btn-generate-quote { display: block; width: 100%; padding: 14px; border: none; border-radius: 8px; background: #F26522; color: white; font-size: 15px; font-weight: 600; cursor: pointer; margin-top: 20px; letter-spacing: 0.3px; transition: background 0.15s; }
        .btn-generate-quote:hover { background: #e05a1a; }
        .total-links { display: flex; justify-content: center; gap: 24px; margin-top: 14px; }
        .total-links a { font-size: 13px; color: var(--sw-text-sec); cursor: pointer; text-decoration: none; }
        .total-links a:hover { color: var(--sw-orange); }
        /* Settings gear */
        .settings-gear { background: none; border: none; cursor: pointer; font-size: 16px; color: var(--sw-text-sec); padding: 4px; transition: color 0.15s; }
        .settings-gear:hover { color: var(--sw-orange); }
        /* Materials modal */
        .mat-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .mat-modal { background: white; border-radius: 12px; padding: 24px; max-width: 800px; width: 95%; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .mat-modal h3 { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
        .mat-modal-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; }
        .mat-modal-controls label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .mat-modal-controls input { width: 60px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: center; }
        .mat-modal-controls input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-controls .btn-apply { padding: 6px 14px; border-radius: 6px; border: 1px solid var(--sw-orange); background: #FFF5F0; color: var(--sw-orange); font-size: 12px; font-weight: 500; cursor: pointer; }
        .mat-modal-controls .btn-apply:hover { background: var(--sw-orange); color: white; }
        .mat-modal-controls .toggle-wrap { display: flex; align-items: center; gap: 6px; margin-left: auto; }
        .mat-modal-controls .toggle-wrap input[type="checkbox"] { accent-color: var(--sw-orange); }
        .mat-modal-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .mat-modal-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 8px 8px; border-bottom: 2px solid var(--sw-border); }
        .mat-modal-table th.r { text-align: right; }
        .mat-modal-table td { padding: 6px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; vertical-align: middle; }
        .mat-modal-table td.r { text-align: right; }
        .mat-modal-table td.mono { font-family: 'SF Mono', monospace; font-size: 12px; }
        .mat-modal-table tr:last-child td { border-bottom: none; }
        .mat-modal-table input { width: 80px; padding: 5px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .mat-modal-table input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-table .markup-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 500; background: #E8F5E9; color: #2E7D32; }
        .mat-modal-table .markup-badge.custom { background: #FFF3E0; color: #E65100; }
        .mat-modal-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--sw-border); }
        .mat-modal-footer .mat-total { font-size: 16px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .mat-modal-footer .btn-done { padding: 10px 28px; border-radius: 6px; border: none; background: var(--sw-orange); color: white; font-size: 14px; font-weight: 500; cursor: pointer; }
        .mat-modal-footer .btn-done:hover { background: #e05a1a; }
        .mat-modal-footer .btn-add-custom { padding: 8px 16px; border-radius: 6px; border: 1px dashed var(--sw-border); background: none; font-size: 12px; color: var(--sw-text-sec); cursor: pointer; }
        .mat-modal-footer .btn-add-custom:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        /* Rates modal */
        .rates-modal { background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .rates-modal h3 { font-size: 16px; font-weight: 600; margin-bottom: 16px; }
        .rate-input { width: 80px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .rate-input:focus { outline: none; border-color: var(--sw-orange); }
        .pricing-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .pricing-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 6px 8px; border-bottom: 2px solid var(--sw-border); }
        .pricing-table td { padding: 5px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; }
        .pricing-table th.r, .pricing-table td.r { text-align: right; }
        .pricing-table tr:last-child td { border-bottom: none; }
        /* Hidden elements for PDF compatibility */
        .pdf-data { display: none; }
        /* Collapsible sections */
        .collapse-header { padding: 12px 20px; border-bottom: 1px solid var(--sw-border); display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
        .collapse-header:hover { background: var(--sw-bg); }
        .collapse-header .section-title { font-size: 15px; font-weight: 600; }
        .collapse-header .section-subtitle { font-size: 11px; color: var(--sw-text-sec); }
        .collapse-arrow { font-size: 12px; color: var(--sw-text-sec); transition: transform 0.25s ease; flex-shrink: 0; margin-left: 12px; }
        .collapse-header.collapsed .collapse-arrow { transform: rotate(-90deg); }
        .collapse-header.collapsed { border-bottom: none; }
        .collapse-body { overflow: hidden; transition: max-height 0.35s ease, opacity 0.25s ease; max-height: 2000px; opacity: 1; }
        .collapse-body.shut { max-height: 0; opacity: 0; padding-top: 0; padding-bottom: 0; }
        /* Import/Export modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .modal-box { background: white; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .modal-box h3 { font-size: 16px; margin-bottom: 12px; }
        .modal-box textarea { width: 100%; height: 200px; font-family: 'SF Mono', monospace; font-size: 11px; border: 1px solid var(--sw-border); border-radius: 6px; padding: 10px; resize: vertical; }
        .modal-box textarea:focus { outline: none; border-color: var(--sw-orange); }
        .modal-btns { display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end; }
        .modal-status { font-size: 12px; color: #34C759; margin-top: 8px; min-height: 18px; }
        .job-details-grid { display: grid; grid-template-columns: 140px 1fr 1fr 150px 150px 140px; gap: 10px; align-items: end; }
        .job-details-grid label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .job-details-grid input, .job-details-grid select { width: 100%; font-size: 12px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-family: inherit; }
        .job-details-grid input:focus, .job-details-grid select:focus { outline: none; border-color: var(--sw-orange); }
        .job-ref-input { font-family: 'SF Mono', monospace !important; font-weight: 600; color: var(--sw-orange); }
        /* Notes card */
        .notes-inline { margin-top: 12px; }
        .notes-inline textarea { width: 100%; padding: 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; min-height: 60px; }
        .notes-inline textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Customer details section */
        .customer-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
        .customer-grid label { font-size: 12px; font-weight: 500; margin-bottom: 4px; display: block; }
        .customer-grid input { width: 100%; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; }
        .customer-grid input:focus { outline: none; border-color: var(--sw-orange); }
        /* Site details subsection */
        .site-details { background: var(--sw-bg); border-radius: 10px; padding: 16px 20px; margin-top: 16px; }
        .site-details-label { font-size: 13px; font-weight: 600; margin-bottom: 4px; }
        .site-details-hint { font-size: 11px; color: var(--sw-text-sec); margin-bottom: 14px; }
        .site-details-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 14px; }
        .radio-group-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .radio-options { display: flex; flex-wrap: wrap; gap: 4px; }
        .radio-pill input[type="radio"] { display: none; }
        .radio-pill span { display: inline-block; padding: 4px 10px; font-size: 12px; border: 1px solid var(--sw-border); border-radius: 16px; cursor: pointer; background: var(--sw-white); transition: all 0.15s; }
        .radio-pill input[type="radio"]:checked + span { background: var(--sw-orange); color: white; border-color: var(--sw-orange); }
        .site-notes-wrap { grid-column: 1 / -1; }
        .site-notes-wrap textarea { width: 100%; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; }
        .site-notes-wrap textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Estimate Options section */
        .estimate-cards { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .est-card { border-radius: 10px; padding: 20px; display: flex; flex-direction: column; }
        .est-card--quick { background: var(--sw-bg); }
        .est-card--full { background: var(--sw-white); border: 1px solid var(--sw-border); }
        .est-card-icon { font-size: 20px; margin-bottom: 4px; }
        .est-card-title { font-size: 15px; font-weight: 700; margin-bottom: 2px; }
        .est-card-desc { font-size: 12px; color: var(--sw-text-sec); line-height: 1.4; }
        .est-card-divider { border: none; border-top: 1px solid var(--sw-border); margin: 14px 0; }
        .est-card-stat { font-size: 13px; color: var(--sw-text-sec); margin-bottom: 2px; }
        .est-card-range { font-size: 22px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .est-card-gst { font-size: 11px; color: var(--sw-text-sec); }
        .est-card-btn { margin-top: auto; padding-top: 16px; }
        .est-card-btn .btn { width: 100%; text-align: center; }
        .est-hint { font-size: 12px; color: var(--sw-text-sec); margin-top: 16px; }
        /* Detailed Configuration groups */
        .cfg-group { border: 1px solid var(--sw-border); border-radius: 8px; margin-bottom: 8px; overflow: hidden; }
        .cfg-group:last-child { margin-bottom: 0; }
        .cfg-group-hdr { display: flex; align-items: center; gap: 8px; padding: 10px 14px; cursor: pointer; user-select: none; background: var(--sw-bg); font-size: 13px; font-weight: 600; }
        .cfg-group-hdr:hover { background: #ECECEE; }
        .cfg-group-arrow { font-size: 10px; color: var(--sw-text-sec); transition: transform 0.2s; }
        .cfg-group-arrow.open { transform: rotate(90deg); }
        .cfg-group-num { color: var(--sw-text-sec); font-size: 11px; font-weight: 500; }
        .cfg-group-body { display: none; }
        .cfg-group-body.open { display: block; }
        .cfg-group-body .mat-hdr { display: grid; grid-template-columns: 1fr 50px 130px 60px 120px; gap: 4px; padding: 5px 14px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); border-bottom: 1px solid var(--sw-border); }
        .cfg-group-body .mat-row { display: grid; grid-template-columns: 1fr 50px 130px 60px 120px; gap: 4px; font-size: 12px; padding: 6px 14px; border-bottom: 1px solid #f0f0f0; align-items: baseline; }
        .cfg-group-body .mat-row:last-child { border-bottom: none; }
        .cfg-group-body .mat-qty { font-weight: 600; color: var(--sw-orange); font-family: 'SF Mono', monospace; font-size: 11px; text-align: right; }
        .cfg-group-body .mat-size { font-size: 11px; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .cfg-group-body .mat-len { font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; }
        .cfg-group-body .mat-clr { font-size: 11px; color: var(--sw-text-sec); }
        .cfg-group-empty { padding: 10px 14px; font-size: 12px; color: var(--sw-text-sec); font-style: italic; }
        /* Pre-order checks */
        .preorder-box { background: var(--sw-bg); border-radius: 8px; padding: 12px 16px; margin-bottom: 16px; }
        .preorder-title { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .preorder-item { font-size: 13px; padding: 3px 0; display: flex; align-items: center; gap: 6px; }
        .preorder-ok { color: #22c55e; }
        .preorder-warn { color: #f59e0b; }

        /* ==================== FLASHING EDITOR ==================== */
        .flash-viewport { background: #fff; border-radius: 10px; border: 1px solid var(--sw-border); position: relative; overflow: hidden; height: 400px; }
        .flash-viewport canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        .flash-viewport canvas.mode-move { cursor: grab; }
        .flash-viewport canvas.mode-move:active { cursor: grabbing; }
        .flash-toolbar { display: flex; gap: 4px; padding: 8px 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; align-items: center; }
        .flash-tool-btn { padding: 5px 10px; border: 1px solid var(--sw-border); background: var(--sw-white); border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); transition: all 0.15s; }
        .flash-tool-btn:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        .flash-tool-btn.active { background: var(--sw-blue-dark); color: white; border-color: var(--sw-blue-dark); }
        .flash-tool-sep { width: 1px; height: 20px; background: var(--sw-border); margin: 0 4px; }
        .flash-info { display: flex; gap: 16px; padding: 8px 12px; border-top: 1px solid var(--sw-border); font-size: 11px; color: var(--sw-text-sec); align-items: center; }
        .flash-info-val { font-weight: 600; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .flash-fields { display: grid; grid-template-columns: 1fr 120px 80px 80px 60px; gap: 8px; padding: 12px; border-bottom: 1px solid var(--sw-border); align-items: end; }
        .flash-fields label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .flash-fields input, .flash-fields select { width: 100%; font-size: 12px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-family: inherit; }
        .flash-fields input:focus, .flash-fields select:focus { outline: none; border-color: var(--sw-orange); }
        .flash-templates { display: flex; gap: 8px; padding: 12px; overflow-x: auto; border-top: 1px solid var(--sw-border); }
        .flash-tpl { min-width: 80px; padding: 8px; border: 1px solid var(--sw-border); border-radius: 6px; cursor: pointer; text-align: center; transition: all 0.15s; flex-shrink: 0; }
        .flash-tpl:hover { border-color: var(--sw-orange); }
        .flash-tpl.active { border-color: var(--sw-orange); background: #FFF5F0; }
        .flash-tpl canvas { display: block; margin: 0 auto 4px; }
        .flash-tpl-name { font-size: 9px; color: var(--sw-text-sec); white-space: nowrap; }
        .flash-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .flash-table th { text-align: left; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 6px 10px; border-bottom: 2px solid var(--sw-border); }
        .flash-table th.r { text-align: right; }
        .flash-table td { padding: 6px 10px; border-bottom: 1px solid #f0f0f0; vertical-align: middle; }
        .flash-table td.r { text-align: right; }
        .flash-table td.mono { font-family: 'SF Mono', monospace; font-size: 11px; }
        .flash-table tr:last-child td { border-bottom: none; }
        .flash-table tr:hover { background: #FAFAFA; }
        .flash-table tr.selected { background: #FFF5F0; }
        .flash-table .flash-row-actions { display: flex; gap: 4px; }
        .flash-table .flash-row-btn { background: none; border: none; cursor: pointer; font-size: 14px; color: #ccc; padding: 0 4px; transition: color 0.15s; }
        .flash-table .flash-row-btn:hover { color: var(--sw-orange); }
        .flash-table .flash-row-btn.del:hover { color: #FF3B30; }
        .flash-total-row { display: flex; justify-content: flex-end; padding: 8px 12px; font-size: 12px; font-weight: 600; color: var(--sw-text); border-top: 1px solid var(--sw-border); }
        .flash-total-row span { font-family: 'SF Mono', monospace; margin-left: 8px; color: var(--sw-orange); }
        .flash-colour-side { display: flex; gap: 4px; align-items: center; }
        .flash-cs-btn { padding: 3px 8px; border: 1px solid var(--sw-border); background: var(--sw-white); border-radius: 3px; font-size: 10px; cursor: pointer; }
        .flash-cs-btn.active { background: var(--sw-orange); color: white; border-color: var(--sw-orange); }
        .flash-header-row { display: flex; justify-content: space-between; align-items: center; padding: 0 0 8px 0; }
        .flash-header-row .section-subtitle { margin: 0; }
        /* Template Folders */
        .template-folders { padding: 8px 12px; }
        .template-folder { margin-bottom: 4px; border: 1px solid var(--sw-border); border-radius: 6px; overflow: hidden; }
        .folder-header { display: flex; align-items: center; gap: 6px; padding: 6px 10px; cursor: pointer; user-select: none; font-size: 11px; font-weight: 600; color: var(--sw-text); background: var(--sw-bg); transition: background 0.15s; }
        .folder-header:hover { background: #E8EAED; }
        .folder-icon { font-size: 13px; }
        .folder-contents { display: flex; flex-wrap: wrap; gap: 6px; padding: 8px 10px; }
        .folder-contents.collapsed { display: none; }
        .folder-contents .flash-tpl { min-width: 70px; padding: 6px; font-size: 10px; }
        .folder-contents .flash-tpl canvas { width: 56px; height: 34px; }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon"><svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg></div>
            <div class="logo-text">Secure<span>Works</span> WA</div>
        </div>
        <div class="job-badge" id="headerBadge"><strong>SW—</strong></div>
        <div style="display:flex;gap:8px">
            <button class="btn btn-secondary" id="layoutToggle" onclick="toggleLayout()">&#9703; Full Width</button>
            <button class="btn btn-secondary" onclick="showLoadJobModal()">Load Job</button>
            <button class="btn btn-primary" onclick="exportOrder()">Export Order</button>
        </div>
    </header>

    <main class="main" id="mainLayout">
        <div class="panel-left">

        <!-- ============ SECTION: BASICS (always expanded) ============ -->
        <div class="section" id="sec-basics">
            <div class="basics-hdr">
                <div class="section-title">Basics</div>
                <div style="display:flex;gap:6px">
                    <button class="btn btn-secondary" style="font-size:11px;padding:5px 10px" onclick="exportJobData()">Export</button>
                    <button class="btn btn-secondary" style="font-size:11px;padding:5px 10px" onclick="showImportModal()">Import</button>
                </div>
            </div>
            <div class="section-body">

                <!-- ROW 1: Job Details -->
                <div class="basics-group">
                    <div class="basics-group-title">Job Details</div>
                    <div class="basics-grid-3">
                        <div class="basics-field">
                            <label>Job Ref</label>
                            <input type="text" id="jobRef" placeholder="SW250208-01">
                        </div>
                        <div class="basics-field">
                            <label>Salesperson</label>
                            <select id="salesperson">
                                <option value="Nithin">Nithin</option>
                                <option value="Marnin">Marnin</option>
                                <option value="Other">Other</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Email</label>
                            <input type="text" id="clientEmail" placeholder="client@email.com">
                        </div>
                    </div>
                    <div class="basics-grid-4" style="margin-top:6px">
                        <div class="basics-field">
                            <label>Customer Name</label>
                            <input type="text" id="customerName" placeholder="Full name" oninput="updateCustomer()">
                        </div>
                        <div class="basics-field" style="grid-column:span 2">
                            <label>Address</label>
                            <input type="text" id="customerAddress" placeholder="Street, suburb, postcode" oninput="updateCustomer()">
                        </div>
                        <div class="basics-field">
                            <label>Phone</label>
                            <input type="text" id="customerPhone" placeholder="0412 345 678" oninput="updateCustomer()">
                        </div>
                    </div>
                    <!-- Hidden fields for save/load compatibility -->
                    <input type="hidden" id="clientName"><input type="hidden" id="siteAddress"><input type="hidden" id="clientPhone">
                </div>

                <div class="basics-divider"></div>

                <!-- ROW 2: Patio Size -->
                <div class="basics-group">
                    <div class="basics-group-title">Patio Size</div>
                    <div class="basics-grid-4">
                        <div class="basics-field">
                            <label>Projection <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                            <input type="number" id="inWidth" value="3" step="0.1" oninput="rebuildAll()">
                        </div>
                        <div class="basics-field">
                            <label>Length <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                            <input type="number" id="inLength" value="6" step="0.1" oninput="rebuildAll()">
                        </div>
                        <div class="basics-field">
                            <label>Post Height <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                            <input type="number" id="inPostHeight" value="2.4" step="0.1" oninput="rebuildAll()">
                        </div>
                        <div class="basics-field" id="pitchField">
                            <label>Pitch <span style="color:var(--sw-text-sec);font-size:9px">&deg;</span></label>
                            <input type="number" id="inPitch" value="10" step="0.5" oninput="rebuildAll()">
                        </div>
                    </div>
                </div>

                <div class="basics-divider"></div>

                <!-- ROW 3: Build Type -->
                <div class="basics-group">
                    <div class="basics-group-title">Build Type</div>
                    <div class="basics-grid-4">
                        <div class="basics-field">
                            <label>Roof Style</label>
                            <select id="inRoofStyle" onchange="updateUI(); rebuildAll()">
                                <option value="gable">Gable</option>
                                <option value="skillion">Skillion</option>
                                <option value="hip">Hip</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Attachment</label>
                            <select id="inConnection" onchange="updateUI(); rebuildAll()">
                                <option value="riser">Riser Beam</option>
                                <option value="flyover">Flyover</option>
                                <option value="freestanding">Freestanding</option>
                                <option value="fascia">Fascia / Receiving</option>
                                <option value="wall">Wall Mount</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Material</label>
                            <select id="inRoofing" onchange="updateUI(); rebuildAll()">
                                <option value="solarspan75">SolarSpan 75mm</option>
                                <option value="solarspan100">SolarSpan 100mm</option>
                                <option value="trimdek">Trimdek</option>
                                <option value="corrugated">Corrugated</option>
                                <option value="spanplus330">SpanPlus 330</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Post Fixing</label>
                            <select id="inPostFix">
                                <option value="concrete">In-ground (concrete footings)</option>
                                <option value="baseplate">Baseplate (bolt to slab)</option>
                            </select>
                        </div>
                    </div>
                    <!-- Frame Steel Sizes -->
                    <div class="basics-grid-4" style="margin-top:6px">
                        <div class="basics-field">
                            <label>Post Size</label>
                            <select id="inPostSize" onchange="rebuildAll()">
                                <option value="65x65">65 &times; 65 &times; 2mm SHS</option>
                                <option value="75x75">75 &times; 75 &times; 2mm SHS</option>
                                <option value="90x90" selected>90 &times; 90 &times; 2mm SHS</option>
                                <option value="100x100">100 &times; 100 &times; 2mm SHS</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Beam Size</label>
                            <select id="inBeamSize" onchange="rebuildAll()">
                                <option value="75x50">75 &times; 50 &times; 2mm RHS</option>
                                <option value="100x50" selected>100 &times; 50 &times; 2mm RHS</option>
                                <option value="150x50">150 &times; 50 &times; 2mm RHS</option>
                            </select>
                        </div>
                        <div class="basics-field" id="ceilingFinishField" style="display:none">
                            <label>Ceiling Finish</label>
                            <select id="inCeilingFinish" onchange="rebuildAll()">
                                <option value="plain">Plain</option>
                                <option value="vj">VJ</option>
                            </select>
                        </div>
                        <div class="basics-field" id="gableInfillField" style="display:none">
                            <label>Gable Infill</label>
                            <select id="inInfill" onchange="rebuildAll()">
                                <option value="colorbond">Colorbond</option>
                                <option value="polycarbonate">Polycarbonate</option>
                                <option value="louvre">Louvre</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="basics-divider"></div>

                <!-- ROW 4: Extras -->
                <div class="basics-group">
                    <div class="basics-group-title">Extras</div>
                    <div class="basics-grid-3">
                        <div class="basics-field extras-toggle">
                            <label>Demo Required?</label>
                            <select id="extraDemo" onchange="toggleExtraCost('demo')">
                                <option value="no">No</option>
                                <option value="yes">Yes</option>
                            </select>
                            <div class="extras-cost" id="demoCostWrap" style="display:none">
                                <label>Demo Cost</label>
                                <input type="number" id="extraDemoCost" value="" placeholder="$" min="0" step="50" oninput="updatePricing()">
                            </div>
                        </div>
                        <div class="basics-field extras-toggle">
                            <label>Removal Required?</label>
                            <select id="extraRemoval" onchange="toggleExtraCost('removal')">
                                <option value="no">No</option>
                                <option value="yes">Yes</option>
                            </select>
                            <div class="extras-cost" id="removalCostWrap" style="display:none">
                                <label>Removal Cost</label>
                                <input type="number" id="extraRemovalCost" value="" placeholder="$" min="0" step="50" oninput="updatePricing()">
                            </div>
                        </div>
                        <div class="basics-field extras-toggle">
                            <label>Electrical?</label>
                            <select id="extraElectrical" onchange="toggleExtraCost('electrical')">
                                <option value="no">No</option>
                                <option value="yes">Yes</option>
                            </select>
                            <div class="extras-cost" id="electricalCostWrap" style="display:none">
                                <label>Electrical Cost</label>
                                <input type="number" id="extraElectricalCost" value="" placeholder="$" min="0" step="50" oninput="updatePricing()">
                                <label style="margin-top:4px">Downlights</label>
                                <input type="number" id="extraDownlights" value="4" min="0" step="1" placeholder="0">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="basics-divider"></div>

                <!-- ROW 5: Allowances -->
                <div class="basics-group">
                    <div class="basics-group-title">Allowances</div>
                    <div class="basics-grid-2">
                        <div class="basics-field">
                            <label>Gutter &amp; Downpipes</label>
                            <input type="number" id="allowGutter" value="800" min="0" step="50" oninput="updatePricing()">
                        </div>
                        <div class="basics-field">
                            <label>Flashings &amp; Finishing</label>
                            <input type="number" id="allowFlashings" value="400" min="0" step="50" oninput="updatePricing()">
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- ============ SECTION: TRUSS CALCULATOR (gable only, collapsed) ============ -->
        <div class="section" id="sec-truss" style="display:none">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-truss')">
                <div>
                    <div class="section-title">Gable Truss Calculator</div>
                    <div class="section-subtitle">Truss design, dimensions &amp; fabrication order</div>
                </div>
                <div style="display:flex;align-items:center;gap:8px">
                    <label style="font-size:10px;color:var(--sw-text-sec)" onclick="event.stopPropagation()">Overhang</label>
                    <input type="number" class="field-input" id="inOverhang" value="0" min="0" step="10" style="width:55px;font-size:11px;padding:3px 6px" oninput="rebuildAll()" onclick="event.stopPropagation()">
                    <span style="font-size:10px;color:var(--sw-text-sec)">mm</span>
                    <button class="btn btn-secondary" style="padding:4px 8px;font-size:10px" onclick="event.stopPropagation();exportTrussPDF()">PDF</button>
                    <span class="collapse-arrow">&#9662;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="padding:0">
                    <div class="truss-config">
                        <div class="truss-config-item">
                            <label><input type="checkbox" id="trussExtOn" onchange="toggleTrussOpt();rebuildAll()"> Extender</label>
                            <div class="truss-opt-fields" id="trussExtInputs" style="display:none">
                                <label>Length <input type="number" id="trussExtLen" value="300" min="0" step="10" oninput="rebuildAll()"><span>mm</span></label>
                            </div>
                        </div>
                        <div class="truss-config-item">
                            <label><input type="checkbox" id="trussRiserOn" onchange="toggleTrussOpt();rebuildAll()"> Risers</label>
                            <div class="truss-opt-fields" id="trussRiserInputs" style="display:none">
                                <label><input type="checkbox" id="trussRiserLock" checked onchange="syncRiserLock();rebuildAll()"> Lock L/R</label>
                            </div>
                        </div>
                        <div class="truss-config-item" id="trussRiserLPanel" style="display:none">
                            <span class="truss-opt-fields" style="display:flex">
                                <label style="font-weight:600;font-size:10px;color:var(--sw-text-sec)">Left Riser</label>
                                <label>Horiz <input type="number" id="riserLH" value="200" min="0" max="800" step="10" oninput="syncRiserInputs('L');rebuildAll()"><span>mm</span></label>
                                <label>Vert <input type="number" id="riserLV" value="150" min="0" max="600" step="10" oninput="syncRiserInputs('L');rebuildAll()"><span>mm</span></label>
                            </span>
                        </div>
                        <div class="truss-config-item" id="trussRiserRPanel" style="display:none">
                            <span class="truss-opt-fields" style="display:flex">
                                <label style="font-weight:600;font-size:10px;color:var(--sw-text-sec)">Right Riser</label>
                                <label>Horiz <input type="number" id="riserRH" value="200" min="0" max="800" step="10" oninput="syncRiserInputs('R');rebuildAll()"><span>mm</span></label>
                                <label>Vert <input type="number" id="riserRV" value="150" min="0" max="600" step="10" oninput="syncRiserInputs('R');rebuildAll()"><span>mm</span></label>
                            </span>
                        </div>
                    </div>
                    <div style="padding:12px">
                        <div class="truss-viewport" id="trussViewport">
                            <canvas id="trussCanvas"></canvas>
                            <div class="truss-view-btns">
                                <button class="truss-view-btn" onclick="setTrussView('3d',this)">3D</button>
                                <button class="truss-view-btn active" onclick="setTrussView('front',this)">Front</button>
                                <button class="truss-view-btn" onclick="setTrussView('side',this)">Side</button>
                                <button class="truss-view-btn" onclick="setTrussView('front',document.querySelector('.truss-view-btn:nth-child(2)'))" title="Reset view" style="font-size:13px;padding:3px 8px">&#x21BA;</button>
                            </div>
                        </div>
                        <div class="truss-panel-vertical">
                            <div class="truss-cards-row">
                                <div class="truss-card">
                                    <h4>Truss Dimensions</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">SP: Span</div><div class="spec-value" id="specA">3000</div></div>
                                        <div class="spec-item"><div class="spec-label">HT: Height</div><div class="spec-value" id="specB">264</div></div>
                                        <div class="spec-item"><div class="spec-label">Rafter</div><div class="spec-value hl" id="specC">1523</div></div>
                                        <div class="spec-item"><div class="spec-label">Pitch</div><div class="spec-value" id="specD">10&deg;</div></div>
                                        <div class="spec-item" id="specExtItem" style="display:none"><div class="spec-label">Extender</div><div class="spec-value" id="specExt">300</div></div>
                                        <div class="spec-item" id="specRiserLItem" style="display:none"><div class="spec-label">Riser L</div><div class="spec-value" id="specRiserL">200×150</div></div>
                                        <div class="spec-item" id="specRiserRItem" style="display:none"><div class="spec-label">Riser R</div><div class="spec-value" id="specRiserR">200×150</div></div>
                                    </div>
                                </div>
                                <div class="truss-card">
                                    <h4>Cut Lengths</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">Chord (cut)</div><div class="spec-value hl" id="specChordCut">--</div></div>
                                        <div class="spec-item"><div class="spec-label">Rafter (cut)</div><div class="spec-value hl" id="specRafterCut">--</div></div>
                                        <div class="spec-item" id="specRiserLMitem" style="display:none"><div class="spec-label">Riser steel (ea)</div><div class="spec-value" id="specRiserLM">--</div></div>
                                        <div class="spec-item"><div class="spec-label">LM / truss</div><div class="spec-value" id="specLMper">--</div></div>
                                        <div class="spec-item"><div class="spec-label">LM all</div><div class="spec-value" id="specLMall">--</div></div>
                                    </div>
                                </div>
                                <div class="truss-card">
                                    <h4>Cut Angles</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">Apex Mitre</div><div class="spec-value" id="angleApex">80&deg;</div></div>
                                        <div class="spec-item"><div class="spec-label">Heel Mitre</div><div class="spec-value" id="angleBase">10&deg;</div></div>
                                    </div>
                                </div>
                            </div>
                            <div class="truss-card" id="webCard" style="display:none">
                                <h4>Web Members</h4>
                                <div class="spec-grid">
                                    <div class="spec-item"><div class="spec-label">Style</div><div class="spec-value" id="webStyle">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Count</div><div class="spec-value" id="webCount">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Cut Lengths</div><div class="spec-value" id="webCuts">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Web LM</div><div class="spec-value" id="webLM">--</div></div>
                                </div>
                            </div>
                            <div class="fab-box" id="fabOrder" style="white-space:pre;font-family:'SF Mono',monospace;font-size:10px;line-height:1.5;padding:12px;overflow-x:auto"></div>
                            <button class="btn btn-secondary" style="margin-top:8px;padding:5px 12px;font-size:10px;opacity:0.5;cursor:not-allowed" disabled title="Coming soon">Design Box Gutter</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============ SECTION: SITE DETAILS (collapsed) ============ -->
        <div class="section" id="sec-site">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-site')">
                <div><div class="section-title">Site Details</div><div class="section-subtitle">Technical config, colours &amp; site survey</div></div>
                <span class="collapse-arrow">&#9662;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">

                    <!-- Technical Configuration -->
                    <div class="basics-group">
                        <div class="basics-group-title">Technical Configuration</div>
                        <div class="basics-grid-4">
                            <div class="basics-field" id="orientationField">
                                <label>Ridge Direction</label>
                                <select id="inOrientation" onchange="rebuildAll()">
                                    <option value="lengthways">Along House</option>
                                    <option value="perpendicular">Away from House</option>
                                </select>
                            </div>
                            <div class="basics-field">
                                <label>Posts (per side)</label>
                                <input type="number" id="inPosts" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="trussField">
                                <label>Trusses</label>
                                <input type="number" id="inTrusses" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="rafterField" style="display:none">
                                <label>Rafters</label>
                                <input type="number" id="inRafters" value="5" min="2" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="basics-grid-4" style="margin-top:6px">
                            <div class="basics-field">
                                <label>Steel Size</label>
                                <select id="inTrussSteel" onchange="rebuildAll()">
                                    <option value="76x38">76 &times; 38 &times; 1.6mm RHS</option>
                                    <option value="75x50">75 &times; 50 &times; 2.0mm RHS</option>
                                    <option value="100x50">100 &times; 50 &times; 2.0mm RHS</option>
                                </select>
                            </div>
                            <div class="basics-field" id="trussBaseField">
                                <label>Truss Base</label>
                                <select id="inTrussBase" onchange="rebuildAll()">
                                    <option value="kingpost">King Post</option>
                                    <option value="verticalwebs">Vertical Webs</option>
                                    <option value="kingdiagonal">King + Diagonal</option>
                                    <option value="open">Open</option>
                                </select>
                            </div>
                            <div class="basics-field" id="trussChordField">
                                <label>Chord</label>
                                <select id="inTrussChord" onchange="rebuildAll()">
                                    <option value="bottom">Bottom</option>
                                    <option value="mid">Mid</option>
                                    <option value="none">None</option>
                                </select>
                            </div>
                            <div class="basics-field" id="fasciaHeightField" style="display:none">
                                <label>Fascia Height <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inFasciaHeight" value="2700" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="houseGutterField" style="display:none">
                                <label>House Gutter</label>
                                <select id="inHouseGutter" onchange="rebuildAll()">
                                    <option value="quad">Existing Quad Gutter</option>
                                    <option value="box">Replace with Box Gutter</option>
                                </select>
                            </div>
                        </div>
                        <div class="basics-grid-4" style="margin-top:6px">
                            <div class="basics-field" id="riserHeightField" style="display:none">
                                <label>Riser Height <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inRiserHeight" value="400" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserOffsetField" style="display:none">
                                <label>Riser Offset <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inRiserOffset" value="150" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserQtyField" style="display:none">
                                <label>Riser Brackets</label>
                                <input type="number" id="inRiserQty" value="" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserGutterField" style="display:none">
                                <label>Riser Gutter</label>
                                <select id="inRiserGutter" onchange="rebuildAll()">
                                    <option value="none">None</option>
                                    <option value="quad">Quad Gutter on Riser Beam</option>
                                </select>
                            </div>
                        </div>
                        <div class="calc-display" id="calcDisplay" style="margin-top:8px">
                            <div class="calc-row"><span class="calc-label">Rise:</span><span class="calc-value" id="calcRise">--</span></div>
                            <div class="calc-row"><span class="calc-label">Rafter TRUE:</span><span class="calc-value" id="calcRafter">--</span></div>
                            <div class="calc-row" id="calcPitchRow" style="display:none"><span class="calc-label">Actual Pitch:</span><span class="calc-value" id="calcPitch">--</span></div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- Colours -->
                    <div class="basics-group">
                        <div class="basics-group-title">Colours</div>
                        <div class="basics-colours">
                            <div class="basics-colour-block">
                                <div class="basics-colour-label">Sheets</div>
                                <div class="color-chips" id="sheetChips"></div>
                                <div class="color-label" id="sheetLabel">Monument</div>
                            </div>
                            <div class="basics-colour-block">
                                <div class="basics-colour-label">Steel</div>
                                <div class="color-chips" id="steelChips"></div>
                                <div class="color-label" id="steelLabel">Monument</div>
                            </div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- Polycarbonate (Trimdek only) -->
                    <div id="polycarbField" style="display:none">
                        <div class="basics-group">
                            <div class="basics-group-title">Polycarbonate</div>
                            <div style="display:flex;align-items:center;gap:12px;margin-bottom:6px">
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="no" checked onchange="updatePolycarbUI();rebuildAll()"> No
                                </label>
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="yes" onchange="updatePolycarbUI();rebuildAll()"> Yes
                                </label>
                            </div>
                            <div id="polycarbOptions" style="display:none">
                                <div class="basics-grid-3" style="gap:6px">
                                    <div class="basics-field">
                                        <label>Brand</label>
                                        <select id="inPolycarbBrand" onchange="updatePolycarbTints();rebuildAll()">
                                            <option value="ampelite">Ampelite Solasafe</option>
                                            <option value="laserlite">Laserlite 2000</option>
                                        </select>
                                    </div>
                                    <div class="basics-field">
                                        <label>Tint</label>
                                        <select id="inPolycarbTint" onchange="rebuildAll()"></select>
                                    </div>
                                    <div class="basics-field">
                                        <label>Pattern</label>
                                        <select id="inPolycarbPattern" onchange="updatePolycarbPreview();rebuildAll()">
                                            <option value="2">Every 2nd (1:1)</option>
                                            <option value="3" selected>Every 3rd (2:1)</option>
                                            <option value="4">Every 4th (3:1)</option>
                                            <option value="custom">Custom</option>
                                        </select>
                                    </div>
                                </div>
                                <div id="polycarbCustomField" style="display:none;margin-top:4px">
                                    <div class="basics-field" style="max-width:140px">
                                        <label>Colorbond per 1 polycarb</label>
                                        <input type="number" id="inPolycarbCustom" value="3" min="1" max="20" step="1" oninput="updatePolycarbPreview();rebuildAll()">
                                    </div>
                                </div>
                                <div style="margin-top:6px">
                                    <div style="font-size:10px;color:var(--sw-text-sec);margin-bottom:3px">Preview</div>
                                    <div id="polycarbPreview" style="display:flex;gap:2px;flex-wrap:wrap"></div>
                                    <div style="font-size:9px;color:var(--sw-text-sec);margin-top:3px">&#9632;=steel &#9633;=polycarb</div>
                                </div>
                            </div>
                        </div>
                        <div class="basics-divider"></div>
                    </div>

                    <!-- Site Survey -->
                    <div class="basics-group">
                        <div class="basics-group-title">Site Survey</div>
                        <div class="site-details-grid">
                            <div>
                                <div class="radio-group-title">Existing Gutter Profile</div>
                                <div class="radio-options">
                                    <label class="radio-pill"><input type="radio" name="gutterProfile" value="quad115" onchange="updateSiteDetails()"><span>Quad 115</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterProfile" value="og125" onchange="updateSiteDetails()"><span>OG 125</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterProfile" value="fascia" onchange="updateSiteDetails()"><span>Fascia</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterProfile" value="unknown" checked onchange="updateSiteDetails()"><span>Unknown</span></label>
                                </div>
                            </div>
                            <div>
                                <div class="radio-group-title">Gutter Manufacturer</div>
                                <div class="radio-options">
                                    <label class="radio-pill"><input type="radio" name="gutterManufacturer" value="stratco" onchange="updateSiteDetails()"><span>Stratco</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterManufacturer" value="lysaght" onchange="updateSiteDetails()"><span>Lysaght</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterManufacturer" value="metroll" onchange="updateSiteDetails()"><span>Metroll</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterManufacturer" value="unknown" checked onchange="updateSiteDetails()"><span>Unknown</span></label>
                                </div>
                            </div>
                            <div>
                                <div class="radio-group-title">Fascia Condition</div>
                                <div class="radio-options">
                                    <label class="radio-pill"><input type="radio" name="fasciaCondition" value="good" onchange="updateSiteDetails()"><span>Good</span></label>
                                    <label class="radio-pill"><input type="radio" name="fasciaCondition" value="needs_repair" onchange="updateSiteDetails()"><span>Needs Repair</span></label>
                                    <label class="radio-pill"><input type="radio" name="fasciaCondition" value="unknown" checked onchange="updateSiteDetails()"><span>Unknown</span></label>
                                </div>
                            </div>
                            <div>
                                <div class="radio-group-title">Site Access</div>
                                <div class="radio-options">
                                    <label class="radio-pill"><input type="radio" name="siteAccess" value="easy" onchange="updateSiteDetails()"><span>Easy</span></label>
                                    <label class="radio-pill"><input type="radio" name="siteAccess" value="restricted" onchange="updateSiteDetails()"><span>Restricted</span></label>
                                    <label class="radio-pill"><input type="radio" name="siteAccess" value="unknown" checked onchange="updateSiteDetails()"><span>Unknown</span></label>
                                </div>
                            </div>
                            <div class="site-notes-wrap">
                                <div class="radio-group-title">Notes</div>
                                <textarea id="siteNotes" rows="2" placeholder="Any additional site notes..." oninput="updateSiteDetails()"></textarea>
                            </div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- Job Notes -->
                    <div class="basics-group">
                        <div class="basics-group-title">Job Notes</div>
                        <textarea id="jobNotes" rows="2" placeholder="Job notes..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                    </div>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: FLASHING EDITOR (collapsed) ============ -->
        <div class="section" id="sec-flashings">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-flashings')">
                <div><div class="section-title">Flashings</div><div class="section-subtitle">Profile editor &amp; job flashing list</div></div>
                <span class="collapse-arrow">&#9662;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <!-- Editor fields -->
                <div class="flash-fields" id="flashFields">
                    <div><label>Name</label><input type="text" id="flashName" placeholder="Apron - Back Wall" value="Apron - Back Wall"></div>
                    <div><label>Colour</label>
                        <select id="flashColour">
                            <option>Monument</option><option>Woodland Grey</option><option>Paperbark</option><option>Surfmist</option>
                            <option>Basalt</option><option>Manor Red</option><option selected>Deep Ocean</option><option>Windspray</option>
                        </select>
                    </div>
                    <div><label>Gauge</label>
                        <select id="flashGauge">
                            <option value="0.42" selected>0.42</option><option value="0.48">0.48</option><option value="0.55">0.55</option>
                        </select>
                    </div>
                    <div><label>Length <span style="font-size:9px;color:var(--sw-text-sec)">mm</span></label><input type="number" id="flashLength" value="4500" step="100"></div>
                    <div><label>Qty</label><input type="number" id="flashQty" value="2" min="1" step="1"></div>
                </div>

                <!-- Drawing toolbar -->
                <div class="flash-toolbar">
                    <button class="flash-tool-btn active" data-tool="draw" onclick="setFlashTool('draw',this)" title="Draw profile (click points)">Draw</button>
                    <button class="flash-tool-btn" data-tool="move" onclick="setFlashTool('move',this)" title="Move / pan view">Move</button>
                    <button class="flash-tool-btn" data-tool="select" onclick="setFlashTool('select',this)" title="Select &amp; edit segments">Select</button>
                    <div class="flash-tool-sep"></div>
                    <button class="flash-tool-btn" onclick="flashFlipH()" title="Flip horizontal (H)">Flip H</button>
                    <button class="flash-tool-btn" onclick="flashFlipV()" title="Flip vertical (V)">Flip V</button>
                    <div class="flash-tool-sep"></div>
                    <button class="flash-tool-btn" onclick="flashUndo()" title="Undo (Ctrl+Z)">Undo</button>
                    <button class="flash-tool-btn" onclick="flashClear()" title="Clear profile">Clear</button>
                    <div class="flash-tool-sep"></div>
                    <div class="flash-colour-side">
                        <span style="font-size:10px;color:var(--sw-text-sec)">Colour side:</span>
                        <button class="flash-cs-btn active" data-cs="top" onclick="setColourSide('top',this)">Top</button>
                        <button class="flash-cs-btn" data-cs="bottom" onclick="setColourSide('bottom',this)">Bottom</button>
                    </div>
                    <div class="flash-tool-sep"></div>
                    <div style="display:flex;align-items:center;gap:4px">
                        <span style="font-size:10px;color:var(--sw-text-sec)">Start:</span>
                        <select id="flashStartTreat" onchange="updateFlashTreatment('start')" style="font-size:10px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:3px">
                            <option value="none">None</option>
                            <option value="miniBreak">Mini Break</option>
                            <option value="hem">Hem</option>
                        </select>
                        <span style="font-size:10px;color:var(--sw-text-sec)">End:</span>
                        <select id="flashEndTreat" onchange="updateFlashTreatment('end')" style="font-size:10px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:3px">
                            <option value="none">None</option>
                            <option value="miniBreak">Mini Break</option>
                            <option value="hem">Hem</option>
                        </select>
                    </div>
                    <div id="flashTreatOpts" style="display:none;align-items:center;gap:4px">
                        <span style="font-size:9px;color:var(--sw-text-sec)">Size:</span>
                        <input type="number" id="flashTreatSize" value="10" min="3" max="30" style="width:36px;font-size:10px;padding:1px 3px;border:1px solid var(--sw-border);border-radius:3px">
                        <span style="font-size:9px;color:var(--sw-text-sec)">Angle:</span>
                        <input type="number" id="flashTreatAngle" value="45" min="10" max="90" step="5" style="width:36px;font-size:10px;padding:1px 3px;border:1px solid var(--sw-border);border-radius:3px">
                        <button class="flash-cs-btn active" id="flashTreatDirOut" onclick="setTreatDir('out')" style="font-size:9px;padding:1px 5px">Out</button>
                        <button class="flash-cs-btn" id="flashTreatDirIn" onclick="setTreatDir('in')" style="font-size:9px;padding:1px 5px">In</button>
                    </div>
                    <div style="flex:1"></div>
                    <button class="flash-tool-btn" style="background:var(--sw-orange);color:white;border-color:var(--sw-orange)" onclick="flashAddToJob()">+ Add to Job</button>
                </div>

                <!-- Canvas -->
                <div class="flash-viewport" id="flashViewport">
                    <canvas id="flashCanvas"></canvas>
                </div>

                <!-- Info bar -->
                <div class="flash-info" id="flashInfoBar">
                    <span>Girth: <span class="flash-info-val" id="flashGirth">0</span> mm</span>
                    <span>Legs: <span class="flash-info-val" id="flashLegs">0</span></span>
                    <span>Zoom: <span class="flash-info-val" id="flashZoom">10</span> mm/grid</span>
                    <span style="margin-left:auto;font-size:10px;color:var(--sw-text-sec)">Click to place points &bull; Shift = constrain angle &bull; Enter = finish &bull; Esc = cancel</span>
                </div>

                <!-- Templates -->
                <div style="padding:8px 12px 0;font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.3px;color:var(--sw-text-sec)">Templates</div>
                <div class="template-folders" id="flashTemplates"></div>

                <!-- Job flashings table -->
                <div style="padding:12px">
                    <div class="flash-header-row">
                        <div>
                            <div style="font-size:13px;font-weight:600">Job Flashings</div>
                        </div>
                    </div>
                    <table class="flash-table" id="flashJobTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Name</th>
                                <th class="r">Girth</th>
                                <th class="r">Length</th>
                                <th class="r">Qty</th>
                                <th>Colour</th>
                                <th>Gauge</th>
                                <th>Side</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="flashJobBody"></tbody>
                    </table>
                    <div class="flash-total-row" id="flashTotalRow" style="display:none">
                        Total area: <span id="flashTotalArea">0</span> m&sup2;
                    </div>
                </div>
            </div>
        </div>

        <!-- ============ SECTION: MATERIALS (collapsed) ============ -->
        <div class="section" id="sec-materials">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-materials')">
                <div><div class="section-title">Materials</div><div class="section-subtitle">Detailed configuration &amp; specifications</div></div>
                <span class="collapse-arrow">&#9662;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div style="padding:16px 20px">
                    <div id="preOrderChecks"></div>
                    <div id="matList"></div>
                </div>
            </div>
        </div>

        <!-- ============ SECTION: PRICING (collapsed) ============ -->
        <div class="section" id="sec-pricing">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-pricing')">
                <div><div class="section-title">Pricing &amp; Costs</div><div class="section-subtitle">Quote builder</div></div>
                <div style="display:flex;align-items:center;gap:8px">
                    <button class="settings-gear" onclick="event.stopPropagation();openRatesModal()" title="Stored Rates">&#9881;</button>
                    <span class="collapse-arrow">&#9662;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="background:#f5f5f5;padding:24px;border-radius:0 0 12px 12px">
                <div class="pricing-cards-container">

                    <!-- CARD 1: MATERIALS -->
                    <div class="q-card" id="materialsCard">
                        <div class="q-card-header">
                            <div>
                                <div class="q-card-title"><span id="matStatusIcon" class="status-ok">&#10003;</span> Materials</div>
                                <div class="q-card-sub"><span id="matItemCount">0 items</span> &bull; <span id="matMarkupPct">35%</span> markup</div>
                            </div>
                            <div style="display:flex;align-items:center;gap:16px">
                                <span class="q-card-amount" id="matSellDisplay">$0</span>
                                <button class="q-card-edit" onclick="openMaterialsModal()">Edit</button>
                            </div>
                        </div>
                    </div>

                    <!-- CARD 2: LABOUR -->
                    <div class="q-card" id="labourCard">
                        <div class="q-card-title">Labour</div>
                        <div class="labour-inline">
                            <input type="number" class="li-input" id="labTrades" value="2" min="1" step="1" oninput="updatePricing()">
                            <span class="li-label">trades</span>
                            <span class="li-label">&times;</span>
                            <input type="number" class="li-input" id="labDays" value="1.5" min="0.5" step="0.5" oninput="updatePricing()">
                            <span class="li-label">days</span>
                            <span class="li-label">&times;</span>
                            <span class="li-label">$</span>
                            <input type="number" class="li-input wide" id="labDayRate" value="400" min="0" step="10" oninput="updatePricing()">
                            <span class="li-label">/day</span>
                            <span class="li-label">=</span>
                            <span class="li-equals" id="labCostDisplay">$1,200</span>
                            <span class="li-label">cost</span>
                        </div>
                        <div class="labour-sell-row">
                            <label>Sell:</label>
                            <input type="number" id="labSellInput" value="2000" min="0" step="50" oninput="updatePricing()" placeholder="0.00">
                        </div>
                    </div>

                    <!-- CARD 3: EXTRAS -->
                    <div class="q-card" id="extrasCard">
                        <div class="q-card-title">Extras</div>
                        <div class="extras-pills">
                            <button class="extras-pill" onclick="addExtra('footings')">+ Footings</button>
                            <button class="extras-pill" onclick="addExtra('electrical')">+ Electrical</button>
                            <button class="extras-pill" onclick="addExtra('downlights')">+ Downlights</button>
                            <button class="extras-pill" onclick="addExtra('demo')">+ Demo</button>
                            <button class="extras-pill" onclick="addExtra('delivery')">+ Delivery</button>
                            <button class="extras-pill" onclick="addExtra('other')">+ Other</button>
                        </div>
                        <div class="extras-rows" id="extrasRowsContainer"></div>
                    </div>

                    <!-- CARD 4: TOTAL -->
                    <div class="total-card" id="totalCard">
                        <div class="total-amount" id="totalAmountDisplay">TOTAL $0 inc GST</div>
                        <div class="total-margin" id="totalMarginDisplay">Margin: $0 (0%)</div>
                        <button class="btn-generate-quote" onclick="generateQuotePDF()">GENERATE QUOTE</button>
                        <div class="total-links">
                            <a onclick="generateSteelOrderPDF()">Steel Order</a>
                            <a onclick="generateSheetsOrderPDF()">Sheets &amp; Flashings</a>
                            <a onclick="generateFabricationOrderPDF()">Fabrication Order</a>
                            <a onclick="generateWorkOrderPDF()">Work Order</a>
                            <a onclick="saveJobData()">Save Job Data</a>
                        </div>
                    </div>

                    <!-- Job Notes (compact) -->
                    <div class="q-card">
                        <div class="q-card-title">Job Notes</div>
                        <div class="notes-inline">
                            <textarea id="pricingNotes" placeholder="Install notes, access issues, special requirements..." rows="2"></textarea>
                        </div>
                    </div>

                </div>
                </div>
            </div>
        </div>

        </div><!-- end panel-left -->

        <div class="panel-right" id="panelRight">

            <!-- 2D Site Plan -->
            <div class="rp-card">
                <div class="rp-card-hdr">Site Plan</div>
                <div class="rp-card-body" style="padding:8px">
                    <div class="plan-2d" style="height:200px"><canvas id="plan2d"></canvas></div>
                </div>
            </div>

            <!-- 3D Assembly Preview -->
            <div class="rp-card">
                <div class="rp-card-hdr">3D Preview</div>
                <div class="asm-viewport" id="asmViewport" style="height:360px;border-radius:0">
                    <canvas id="asmCanvas"></canvas>
                    <button class="fullscreen-btn" onclick="toggleFullscreen()">&#x26F6; Fullscreen</button>
                    <div class="layer-panel">
                        <div class="layer-title">Layers</div>
                        <div class="layer-item active" data-layer="steel" onclick="toggleLayer('steel',this)"><span class="layer-check"></span>Steel</div>
                        <div class="layer-item active" data-layer="roof" onclick="toggleLayer('roof',this)"><span class="layer-check"></span>Roofing</div>
                        <div class="layer-item active" data-layer="acc" onclick="toggleLayer('acc',this)"><span class="layer-check"></span>Gutters/DP</div>
                        <div class="layer-item active" data-layer="house" onclick="toggleLayer('house',this)"><span class="layer-check"></span>House</div>
                    </div>
                    <div class="tooltip" id="tooltip"><div class="tooltip-title" id="ttTitle"></div><div id="ttContent"></div></div>
                    <div class="view-panel">
                        <button class="view-btn active" onclick="setAsmView('3d',this)">3D</button>
                        <button class="view-btn" onclick="setAsmView('front',this)">Front</button>
                        <button class="view-btn" onclick="setAsmView('side',this)">Side</button>
                        <button class="view-btn" onclick="setAsmView('top',this)">Top</button>
                    </div>
                </div>
            </div>

            <!-- Summary -->
            <div class="rp-card">
                <div class="rp-card-hdr">Summary</div>
                <div class="rp-card-body">
                    <div class="rp-summary-grid">
                        <div class="rp-summary-item">
                            <div class="rp-summary-label">Dimensions</div>
                            <div class="rp-summary-value" id="rpDims">6.0m × 3.0m</div>
                        </div>
                        <div class="rp-summary-item">
                            <div class="rp-summary-label">Roof Type</div>
                            <div class="rp-summary-value" id="rpRoofType">Gable</div>
                        </div>
                        <div class="rp-summary-item">
                            <div class="rp-summary-label">Material</div>
                            <div class="rp-summary-value" id="rpMaterial">Corrugated</div>
                        </div>
                        <div class="rp-summary-item">
                            <div class="rp-summary-label">Colour</div>
                            <div class="rp-summary-value" id="rpColour">Monument</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Quick Scope Estimate -->
            <div class="rp-card">
                <div class="rp-card-hdr">Quick Scope Estimate</div>
                <div class="rp-card-body">
                    <div class="rp-est-label" id="rpEstSqm">—</div>
                    <div class="rp-est-range" id="rpEstRange">—</div>
                    <div class="rp-est-btn">
                        <button class="btn btn-primary" onclick="copyEstimate()">Copy Estimate</button>
                    </div>
                </div>
            </div>

        </div><!-- end panel-right -->

        <!-- Hidden: Complexity scores preserved for export/import -->
        <div style="display:none">
            <input type="number" id="cxBuild" value="3"><input type="number" id="cxAccess" value="3">
            <input type="number" id="cxDistance" value="2"><input type="number" id="cxFooting" value="3"><input type="number" id="cxHeight" value="2">
        </div>

        <!-- Materials Edit Modal -->
        <div id="materialsModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)closeMaterialsModal()">
            <div class="mat-modal">
                <h3>Materials &amp; Pricing</h3>
                <div class="mat-modal-controls">
                    <label>Markup:</label>
                    <input type="number" id="globalMarkupPct" value="35" min="0" max="200" step="1">
                    <span style="font-size:13px;color:var(--sw-text-sec)">%</span>
                    <button class="btn-apply" onclick="applyMarkupAll()">Apply to All</button>
                    <div class="toggle-wrap">
                        <input type="checkbox" id="showCostToggle" onchange="renderMaterialsModal()">
                        <label for="showCostToggle" style="font-size:12px;color:var(--sw-text-sec);cursor:pointer">Show cost prices</label>
                    </div>
                </div>
                <table class="mat-modal-table">
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Qty</th>
                            <th class="r cost-col" style="display:none">Cost</th>
                            <th class="r">Sell Price</th>
                            <th class="r">Markup</th>
                            <th style="width:24px"></th>
                        </tr>
                    </thead>
                    <tbody id="matModalBody"></tbody>
                </table>
                <div class="mat-modal-footer">
                    <div>
                        <button class="btn-add-custom" onclick="addCustomMaterialRow()">+ Add Custom Item</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:16px">
                        <span>Total: <span class="mat-total" id="matModalTotal">$0.00</span></span>
                        <button class="btn-done" onclick="closeMaterialsModal()">Done</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Rates Settings Modal -->
        <div id="ratesModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
            <div class="rates-modal">
                <h3>Stored Rates</h3>
                <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:12px">Default $/LM rates &amp; day rates. Saved to browser.</p>
                <table class="pricing-table">
                    <thead><tr><th>Material / Role</th><th class="r">Rate $</th></tr></thead>
                    <tbody id="ratesBody"></tbody>
                </table>
                <div style="text-align:right;margin-top:16px">
                    <button class="btn-done" style="padding:8px 20px;border-radius:6px;border:none;background:var(--sw-orange);color:white;font-size:13px;cursor:pointer" onclick="document.getElementById('ratesModal').style.display='none'">Done</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Import Modal -->
    <div id="importModal" class="modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
        <div class="modal-box">
            <h3>Import Job Data</h3>
            <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:8px">Paste previously exported JSON data below, then click Load Job.</p>
            <textarea id="importTextarea" placeholder="Paste job JSON here..."></textarea>
            <div class="modal-status" id="importStatus"></div>
            <div class="modal-btns">
                <button class="btn btn-secondary" onclick="document.getElementById('importModal').style.display='none'">Cancel</button>
                <button class="btn btn-primary" onclick="importJobData()">Load Job</button>
            </div>
        </div>
    </div>

    <div id="loadJobModal" class="modal-overlay" style="display:none" onclick="if(event.target===this)closeLoadJobModal()">
        <div class="modal-box" style="max-width:500px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
                <h3 style="margin:0">Load Job</h3>
                <span style="cursor:pointer;font-size:18px;color:var(--sw-text-sec);padding:4px" onclick="closeLoadJobModal()">&times;</span>
            </div>
            <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:8px">Paste job data JSON:</p>
            <textarea id="loadJobTextarea" rows="6" placeholder="Paste job JSON here..." style="height:auto"></textarea>
            <div class="modal-status" id="loadJobStatus"></div>
            <div class="modal-btns">
                <button class="btn btn-secondary" onclick="closeLoadJobModal()">Cancel</button>
                <button class="btn btn-primary" onclick="loadJobData()">Load Job</button>
            </div>
        </div>
    </div>

    <script>
        /*
         * V18 FIXES:
         * 1. Downpipes - now extend from ground to actual gutter height (not postH)
         * 2. Gable sheets perpendicular - complete rotation rewrite for proper roof alignment
         * 3. Carry beam condition - removed for gable+fascia (trusses sit on fascia beam directly)
         * 4. Gable+riser beam stacking - riser beam now sits ON TOP of risers correctly
         */

        // ==================== CONFIG ====================
        const COLORS = [
            {name:'Monument',hex:'#2D3436'},{name:'Woodland Grey',hex:'#4B5D52'},{name:'Paperbark',hex:'#C4BAA2'},
            {name:'Surfmist',hex:'#E8E6E0'},{name:'Basalt',hex:'#5C5C5C'},{name:'Manor Red',hex:'#6B2D2D'},
            {name:'Deep Ocean',hex:'#1E3A4C'},{name:'Windspray',hex:'#7D8B8A'}
        ];
        const STEEL = {'76x38':{w:0.076,h:0.038,name:'76×38×1.6',bmt:1.6},'75x50':{w:0.075,h:0.05,name:'75×50×2',bmt:2.0},'100x50':{w:0.1,h:0.05,name:'100×50×2',bmt:2.0}};
        const FRAME_POSTS = {
            '65x65': {w:0.065, name:'65×65×2 SHS', label:'65×65×2'},
            '75x75': {w:0.075, name:'75×75×2 SHS', label:'75×75×2'},
            '90x90': {w:0.09,  name:'90×90×2 SHS', label:'90×90×2'},
            '100x100':{w:0.1,  name:'100×100×2 SHS',label:'100×100×2'}
        };
        const FRAME_BEAMS = {
            '75x50':  {w:0.075, h:0.05, name:'75×50×2 RHS', label:'75×50×2'},
            '100x50': {w:0.1,   h:0.05, name:'100×50×2 RHS', label:'100×50×2'},
            '150x50': {w:0.15,  h:0.05, name:'150×50×2 RHS', label:'150×50×2'}
        };

        const SHEET_COVERAGE = {
            corrugated: 762,
            trimdek: 762,
            spandek: 762,
            solarspan75: 1000,
            solarspan100: 1000,
            spanplus330: 330
        };

        const SPAN_TABLES = {
            corrugated: { maxSpan: 1100, endSpan: 900, needsPurlins: true },
            trimdek: { maxSpan: 2100, endSpan: 1500, needsPurlins: true },
            spandek: { maxSpan: 2400, endSpan: 1800, needsPurlins: true },
            solarspan75: { maxSpan: 6000, endSpan: 6000, needsPurlins: false },
            solarspan100: { maxSpan: 6000, endSpan: 6000, needsPurlins: false },
            spanplus330: { maxSpan: 1800, endSpan: 1200, needsPurlins: true }
        };

        function isInsulated(roofing) {
            return roofing === 'solarspan75' || roofing === 'solarspan100';
        }

        const ROOFING_TYPES = {
            solarspan75:  { name: 'SolarSpan 75mm',  coverWidth: 1000, costPerLm: 110.00, sqmRate: 520 },
            solarspan100: { name: 'SolarSpan 100mm', coverWidth: 1000, costPerLm: 130.00, sqmRate: 560 },
            trimdek:      { name: 'Trimdek',         coverWidth: 762,  costPerLm: 15.00,  sqmRate: 420 },
            corrugated:   { name: 'Corrugated',      coverWidth: 762,  costPerLm: 12.04,  sqmRate: 380 },
            spanplus330:  { name: 'SpanPlus 330',    coverWidth: 330,  costPerLm: 12.04,  sqmRate: 400 }
        };

        const SPANPLUS_COLOURS = [
            'Basalt','Classic Cream','Cottage Green','Deep Ocean','Domain','Dune',
            'Evening Haze','Ironstone','Jasper','Manor Red','Monument',
            'Pale Eucalypt','Paperbark','Shale Grey','Surfmist','Woodland Grey'
        ];

        // Polycarbonate tint options per brand
        const POLYCARB_TINTS = {
            ampelite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Light Bronze',color:'rgba(180,150,100,0.4)'},
                {name:'Grey',       color:'rgba(160,160,165,0.45)'},
                {name:'Dark Tint',  color:'rgba(80,80,85,0.55)'},
                {name:'Smooth Cream',color:'rgba(245,235,210,0.5)'}
            ],
            laserlite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Cream',      color:'rgba(245,235,210,0.5)'},
                {name:'Bronze Tint',color:'rgba(170,140,90,0.45)'},
                {name:'Grey Tint',  color:'rgba(150,150,155,0.45)'}
            ]
        };

        // Three.js tint colours for polycarb 3D rendering
        const POLYCARB_3D_TINTS = {
            'Clear':        {color: 0x88CCEE, opacity: 0.5},
            'Opal':         {color: 0xE8E8F0, opacity: 0.6},
            'Light Bronze': {color: 0xB49664, opacity: 0.55},
            'Grey':         {color: 0x909098, opacity: 0.55},
            'Dark Tint':    {color: 0x505055, opacity: 0.65},
            'Smooth Cream': {color: 0xF0E4C8, opacity: 0.55},
            'Cream':        {color: 0xF0E4C8, opacity: 0.55},
            'Bronze Tint':  {color: 0xAA8C5A, opacity: 0.55},
            'Grey Tint':    {color: 0x868690, opacity: 0.55}
        };

        let sheetColor = COLORS[0];
        let steelColor = COLORS[0];
        let calc = {};

        // ==================== CUSTOMER STATE ====================
        let customer = { name: '', address: '', phone: '' };
        function updateCustomer() {
            customer = {
                name: document.getElementById('customerName').value,
                address: document.getElementById('customerAddress').value,
                phone: document.getElementById('customerPhone').value
            };
            // Sync hidden client fields for save/load compatibility
            document.getElementById('clientName').value = customer.name;
            document.getElementById('siteAddress').value = customer.address;
            document.getElementById('clientPhone').value = customer.phone;
        }

        // ==================== SITE DETAILS STATE ====================
        let siteDetails = {
            gutterProfile: 'unknown',
            gutterManufacturer: 'unknown',
            fasciaCondition: 'unknown',
            siteAccess: 'unknown',
            electrical: 'tbd',
            demo: 'tbd',
            notes: ''
        };
        function updateSiteDetails() {
            var gp = document.querySelector('input[name="gutterProfile"]:checked');
            var gm = document.querySelector('input[name="gutterManufacturer"]:checked');
            var fc = document.querySelector('input[name="fasciaCondition"]:checked');
            var sa = document.querySelector('input[name="siteAccess"]:checked');
            siteDetails = {
                gutterProfile: gp ? gp.value : 'unknown',
                gutterManufacturer: gm ? gm.value : 'unknown',
                fasciaCondition: fc ? fc.value : 'unknown',
                siteAccess: sa ? sa.value : 'unknown',
                electrical: document.getElementById('extraElectrical') ? document.getElementById('extraElectrical').value : 'no',
                demo: document.getElementById('extraDemo') ? document.getElementById('extraDemo').value : 'no',
                notes: document.getElementById('siteNotes') ? document.getElementById('siteNotes').value : ''
            };
        }

        // ==================== EXTRAS TOGGLE ====================
        function toggleExtraCost(type) {
            var sel = document.getElementById('extra' + type.charAt(0).toUpperCase() + type.slice(1));
            var wrap = document.getElementById(type + 'CostWrap');
            if (sel && wrap) wrap.style.display = sel.value === 'yes' ? 'block' : 'none';
        }

        function toggleTrussOpt() {
            var rOn = document.getElementById('trussRiserOn').checked;
            var eOn = document.getElementById('trussExtOn').checked;
            document.getElementById('trussRiserInputs').style.display = rOn ? 'flex' : 'none';
            document.getElementById('trussRiserLPanel').style.display = rOn ? '' : 'none';
            document.getElementById('trussRiserRPanel').style.display = rOn ? '' : 'none';
            document.getElementById('trussExtInputs').style.display = eOn ? 'flex' : 'none';
        }

        // Sync left/right riser inputs when Lock L/R is on
        function syncRiserInputs(side) {
            var locked = document.getElementById('trussRiserLock').checked;
            if (!locked) return;
            if (side === 'L') {
                document.getElementById('riserRH').value = document.getElementById('riserLH').value;
                document.getElementById('riserRV').value = document.getElementById('riserLV').value;
            } else {
                document.getElementById('riserLH').value = document.getElementById('riserRH').value;
                document.getElementById('riserLV').value = document.getElementById('riserRV').value;
            }
        }

        // When lock is toggled on, sync right to match left
        function syncRiserLock() {
            if (document.getElementById('trussRiserLock').checked) {
                document.getElementById('riserRH').value = document.getElementById('riserLH').value;
                document.getElementById('riserRV').value = document.getElementById('riserLV').value;
            }
        }

        // ==================== QUICK SCOPE ESTIMATE ====================
        function updateEstimate() {
            const projM = parseFloat(document.getElementById('inWidth').value) || 3;
            const lenM = parseFloat(document.getElementById('inLength').value) || 6;
            const roofing = document.getElementById('inRoofing').value;
            const roofStyle = document.getElementById('inRoofStyle').value;
            const connection = document.getElementById('inConnection').value;
            const sqm = projM * lenM;

            const roofKey = roofing;
            const baseRate = (ROOFING_TYPES[roofKey] || ROOFING_TYPES.corrugated).sqmRate;

            let modifier = 1.0;
            if (roofStyle === 'gable') modifier *= 1.12;
            if (roofStyle === 'hip') modifier *= 1.15;
            if (connection === 'flyover') modifier *= 1.08;
            if (connection === 'freestanding') modifier *= 1.18;

            const base = sqm * baseRate * modifier;
            const low = Math.round((base * 0.95 * 1.1) / 500) * 500;
            const high = Math.round((base * 1.10 * 1.1) / 500) * 500;

            var rpSqm = document.getElementById('rpEstSqm');
            var rpRange = document.getElementById('rpEstRange');
            if (rpSqm) rpSqm.textContent = sqm.toFixed(0) + ' sqm';
            if (rpRange) rpRange.textContent = '~$' + low.toLocaleString() + ' \u2013 $' + high.toLocaleString() + ' (inc GST)';
        }

        function copyEstimate() {
            const projM = parseFloat(document.getElementById('inWidth').value) || 3;
            const lenM = parseFloat(document.getElementById('inLength').value) || 6;
            const roofStyle = document.getElementById('inRoofStyle').value;
            const roofing = document.getElementById('inRoofing').value;
            const roofName = (ROOFING_TYPES[roofing] || ROOFING_TYPES.corrugated).name;
            const styleName = roofStyle.charAt(0).toUpperCase() + roofStyle.slice(1);

            const rangeEl = document.getElementById('rpEstRange');
            const rangeText = rangeEl ? rangeEl.textContent : '';
            const text = 'SecureWorks Patio Estimate\n' +
                lenM.toFixed(1) + 'm \u00D7 ' + projM.toFixed(1) + 'm ' + styleName + ' - ' + roofName + '\n' +
                'Approximately ' + rangeText.replace('~', '') + ' inc GST\n\n' +
                'This is a preliminary estimate only.\nFinal price confirmed after detailed scope.';

            navigator.clipboard.writeText(text).then(function() {
                var btn = document.querySelector('.rp-est-btn .btn');
                if (!btn) return;
                var orig = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(function() { btn.textContent = orig; }, 1500);
            });
        }

        // ==================== COLOR CHIPS ====================
        function initColorChips(containerId, labelId, setFn) {
            const container = document.getElementById(containerId);
            COLORS.forEach((c,i) => {
                const el = document.createElement('div');
                el.className = 'color-chip' + (i===0?' active':'');
                el.style.background = c.hex;
                el.title = c.name;
                el.onclick = () => {
                    setFn(c);
                    container.querySelectorAll('.color-chip').forEach(x=>x.classList.remove('active'));
                    el.classList.add('active');
                    document.getElementById(labelId).textContent = c.name;
                    rebuildAll();
                };
                container.appendChild(el);
            });
        }
        initColorChips('sheetChips', 'sheetLabel', c => sheetColor = c);
        initColorChips('steelChips', 'steelLabel', c => steelColor = c);

        // ==================== POLYCARBONATE ====================
        function isPolycarbEnabled() {
            return document.querySelector('input[name="polycarb"][value="yes"]')?.checked || false;
        }

        function getPolycarbConfig() {
            if (!isPolycarbEnabled()) return null;
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintEl = document.getElementById('inPolycarbTint');
            const tint = tintEl.value || 'Clear';
            const patternSel = document.getElementById('inPolycarbPattern').value;
            let steelPerPoly;
            if (patternSel === 'custom') {
                steelPerPoly = parseInt(document.getElementById('inPolycarbCustom').value) || 3;
            } else {
                steelPerPoly = parseInt(patternSel) - 1; // "Every 3rd" = 2 steel per 1 poly
            }
            return { brand, tint, steelPerPoly, patternN: steelPerPoly + 1 };
        }

        function getPolycarbSheetSplit(totalSheets) {
            const pc = getPolycarbConfig();
            if (!pc) return { colorbond: totalSheets, polycarb: 0 };
            const patternN = pc.patternN;
            const fullGroups = Math.floor(totalSheets / patternN);
            const remainder = totalSheets % patternN;
            const polycarb = fullGroups + (remainder >= patternN ? 1 : 0);
            const colorbond = totalSheets - polycarb;
            return { colorbond, polycarb };
        }

        function updatePolycarbUI() {
            const enabled = isPolycarbEnabled();
            document.getElementById('polycarbOptions').style.display = enabled ? 'block' : 'none';
            if (enabled) {
                updatePolycarbTints();
                updatePolycarbPreview();
            }
        }

        function updatePolycarbTints() {
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintSelect = document.getElementById('inPolycarbTint');
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const currentVal = tintSelect.value;
            tintSelect.innerHTML = tints.map(t =>
                `<option value="${t.name}">${t.name}</option>`
            ).join('');
            // Restore previous selection if still valid
            if (tints.some(t => t.name === currentVal)) {
                tintSelect.value = currentVal;
            }
            updatePolycarbPreview();
        }

        function updatePolycarbPreview() {
            const container = document.getElementById('polycarbPreview');
            if (!container) return;
            const patternSel = document.getElementById('inPolycarbPattern').value;
            document.getElementById('polycarbCustomField').style.display = patternSel === 'custom' ? 'block' : 'none';
            const pc = getPolycarbConfig();
            if (!pc) { container.innerHTML = ''; return; }

            // Get tint colour for preview
            const brand = pc.brand;
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const tintObj = tints.find(t => t.name === pc.tint) || tints[0];
            const tintColor = tintObj.color;

            // Show ~12 blocks as preview
            const previewCount = Math.min(12, Math.max(6, pc.patternN * 3));
            let html = '';
            for (let i = 0; i < previewCount; i++) {
                const isPoly = ((i + 1) % pc.patternN) === 0;
                if (isPoly) {
                    html += `<div class="pc-block polycarb" style="background:${tintColor}"></div>`;
                } else {
                    html += `<div class="pc-block steel"></div>`;
                }
            }
            container.innerHTML = html;
        }

        // Init polycarb tints on load
        updatePolycarbTints();

        // ==================== UI UPDATES ====================
        function updateUI() {
            const roofSelect = document.getElementById('inRoofStyle');
            const connSelect = document.getElementById('inConnection');
            const roofingSelect = document.getElementById('inRoofing');
            let conn = connSelect.value;
            const roofing = roofingSelect.value;
            const style = roofSelect.value;
            const isGable = style === 'gable' || style === 'hip';
            const isHip = style === 'hip';

            // === RESTRICTION: Wall mount only works with skillion ===
            const gableOption = roofSelect.querySelector('option[value="gable"]');
            const hipOption = roofSelect.querySelector('option[value="hip"]');
            if (conn === 'wall') {
                if (isGable) roofSelect.value = 'skillion';
                if (gableOption) gableOption.disabled = true;
                if (hipOption) hipOption.disabled = true;
            } else {
                if (gableOption) gableOption.disabled = false;
                if (hipOption) hipOption.disabled = false;
            }

            // === RESTRICTION: Gable/Hip restrict connection types ===
            const fasciaOption = connSelect.querySelector('option[value="fascia"]');
            const wallOption = connSelect.querySelector('option[value="wall"]');
            if (isGable) {
                if (conn === 'fascia' || conn === 'wall') { connSelect.value = 'riser'; conn = 'riser'; }
                if (fasciaOption) fasciaOption.disabled = true;
                if (wallOption) wallOption.disabled = true;
            } else {
                if (fasciaOption) fasciaOption.disabled = false;
                if (wallOption) wallOption.disabled = false;
            }

            // === RESTRICTION: Flyover only works with SolarSpan + skillion ===
            const flyoverOption = connSelect.querySelector('option[value="flyover"]');
            if (!isInsulated(roofing) || isGable) {
                if (conn === 'flyover') { connSelect.value = 'riser'; conn = 'riser'; }
                if (flyoverOption) flyoverOption.disabled = true;
            } else {
                if (flyoverOption) flyoverOption.disabled = false;
            }

            const isAttached = conn !== 'freestanding';

            // Truss calculator (gable only, not hip)
            document.getElementById('sec-truss').style.display = (style === 'gable') ? 'block' : 'none';
            // Technical config fields
            document.getElementById('orientationField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussField').style.display = isGable ? 'block' : 'none';
            document.getElementById('rafterField').style.display = isGable ? 'none' : 'block';
            document.getElementById('trussBaseField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussChordField').style.display = isGable ? 'block' : 'none';

            // Gable infill in BASICS (gable or hip)
            document.getElementById('gableInfillField').style.display = isGable ? 'block' : 'none';

            // Ceiling finish (SolarSpan only)
            document.getElementById('ceilingFinishField').style.display = isInsulated(roofing) ? 'block' : 'none';

            const showPitchInput = isGable || !isAttached;
            document.getElementById('pitchField').style.display = showPitchInput ? 'block' : 'none';
            document.getElementById('calcPitchRow').style.display = (!isGable && isAttached) ? 'flex' : 'none';

            // Connection sub-fields (in Site Details)
            document.getElementById('fasciaHeightField').style.display = isAttached ? 'block' : 'none';
            const showRiserOptions = conn === 'riser';
            document.getElementById('riserHeightField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserOffsetField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserQtyField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('houseGutterField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserGutterField').style.display = (showRiserOptions && isGable) ? 'block' : 'none';

            // Polycarbonate: only for Trimdek
            const showPolycarb = roofing === 'trimdek';
            document.getElementById('polycarbField').style.display = showPolycarb ? 'block' : 'none';
            if (!showPolycarb) {
                const noRadio = document.querySelector('input[name="polycarb"][value="no"]');
                if (noRadio) noRadio.checked = true;
                var pcOpts = document.getElementById('polycarbOptions');
                if (pcOpts) pcOpts.style.display = 'none';
            }
        }

        // ==================== GET INPUTS & CALCULATE ====================
        function getInputs() {
            const roofStyle = document.getElementById('inRoofStyle').value;
            const orientation = document.getElementById('inOrientation').value;
            const projInput = (parseFloat(document.getElementById('inWidth').value) || 3) * 1000;
            const lenInput = (parseFloat(document.getElementById('inLength').value) || 6) * 1000;
            const userPitch = parseFloat(document.getElementById('inPitch').value) || 10;
            const postH = (parseFloat(document.getElementById('inPostHeight').value) || 2.4) * 1000;
            const nPosts = parseInt(document.getElementById('inPosts').value) || 3;
            const nTruss = parseInt(document.getElementById('inTrusses').value) || 3;
            const nRafters = parseInt(document.getElementById('inRafters').value) || 5;
            const postSizeKey = document.getElementById('inPostSize').value;
            const beamSizeKey = document.getElementById('inBeamSize').value;
            const framePost = FRAME_POSTS[postSizeKey] || FRAME_POSTS['90x90'];
            const frameBeam = FRAME_BEAMS[beamSizeKey] || FRAME_BEAMS['100x50'];
            const trussStyle = document.getElementById('inTrussBase').value;
            const trussChord = document.getElementById('inTrussChord').value;
            const trussSteel = document.getElementById('inTrussSteel').value;

            // Truss options: extender + separate risers (L/R)
            // Use helper to allow 0 as valid input (|| would treat 0 as falsy)
            function numVal(id, def) { const v = parseFloat(document.getElementById(id)?.value); return isNaN(v) ? def : v; }
            const trussExtOn = document.getElementById('trussExtOn')?.checked || false;
            const trussExtLen = trussExtOn ? numVal('trussExtLen', 300) : 0;
            const trussRiserOn = document.getElementById('trussRiserOn')?.checked || false;
            const trussRiserLocked = document.getElementById('trussRiserLock')?.checked || true;
            const riserLH = trussRiserOn ? numVal('riserLH', 200) : 0;
            const riserLV = trussRiserOn ? numVal('riserLV', 150) : 0;
            const riserRH = trussRiserOn ? numVal('riserRH', 200) : 0;
            const riserRV = trussRiserOn ? numVal('riserRV', 150) : 0;
            const roofing = document.getElementById('inRoofing').value;
            const infill = document.getElementById('inInfill').value;
            const connection = document.getElementById('inConnection').value;
            const fasciaH = parseFloat(document.getElementById('inFasciaHeight').value) || 2700;
            const riserH = parseFloat(document.getElementById('inRiserHeight').value) || 400;
            const riserOffset = parseFloat(document.getElementById('inRiserOffset').value) || 150;
            const riserQtyInput = parseInt(document.getElementById('inRiserQty').value);
            const houseGutter = document.getElementById('inHouseGutter').value;
            const riserGutter = document.getElementById('inRiserGutter').value;

            const isGable = roofStyle === 'gable' || roofStyle === 'hip';
            const isAttached = connection !== 'freestanding';
            const hasFascia = (connection === 'fascia' || connection === 'riser' || connection === 'flyover');
            const isRecvChan = (connection === 'fascia' || connection === 'wall');

            let W, L;
            if (isGable && orientation === 'perpendicular') {
                W = lenInput;
                L = projInput;
            } else {
                W = projInput;
                L = lenInput;
            }

            // ========== V18 FIX: BEAM HEIGHTS - Proper stacking for gable+riser ==========
            let frontBeamY = postH;
            const beamH = frameBeam.h * 1000;  // beam height in mm from selected beam size
            const riserMemberSize = framePost.w * 1000;  // riser elbow SHS from post size
            // Patio attaches at rafter level (fasciaH = wall top / rafter base)
            // This is ABOVE the fascia board and gutter which hang below

            let backBeamY, fasciaBeamY;
            if (isGable) {
                if (connection === 'riser') {
                    // Gable + Riser: fascia beam sits below house gutter, against lower house fascia
                    // Gutter front face 76mm + 5mm gap ≈ beam top 50mm below fascia top
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    const elevatedBeamY = fasciaH + beamH + riserMemberSize + riserH;
                    frontBeamY = elevatedBeamY;
                    backBeamY = elevatedBeamY;
                } else if (connection === 'fascia' || connection === 'wall') {
                    // Gable + Fascia/Wall: both beams lowered for sheet clearance
                    fasciaBeamY = (connection === 'fascia') ? (fasciaH) : null;
                    frontBeamY = fasciaH;
                    backBeamY = fasciaH;
                } else if (connection === 'flyover') {
                    // Gable + Flyover: beams above existing house roof
                    fasciaBeamY = fasciaH;
                    // Calculate actual house roof rise: 1.5m depth at 15° pitch
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150; // 150mm clearance above roof ridge
                    const flyoverBeamY = fasciaH + houseRoofRise + flyoverClearance;
                    frontBeamY = flyoverBeamY;
                    backBeamY = flyoverBeamY;
                } else {
                    // Freestanding - back beam at post height
                    backBeamY = postH;
                    fasciaBeamY = null;
                }
            } else {
                // SKILLION
                if (connection === 'freestanding') {
                    const rise = W * Math.tan(userPitch * Math.PI / 180);
                    backBeamY = postH + rise;
                    fasciaBeamY = null;
                } else if (connection === 'riser') {
                    // Fascia beam sits below house gutter, against lower house fascia
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    backBeamY = fasciaH + beamH + riserMemberSize + riserH;
                } else if (connection === 'flyover') {
                    fasciaBeamY = fasciaH;
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150;
                    backBeamY = fasciaH + houseRoofRise + flyoverClearance;
                } else {
                    // fascia or wall
                    fasciaBeamY = (connection === 'fascia') ? (fasciaH) : null;
                    backBeamY = fasciaH;
                }
            }

            // ========== PITCH & RISE CALCULATION ==========
            let pitch, pitchRad, rise, rafter, trussSpan;

            if (isGable) {
                pitch = userPitch;
                pitchRad = pitch * Math.PI / 180;
                trussSpan = W;
                rise = (W / 2) * Math.tan(pitchRad);
                rafter = Math.sqrt((W / 2) ** 2 + rise ** 2);
            } else {
                rise = backBeamY - frontBeamY;
                pitch = Math.atan(rise / W) * 180 / Math.PI;
                pitchRad = pitch * Math.PI / 180;
                rafter = Math.sqrt(W ** 2 + rise ** 2);
                trussSpan = W;
            }

            calc = {
                roofStyle, orientation, W, L, projInput, lenInput, userPitch, pitch, pitchRad,
                postH, nPosts, nTruss, nRafters, trussStyle, trussChord, trussSteel, trussSpan,
                roofing, infill, connection, fasciaH, riserH, riserOffset, houseGutter, riserGutter,
                riserQty: riserQtyInput || Math.max(2, Math.ceil(L / 1200)),
                rise, rafter, isGable, isAttached, hasFascia, isRecvChan,
                frontBeamY, backBeamY, fasciaBeamY,
                steel: STEEL[trussSteel],
                framePost, frameBeam,
                sheetCoverage: SHEET_COVERAGE[roofing],
                trussRiserLeft: { enabled: trussRiserOn, length: riserLH, height: riserLV },
                trussRiserRight: { enabled: trussRiserOn, length: riserRH, height: riserRV },
                trussRiserLocked: trussRiserLocked,
                trussExtender: { enabled: trussExtOn, length: trussExtLen }
            };

            document.getElementById('calcRise').textContent = Math.round(rise) + 'mm';
            document.getElementById('calcRafter').textContent = Math.round(rafter) + 'mm';
            document.getElementById('calcPitch').textContent = pitch.toFixed(1) + '°';
            // Set riser qty placeholder to show calculated default
            document.getElementById('inRiserQty').placeholder = Math.max(2, Math.ceil(L / 1200));

            if (isGable) {
                const steelW = STEEL[trussSteel].w * 1000;
                const steelH = STEEL[trussSteel].h * 1000;
                const bmt = STEEL[trussSteel].bmt;
                const overhang = parseFloat(document.getElementById('inOverhang')?.value) || 0;
                const apexAngle = 90 - pitch;
                const heelAngle = pitch;
                const cosP = Math.cos(pitchRad);
                const sinP = Math.sin(pitchRad);

                // Bottom chord: full span (truss is a standard gable shape)
                const chordCut = Math.round(trussSpan - 2 * steelH * cosP);

                // Rafter cut length: from heel face to apex face
                const apexDeduct = steelH / (2 * sinP);
                const heelAllowance = steelH * cosP;
                const rafterCut = Math.round(rafter - apexDeduct - heelAllowance + overhang);

                // Truss steel: chord + 2 rafters
                let trussLM = (chordCut + 2 * rafterCut) / 1000;
                const stickLength = 6000;

                // Extender: extends bottom chord at BOTH ends (gutter bracket mount point)
                let extLM = 0;
                if (trussExtOn) {
                    extLM = (2 * trussExtLen) / 1000;
                }
                trussLM += extLM;

                const kingPostH = rise - steelH;

                // Web member calculations
                let webLM = 0;
                let webText = '';
                let webMembers = []; // array of {type, count, length}
                const showWeb = trussStyle !== 'open';
                document.getElementById('webCard').style.display = showWeb ? 'block' : 'none';

                if (trussStyle === 'kingpost') {
                    const kh = Math.round(kingPostH);
                    webMembers.push({type: 'King Post', count: 1, length: kh});
                    webLM = kh / 1000;
                    webText = '  King Post:     1 \u00D7 ' + kh + 'mm';
                } else if (trussStyle === 'verticalwebs') {
                    // Evenly-spaced vertical members from chord to rafter, each side
                    const halfSpanMM = trussSpan / 2;
                    // Target spacing ~400-600mm; pick count to land in that range
                    const nWebs = Math.max(1, Math.round(halfSpanMM / 500));
                    const spacing = halfSpanMM / (nWebs + 1);
                    const chordY = (trussChord === 'mid') ? (steelH + rise / 3) : steelH;
                    let totalWebLM = 0;
                    let cuts = [];
                    for (let i = 1; i <= nWebs; i++) {
                        const x = i * spacing;
                        // Rafter height at x from center (rafter goes from heel at halfSpan to apex at 0)
                        const rafterY = steelH + rise * (1 - x / halfSpanMM);
                        // For mid chord: chord is higher, so web only exists if rafterY > chordY
                        let webH;
                        if (trussChord === 'mid') {
                            // Mid chord runs between the rafter intersection points
                            const midY = steelH + rise / 3;
                            const lT = (midY - steelH) / rise;
                            const midHalfSpan = halfSpanMM * (1 - lT);
                            if (x > midHalfSpan) {
                                // Beyond mid chord - web goes from rafter to rafter (skip, it's above chord)
                                continue;
                            }
                            webH = rafterY - midY - steelH;
                        } else {
                            webH = rafterY - steelH - steelH; // from top of chord to bottom of rafter
                        }
                        if (webH > steelH) {
                            const wh = Math.round(webH);
                            cuts.push(wh);
                            totalWebLM += webH / 1000;
                        }
                    }
                    // Symmetric: double for both sides
                    const totalCount = cuts.length * 2;
                    webLM = totalWebLM * 2;
                    if (cuts.length > 0) {
                        webMembers = cuts.map(function(h) { return {type: 'Vertical', count: 2, length: h}; });
                        const cutStrs = cuts.map(function(h) { return h + 'mm'; });
                        webText = '  Verticals:     ' + totalCount + ' pcs (' + cutStrs.join(', ') + ' \u00D7 2)';
                    }
                } else if (trussStyle === 'kingdiagonal') {
                    // King post + 2 diagonal webs each side (fan pattern)
                    const kh = Math.round(kingPostH);
                    const halfSpanMM = trussSpan / 2;
                    const chordY = (trussChord === 'mid') ? (steelH + rise / 3) : steelH;
                    const apexYmm = steelH + rise;

                    // King post
                    webMembers.push({type: 'King Post', count: 1, length: kh});
                    webLM = kh / 1000;

                    // Diagonals: from lower chord (at 1/3 and 2/3 span) up to mid-rafter points
                    // Each diagonal runs from chord near heel up toward apex along rafter
                    // Lower diagonal: from chord at 2/3 halfSpan to rafter at 1/3 halfSpan
                    // Upper diagonal: from chord at 1/3 halfSpan to rafter at 1/6 halfSpan (near apex)
                    const pts = [
                        {cx: halfSpanMM * 2 / 3, rx: halfSpanMM * 1 / 3},
                        {cx: halfSpanMM * 1 / 3, rx: halfSpanMM * 1 / 6}
                    ];
                    let diagText = [];
                    for (let i = 0; i < pts.length; i++) {
                        var p = pts[i];
                        var cy = chordY + steelH / 2; // top of chord
                        var ry = steelH + rise * (1 - p.rx / halfSpanMM) - steelH / 2; // underside of rafter at rx
                        if (trussChord === 'mid') {
                            cy = (steelH + rise / 3) + steelH / 2;
                        }
                        var dx = p.cx - p.rx;
                        var dy = ry - cy;
                        var diagLen = Math.round(Math.sqrt(dx * dx + dy * dy));
                        if (diagLen > steelH) {
                            webMembers.push({type: 'Diagonal', count: 2, length: diagLen});
                            webLM += (diagLen / 1000) * 2;
                            diagText.push(diagLen + 'mm');
                        }
                    }
                    webText = '  King Post:     1 \u00D7 ' + kh + 'mm';
                    if (diagText.length > 0) {
                        webText += '\n  Diagonals:     ' + (diagText.length * 2) + ' pcs (' + diagText.join(', ') + ' \u00D7 2)';
                    }
                }

                // Update web card display
                if (showWeb) {
                    var styleName = trussStyle === 'kingpost' ? 'King Post' : trussStyle === 'verticalwebs' ? 'Vertical Webs' : 'King + Diagonal';
                    var totalPcs = 0;
                    var cutList = [];
                    for (var wi = 0; wi < webMembers.length; wi++) {
                        totalPcs += webMembers[wi].count;
                        cutList.push(webMembers[wi].count + '\u00D7' + webMembers[wi].length + 'mm');
                    }
                    document.getElementById('webStyle').textContent = styleName;
                    document.getElementById('webCount').textContent = totalPcs + ' pcs';
                    document.getElementById('webCuts').textContent = cutList.join(', ') || '--';
                    document.getElementById('webLM').textContent = webLM.toFixed(2) + ' LM';
                }

                const totalLM = trussLM + webLM;
                const totalAllLM = totalLM * nTruss;
                const totalSticks = Math.ceil((totalAllLM * 1000) / stickLength);

                // Riser steel: SEPARATE pieces bolted to truss ends (not part of truss)
                const riserLeftLM = trussRiserOn ? (riserLH + riserLV) / 1000 : 0;
                const riserRightLM = trussRiserOn ? (riserRH + riserRV) / 1000 : 0;
                const riserTotalLM = (riserLeftLM + riserRightLM) * nTruss;

                // Update spec cards
                document.getElementById('specA').textContent = Math.round(trussSpan);
                document.getElementById('specB').textContent = Math.round(rise);
                document.getElementById('specC').textContent = Math.round(rafter);
                document.getElementById('specD').textContent = pitch.toFixed(1) + '\u00B0';

                // Conditional dimension items
                document.getElementById('specExtItem').style.display = trussExtOn ? 'block' : 'none';
                document.getElementById('specRiserLItem').style.display = trussRiserOn ? 'block' : 'none';
                document.getElementById('specRiserRItem').style.display = trussRiserOn ? 'block' : 'none';
                document.getElementById('specRiserLMitem').style.display = trussRiserOn ? 'block' : 'none';
                if (trussExtOn) {
                    document.getElementById('specExt').textContent = Math.round(trussExtLen);
                }
                if (trussRiserOn) {
                    document.getElementById('specRiserL').textContent = Math.round(riserLH) + '\u00D7' + Math.round(riserLV);
                    document.getElementById('specRiserR').textContent = Math.round(riserRH) + '\u00D7' + Math.round(riserRV);
                    document.getElementById('specRiserLM').textContent = (riserLeftLM + riserRightLM).toFixed(2);
                }

                document.getElementById('specChordCut').textContent = chordCut + (trussExtOn ? ' (+' + Math.round(trussExtLen * 2) + ' ext)' : '');
                document.getElementById('specRafterCut').textContent = rafterCut + (overhang > 0 ? ' (+' + overhang + ')' : '');
                document.getElementById('specLMper').textContent = totalLM.toFixed(2);
                document.getElementById('specLMall').textContent = totalAllLM.toFixed(1) + (riserTotalLM > 0 ? ' (+' + riserTotalLM.toFixed(1) + ' risers)' : '');

                document.getElementById('angleApex').textContent = apexAngle.toFixed(1) + '\u00B0';
                document.getElementById('angleBase').textContent = heelAngle.toFixed(1) + '\u00B0';

                // Build CMI format order text
                const steelName = STEEL[trussSteel].name;
                const clr = steelColor.name;

                const baseName = trussStyle === 'kingpost' ? 'King Post' : trussStyle === 'verticalwebs' ? 'Vertical Webs' : trussStyle === 'kingdiagonal' ? 'King + Diagonal' : 'Open';
                const chordName = trussChord === 'bottom' ? 'Bottom Chord' : (trussChord === 'mid' ? 'Mid Chord' : 'No Chord');
                let extras = '';
                if (trussExtOn) extras += ' + Extender';
                if (trussRiserOn) extras += ' + Risers (separate)';
                const line1 = nTruss + '\u00D7 Gable Truss - ' + baseName + ', ' + chordName + extras;

                let dims = 'SP: ' + Math.round(trussSpan) + '  HT: ' + Math.round(rise);
                if (trussExtOn) dims += '  Ext: ' + Math.round(trussExtLen);

                const line3 = steelName + ' RHS - ' + clr;

                let fab = line1 + '\n ' + dims + '\n ' + line3;

                fab += '\n\n\u2500\u2500 Cut List (per truss) \u2500\u2500';
                fab += '\n Chord:        1 \u00D7 ' + chordCut + 'mm';
                if (trussExtOn) {
                    fab += '\n Extender:     2 \u00D7 ' + Math.round(trussExtLen) + 'mm';
                }
                fab += '\n Rafters:      2 \u00D7 ' + rafterCut + 'mm';
                for (var wi = 0; wi < webMembers.length; wi++) {
                    var wm = webMembers[wi];
                    var label = (wm.type + ':').padEnd(14, ' ');
                    fab += '\n ' + label + wm.count + ' \u00D7 ' + wm.length + 'mm';
                }
                fab += '\n Apex Mitre:   ' + apexAngle.toFixed(1) + '\u00B0';
                fab += '\n Heel Mitre:   ' + heelAngle.toFixed(1) + '\u00B0';

                if (trussRiserOn) {
                    fab += '\n\n\u2500\u2500 Risers (separate steel) \u2500\u2500';
                    fab += '\n Left:  ' + Math.round(riserLH) + 'mm horiz + ' + Math.round(riserLV) + 'mm vert = ' + riserLeftLM.toFixed(2) + ' LM';
                    fab += '\n Right: ' + Math.round(riserRH) + 'mm horiz + ' + Math.round(riserRV) + 'mm vert = ' + riserRightLM.toFixed(2) + ' LM';
                    fab += '\n Total riser steel: ' + riserTotalLM.toFixed(2) + ' LM (' + nTruss + ' trusses)';
                }

                fab += '\n\n\u2500\u2500 Material \u2500\u2500';
                fab += '\n Truss LM/ea: ' + totalLM.toFixed(3) + ' LM';
                fab += '\n Truss total: ' + totalAllLM.toFixed(2) + ' LM';
                if (riserTotalLM > 0) fab += '\n Riser total: ' + riserTotalLM.toFixed(2) + ' LM';
                fab += '\n Grand total: ' + (totalAllLM + riserTotalLM).toFixed(2) + ' LM';
                fab += '\n Order:       ' + Math.ceil(((totalAllLM + riserTotalLM) * 1000) / stickLength) + ' \u00D7 6m sticks';

                document.getElementById('fabOrder').textContent = fab;

                // Store truss data for PDF export
                calc.trussData = {
                    steelName, bmt, clr, nTruss, trussSpan: Math.round(trussSpan),
                    rise: Math.round(rise), pitch, overhang, chordCut, rafterCut,
                    apexAngle, heelAngle, webText, webMembers, totalLM, totalAllLM, totalSticks,
                    trussStyle, trussChord, kingPostH: Math.round(kingPostH),
                    riserLeft: { enabled: trussRiserOn, length: riserLH, height: riserLV, lm: riserLeftLM },
                    riserRight: { enabled: trussRiserOn, length: riserRH, height: riserRV, lm: riserRightLM },
                    riserTotalLM: riserTotalLM,
                    extender: { enabled: trussExtOn, length: trussExtLen }
                };
            }

            return calc;
        }

        // ==================== 2D PLAN ====================
        function draw2DPlan() {
            const canvas = document.getElementById('plan2d');
            const p = canvas.parentElement;
            canvas.width = p.clientWidth; canvas.height = p.clientHeight;
            const ctx = canvas.getContext('2d');
            const c = calc;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            const planL = c.lenInput;
            const planW = c.projInput;

            const scale = Math.min((canvas.width-60)/planL, (canvas.height-60)/planW) * 0.85;
            const ox = (canvas.width - planL*scale)/2;
            const oy = (canvas.height - planW*scale)/2 + 10;

            if (c.connection !== 'freestanding') {
                ctx.fillStyle = '#D4C4B0';
                ctx.fillRect(ox-5, oy-20, planL*scale+10, 18);
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('HOUSE', ox+planL*scale/2, oy-6);
            }

            ctx.strokeStyle = steelColor.hex;
            ctx.lineWidth = 2;
            ctx.strokeRect(ox, oy, planL*scale, planW*scale);

            ctx.strokeStyle = '#F15A29';
            ctx.lineWidth = 2;
            if (c.isGable) {
                if (c.orientation === 'lengthways') {
                    ctx.beginPath();
                    ctx.moveTo(ox, oy + planW*scale/2);
                    ctx.lineTo(ox + planL*scale, oy + planW*scale/2);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.fillText('RIDGE', ox + planL*scale/2, oy + planW*scale/2 - 5);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(ox + planL*scale/2, oy);
                    ctx.lineTo(ox + planL*scale/2, oy + planW*scale);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.save();
                    ctx.translate(ox + planL*scale/2 + 12, oy + planW*scale/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.fillText('RIDGE', 0, 0);
                    ctx.restore();
                }
            } else {
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2, oy + 15);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2 - 6, oy + planW*scale - 25);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.lineTo(ox + planL*scale/2 + 6, oy + planW*scale - 25);
                ctx.stroke();
                ctx.fillStyle = '#F15A29';
                ctx.font = '9px sans-serif';
                ctx.fillText('FALL ' + calc.pitch.toFixed(1) + '°', ox + planL*scale/2 + 30, oy + planW*scale/2);
            }

            ctx.fillStyle = steelColor.hex;
            for (let i = 0; i < c.nPosts; i++) {
                const x = ox + (planL*scale/(c.nPosts-1)) * i;
                ctx.fillRect(x-4, oy + planW*scale - 4, 8, 8);
            }

            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = ox + (planL*scale/(c.nPosts-1)) * i;
                    ctx.fillRect(x-4, oy - 4, 8, 8);
                }
            }

            if (c.isAttached) {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.lineTo(ox + planL*scale, oy);
                ctx.stroke();
                ctx.fillStyle = '#666';
                ctx.font = '8px sans-serif';
                ctx.fillText('FASCIA', ox + planL*scale/2, oy + 10);
            }

            ctx.fillStyle = '#333';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(planL + 'mm', ox + planL*scale/2, oy + planW*scale + 20);
            ctx.save();
            ctx.translate(ox - 15, oy + planW*scale/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText(planW + 'mm', 0, 0);
            ctx.restore();
        }

        // ==================== TRUSS 3D (Section 2) ====================
        let trussScene, trussCam, trussRend, trussGroup, trussControls;

        function initTruss3D() {
            const container = document.getElementById('trussViewport');
            const canvas = document.getElementById('trussCanvas');
            var w = container.clientWidth || 600;
            var h = container.clientHeight || 420;
            trussScene = new THREE.Scene();
            trussScene.background = new THREE.Color(0xF0F2F5);
            trussCam = new THREE.PerspectiveCamera(35, w/h, 0.01, 50);
            trussRend = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true});
            trussRend.setSize(w, h);
            trussRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            trussRend.toneMapping = THREE.ACESFilmicToneMapping;
            trussRend.toneMappingExposure = 1.1;

            // Enhanced lighting
            trussScene.add(new THREE.AmbientLight(0xffffff, 0.55));
            const keyLight = new THREE.DirectionalLight(0xffffff, 0.85);
            keyLight.position.set(3, 5, 4);
            trussScene.add(keyLight);
            const fillLight = new THREE.DirectionalLight(0xB0C4DE, 0.35);
            fillLight.position.set(-2, 3, -3);
            trussScene.add(fillLight);
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.2);
            rimLight.position.set(0, -1, 5);
            trussScene.add(rimLight);

            trussGroup = new THREE.Group();
            trussScene.add(trussGroup);

            // OrbitControls - full pan/zoom/rotate
            trussControls = new THREE.OrbitControls(trussCam, canvas);
            trussControls.enableDamping = true;
            trussControls.dampingFactor = 0.05;
            trussControls.screenSpacePanning = true;
            trussControls.enablePan = true;
            trussControls.enableZoom = true;
            trussControls.enableRotate = true;
            trussControls.minDistance = 0.15;
            trussControls.maxDistance = 15;
            trussControls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            trussControls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            // Default to front view
            setTrussView('front', document.querySelector('.truss-view-btn.active'));
            buildTruss3D();

            // Edge panning for truss 3D viewer
            setupEdgePanning3D(container, trussCam, trussControls);

            animateTruss();
        }

        // Truss is built in XY plane: X = span (horizontal), Y = rise (vertical), Z = depth
        function buildTruss3D() {
            while (trussGroup.children.length) trussGroup.remove(trussGroup.children[0]);
            if (!calc.isGable) return;

            const c = calc;
            const span = c.trussSpan / 1000;
            const rise = c.rise / 1000;
            const halfSpan = span / 2;
            const tw = c.steel.w;
            const th = c.steel.h;
            const overhang = (parseFloat(document.getElementById('inOverhang')?.value) || 0) / 1000;
            const mat = new THREE.MeshStandardMaterial({color: new THREE.Color(steelColor.hex), metalness: 0.6, roughness: 0.45, envMapIntensity: 0.3});

            // Truss options (mm → m)
            const extOn = c.trussExtender.enabled;
            const extLen = c.trussExtender.length / 1000;
            const riserOn = c.trussRiserLeft.enabled;
            const rLH = c.trussRiserLeft.length / 1000;
            const rLV = c.trussRiserLeft.height / 1000;
            const rRH = c.trussRiserRight.length / 1000;
            const rRV = c.trussRiserRight.height / 1000;
            const chordType = c.trussChord;
            const heelY = th;           // both heels at same level (standard gable)
            const apexY = th + rise;
            const jt = th * 0.6;        // joint overlap extension

            // Helper: box member between two 2D points
            // extS/extE = extend start/end past endpoints for joint overlap
            function mbr(x1, y1, x2, y2, extS, extE) {
                if (extS === undefined) extS = 0;
                if (extE === undefined) extE = 0;
                const dx = x2 - x1, dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len < 0.001) return;
                const ux = dx / len, uy = dy / len;
                const ax = x1 - ux * extS, ay = y1 - uy * extS;
                const bx = x2 + ux * extE, by = y2 + uy * extE;
                const totalLen = len + extS + extE;
                const geo = new THREE.BoxGeometry(totalLen, th, tw);
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.position.set((ax + bx) / 2, (ay + by) / 2, 0);
                mesh.rotation.z = Math.atan2(dy, dx);
                trussGroup.add(mesh);
            }

            // --- Bottom Chord (standard horizontal, full span) ---
            if (chordType === 'bottom') {
                mbr(-halfSpan, th / 2, halfSpan, th / 2, jt, jt);
                if (extOn) {
                    mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2, 0, jt);
                    mbr(halfSpan, th / 2, halfSpan + extLen, th / 2, jt, 0);
                }
            } else if (chordType === 'mid') {
                const midY = th + rise / 3;
                const lT = (midY - heelY) / (apexY - heelY);
                const midLeftX = lT > 0 ? -halfSpan * (1 - lT) : -halfSpan;
                const midRightX = lT > 0 ? halfSpan * (1 - lT) : halfSpan;
                if (midLeftX < midRightX) mbr(midLeftX, midY, midRightX, midY, jt, jt);
                if (extOn) {
                    mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2, 0, jt);
                    mbr(halfSpan, th / 2, halfSpan + extLen, th / 2, jt, 0);
                }
            } else if (extOn) {
                mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2);
                mbr(halfSpan, th / 2, halfSpan + extLen, th / 2);
            }

            // --- Rafters (symmetrical, both from heelY to apex) ---
            {
                const rdx = halfSpan, rdy = apexY - heelY;
                const rd = Math.sqrt(rdx * rdx + rdy * rdy);
                // Left rafter - extends past heel and apex for clean joints
                const lsX = overhang > 0 ? -halfSpan - (rdx / rd) * overhang : -halfSpan;
                const lsY = overhang > 0 ? heelY - (rdy / rd) * overhang : heelY;
                mbr(lsX, lsY, 0, apexY, overhang > 0 ? 0 : jt, jt);
                // Right rafter
                const rsX = overhang > 0 ? halfSpan + (rdx / rd) * overhang : halfSpan;
                const rsY = overhang > 0 ? heelY - (rdy / rd) * overhang : heelY;
                mbr(rsX, rsY, 0, apexY, overhang > 0 ? 0 : jt, jt);
            }

            // --- Web Members ---
            if (c.trussStyle === 'kingpost') {
                const kBottom = chordType === 'mid' ? (th + rise / 3 + th / 2) : th;
                const kTop = apexY - th;
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop, jt, jt);
                }
            } else if (c.trussStyle === 'verticalwebs') {
                const halfSpanM = halfSpan;
                const nWebs = Math.max(1, Math.round((halfSpanM * 1000) / 500));
                const spacingM = halfSpanM / (nWebs + 1);
                const chordYm = chordType === 'mid' ? (th + rise / 3) : th;
                for (let i = 1; i <= nWebs; i++) {
                    const x = i * spacingM;
                    const rafterYm = th + rise * (1 - x / halfSpanM);
                    let bottomY, topY;
                    if (chordType === 'mid') {
                        const midY = th + rise / 3;
                        const lT = (midY - th) / rise;
                        const midHalfSpan = halfSpanM * (1 - lT);
                        if (x > midHalfSpan) continue;
                        bottomY = midY + th / 2;
                        topY = rafterYm - th / 2;
                    } else {
                        bottomY = th + th / 2;  // top of chord
                        topY = rafterYm - th / 2;  // bottom of rafter
                    }
                    if (topY > bottomY + th * 0.5) {
                        // Left side (negative X)
                        mbr(-x, bottomY, -x, topY, jt, jt);
                        // Right side (positive X)
                        mbr(x, bottomY, x, topY, jt, jt);
                    }
                }
            } else if (c.trussStyle === 'kingdiagonal') {
                // King post
                const kBottom = chordType === 'mid' ? (th + rise / 3 + th / 2) : th;
                const kTop = apexY - th;
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop, jt, jt);
                }
                // Diagonal webs: fan pattern from lower chord up to rafter
                const halfSpanM = halfSpan;
                const chordYm = chordType === 'mid' ? (th + rise / 3) : th;
                const pts = [
                    {cx: halfSpanM * 2 / 3, rx: halfSpanM * 1 / 3},
                    {cx: halfSpanM * 1 / 3, rx: halfSpanM * 1 / 6}
                ];
                for (let i = 0; i < pts.length; i++) {
                    const p = pts[i];
                    const cy = chordYm + th / 2; // top of chord
                    const ry = th + rise * (1 - p.rx / halfSpanM) - th / 2; // underside of rafter
                    if (ry > cy + th) {
                        // Left side: chord at -cx, rafter at -rx
                        mbr(-p.cx, cy, -p.rx, ry, jt, jt);
                        // Right side: chord at +cx, rafter at +rx
                        mbr(p.cx, cy, p.rx, ry, jt, jt);
                    }
                }
            }

            // --- Risers (SEPARATE L-shaped pieces bolted to truss heel ends) ---
            if (riserOn) {
                const lHeelX = extOn ? -halfSpan - extLen : -halfSpan;
                mbr(lHeelX, th / 2, lHeelX, th / 2 - rLV, jt, 0);        // vertical down
                mbr(lHeelX, th / 2 - rLV, lHeelX - rLH, th / 2 - rLV, jt, 0); // horizontal out

                const rHeelX = extOn ? halfSpan + extLen : halfSpan;
                mbr(rHeelX, th / 2, rHeelX, th / 2 - rRV, jt, 0);        // vertical down
                mbr(rHeelX, th / 2 - rRV, rHeelX + rRH, th / 2 - rRV, jt, 0); // horizontal out
            }

            // --- Dimension annotations ---
            const dimMat = new THREE.LineBasicMaterial({color: 0xF15A29});
            const off = 0.08;
            // Lowest point for SP baseline
            const lowestY = (riserOn ? Math.min(th / 2 - rLV, th / 2 - rRV) : 0) - off;
            const spBaseY = Math.min(-off, lowestY);

            // SP: Span
            addDimLine(-halfSpan, spBaseY, halfSpan, spBaseY, dimMat);
            addTrussLabel('SP: ' + Math.round(c.trussSpan) + 'mm', 0, spBaseY - 0.07);

            // HT: Height (from chord level to apex)
            const htX = halfSpan + off * 1.5 + (extOn ? extLen : 0);
            addDimLine(htX, th, htX, apexY, dimMat);
            addTrussLabel('HT: ' + Math.round(c.rise) + 'mm', htX + 0.15, th + rise / 2);

            // Rafter label (on left rafter)
            const rMidX = halfSpan * 0.55;
            const rMidY = heelY + (apexY - heelY) * 0.45;
            addTrussLabel('Rafter: ' + Math.round(c.rafter) + 'mm', -rMidX - 0.18, rMidY + 0.05);

            // Extender labels (orange, both sides)
            if (extOn) {
                const eMat = new THREE.LineBasicMaterial({color: 0xFF9800});
                const extY = -off * 0.5;
                addDimLine(halfSpan, extY, halfSpan + extLen, extY, eMat);
                addSmallLabel('Ext: ' + Math.round(c.trussExtender.length), halfSpan + extLen / 2, extY - off);
                addDimLine(-halfSpan - extLen, extY, -halfSpan, extY, eMat);
                addSmallLabel('Ext', -halfSpan - extLen / 2, extY - off);
            }

            // Riser labels (blue, both sides)
            if (riserOn) {
                const rMat = new THREE.LineBasicMaterial({color: 0x2196F3});
                // Left riser dims
                const lhx = extOn ? -halfSpan - extLen : -halfSpan;
                addDimLine(lhx - off, th / 2, lhx - off, th / 2 - rLV, rMat);
                addSmallLabel(Math.round(c.trussRiserLeft.height) + 'v', lhx - off * 2.5, th / 2 - rLV / 2);
                addDimLine(lhx - rLH, th / 2 - rLV - off, lhx, th / 2 - rLV - off, rMat);
                addSmallLabel(Math.round(c.trussRiserLeft.length) + 'h', lhx - rLH / 2, th / 2 - rLV - off * 2);
                // Right riser dims
                const rhx = extOn ? halfSpan + extLen : halfSpan;
                addDimLine(rhx + off, th / 2, rhx + off, th / 2 - rRV, rMat);
                addSmallLabel(Math.round(c.trussRiserRight.height) + 'v', rhx + off * 2.5, th / 2 - rRV / 2);
                addDimLine(rhx, th / 2 - rRV - off, rhx + rRH, th / 2 - rRV - off, rMat);
                addSmallLabel(Math.round(c.trussRiserRight.length) + 'h', rhx + rRH / 2, th / 2 - rRV - off * 2);
            }

            // Pitch angle arc at right heel
            addAngleArc(halfSpan, heelY, 0.15, c.pitchRad, dimMat);
            addSmallLabel(c.pitch.toFixed(1) + '\u00B0', halfSpan - 0.06, heelY + 0.07);

            // Apex angle arc
            addAngleArc(0, apexY, 0.1, Math.PI / 2 - c.pitchRad, dimMat, true);
            addSmallLabel((90 - c.pitch).toFixed(1) + '\u00B0', 0, apexY + 0.08);

            // Cut markers
            addCutMarker(0, apexY, 'APEX');
            addCutMarker(-halfSpan, heelY, 'HEEL');
            addCutMarker(halfSpan, heelY, 'HEEL');

            if (trussControls) trussControls.update();
        }

        function addDimLine(x1, y1, x2, y2, mat) {
            const pts = [new THREE.Vector3(x1, y1, 0.005), new THREE.Vector3(x2, y2, 0.005)];
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            trussGroup.add(new THREE.Line(geo, mat));
            const tick = 0.035;
            const isVert = Math.abs(y2 - y1) > Math.abs(x2 - x1);
            [pts[0], pts[1]].forEach(p => {
                const t = isVert
                    ? [new THREE.Vector3(p.x - tick, p.y, 0.005), new THREE.Vector3(p.x + tick, p.y, 0.005)]
                    : [new THREE.Vector3(p.x, p.y - tick, 0.005), new THREE.Vector3(p.x, p.y + tick, 0.005)];
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(t), mat));
            });
        }

        function addAngleArc(cx, cy, radius, angle, mat, isApex) {
            const pts = [];
            const segs = 24;
            for (let i = 0; i <= segs; i++) {
                const a = (i / segs) * angle;
                if (isApex) {
                    const startAngle = Math.PI/2 + angle;
                    const aa = startAngle - (i / segs) * angle;
                    pts.push(new THREE.Vector3(cx + radius * Math.cos(aa), cy + radius * Math.sin(aa), 0.005));
                } else {
                    pts.push(new THREE.Vector3(cx - radius * Math.cos(a), cy + radius * Math.sin(a), 0.005));
                }
            }
            trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
        }

        function addCutMarker(x, y, label) {
            const markerMat = new THREE.MeshBasicMaterial({color: 0xFF6B35, transparent: true, opacity: 0.9});
            const marker = new THREE.Mesh(new THREE.CircleGeometry(0.025, 16), markerMat);
            marker.position.set(x, y, 0.015);
            trussGroup.add(marker);
        }

        function addSmallLabel(text, x, y) {
            const dpr = 2;
            const cv = document.createElement('canvas');
            cv.width = 160 * dpr; cv.height = 36 * dpr;
            const ctx = cv.getContext('2d');
            ctx.scale(dpr, dpr);
            ctx.fillStyle = 'rgba(40,55,65,0.92)';
            ctx.beginPath(); ctx.roundRect(0, 2, 160, 32, 5); ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px "SF Mono", Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 80, 19);
            const tex = new THREE.CanvasTexture(cv);
            tex.minFilter = THREE.LinearFilter;
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex, depthTest: false}));
            sprite.scale.set(0.18, 0.045, 1);
            sprite.position.set(x, y, 0.03);
            trussGroup.add(sprite);
        }

        function addTrussLabel(text, x, y) {
            const dpr = 2;
            const cv = document.createElement('canvas');
            cv.width = 320 * dpr; cv.height = 48 * dpr;
            const ctx = cv.getContext('2d');
            ctx.scale(dpr, dpr);
            // Shadow
            ctx.shadowColor = 'rgba(0,0,0,0.25)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetY = 2;
            ctx.fillStyle = '#F15A29';
            ctx.beginPath(); ctx.roundRect(2, 4, 316, 40, 6); ctx.fill();
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px "SF Mono", Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 160, 25);
            const tex = new THREE.CanvasTexture(cv);
            tex.minFilter = THREE.LinearFilter;
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex, depthTest: false}));
            sprite.scale.set(0.38, 0.07, 1);
            sprite.position.set(x, y, 0.03);
            trussGroup.add(sprite);
        }

        function setTrussView(v, btn) {
            document.querySelectorAll('.truss-view-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            const span = (calc.trussSpan || 3000) / 1000;
            const rise = (calc.rise || 264) / 1000;
            const apexY = (calc.steel ? calc.steel.h : 0.038) + rise;
            const targetY = apexY * 0.4;
            const baseDist = Math.max(2.5, span * 0.75);
            const target = new THREE.Vector3(0, targetY, 0);

            if (trussControls) trussControls.target.copy(target);
            if (v === '3d') {
                trussCam.position.set(baseDist * 0.4, targetY + baseDist * 0.3, baseDist * 0.85);
            } else if (v === 'front') {
                trussCam.position.set(0, targetY, baseDist);
            } else if (v === 'side') {
                trussCam.position.set(baseDist * 0.5, targetY + 0.05, 0.01);
            }
            trussCam.lookAt(target);
            if (trussControls) trussControls.update();
        }

        function animateTruss() {
            requestAnimationFrame(animateTruss);
            if (trussControls) trussControls.update();
            if (trussRend && trussScene && trussCam) {
                trussRend.render(trussScene, trussCam);
            }
        }

        // ==================== ASSEMBLY 3D (Section 3) ====================
        let asmScene, asmCam, asmRend, asmRay, asmMouse, asmControls;
        // rpRend removed — single renderer now lives in right panel as asmRend
        let steelGrp, roofGrp, accGrp, houseGrp;
        let compData = new Map();
        let hovered = null;

        function initAsm3D() {
            const container = document.getElementById('asmViewport');
            const canvas = document.getElementById('asmCanvas');
            var w = container.clientWidth || 600;
            var h = container.clientHeight || 360;
            asmScene = new THREE.Scene();
            asmScene.background = new THREE.Color(0xC4CCD4);
            asmCam = new THREE.PerspectiveCamera(35, w/h, 0.1, 100);
            asmRend = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true});
            asmRend.setSize(w, h);
            asmRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            asmRend.shadowMap.enabled = true;
            asmRend.shadowMap.type = THREE.PCFSoftShadowMap;
            asmRend.toneMapping = THREE.ACESFilmicToneMapping;
            asmRend.toneMappingExposure = 1.1;

            asmRay = new THREE.Raycaster();
            asmMouse = new THREE.Vector2();

            // Lighting: ambient + sun with shadows + fill
            asmScene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const sun = new THREE.DirectionalLight(0xffffff, 0.85);
            sun.position.set(5, 10, 7);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            asmScene.add(sun);
            const fill = new THREE.DirectionalLight(0xB0C4DE, 0.3);
            fill.position.set(-3, 2, -3);
            asmScene.add(fill);

            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshStandardMaterial({color: 0xA8A090, roughness: 0.9})
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            asmScene.add(ground);

            steelGrp = new THREE.Group();
            roofGrp = new THREE.Group();
            accGrp = new THREE.Group();
            houseGrp = new THREE.Group();
            asmScene.add(steelGrp);
            asmScene.add(roofGrp);
            asmScene.add(accGrp);
            asmScene.add(houseGrp);

            // OrbitControls - full pan/zoom/rotate
            asmControls = new THREE.OrbitControls(asmCam, canvas);
            asmControls.enableDamping = true;
            asmControls.dampingFactor = 0.05;
            asmControls.screenSpacePanning = true;
            asmControls.enablePan = true;
            asmControls.enableZoom = true;
            asmControls.enableRotate = true;
            asmControls.minDistance = 0.5;
            asmControls.maxDistance = 25;
            asmControls.target.set(0, 1.5, 0);
            asmControls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            asmControls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            // Hover detection (keep for tooltip)
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                asmMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                asmMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                checkHover(e.clientX - rect.left, e.clientY - rect.top);
            });
            canvas.addEventListener('mouseleave', () => { clearHover(); });

            // Set default 3D view position
            asmCam.position.set(8, 5, 8);
            asmCam.lookAt(0, 1.5, 0);
            asmControls.update();

            buildAsm3D();

            // Edge panning for assembly 3D viewer
            setupEdgePanning3D(container, asmCam, asmControls);

            animateAsm();
        }

        function createCorrugatedGeometry(width, length, segments = 20) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const waveHeight = 0.012;
            const waveFreq = 15;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                pos.setZ(i, Math.sin(x * waveFreq * Math.PI) * waveHeight);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createTrimdekGeometry(width, length, segments = 30) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const ribHeight = 0.025;
            const ribWidth = 0.04;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const phase = ((x / ribWidth) % 1 + 1) % 1;
                let z = 0;
                if (phase < 0.3) z = ribHeight * (phase / 0.3);
                else if (phase < 0.7) z = ribHeight;
                else z = ribHeight * (1 - (phase - 0.7) / 0.3);
                pos.setZ(i, z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createInsulatedGeometry(width, length) {
            return new THREE.BoxGeometry(width, length, 0.05);
        }

        function buildAsm3D() {
            if (!steelGrp || !calc.W) return;
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => { while(g.children.length) g.remove(g.children[0]); });
            compData.clear();

            const c = calc;
            const W = c.W / 1000;
            const L = c.L / 1000;
            const postH = c.postH / 1000;
            const rise = c.rise / 1000;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;
            const th = c.steel.h;
            const frontBeamY = c.frontBeamY / 1000;
            const backBeamY = c.backBeamY / 1000;
            const fasciaBeamY = c.fasciaBeamY ? c.fasciaBeamY / 1000 : null;

            const steelCol = new THREE.Color(steelColor.hex);
            const sheetCol = new THREE.Color(sheetColor.hex);
            const sMat = () => new THREE.MeshStandardMaterial({color: steelCol, metalness: 0.8, roughness: 0.3});
            const rMat = () => new THREE.MeshStandardMaterial({color: sheetCol, metalness: 0.5, roughness: 0.4, side: THREE.DoubleSide});

            const fasciaCol = new THREE.Color(steelColor.hex).offsetHSL(0, -0.1, 0.15);
            const fasciaMat = () => new THREE.MeshStandardMaterial({color: fasciaCol, metalness: 0.7, roughness: 0.4});

            const riserCol = new THREE.Color(0x8B4513);
            const riserMat = () => new THREE.MeshStandardMaterial({color: riserCol, metalness: 0.6, roughness: 0.5});

            const beamW = c.frameBeam.w, beamH = c.frameBeam.h, postW = c.framePost.w;

            const isPerpendicular = c.isGable && c.orientation === 'perpendicular';

            // ===== FRONT POSTS (Gutter side) =====
            const fpostH = frontBeamY;  // May be elevated for gable+riser
            for (let i = 0; i < c.nPosts; i++) {
                const x = -L/2 + (L / (c.nPosts - 1)) * i;
                const post = new THREE.Mesh(new THREE.BoxGeometry(postW, fpostH, postW), sMat());
                if (isPerpendicular) {
                    post.position.set(W/2, fpostH/2, x);
                } else {
                    post.position.set(x, fpostH/2, W/2);
                }
                post.castShadow = true;
                steelGrp.add(post);
                regComp(post, 'Front Post ' + (i+1), {'Size': c.framePost.name, 'Height': Math.round(fpostH*1000) + 'mm'});
            }

            // ===== BACK POSTS (freestanding only) =====
            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = -L/2 + (L / (c.nPosts - 1)) * i;
                    const bpostH = backBeamY;
                    const post = new THREE.Mesh(new THREE.BoxGeometry(postW, bpostH, postW), sMat());
                    if (isPerpendicular) {
                        post.position.set(-W/2, bpostH/2, x);
                    } else {
                        post.position.set(x, bpostH/2, -W/2);
                    }
                    post.castShadow = true;
                    steelGrp.add(post);
                    regComp(post, 'Back Post ' + (i+1), {'Size': c.framePost.name, 'Height': Math.round(bpostH*1000) + 'mm'});
                }
            }

            // ===== GUTTER BEAM (Front beam on posts) =====
            const gutterBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamH, beamW), sMat());
            if (isPerpendicular) {
                gutterBeam.rotation.y = Math.PI / 2;
                gutterBeam.position.set(W/2, frontBeamY + beamH/2, 0);
            } else {
                gutterBeam.position.set(0, frontBeamY + beamH/2, W/2);
            }
            gutterBeam.castShadow = true;
            steelGrp.add(gutterBeam);
            regComp(gutterBeam, 'Gutter Beam', {'Size': c.frameBeam.name, 'Length': c.L + 'mm'});

            // ===== FASCIA BEAM (on house - for attached only) =====
            // Against house fascia board face, below gutter in exposed fascia zone
            if (c.isAttached && fasciaBeamY !== null) {
                const fasciaBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamW * 1.1, beamH * 1.2), fasciaMat());
                // Z: against house fascia face (wall face + fascia board thickness offset)
                const fbmZ = -W/2 - 0.02;
                if (isPerpendicular) {
                    fasciaBeam.rotation.y = Math.PI / 2;
                    fasciaBeam.position.set(fbmZ, fasciaBeamY + beamW/2, 0);
                } else {
                    fasciaBeam.position.set(0, fasciaBeamY + beamW/2, fbmZ);
                }
                fasciaBeam.castShadow = true;
                steelGrp.add(fasciaBeam);
                regComp(fasciaBeam, 'Fascia Beam', {'Size': c.frameBeam.name, 'Length': c.L + 'mm', 'Height': c.fasciaH + 'mm', 'Note': 'House connection'});
            }

            // ===== RAFTER BRACKETS (for fascia connections only) =====
            if (c.connection === 'fascia') {
                const bracketLen = 0.5;
                const bracketH = 0.006;
                const bracketW = 0.05;
                const bracketCount = Math.max(3, Math.ceil(L / 1.0));
                for (let i = 0; i < bracketCount; i++) {
                    const x = -L/2 + (L / (bracketCount - 1)) * i;
                    const bracket = new THREE.Mesh(
                        new THREE.BoxGeometry(bracketW, bracketH, bracketLen),
                        sMat()
                    );
                    if (isPerpendicular) {
                        bracket.rotation.y = Math.PI / 2;
                        bracket.position.set(-W/2 - bracketLen/2 - 0.08, fasciaBeamY + beamH + 0.1, x);
                    } else {
                        bracket.position.set(x, fasciaBeamY + beamH + 0.1, -W/2 - bracketLen/2 - 0.08);
                    }
                    steelGrp.add(bracket);
                }
            }

            // ===== V18 FIX: RISERS with correct stacking =====
            if (c.connection === 'riser') {
                // V18: Riser beam sits ON TOP of risers
                const riserOff = c.riserOffset / 1000;
                const riserSize = postW;  // riser elbows match post size
                const count = c.riserQty;

                // Calculate actual vertical rise of risers
                // Span from fascia beam top (horiz piece) up to riser beam bottom (backBeamY)
                const actualRiserH = backBeamY - (fasciaBeamY + beamH + riserSize);

                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;

                    // HORIZONTAL piece (comes out from fascia beam)
                    const horizPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, riserSize, riserOff),
                        riserMat()
                    );

                    // VERTICAL piece (rises up)
                    const vertPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, actualRiserH, riserSize),
                        riserMat()
                    );

                    if (isPerpendicular) {
                        horizPiece.rotation.y = Math.PI / 2;
                        horizPiece.position.set(-W/2 + riserOff/2, fasciaBeamY + beamH + riserSize/2, x);
                        vertPiece.position.set(-W/2 + riserOff, fasciaBeamY + beamH + riserSize + actualRiserH/2, x);
                    } else {
                        horizPiece.position.set(x, fasciaBeamY + beamH + riserSize/2, -W/2 + riserOff/2);
                        vertPiece.position.set(x, fasciaBeamY + beamH + riserSize + actualRiserH/2, -W/2 + riserOff);
                    }

                    horizPiece.castShadow = true;
                    vertPiece.castShadow = true;
                    steelGrp.add(horizPiece);
                    steelGrp.add(vertPiece);
                    regComp(vertPiece, 'Riser Elbow ' + (i+1), {
                        'Size': c.framePost.name,
                        'Offset': c.riserOffset + 'mm',
                        'Rise': Math.round(actualRiserH * 1000) + 'mm',
                        'Note': '90° elbow clears house gutter'
                    });
                }

                // Riser brackets – threaded rod through house fascia, clamps fascia beam tight
                // Strip lays along rafter top, threaded rod pokes through fascia board
                const galvMat = () => new THREE.MeshStandardMaterial({color: 0xC0C0C0, metalness: 0.7, roughness: 0.4});
                const fasciaHmR = c.fasciaH / 1000; // rafter base Y (independent of fascia beam)
                const fasciaBdH = 0.15; // house fascia board height
                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;
                    const stripLen = 0.45;   // 450mm long
                    const stripW = 0.03;     // 30mm wide
                    const stripT = 0.006;    // 6mm thick galv plate
                    // Y: vertically centred on house fascia board
                    const bkY = fasciaHmR - fasciaBdH / 2;
                    // House fascia front face is 50mm behind patio edge
                    // Fascia beam front face is 10mm past patio edge
                    const fasciaFaceOff = -0.05; // house fascia front face relative to -W/2
                    const fbmFrontOff = 0.01;    // fascia beam front face relative to -W/2
                    // Threaded rod: from fascia face through to fascia beam front face
                    const rodLen = fbmFrontOff - fasciaFaceOff; // 60mm
                    const rodD = 0.012; // M12 threaded rod
                    // Strip: mostly behind wall, tip at house fascia face
                    const strip = new THREE.Mesh(
                        new THREE.BoxGeometry(stripW, stripT, stripLen),
                        galvMat()
                    );
                    // Threaded rod: pokes through fascia, does NOT protrude past fascia beam
                    const bolt = new THREE.Mesh(
                        new THREE.BoxGeometry(rodD, rodD, rodLen),
                        galvMat()
                    );
                    if (isPerpendicular) {
                        strip.rotation.y = Math.PI / 2;
                        strip.position.set(-W/2 + fasciaFaceOff - stripLen/2, bkY, x);
                        bolt.rotation.y = Math.PI / 2;
                        bolt.position.set(-W/2 + fasciaFaceOff + rodLen/2, bkY, x);
                    } else {
                        strip.position.set(x, bkY, -W/2 + fasciaFaceOff - stripLen/2);
                        bolt.position.set(x, bkY, -W/2 + fasciaFaceOff + rodLen/2);
                    }
                    steelGrp.add(strip);
                    steelGrp.add(bolt);
                    regComp(strip, 'Riser Bracket ' + (i+1), {'Size': '450×30×6mm Galv Flat Bar', 'Rod': 'M12 threaded rod', 'Note': 'Threaded rod through fascia, clamps fascia beam tight'});
                }

                // Box gutter (if selected) - sits in gap between house wall and riser beam
                if (c.houseGutter === 'box') {
                    // Width sized to fit the gap between house fascia and riser beam
                    const boxGutterW = riserOff;
                    const boxGutterD = 0.1;       // inner wall height (house side)
                    const boxGutterOuter = 0.12;  // outer wall height (riser side, taller to catch water)
                    const wallT = 0.01;

                    // U-shaped cross-section: X=0 is house side, X=boxGutterW is riser side
                    const gutterShape = new THREE.Shape();
                    gutterShape.moveTo(0, 0);
                    gutterShape.lineTo(boxGutterW, 0);
                    gutterShape.lineTo(boxGutterW, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, wallT);
                    gutterShape.lineTo(wallT, wallT);
                    gutterShape.lineTo(wallT, boxGutterD);
                    gutterShape.lineTo(0, boxGutterD);
                    gutterShape.closePath();

                    const extrudeSettings = { depth: L, bevelEnabled: false };
                    const gutterGeo = new THREE.ExtrudeGeometry(gutterShape, extrudeSettings);
                    const boxGutter = new THREE.Mesh(gutterGeo, sMat());

                    // Y: gutter bottom sits ON TOP of the riser elbow horizontal pieces
                    // horiz piece top = fasciaBeamY + beamH + riserSize
                    const boxGutterY = fasciaBeamY + beamH + riserSize;

                    if (isPerpendicular) {
                        // House wall at X = -W/2, riser beam at X = -W/2 + riserOff
                        // rotation.y = π: local X → world -X, local +Z → world -Z
                        // Shape X=0 (house side) → world X = position.x (riser beam)
                        // Shape X=gutterW (riser side) → world X = position.x - gutterW = -W/2 (house)
                        // So we need to flip: position at -W/2, no extra rotation for X direction
                        // Use rotation.y = 0: local X → world +X, local Z → world +Z
                        // Shape X=0 (house side) at world X = -W/2, X=gutterW at -W/2 + riserOff
                        boxGutter.rotation.y = 0;
                        boxGutter.position.set(-W/2, boxGutterY, -L/2);
                    } else {
                        // House wall at Z = -W/2, riser beam at Z = -W/2 + riserOff
                        // rotation.y = -π/2: local X → world +Z, local +Z → world -X
                        // Shape X=0 (house side) at world Z = -W/2
                        // Shape X=gutterW (riser side) at world Z = -W/2 + riserOff
                        // Extrusion goes -X, so position at X = +L/2
                        boxGutter.rotation.y = -Math.PI / 2;
                        boxGutter.position.set(L/2, boxGutterY, -W/2);
                    }
                    accGrp.add(boxGutter);
                    regComp(boxGutter, 'Box Gutter', {'Width': Math.round(riserOff*1000)+'mm', 'Inner Depth': '100mm', 'Outer Depth': '120mm'});
                }

                // Patio gutter on riser beam (gable only) - catches back slope water
                if (c.isGable && c.riserGutter === 'quad') {
                    const rgW = 0.115;     // 115mm quad gutter
                    const rgFront = 0.076; // 76mm front face
                    const rgBack = 0.045;  // 45mm back face
                    const rgT = 0.001;     // 1mm sheet steel
                    const rgs = new THREE.Shape();
                    rgs.moveTo(0, 0);
                    rgs.lineTo(rgW, 0);
                    rgs.lineTo(rgW, rgFront);
                    rgs.lineTo(rgW - rgT, rgFront);
                    rgs.lineTo(rgW - rgT, rgT);
                    rgs.lineTo(rgT, rgT);
                    rgs.lineTo(rgT, rgBack);
                    rgs.lineTo(0, rgBack);
                    rgs.closePath();
                    const rgGeo = new THREE.ExtrudeGeometry(rgs, { depth: L, bevelEnabled: false });
                    const riserGutterMesh = new THREE.Mesh(rgGeo, sMat());
                    // Sits on top of riser beam
                    const riserBeamTop = backBeamY + beamW; // riser beam on edge: height = beam width
                    if (isPerpendicular) {
                        riserGutterMesh.position.set(-W/2 + riserOff - rgW/2, riserBeamTop, -L/2);
                    } else {
                        riserGutterMesh.rotation.y = -Math.PI / 2;
                        riserGutterMesh.position.set(L/2, riserBeamTop, -W/2 + riserOff - rgW/2);
                    }
                    accGrp.add(riserGutterMesh);
                    regComp(riserGutterMesh, 'Riser Beam Gutter', {'Type': '115mm Quad', 'Length': c.L + 'mm', 'Note': 'Catches gable back slope water'});
                }
            }

            // ===== CARRY / BACK BEAM - NOT for receiving channel (fascia/wall use channel instead) =====
            if (c.connection !== 'fascia' && c.connection !== 'wall') {
                const isRiser = c.connection === 'riser';
                const isFlyover = c.connection === 'flyover';
                // Riser: beam on edge (swap w/h), Flyover: always 150×50, Default: selected beam
                const beamHeight = isRiser ? beamW : (isFlyover ? 0.05 : beamH);
                const beamWidth = isRiser ? beamH : (isFlyover ? 0.15 : beamW);
                const riserOff = isRiser ? c.riserOffset/1000 : 0;

                const carryBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamHeight, beamWidth), sMat());
                if (isPerpendicular) {
                    carryBeam.rotation.y = Math.PI / 2;
                    carryBeam.position.set(-W/2 + riserOff, backBeamY + beamHeight/2, 0);
                } else {
                    carryBeam.position.set(0, backBeamY + beamHeight/2, -W/2 + riserOff);
                }
                carryBeam.castShadow = true;
                steelGrp.add(carryBeam);
                const beamName = isRiser ? 'Riser Beam' : (isFlyover ? 'Flyover Beam' : 'Back Beam');
                const beamSpec = isRiser ? (c.frameBeam.name + ' (on edge)') : (isFlyover ? '150×50×2 RHS' : c.frameBeam.name);
                regComp(carryBeam, beamName, {'Size': beamSpec, 'Length': c.L + 'mm', 'Height': Math.round(backBeamY*1000) + 'mm'});
            }

            // ===== FLYOVER VERTICAL STRUTS - sit ON TOP of house roof =====
            // Struts penetrate through roof sheets and bolt to house rafters
            if (c.connection === 'flyover') {
                const fasciaHm = c.fasciaH / 1000;
                const hRafterH = 0.09; // house rafter height
                // Struts positioned on house roof near the eave, directly under the flyover beam
                // Roof surface at the eave = rafter top = fasciaHm + hRafterH
                const roofSurfaceY = fasciaHm + hRafterH;
                const strutSize = postW; // struts match post size
                const strutH = Math.max(0.15, backBeamY - roofSurfaceY);
                const strutCount = Math.max(2, Math.ceil(L / 1.2));
                // Struts are at same Z as the flyover beam (at patio back edge)
                // They go through the roof/fascia and bolt to the house rafters below

                for (let i = 0; i < strutCount; i++) {
                    const x = -L/2 + (L / (strutCount - 1)) * i;
                    const strut = new THREE.Mesh(
                        new THREE.BoxGeometry(strutSize, strutH, strutSize),
                        sMat()
                    );
                    if (isPerpendicular) {
                        strut.position.set(-W/2, roofSurfaceY + strutH/2, x);
                    } else {
                        strut.position.set(x, roofSurfaceY + strutH/2, -W/2);
                    }
                    strut.castShadow = true;
                    steelGrp.add(strut);
                    regComp(strut, 'Flyover Strut ' + (i+1), {'Size': c.framePost.name, 'Height': Math.round(strutH*1000) + 'mm'});
                }
            }

            // ===== ROOF STRUCTURE =====
            const frontTop = frontBeamY + beamH;
            const backTop = backBeamY + beamH;
            const sheetW = c.sheetCoverage / 1000;

            // V18: Calculate actual gutter height for downpipes
            let gutterY;

            if (c.isGable) {
                // ========== GABLE ROOF ==========
                const trussBaseY = (frontTop + backTop) / 2;
                const tiltAngle = Math.atan2(backTop - frontTop, W);
                gutterY = frontTop - 0.04;

                // Trusses (peak from internal geometry; tilt spans between beams when heights differ)
                for (let i = 0; i < c.nTruss; i++) {
                    const x = -L/2 + (L / (c.nTruss - 1)) * i;
                    const truss = createTrussUnit(W, rise, rafter, tw, th, sMat(), c);
                    if (isPerpendicular) {
                        truss.rotation.order = 'ZYX';
                        truss.rotation.y = Math.PI / 2;
                        truss.rotation.z = -tiltAngle;
                        truss.position.set(0, trussBaseY, x);
                    } else {
                        truss.rotation.x = tiltAngle;
                        truss.position.set(x, trussBaseY, 0);
                    }
                    steelGrp.add(truss);
                    regComp(truss, 'Truss ' + (i+1), {'Span': Math.round(c.trussSpan) + 'mm', 'Rise': Math.round(c.rise) + 'mm'});

                    // Gable infill
                    if ((i === 0 || i === c.nTruss - 1) && c.infill !== 'none') {
                        const shape = new THREE.Shape();
                        shape.moveTo(-W/2, th);
                        shape.lineTo(0, rise + th);
                        shape.lineTo(W/2, th);
                        shape.closePath();
                        const isTransparent = c.infill === 'polycarbonate';
                        const isLouvre = c.infill === 'louvre';
                        const infillMat = new THREE.MeshStandardMaterial({
                            color: isTransparent ? 0xDDEEEE : (isLouvre ? 0xCCCCCC : sheetCol),
                            transparent: isTransparent,
                            opacity: isTransparent ? 0.6 : 1,
                            side: THREE.DoubleSide
                        });
                        const infillMesh = new THREE.Mesh(new THREE.ShapeGeometry(shape), infillMat);

                        if (isPerpendicular) {
                            infillMesh.rotation.y = x > 0 ? Math.PI : 0;
                            infillMesh.position.set(0, trussBaseY, x);
                        } else {
                            infillMesh.rotation.y = Math.PI / 2;
                            infillMesh.position.set(x, trussBaseY, 0);
                        }
                        roofGrp.add(infillMesh);
                        const infillLabel = {colorbond:'Colorbond', polycarbonate:'Polycarbonate', louvre:'Louvre'}[c.infill] || c.infill;
                        regComp(infillMesh, 'Gable Infill', {'Material': infillLabel});
                    }
                }

                // Purlins
                const purlinCount = Math.max(2, Math.ceil(rafter / 0.8));
                for (let side = -1; side <= 1; side += 2) {
                    for (let p = 1; p <= purlinCount; p++) {
                        const frac = p / (purlinCount + 1);
                        const zPos = (W/2) * frac * side;
                        const yPos = trussBaseY + th + rise * (1 - frac);
                        const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                        if (isPerpendicular) {
                            purlin.rotation.y = Math.PI / 2;
                            purlin.position.set(zPos, yPos, 0);
                        } else {
                            purlin.position.set(0, yPos, zPos);
                        }
                        steelGrp.add(purlin);
                    }
                }

                // V18 FIX: Roof sheets - corrected rotation for perpendicular mode
                const numSheets = Math.ceil(L / sheetW);
                const gablePc = (c.roofing === 'trimdek') ? getPolycarbConfig() : null;
                for (let side = -1; side <= 1; side += 2) {
                    for (let s = 0; s < numSheets; s++) {
                        const sheetPos = -L/2 + sheetW/2 + s * sheetW;
                        const isPolySheet = gablePc && ((s + 1) % gablePc.patternN === 0);
                        let sheetGeo;
                        if (c.roofing === 'corrugated') {
                            sheetGeo = createCorrugatedGeometry(sheetW, rafter + 0.05);
                        } else if (c.roofing === 'trimdek') {
                            sheetGeo = createTrimdekGeometry(sheetW, rafter + 0.05);
                        } else {
                            sheetGeo = createInsulatedGeometry(sheetW, rafter + 0.05);
                        }

                        let sheetMat;
                        if (isPolySheet) {
                            const tintData = POLYCARB_3D_TINTS[gablePc.tint] || POLYCARB_3D_TINTS['Clear'];
                            sheetMat = new THREE.MeshStandardMaterial({
                                color: tintData.color, transparent: true, opacity: tintData.opacity,
                                metalness: 0.1, roughness: 0.15, side: THREE.DoubleSide
                            });
                        } else {
                            sheetMat = rMat();
                        }
                        const sheet = new THREE.Mesh(sheetGeo, sheetMat);

                        if (isPerpendicular) {
                            sheet.rotation.order = 'YXZ';
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                            sheet.rotation.y = Math.PI / 2;

                            const midHeight = trussBaseY + th + rise/2;
                            sheet.position.set(side * W/4, midHeight + th/2 + 0.02, sheetPos);
                        } else {
                            sheet.position.set(sheetPos, trussBaseY + th + th/2 + rise/2 + 0.01, side * W/4);
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                        }
                        sheet.castShadow = !isPolySheet;
                        roofGrp.add(sheet);
                        const sideLabel = side === -1 ? 'A' : 'B';
                        const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                        regComp(sheet, 'Roof Sheet ' + sideLabel + (s+1), {'Profile': sheetType, 'Length': Math.round((rafter + 0.05)*1000) + 'mm', 'Side': side === -1 ? 'Left slope' : 'Right slope'});
                    }
                }

                // Ridge capping
                const ridge = new THREE.Mesh(new THREE.BoxGeometry(L, 0.04, 0.3), rMat());
                if (isPerpendicular) {
                    ridge.rotation.y = Math.PI / 2;
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                } else {
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                }
                accGrp.add(ridge);
                regComp(ridge, 'Ridge Cap', {'Length': c.L + 'mm'});

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                if (isPerpendicular) {
                    gutter.rotation.y = Math.PI / 2;
                    gutter.position.set(W/2 + 0.07, gutterY, 0);
                } else {
                    gutter.position.set(0, gutterY, W/2 + 0.07);
                }
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.L + 'mm'});

                // Gable barges
                const bargeThick = 0.003;
                const bargeWidth = 0.15;
                const bargeLen = rafter + 0.05;

                if (isPerpendicular) {
                    [-L/2, L/2].forEach((zEnd) => {
                        const bargeL = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeL.position.set(-W/4, trussBaseY + th + rise/2, zEnd);
                        bargeL.rotation.z = c.pitchRad;
                        accGrp.add(bargeL);

                        const bargeR = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeR.position.set(W/4, trussBaseY + th + rise/2, zEnd);
                        bargeR.rotation.z = -c.pitchRad;
                        accGrp.add(bargeR);
                    });
                } else {
                    [-L/2, L/2].forEach((xEnd) => {
                        const bargeHouse = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeHouse.position.set(xEnd, trussBaseY + th + rise/2, -W/4);
                        bargeHouse.rotation.x = -c.pitchRad;
                        accGrp.add(bargeHouse);

                        const bargeGutter = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeGutter.position.set(xEnd, trussBaseY + th + rise/2, W/4);
                        bargeGutter.rotation.x = c.pitchRad;
                        accGrp.add(bargeGutter);
                    });
                }

            } else {
                // ========== SKILLION ROOF ==========
                gutterY = frontTop - 0.04;  // V18: Store gutter Y for downpipes

                const riserOff = c.connection === 'riser' ? c.riserOffset / 1000 : 0;
                const backEdgeZ = -W/2 + riserOff;

                // Rafters
                for (let i = 0; i < c.nRafters; i++) {
                    const x = -L/2 + (L / (c.nRafters - 1)) * i;
                    const rafterGeo = new THREE.BoxGeometry(tw, th, rafter);
                    rafterGeo.translate(0, 0, rafter/2);
                    const raft = new THREE.Mesh(rafterGeo, sMat());
                    raft.position.set(x, backTop + th/2, backEdgeZ);
                    raft.rotation.x = c.pitchRad;
                    steelGrp.add(raft);
                    regComp(raft, 'Rafter ' + (i+1), {'Size': c.steel.name, 'Length': Math.round(c.rafter) + 'mm'});
                }

                // Purlins
                const effectiveW = W - riserOff;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9));
                for (let p = 0; p <= purlinCount; p++) {
                    const frac = p / purlinCount;
                    const zPos = backEdgeZ + effectiveW * frac;
                    const yPos = backTop + th - (backTop - frontTop) * frac;
                    const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                    purlin.position.set(0, yPos, zPos);
                    steelGrp.add(purlin);
                }

                // Roof sheets
                const sheetInset = c.isRecvChan ? 0.03 : 0; // 30mm into channel
                const numSheets = Math.ceil(L / sheetW);
                const skillPc = (c.roofing === 'trimdek') ? getPolycarbConfig() : null;
                for (let s = 0; s < numSheets; s++) {
                    const xPos = -L/2 + sheetW/2 + s * sheetW;
                    const isPolySheet = skillPc && ((s + 1) % skillPc.patternN === 0);
                    let sheetGeo;
                    if (c.roofing === 'corrugated') {
                        sheetGeo = createCorrugatedGeometry(sheetW, rafter);
                    } else if (c.roofing === 'trimdek') {
                        sheetGeo = createTrimdekGeometry(sheetW, rafter);
                    } else {
                        sheetGeo = createInsulatedGeometry(sheetW, rafter);
                    }
                    sheetGeo.translate(0, rafter/2, 0);

                    let sheetMat;
                    if (isPolySheet) {
                        const tintData = POLYCARB_3D_TINTS[skillPc.tint] || POLYCARB_3D_TINTS['Clear'];
                        sheetMat = new THREE.MeshStandardMaterial({
                            color: tintData.color, transparent: true, opacity: tintData.opacity,
                            metalness: 0.1, roughness: 0.15, side: THREE.DoubleSide
                        });
                    } else {
                        sheetMat = rMat();
                    }
                    const sheet = new THREE.Mesh(sheetGeo, sheetMat);
                    sheet.position.set(xPos, backTop + th + th/2 + 0.01, backEdgeZ - sheetInset);
                    sheet.rotation.x = Math.PI/2 + c.pitchRad;
                    sheet.castShadow = !isPolySheet;
                    roofGrp.add(sheet);
                    const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                    regComp(sheet, 'Roof Sheet ' + (s+1), {'Profile': sheetType, 'Length': Math.round(rafter*1000) + 'mm'});
                }

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                gutter.position.set(0, gutterY, W/2 + 0.07);
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.lenInput + 'mm'});

                // Back flashing - skip for riser+box gutter AND receiving channel (channel acts as flashing)
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    const flash = new THREE.Mesh(new THREE.BoxGeometry(L, 0.15, 0.003), sMat());
                    flash.position.set(0, backTop + 0.08, backEdgeZ - 0.05);
                    flash.rotation.x = -0.3;
                    accGrp.add(flash);
                    regComp(flash, 'Back Flashing', {'Length': c.lenInput + 'mm'});
                }

                // Barge flashings
                [-L/2, L/2].forEach((xPos, idx) => {
                    const barge = new THREE.Mesh(new THREE.BoxGeometry(0.1, rafter, 0.003), sMat());
                    barge.position.set(xPos, (backTop + frontTop)/2 + th, 0);
                    barge.rotation.x = -(Math.PI/2 - c.pitchRad);
                    accGrp.add(barge);
                });
            }

            // ===== V18 FIX: DOWNPIPES - Use actual gutter height =====
            let dpPositions;
            if (isPerpendicular) {
                dpPositions = [[W/2 + 0.1, -L/2 + 0.1], [W/2 + 0.1, L/2 - 0.1]];
            } else {
                dpPositions = [[-L/2 + 0.1, W/2 + 0.1], [L/2 - 0.1, W/2 + 0.1]];
            }
            dpPositions.forEach((pos, idx) => {
                // V18 FIX: Downpipe height = from ground to gutter, not postH
                const dpHeight = gutterY + 0.04;  // Gutter bottom + 40mm into gutter
                const dp = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, dpHeight, 12), sMat());
                dp.position.set(pos[0], dpHeight/2, pos[1]);
                accGrp.add(dp);
                regComp(dp, 'Downpipe ' + (idx+1), {'Size': '90mm Round', 'Height': Math.round(dpHeight*1000) + 'mm'});
            });

            // ===== HOUSE / WALL REPRESENTATION =====
            // riser, fascia, flyover: house with wall + fascia board + Colorbond roof
            // wall: flat wall only (receiving channel bolts to wall surface)
            // freestanding: no wall
            if (c.isAttached) {
                const fasciaHm = c.fasciaH / 1000;
                const wallThick = 0.15;
                const wallLen = L + 0.2;
                const wallMat = new THREE.MeshStandardMaterial({color: 0xD4C4B0, roughness: 0.9});
                const fasciaTimberMat = new THREE.MeshStandardMaterial({color: 0x8B7355, roughness: 0.8});
                // Monument colour (#3C3C3C) for existing house Colorbond roof
                const roofColorbondMat = new THREE.MeshStandardMaterial({color: 0x3C3C3C, roughness: 0.5, metalness: 0.4});

                if (c.connection === 'wall') {
                    // === WALL MODE: just a flat brick/render wall ===
                    const wallH = Math.max(backBeamY + 0.5, fasciaHm + 0.5);
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                } else {
                    // === HOUSE MODE (riser, fascia, flyover): wall + fascia + roof ===
                    // Wall: only up to fascia height (roof sits above)
                    const wallH = fasciaHm;
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                    // Fascia board (timber) covers the full rafter end face
                    if (fasciaHm > 0) {
                        const fasciaBoardH = 0.15;   // 150mm tall
                        const fasciaBoardT = 0.025;  // 25mm thick
                        const fasciaBoard = new THREE.Mesh(
                            new THREE.BoxGeometry(wallLen, fasciaBoardH, fasciaBoardT),
                            fasciaTimberMat
                        );
                        // Fascia board top aligns with rafter bottom (fasciaHm)
                        // Gutter sits against fascia front face at the top half
                        const fbZ = -W/2 - wallThick/2 + fasciaBoardT/2;
                        const fbY = fasciaHm - fasciaBoardH/2; // center of board, top at rafter bottom
                        if (isPerpendicular) {
                            fasciaBoard.rotation.y = Math.PI / 2;
                            fasciaBoard.position.set(fbZ, fbY, 0);
                        } else {
                            fasciaBoard.position.set(0, fbY, fbZ);
                        }
                        fasciaBoard.castShadow = true;
                        houseGrp.add(fasciaBoard);
                        regComp(fasciaBoard, 'House Fascia Board', {'Size': '150×25mm Timber', 'Height': c.fasciaH + 'mm'});
                    }

                    // House roof: timber rafters + individual Colorbond sheets
                    const roofDepth = 1.5;       // 1.5m visible depth
                    const roofPitch = 15 * Math.PI / 180;
                    const roofRise = roofDepth * Math.tan(roofPitch);
                    const roofBaseY = fasciaHm;  // rafters sit on wall top plate
                    const roofCenterY = roofBaseY + roofRise / 2;
                    const roofZCenter = -W/2 - wallThick/2 - roofDepth/2;

                    // Timber rafters (45×90mm) at 600mm spacing
                    const rafterW = 0.045, rafterH = 0.09, rafterSpacing = 0.6;
                    const rafterCount = Math.max(2, Math.ceil(wallLen / rafterSpacing) + 1);
                    for (let i = 0; i < rafterCount; i++) {
                        const pos = -wallLen/2 + (wallLen / (rafterCount - 1)) * i;
                        const rafter = new THREE.Mesh(
                            new THREE.BoxGeometry(rafterW, rafterH, roofDepth),
                            fasciaTimberMat
                        );
                        if (isPerpendicular) {
                            rafter.rotation.order = 'YXZ';
                            rafter.rotation.y = Math.PI / 2;
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(roofZCenter, roofCenterY, pos);
                        } else {
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(pos, roofCenterY, roofZCenter);
                        }
                        rafter.castShadow = true;
                        houseGrp.add(rafter);
                    }
                    // Register first rafter for tooltip
                    if (houseGrp.children.length > 0) {
                        const lastRafter = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastRafter, 'House Rafter', {'Size': '45×90mm Timber', 'Spacing': '600mm', 'Qty': rafterCount});
                    }

                    // Individual Colorbond roof sheets on top of rafters
                    // Sheets overhang 50mm past fascia into gutter
                    const hSheetW = 0.762;  // corrugated sheet cover width
                    const hSheetT = 0.001;  // ~1mm Colorbond
                    const hOverhang = 0.05; // 50mm overhang past fascia
                    const hSheetDepth = roofDepth + hOverhang;
                    const hSheetZCenter = roofZCenter + hOverhang/2; // shift toward fascia
                    const hSheetCount = Math.max(1, Math.ceil(wallLen / hSheetW));
                    const hSheetCenterY = roofCenterY + rafterH/2 + hSheetT/2;
                    for (let i = 0; i < hSheetCount; i++) {
                        const sw = (i === hSheetCount - 1) ? (wallLen - hSheetW * i) : hSheetW;
                        const pos = -wallLen/2 + hSheetW * i + sw/2;
                        const hSheet = new THREE.Mesh(
                            new THREE.BoxGeometry(sw, hSheetT, hSheetDepth),
                            roofColorbondMat.clone()
                        );
                        if (isPerpendicular) {
                            hSheet.rotation.order = 'YXZ';
                            hSheet.rotation.y = Math.PI / 2;
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(hSheetZCenter, hSheetCenterY, pos);
                        } else {
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(pos, hSheetCenterY, hSheetZCenter);
                        }
                        hSheet.castShadow = true;
                        hSheet.receiveShadow = true;
                        houseGrp.add(hSheet);
                    }
                    const roofLabel = c.connection === 'flyover' ? 'Existing House Roof (Flyover)' : 'Existing House Roof';
                    if (houseGrp.children.length > 0) {
                        const lastSheet = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastSheet, roofLabel, {'Pitch': '15°', 'Material': 'Colorbond', 'Sheets': hSheetCount});
                    }

                    // House quad gutter – sits against front face of fascia, at the top half
                    // Hidden when box gutter is selected (box gutter replaces it)
                    const showHouseGutter = !(c.connection === 'riser' && c.houseGutter === 'box');
                    if (showHouseGutter) {
                    const hGutterW = 0.115;    // 115mm wide
                    const hGutterFront = 0.076; // 76mm front face
                    const hGutterBack = 0.045;  // 45mm back face
                    const hGutterT = 0.001;     // 1mm sheet steel
                    const hgs = new THREE.Shape();
                    hgs.moveTo(0, 0);
                    hgs.lineTo(hGutterW, 0);
                    hgs.lineTo(hGutterW, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterBack);
                    hgs.lineTo(0, hGutterBack);
                    hgs.closePath();
                    const hGutterGeo = new THREE.ExtrudeGeometry(hgs, { depth: L, bevelEnabled: false });
                    const hGutter = new THREE.Mesh(hGutterGeo, roofColorbondMat.clone());
                    // Back lip top at fasciaHm – gutter against top half of fascia face
                    const hGutterY = fasciaHm - hGutterBack;
                    const hGutterZ = -W/2 - wallThick/2 + 0.025; // at fascia board front face
                    if (isPerpendicular) {
                        // extrude along +Z; rotation.y=0 keeps local Z=world Z
                        hGutter.position.set(hGutterZ, hGutterY, -L/2);
                    } else {
                        // rotation.y=-π/2: local +Z → world -X, shape X → world +Z
                        hGutter.rotation.y = -Math.PI / 2;
                        hGutter.position.set(L/2, hGutterY, hGutterZ);
                    }
                    houseGrp.add(hGutter);
                    regComp(hGutter, 'House Quad Gutter', {'Size': '115mm Quad', 'Front': '76mm', 'Back': '45mm'});
                    } // end showHouseGutter
                }

                // C-Channel - for receiving channel modes (fascia and wall only)
                if (c.isRecvChan) {
                    const chanW = 0.075;  // 75mm wide – captures sheet edges
                    const chanH = 0.03;   // 30mm tall
                    const chanT = 0.003;  // 3mm steel thickness
                    // C-channel profile (U-shape opening toward patio)
                    const chanShape = new THREE.Shape();
                    chanShape.moveTo(0, 0);
                    chanShape.lineTo(chanW, 0);
                    chanShape.lineTo(chanW, chanT);
                    chanShape.lineTo(chanT, chanT);
                    chanShape.lineTo(chanT, chanH - chanT);
                    chanShape.lineTo(chanW, chanH - chanT);
                    chanShape.lineTo(chanW, chanH);
                    chanShape.lineTo(0, chanH);
                    chanShape.closePath();

                    const chanGeo = new THREE.ExtrudeGeometry(chanShape, { depth: L, bevelEnabled: false });
                    const channel = new THREE.Mesh(chanGeo, sMat());

                    if (c.connection === 'fascia') {
                        // On fascia board face, at fascia beam height
                        const chanY = fasciaHm + beamH/2 - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    } else {
                        // Wall mode: on wall surface at connection height
                        const chanY = fasciaHm - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    }
                    steelGrp.add(channel);
                    regComp(channel, 'Receiving Channel', {'Size': '75×30mm C-Channel', 'Length': c.L + 'mm', 'Type': c.connection === 'fascia' ? 'Fascia mount' : 'Wall mount'});
                }
            }

            updateMatList();

            // Update camera orbit target to center of combined patio + house
            const bbox = new THREE.Box3();
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => {
                if (g.children.length > 0) bbox.expandByObject(g);
            });
            if (!bbox.isEmpty() && asmControls) {
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                asmControls.target.copy(center);
                asmControls.update();
            }
        }

        function createTrussUnit(W, rise, rafter, tw, th, mat, c) {
            const g = new THREE.Group();
            const halfW = W / 2;
            const heelY = th;
            const apexY = th + rise;

            const extOn = c.trussExtender.enabled;
            const extLen = c.trussExtender.length / 1000;
            const riserOn = c.trussRiserLeft.enabled;
            const rLH = c.trussRiserLeft.length / 1000;
            const rLV = c.trussRiserLeft.height / 1000;
            const rRH = c.trussRiserRight.length / 1000;
            const rRV = c.trussRiserRight.height / 1000;
            const chordType = c.trussChord;
            const style = c.trussStyle;

            // Helper: box member between two ZY points (Z = span, Y = height)
            function mbr(z1, y1, z2, y2) {
                const dz = z2 - z1, dy = y2 - y1;
                const len = Math.sqrt(dz * dz + dy * dy);
                if (len < 0.001) return;
                const geo = new THREE.BoxGeometry(tw, th, len);
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.position.set(0, (y1 + y2) / 2, (z1 + z2) / 2);
                mesh.rotation.x = -Math.atan2(dy, dz);
                g.add(mesh);
            }

            // --- Bottom Chord (standard horizontal, full span) ---
            if (chordType === 'bottom') {
                mbr(-halfW, th / 2, halfW, th / 2);
                if (extOn) {
                    mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                    mbr(halfW, th / 2, halfW + extLen, th / 2);
                }
            } else if (chordType === 'mid') {
                const midY = th + rise / 3;
                const lT = (midY - heelY) / (apexY - heelY);
                const midHalfZ = lT > 0 ? halfW * (1 - lT) : halfW;
                mbr(-midHalfZ, midY, midHalfZ, midY);
                if (extOn) {
                    mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                    mbr(halfW, th / 2, halfW + extLen, th / 2);
                }
            } else if (extOn) {
                mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                mbr(halfW, th / 2, halfW + extLen, th / 2);
            }

            // --- Rafters (symmetrical) ---
            mbr(-halfW, heelY, 0, apexY);
            mbr(halfW, heelY, 0, apexY);

            // --- Web Members ---
            if (style === 'kingpost') {
                const kBottom = chordType === 'mid' ? (th + rise / 3 + th / 2) : th;
                const kTop = apexY - th;
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop);
                }
            } else if (style === 'verticalwebs') {
                const nWebs = Math.max(1, Math.round((halfW * 1000) / 500));
                const spacingM = halfW / (nWebs + 1);
                for (let i = 1; i <= nWebs; i++) {
                    const z = i * spacingM;
                    const rafterYm = th + rise * (1 - z / halfW);
                    let bottomY, topY;
                    if (chordType === 'mid') {
                        const midY = th + rise / 3;
                        const lT = (midY - th) / rise;
                        const midHalfW = halfW * (1 - lT);
                        if (z > midHalfW) continue;
                        bottomY = midY + th / 2;
                        topY = rafterYm - th / 2;
                    } else {
                        bottomY = th + th / 2;
                        topY = rafterYm - th / 2;
                    }
                    if (topY > bottomY + th * 0.5) {
                        mbr(-z, bottomY, -z, topY);
                        mbr(z, bottomY, z, topY);
                    }
                }
            } else if (style === 'kingdiagonal') {
                const kBottom = chordType === 'mid' ? (th + rise / 3 + th / 2) : th;
                const kTop = apexY - th;
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop);
                }
                const chordYm = chordType === 'mid' ? (th + rise / 3) : th;
                const pts = [
                    {cx: halfW * 2 / 3, rx: halfW * 1 / 3},
                    {cx: halfW * 1 / 3, rx: halfW * 1 / 6}
                ];
                for (let i = 0; i < pts.length; i++) {
                    const p = pts[i];
                    const cy = chordYm + th / 2;
                    const ry = th + rise * (1 - p.rx / halfW) - th / 2;
                    if (ry > cy + th) {
                        mbr(-p.cx, cy, -p.rx, ry);
                        mbr(p.cx, cy, p.rx, ry);
                    }
                }
            }

            // --- Risers (SEPARATE L-shaped pieces at heel ends) ---
            if (riserOn) {
                const lhz = extOn ? -halfW - extLen : -halfW;
                mbr(lhz, th / 2, lhz, th / 2 - rLV);
                mbr(lhz, th / 2 - rLV, lhz - rLH, th / 2 - rLV);
                const rhz = extOn ? halfW + extLen : halfW;
                mbr(rhz, th / 2, rhz, th / 2 - rRV);
                mbr(rhz, th / 2 - rRV, rhz + rRH, th / 2 - rRV);
            }

            return g;
        }

        function regComp(mesh, name, specs) {
            compData.set(mesh.uuid, {name, specs});
        }

        function checkHover(mx, my) {
            asmRay.setFromCamera(asmMouse, asmCam);
            const all = [];
            if (steelGrp.visible) all.push(...steelGrp.children);
            if (roofGrp.visible) all.push(...roofGrp.children);
            if (accGrp.visible) all.push(...accGrp.children);
            if (houseGrp.visible) all.push(...houseGrp.children);
            const hits = asmRay.intersectObjects(all, true);
            if (hits.length > 0) {
                let obj = hits[0].object;
                while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;
                if (compData.has(obj.uuid)) {
                    if (hovered !== obj) { clearHover(); hovered = obj; highlight(obj); }
                    showTooltip(mx, my, compData.get(obj.uuid));
                    return;
                }
            }
            clearHover();
        }

        function highlight(mesh) {
            const hl = new THREE.Color(0xF15A29);
            if (mesh.material) { mesh.material.emissive = hl; mesh.material.emissiveIntensity = 0.3; }
            mesh.traverse(c => { if (c.material) { c.material.emissive = hl; c.material.emissiveIntensity = 0.3; }});
        }

        function clearHover() {
            if (hovered) {
                if (hovered.material) { hovered.material.emissive = new THREE.Color(0); hovered.material.emissiveIntensity = 0; }
                hovered.traverse(c => { if (c.material) { c.material.emissive = new THREE.Color(0); c.material.emissiveIntensity = 0; }});
                hovered = null;
            }
            hideTooltip();
        }

        function showTooltip(x, y, data) {
            const tt = document.getElementById('tooltip');
            document.getElementById('ttTitle').textContent = data.name;
            document.getElementById('ttContent').innerHTML = Object.entries(data.specs)
                .map(([k,v]) => `<div class="tooltip-row"><span class="tooltip-label">${k}</span><span class="tooltip-value">${v}</span></div>`).join('');
            tt.style.left = (x + 15) + 'px';
            tt.style.top = (y + 15) + 'px';
            tt.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function toggleLayer(layer, el) {
            el.classList.toggle('active');
            const vis = el.classList.contains('active');
            if (layer === 'steel') steelGrp.visible = vis;
            if (layer === 'roof') roofGrp.visible = vis;
            if (layer === 'acc') accGrp.visible = vis;
            if (layer === 'house') houseGrp.visible = vis;
        }

        function setAsmView(v, btn) {
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            var t = asmControls ? asmControls.target.clone() : new THREE.Vector3(0, 1.5, 0);
            var d = asmControls ? asmCam.position.distanceTo(t) : 12;
            if (v === '3d') {
                asmCam.position.set(t.x + d * 0.55, t.y + d * 0.4, t.z + d * 0.7);
            } else if (v === 'front') {
                asmCam.position.set(t.x, t.y + d * 0.15, t.z + d);
            } else if (v === 'side') {
                asmCam.position.set(t.x + d, t.y + d * 0.15, t.z);
            } else if (v === 'top') {
                asmCam.position.set(t.x, t.y + d, t.z + 0.01);
            }
            asmCam.lookAt(t);
            if (asmControls) asmControls.update();
        }

        function toggleFullscreen() {
            const el = document.getElementById('asmViewport');
            el.classList.toggle('fullscreen');
            setTimeout(() => {
                asmCam.aspect = el.clientWidth / el.clientHeight;
                asmCam.updateProjectionMatrix();
                asmRend.setSize(el.clientWidth, el.clientHeight);
            }, 100);
        }

        function getSheetMatEntries(numSheets, roofing) {
            const pc = (roofing === 'trimdek') ? getPolycarbConfig() : null;
            if (!pc) return [{d: roofing + ' Sheets', q: numSheets}];
            const split = getPolycarbSheetSplit(numSheets);
            const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
            const colorbondColour = sheetColor ? sheetColor.name : '';
            const entries = [];
            if (split.colorbond > 0) entries.push({d: 'Trimdek Colorbond' + (colorbondColour ? ' ' + colorbondColour : '') + ' Sheets', q: split.colorbond});
            if (split.polycarb > 0) entries.push({d: 'Trimdek Polycarb ' + brandLabel + ' ' + pc.tint + ' Sheets', q: split.polycarb});
            return entries;
        }

        function updateMatList() {
            const c = calc;
            let mats = [];
            const sheetCover = c.sheetCoverage;

            if (c.isGable) {
                const numSheets = Math.ceil(c.L / sheetCover) * 2;
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                const riserCount = c.riserQty;
                // Beam count depends on connection type
                let beamCount;
                if (c.connection === 'freestanding') {
                    beamCount = 2;  // Gutter beam + back beam
                } else if (c.connection === 'riser') {
                    beamCount = 3;  // Gutter beam + fascia beam + riser beam
                } else {
                    beamCount = 2;  // Gutter beam + fascia/back beam
                }
                const purlinCount = Math.max(2, Math.ceil(c.rafter / 1000 / 0.8)) * 2;
                mats = [
                    {d: 'Posts ' + c.framePost.label, q: postCount},
                    {d: 'Beams ' + c.frameBeam.label, q: beamCount},
                    {d: 'Trusses ' + c.steel.name, q: c.nTruss},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Ridge Cap', q: 1},
                    {d: 'Gable Barges', q: 4},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                if (c.infill !== 'none') mats.push({d: 'Gable Infill', q: 2});
                if (c.connection === 'riser') {
                    mats.push({d: 'Riser Elbows ' + c.framePost.label, q: riserCount});
                    mats.push({d: 'Riser Beam ' + c.frameBeam.label, q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                    if (c.riserGutter === 'quad') {
                        mats.push({d: 'Riser Beam Gutter 115mm Quad', q: 1});
                    }
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            } else {
                const numSheets = Math.ceil(c.L / sheetCover);
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                let beamCount;
                if (c.connection === 'riser') {
                    beamCount = 3;  // gutter + fascia + riser beam
                } else if (c.isRecvChan) {
                    beamCount = 1;  // gutter beam only (channel replaces back beam)
                } else {
                    beamCount = 2;  // gutter + back/flyover beam
                }
                const riserCount = c.riserQty;
                const effectiveW = (c.W - (c.connection === 'riser' ? c.riserOffset : 0)) / 1000;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9)) + 1;
                mats = [
                    {d: 'Posts ' + c.framePost.label, q: postCount},
                    {d: 'Beams ' + c.frameBeam.label, q: beamCount},
                    {d: 'Rafters ' + c.steel.name, q: c.nRafters},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Barge Flashings', q: 2},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                // Back flashing - skip for riser+box gutter AND receiving channel
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    mats.splice(5, 0, {d: 'Back Flashing', q: 1});
                }
                if (c.connection === 'riser') {
                    mats.splice(2, 0, {d: 'Riser Elbows ' + c.framePost.label, q: riserCount});
                    mats.splice(3, 0, {d: 'Riser Beam ' + c.frameBeam.label, q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                }
                if (c.connection === 'flyover') {
                    const strutCount = Math.max(2, Math.ceil(c.L / 1200));
                    mats.push({d: 'Flyover Struts ' + c.framePost.label, q: strutCount});
                    mats.push({d: 'Flyover Beam 150×50×2', q: 1});
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                    mats.push({d: 'Foam Backfill Strips (' + c.roofing + ')', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            }

            // Group materials by build sequence
            const groups = [
                { id: 'cfg-structure',  num: '1', name: 'Structure',  items: [] },
                { id: 'cfg-roofing',    num: '2', name: 'Roofing',    items: [] },
                { id: 'cfg-drainage',   num: '3', name: 'Drainage',   items: [] },
                { id: 'cfg-finishing',   num: '4', name: 'Finishing',  items: [] },
                { id: 'cfg-fixings',    num: '5', name: 'Fixings',    items: [] }
            ];

            mats.forEach(function(m) {
                const d = m.d.toLowerCase();
                if (d.includes('post') || d.includes('beam') ||
                    d.includes('purlin') || d.includes('truss') || d.includes('rafter') ||
                    d.includes('riser elbow') || d.includes('strut')) {
                    groups[0].items.push(m);
                } else if (d.includes('sheet') || d.includes('solarspan') || d.includes('trimdek') ||
                           d.includes('corrugated') || d.includes('spanplus') || d.includes('ridge cap') ||
                           d.includes('polycarb')) {
                    groups[1].items.push(m);
                } else if (d.includes('gutter') || d.includes('downpipe') || d.includes('box gutter')) {
                    groups[2].items.push(m);
                } else if (d.includes('barge') || d.includes('infill') || d.includes('flashing') ||
                           d.includes('fascia') || d.includes('channel') || d.includes('foam')) {
                    groups[3].items.push(m);
                } else {
                    groups[4].items.push(m);
                }
            });

            // Helpers to extract size, display name, length, colour for each material
            function matSize(desc) {
                var d = desc.toLowerCase();
                if (d.includes('65×65'))    return '65×65×2 SHS';
                if (d.includes('75×75'))    return '75×75×2 SHS';
                if (d.includes('90×90'))    return '90×90×2 SHS';
                if (d.includes('100×100'))  return '100×100×2 SHS';
                if (d.includes('150×50'))   return '150×50×2 RHS';
                if (d.includes('100×50'))   return '100×50×2 RHS';
                if (d.includes('75×50'))    return '75×50×2 RHS';
                if (d.includes('76×38'))    return '76×38×1.6 RHS';
                if (d.includes('solarspan'))return 'Insulated Panel';
                if (d.includes('trimdek'))  return 'Trimdek';
                if (d.includes('corrugated'))return 'Corrugated';
                if (d.includes('spanplus')) return 'SpanPlus 330';
                if (d.includes('115mm'))    return '115mm Quad';
                return '\u2014';
            }
            function matName(desc) {
                var d = desc.toLowerCase();
                if (d.includes('post'))         return 'Posts';
                if (d.includes('riser beam gutter')) return 'Riser Beam Gutter';
                if (d.includes('riser beam'))   return 'Riser Beam';
                if (d.includes('riser elbow'))  return 'Riser Elbows';
                if (d.includes('flyover beam')) return 'Flyover Beam';
                if (d.includes('flyover strut'))return 'Flyover Struts';
                if (d.includes('beam'))         return 'Beams';
                if (d.includes('truss'))        return 'Trusses';
                if (d.includes('rafter'))       return 'Rafters';
                if (d.includes('purlin'))       return 'Purlins';
                if (d.includes('ridge cap'))    return 'Ridge Cap';
                if (d.includes('downpipe'))     return 'Downpipes';
                if (d.includes('box gutter'))   return 'Box Gutter';
                if (d.includes('gutter'))       return 'Gutter';
                if (d.includes('barge'))        return 'Barge Flashings';
                if (d.includes('back flashing'))return 'Back Flashing';
                if (d.includes('infill'))       return 'Gable Infill';
                if (d.includes('fascia board')) return 'House Fascia Board';
                if (d.includes('channel'))      return 'Receiving Channel';
                if (d.includes('foam'))         return 'Foam Backfill';
                if (d.includes('polycarb'))     return 'Polycarb Sheets';
                if (d.includes('sheet'))        return 'Sheets';
                return desc;
            }
            function matLen(desc) {
                var len = getItemLength(desc);
                return len > 0 ? len.toFixed(1) + 'm' : '\u2014';
            }
            function matColour(desc) {
                var d = desc.toLowerCase();
                if (d.includes('post') || d.includes('beam') || d.includes('purlin') ||
                    d.includes('truss') || d.includes('rafter') || d.includes('strut') ||
                    d.includes('75×75') || d.includes('barge') || d.includes('gutter') ||
                    d.includes('downpipe') || d.includes('ridge') || d.includes('flashing') ||
                    d.includes('channel')) return steelColor.name;
                if (d.includes('polycarb')) return '\u2014';
                if (d.includes('sheet') || d.includes('infill')) return sheetColor.name;
                return '\u2014';
            }

            var hdrRow = '<div class="mat-hdr"><span>Item</span><span style="text-align:right">Qty</span><span>Size</span><span style="text-align:right">Length</span><span>Colour</span></div>';

            let html = '';
            groups.forEach(function(g, idx) {
                const isOpen = idx === 0;
                var rows = '';
                if (g.items.length > 0) {
                    rows = hdrRow + g.items.map(function(m) {
                        return '<div class="mat-row" data-desc="' + m.d.replace(/"/g, '&quot;') + '">' +
                            '<span>' + matName(m.d) + '</span>' +
                            '<span class="mat-qty">' + m.q + '×</span>' +
                            '<span class="mat-size">' + matSize(m.d) + '</span>' +
                            '<span class="mat-len">' + matLen(m.d) + '</span>' +
                            '<span class="mat-clr">' + matColour(m.d) + '</span>' +
                            '</div>';
                    }).join('');
                }
                const body = g.items.length > 0 ? rows : '<div class="cfg-group-empty">No items in this category</div>';
                html += '<div class="cfg-group">' +
                    '<div class="cfg-group-hdr" onclick="toggleCfgGroup(\'' + g.id + '\')">' +
                        '<span class="cfg-group-arrow' + (isOpen ? ' open' : '') + '" id="' + g.id + '-arrow">&#9654;</span>' +
                        '<span class="cfg-group-num">' + g.num + '.</span> ' + g.name +
                    '</div>' +
                    '<div class="cfg-group-body' + (isOpen ? ' open' : '') + '" id="' + g.id + '-body">' + body + '</div>' +
                '</div>';
            });

            document.getElementById('matList').innerHTML = html;

            // Pre-order validation checks
            var checks = [];

            // 1. Sheet coverage check
            var totalSheets = 0;
            mats.forEach(function(m) {
                if (m.d.toLowerCase().includes('sheet')) totalSheets += m.q;
            });
            // For gable, sheets cover one side; coverage = sheets/2 * coverWidth vs L
            var coverageMm, requiredMm;
            if (c.isGable) {
                coverageMm = Math.floor(totalSheets / 2) * sheetCover;
                requiredMm = c.L;
            } else {
                coverageMm = totalSheets * sheetCover;
                requiredMm = c.L;
            }
            if (coverageMm < requiredMm) {
                var shortBy = requiredMm - coverageMm;
                checks.push({ ok: false, text: 'May be short by ' + Math.round(shortBy) + 'mm \u2014 check sheet count' });
            } else {
                checks.push({ ok: true, text: 'Sheet coverage OK' });
            }

            // 2. Gutter overhang check
            var sheetLenMm = c.isGable ? c.rafter : c.rafter;
            var projMm = c.W;
            var overhangNeeded = projMm + 50;
            if (sheetLenMm < overhangNeeded) {
                checks.push({ ok: false, text: 'Add 50mm for gutter overhang' });
            } else {
                checks.push({ ok: true, text: 'Gutter overhang OK' });
            }

            // 3. Downpipe count
            var dpCount = 0;
            mats.forEach(function(m) {
                if (m.d.toLowerCase().includes('downpipe')) dpCount += m.q;
            });
            var widthMm = c.L;
            if (widthMm > 12000 && dpCount < 2) {
                checks.push({ ok: false, text: 'Consider 2 downpipes for 12m+ gutter' });
            } else {
                checks.push({ ok: true, text: 'Downpipe count OK' });
            }

            var checksHtml = '<div class="preorder-box"><div class="preorder-title">Pre-Order Checks</div>';
            checks.forEach(function(ch) {
                if (ch.ok) {
                    checksHtml += '<div class="preorder-item preorder-ok">\u2713 ' + ch.text + '</div>';
                } else {
                    checksHtml += '<div class="preorder-item preorder-warn">\u26A0\uFE0F ' + ch.text + '</div>';
                }
            });
            checksHtml += '</div>';
            document.getElementById('preOrderChecks').innerHTML = checksHtml;
        }

        function toggleCfgGroup(id) {
            var body = document.getElementById(id + '-body');
            var arrow = document.getElementById(id + '-arrow');
            body.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        function animateAsm() {
            requestAnimationFrame(animateAsm);
            if (asmControls) asmControls.update();
            if (asmRend && asmScene && asmCam) {
                asmRend.render(asmScene, asmCam);
            }
        }

        // ==================== PRICING ====================
        const DEFAULT_RATES = {
            // Steel ($/LM)
            '65×65×2 SHS':     22.00,
            '75×75×2 SHS':     28.00,
            '90×90×2 SHS':     35.50,
            '100×100×2 SHS':   42.00,
            '76×38×1.6 RHS':   15.50,
            '75×50×2 RHS':     26.00,
            '100×50×2 RHS':    30.00,
            '150×50×2 RHS':    39.05,
            // Roofing ($/LM)
            'Solarspan 75mm':  110.00,
            'Corrugated Colorbond': 12.04,
            'Trimdek Colorbond':   14.00,
            'Ampelite Solasafe 5-Rib': 25.00,
            'Laserlite 2000 5-Rib':    27.00,
            // Flashings ($/LM)
            'Ridge Cap':       15.00,
            'Barge Flashing':  12.00,
            'Back Flashing':   14.00,
            'Gutter Flashing': 10.00,
            // Gutters & Drainage ($/LM)
            'Quad Gutter 115mm': 18.00,
            'Box Gutter':      45.00,
            'Downpipe 90mm':   12.00,
            // Extras
            'Gable Infill (sqm)': 45.00,
            'Riser Bracket (ea)': 12.00,
            'Fixings ($/sqm)': 2.50,
            'Foam Strip':      3.00,
            // Labour ($/day)
            'Skilled Trade':   400.00,
            'Labourer':        250.00,
            'Electrician':     450.00
        };

        const DEFAULT_SELL_MARKUP = 1.35; // 35% default markup on cost for sell price
        let storedRates = {};
        let jobRows = [];      // {desc, qty, length, unitCost, unitSell, isAddon}
        let labourRows = [];   // {desc, trades, days, dayRate, sell}
        let extrasRows = [];   // {desc, qty, unitCost, unitSell, type}
        let pricingState = {}; // cached pricing calcs for PDF access

        function loadRates() {
            try {
                const saved = localStorage.getItem('patioRates');
                storedRates = saved ? JSON.parse(saved) : { ...DEFAULT_RATES };
                // Merge in any new default keys missing from saved data
                Object.keys(DEFAULT_RATES).forEach(k => {
                    if (!(k in storedRates)) storedRates[k] = DEFAULT_RATES[k];
                });
            } catch (e) {
                storedRates = { ...DEFAULT_RATES };
            }
        }

        function saveRates() {
            localStorage.setItem('patioRates', JSON.stringify(storedRates));
        }

        function renderRatesPanel() {
            const body = document.getElementById('ratesBody');
            body.innerHTML = Object.entries(storedRates).map(([k, v]) =>
                `<tr><td>${k}</td><td><input type="number" class="rate-input" step="0.01" value="${v.toFixed(2)}" onchange="updateRate('${k}', this.value)"></td></tr>`
            ).join('');
        }

        function updateRate(key, val) {
            storedRates[key] = parseFloat(val) || 0;
            saveRates();
            buildJobRows();
            // Update labour day rate if applicable
            if (key === 'Skilled Trade') {
                const el = document.getElementById('labDayRate');
                if (el && parseFloat(el.value) === 400) el.value = storedRates[key];
            }
            updatePricing();
        }

        function openRatesModal() {
            renderRatesPanel();
            document.getElementById('ratesModal').style.display = '';
        }


        function matchRate(desc) {
            const d = desc.toLowerCase();
            // Steel - SHS (posts/struts/risers)
            if (d.includes('65×65') || d.includes('65x65')) return storedRates['65×65×2 SHS'] || 0;
            if (d.includes('75×75') || d.includes('75x75')) return storedRates['75×75×2 SHS'] || 0;
            if (d.includes('90×90') || d.includes('90x90')) return storedRates['90×90×2 SHS'] || 0;
            if (d.includes('100×100') || d.includes('100x100')) return storedRates['100×100×2 SHS'] || 0;
            // Steel - RHS (beams/trusses)
            if (d.includes('76×38') || d.includes('76x38')) return storedRates['76×38×1.6 RHS'] || 0;
            if (d.includes('75×50') || d.includes('75x50')) return storedRates['75×50×2 RHS'] || 0;
            if (d.includes('150×50') || d.includes('150x50')) return storedRates['150×50×2 RHS'] || 0;
            if (d.includes('100×50') || d.includes('100x50')) return storedRates['100×50×2 RHS'] || 0;
            // Roofing
            if (d.includes('solarspan')) return storedRates['Solarspan 75mm'] || 0;
            if (d.includes('polycarb') && d.includes('laserlite')) return storedRates['Laserlite 2000 5-Rib'] || 0;
            if (d.includes('polycarb') && d.includes('ampelite')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('polycarb')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('trimdek') && d.includes('sheet')) return storedRates['Trimdek Colorbond'] || 0;
            if (d.includes('sheet') && !d.includes('solarspan')) return storedRates['Corrugated Colorbond'] || 0;
            // Flashings
            if (d.includes('ridge cap') || d.includes('ridge flash')) return storedRates['Ridge Cap'] || 0;
            if (d.includes('barge')) return storedRates['Barge Flashing'] || 0;
            if (d.includes('back flash') || d.includes('wall flash')) return storedRates['Back Flashing'] || 0;
            if (d.includes('gutter flash')) return storedRates['Gutter Flashing'] || 0;
            // Gutters & drainage
            if (d.includes('box gutter')) return storedRates['Box Gutter'] || 0;
            if (d.includes('gutter') && !d.includes('box') && !d.includes('downpipe') && !d.includes('flash')) return storedRates['Quad Gutter 115mm'] || 0;
            if (d.includes('downpipe')) return storedRates['Downpipe 90mm'] || 0;
            // Extras
            if (d.includes('infill')) return storedRates['Gable Infill (sqm)'] || 0;
            if (d.includes('riser') && d.includes('bracket')) return storedRates['Riser Bracket (ea)'] || 0;
            if (d.includes('foam')) return storedRates['Foam Strip'] || 0;
            if (d.includes('channel') && !d.includes('gutter')) return storedRates['Back Flashing'] || 0;
            if (d.includes('strut')) return storedRates['76×38×1.6 RHS'] || 0;
            if (d.includes('elbow')) return storedRates['Downpipe 90mm'] || 0;
            if (d.includes('fascia board')) return storedRates['Barge Flashing'] || 0;
            return 0;
        }

        function getItemLength(desc) {
            const c = calc;
            const d = desc.toLowerCase();
            const Lm = c.L / 1000;
            const Wm = c.W / 1000;
            if (d.includes('post')) return c.postH / 1000;
            if (d.includes('beam') || d.includes('ridge') || d.includes('barge') || d.includes('flashing') || d.includes('channel') || d.includes('gutter') || d.includes('fascia board')) return Lm;
            if (d.includes('truss') || d.includes('rafter')) return c.rafter / 1000;
            if (d.includes('purlin')) return Lm;
            if (d.includes('sheet') && d.includes('solarspan')) return Wm;
            if (d.includes('sheet')) return c.rafter / 1000;
            if (d.includes('downpipe')) return c.postH / 1000;
            if (d.includes('strut')) return 0.5;
            if (d.includes('riser elbow')) return 0.5;
            if (d.includes('infill')) return c.rafter / 1000;
            if (d.includes('foam')) return Lm;
            return 1;
        }

        // Build jobRows from the materials list (called after rebuildAll)
        function buildJobRows() {
            const matRowEls = document.querySelectorAll('#matList .mat-row');
            // Preserve existing addon rows
            const addons = jobRows.filter(r => r.isAddon);
            jobRows = [];
            matRowEls.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length < 2) return;
                const desc = row.dataset.desc || spans[0].textContent.trim();
                const qty = parseInt(spans[1].textContent.trim().replace('×', '')) || 1;
                const length = getItemLength(desc);
                const unitCost = matchRate(desc);
                const unitSell = +(unitCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc, qty, length, unit: 'LM', unitCost, unitSell, isAddon: false });
            });
            // Auto-add fixings estimate based on patio area
            const c = calc;
            if (c.L && c.W) {
                const areaSqm = (c.L / 1000) * (c.W / 1000);
                const fixCost = storedRates['Fixings ($/sqm)'] || 2.50;
                const fixSell = +(fixCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc: 'Fixings (screws, anchors, silicone, foam)', qty: +areaSqm.toFixed(1), length: 1, unit: 'sqm', unitCost: fixCost, unitSell: fixSell, isAddon: false });
            }
            // Re-append addons
            addons.forEach(a => { if (!a.unit) a.unit = 'each'; jobRows.push(a); });
        }

        const UNIT_OPTIONS = ['each', 'LM', 'sqm', 'hours', 'days', 'lot'];

        // Keep renderJobTable for compatibility (materials modal uses it internally)
        function renderJobTable() { /* now handled by materials modal */ }

        // Extras presets
        function addExtra(type) {
            const nPosts = calc.nPosts ? calc.nPosts * 2 : 6;
            const presets = {
                footings:    { desc: 'Concrete Footings', qty: nPosts, unitCost: 85,  unitSell: 150, type: 'footings' },
                electrical:  { desc: 'Electrical',        qty: 1,      unitCost: 0,   unitSell: 0,   type: 'electrical' },
                downlights:  { desc: 'Downlights',        qty: 4,      unitCost: 50,  unitSell: 85,  type: 'downlights' },
                demo:        { desc: 'Demo/Removal',      qty: 1,      unitCost: 0,   unitSell: 0,   type: 'demo' },
                delivery:    { desc: 'Delivery',           qty: 1,      unitCost: 200, unitSell: 350, type: 'delivery' },
                other:       { desc: '',                   qty: 1,      unitCost: 0,   unitSell: 0,   type: 'other' }
            };
            const p = presets[type];
            if (!p) return;
            extrasRows.push({ ...p });
            renderExtras();
            updatePricing();
        }

        function removeExtra(idx) {
            extrasRows.splice(idx, 1);
            renderExtras();
            updatePricing();
        }

        function renderExtras() {
            const container = document.getElementById('extrasRowsContainer');
            if (extrasRows.length === 0) {
                container.innerHTML = '';
                return;
            }
            container.innerHTML = extrasRows.map((r, i) => {
                const totalCost = r.qty * r.unitCost;
                const totalSell = r.qty * r.unitSell;
                const fmt = v => '$' + v.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                const descInput = r.type === 'other'
                    ? `<input type="text" class="ex-input desc-input" value="${r.desc}" placeholder="Description" onchange="extrasRows[${i}].desc=this.value">`
                    : `<span>${r.desc}${r.qty > 1 ? ' (' + r.qty + ')' : ''}</span>`;
                return `<div class="extras-row">
                    <div class="ex-desc">${descInput}</div>
                    ${r.type === 'downlights' || r.type === 'footings' ? `<div class="ex-field">Qty: <input type="number" class="ex-input" style="width:50px" value="${r.qty}" min="1" step="1" onchange="extrasRows[${i}].qty=parseFloat(this.value)||1;renderExtras();updatePricing()"></div>` : ''}
                    <div class="ex-field">Cost: <input type="number" class="ex-input" value="${totalCost.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitCost=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <div class="ex-field">Sell: <input type="number" class="ex-input" value="${totalSell.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitSell=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <button class="ex-remove" onclick="removeExtra(${i})">&times;</button>
                </div>`;
            }).join('');
        }

        // Legacy addon compat: migrate old addon rows to extras on import
        function addSmartAddon(type) {
            const typeMap = { concrete: 'footings', electrical: 'electrical', downlights: 'downlights', demo: 'demo', fan: 'other', fascia: 'other', posts: 'other', permit: 'other' };
            addExtra(typeMap[type] || 'other');
        }
        function addCustomLine() { addExtra('other'); }
        function removeJobRow(idx) { jobRows.splice(idx, 1); updatePricing(); }

        // Labour — read from inline card inputs
        function getLabourFromCard() {
            const trades = parseFloat(document.getElementById('labTrades').value) || 0;
            const days = parseFloat(document.getElementById('labDays').value) || 0;
            const dayRate = parseFloat(document.getElementById('labDayRate').value) || 0;
            const sell = parseFloat(document.getElementById('labSellInput').value) || 0;
            const cost = trades * days * dayRate;
            return { trades, days, dayRate, cost, sell };
        }

        // Sync labourRows from card for PDF/export compat
        function syncLabourRows() {
            const l = getLabourFromCard();
            labourRows = [{ role: 'Skilled (Patio Install)', trades: l.trades, days: l.days, dayRate: l.dayRate, sell: l.sell }];
        }

        // Kept for export/import compat
        function renderLabourTable() {}
        function addLabourRole() {}
        function matchDayRate(role) {
            const r = role.toLowerCase();
            if (r.includes('electrician')) return storedRates['Electrician'] || 450;
            if (r.includes('labourer')) return storedRates['Labourer'] || 250;
            return storedRates['Skilled Trade'] || 400;
        }

        // Complexity — kept for export/import compat (hidden inputs)
        function updateComplexity() {}

        // ==================== MATERIALS MODAL ====================
        function openMaterialsModal() {
            renderMaterialsModal();
            document.getElementById('materialsModal').style.display = '';
        }

        function closeMaterialsModal() {
            document.getElementById('materialsModal').style.display = 'none';
            updatePricing();
        }

        function renderMaterialsModal() {
            const showCost = document.getElementById('showCostToggle').checked;
            const body = document.getElementById('matModalBody');
            // Show only non-addon material rows
            const matRows = jobRows.filter(r => !r.isAddon);
            let totalSell = 0;

            body.innerHTML = matRows.map((r, realIdx) => {
                const i = jobRows.indexOf(r);
                const mult = r.unit === 'LM' ? r.length : 1;
                const lineCost = r.qty * mult * r.unitCost;
                const lineSell = r.qty * mult * r.unitSell;
                totalSell += lineSell;
                const markupPct = r.unitCost > 0 ? ((r.unitSell - r.unitCost) / r.unitCost * 100) : 0;
                const globalMk = parseFloat(document.getElementById('globalMarkupPct').value) || 35;
                const isCustom = Math.abs(markupPct - globalMk) > 1;
                const qtyStr = r.qty + (r.unit === 'LM' && r.length > 0 ? ' \u00D7 ' + r.length.toFixed(1) + 'm' : r.unit !== 'LM' ? ' ' + r.unit : '');

                return `<tr>
                    <td>${r.desc}</td>
                    <td>${qtyStr}</td>
                    ${showCost ? `<td class="r mono">$${lineCost.toFixed(2)}</td>` : `<td class="r cost-col" style="display:none"></td>`}
                    <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" onchange="updateMatSellFromModal(${i},this.value)" style="width:90px"></td>
                    <td class="r"><span class="markup-badge${isCustom ? ' custom' : ''}">${markupPct.toFixed(0)}%${isCustom ? '*' : ''}</span></td>
                    <td></td>
                </tr>`;
            }).join('');

            // Also show custom addon rows in modal
            const addonRows = jobRows.filter(r => r.isAddon);
            if (addonRows.length > 0) {
                body.innerHTML += `<tr><td colspan="6" style="font-size:11px;font-weight:600;text-transform:uppercase;color:var(--sw-text-sec);padding-top:12px;border-bottom:1px solid var(--sw-border)">Custom Items</td></tr>`;
                body.innerHTML += addonRows.map(r => {
                    const i = jobRows.indexOf(r);
                    const mult = r.unit === 'LM' ? r.length : 1;
                    const lineSell = r.qty * mult * r.unitSell;
                    totalSell += lineSell;
                    return `<tr>
                        <td><input type="text" value="${r.desc}" style="width:160px;padding:4px 6px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px" onchange="jobRows[${i}].desc=this.value"></td>
                        <td><input type="number" value="${r.qty}" min="0" step="1" style="width:50px;padding:4px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px;text-align:center" onchange="jobRows[${i}].qty=parseFloat(this.value)||0;renderMaterialsModal()"></td>
                        ${showCost ? `<td class="r"><input type="number" value="${(r.qty*mult*r.unitCost).toFixed(2)}" min="0" step="1" style="width:80px" onchange="jobRows[${i}].unitCost=parseFloat(this.value)/(jobRows[${i}].qty*(jobRows[${i}].unit==='LM'?jobRows[${i}].length:1)||1);renderMaterialsModal()"></td>` : `<td style="display:none"></td>`}
                        <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" style="width:90px" onchange="updateMatSellFromModal(${i},this.value)"></td>
                        <td class="r"></td>
                        <td><button style="background:none;border:none;color:#ccc;cursor:pointer;font-size:16px" onclick="jobRows.splice(${i},1);renderMaterialsModal()" onmouseover="this.style.color='#FF3B30'" onmouseout="this.style.color='#ccc'">&times;</button></td>
                    </tr>`;
                }).join('');
            }

            // Update cost column visibility (header + all cost cells)
            document.querySelectorAll('.mat-modal-table .cost-col').forEach(el => el.style.display = showCost ? '' : 'none');

            document.getElementById('matModalTotal').textContent = '$' + totalSell.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        function updateMatSellFromModal(idx, val) {
            const r = jobRows[idx];
            const mult = r.unit === 'LM' ? r.length : 1;
            const totalQty = r.qty * mult;
            r.unitSell = totalQty > 0 ? parseFloat(val) / totalQty : 0;
            renderMaterialsModal();
        }

        function applyMarkupAll() {
            const pct = parseFloat(document.getElementById('globalMarkupPct').value) || 35;
            jobRows.forEach(r => {
                if (!r.isAddon) {
                    r.unitSell = +(r.unitCost * (1 + pct / 100)).toFixed(2);
                }
            });
            renderMaterialsModal();
            updatePricing();
        }

        function addCustomMaterialRow() {
            jobRows.push({ desc: 'Custom item', qty: 1, length: 1, unit: 'each', unitCost: 0, unitSell: 0, isAddon: true });
            renderMaterialsModal();
        }

        // ==================== MAIN PRICING UPDATE ====================
        function updatePricing() {
            const fmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            const fmtShort = v => '$' + Math.round(v).toLocaleString();

            // Materials from jobRows (non-addon = materials, addon = custom material items included in materials total)
            let matCost = 0, matSell = 0;
            let matItemCount = 0;
            jobRows.forEach(r => {
                const mult = r.unit === 'LM' ? r.length : 1;
                matCost += r.qty * mult * r.unitCost;
                matSell += r.qty * mult * r.unitSell;
                matItemCount++;
            });

            // Materials card update
            const matMarkup = matCost > 0 ? ((matSell - matCost) / matCost * 100) : 0;
            document.getElementById('matSellDisplay').textContent = fmtShort(matSell);
            document.getElementById('matItemCount').textContent = matItemCount + ' item' + (matItemCount !== 1 ? 's' : '');
            document.getElementById('matMarkupPct').textContent = matMarkup.toFixed(0) + '%';

            // Validation: warn if any item has $0 sell
            const hasZero = jobRows.some(r => !r.isAddon && r.unitSell === 0 && r.unitCost > 0);
            const iconEl = document.getElementById('matStatusIcon');
            if (hasZero) {
                iconEl.textContent = '\u26A0';
                iconEl.className = 'status-warn';
            } else {
                iconEl.textContent = '\u2713';
                iconEl.className = 'status-ok';
            }

            // Labour from card inputs
            const lab = getLabourFromCard();
            const labCost = lab.cost;
            const labSell = lab.sell;

            // Update labour cost display
            document.getElementById('labCostDisplay').textContent = fmtShort(labCost);

            // Sync labourRows for PDF/export
            syncLabourRows();

            // Extras
            let extrasCost = 0, extrasSell = 0;
            extrasRows.forEach(r => {
                extrasCost += r.qty * r.unitCost;
                extrasSell += r.qty * r.unitSell;
            });

            // Totals
            const totalCost = matCost + labCost + extrasCost;
            const totalSell = matSell + labSell + extrasSell;
            const gst = totalSell * 0.10;
            const totalIncGST = totalSell + gst;
            const margin = totalSell - totalCost;
            const marginPct = totalSell > 0 ? (margin / totalSell * 100) : 0;

            // Total card
            document.getElementById('totalAmountDisplay').textContent = 'TOTAL ' + fmtShort(totalIncGST) + ' inc GST';

            const marginEl = document.getElementById('totalMarginDisplay');
            const marginIcon = marginPct > 20 ? '  \u2713' : marginPct >= 10 ? '' : '  \u2717';
            marginEl.textContent = 'Margin ' + fmtShort(margin) + ' (' + marginPct.toFixed(1) + '%)' + marginIcon;
            if (marginPct > 20) {
                marginEl.className = 'total-margin margin-green';
            } else if (marginPct >= 10) {
                marginEl.className = 'total-margin margin-orange';
            } else {
                marginEl.className = 'total-margin margin-red';
            }

            // Cache pricing state for PDF generators
            pricingState = {
                matCost, matSell, labCost, labSell, extrasCost, extrasSell,
                totalCost, totalSell, gst, totalIncGST, margin, marginPct,
                fmt
            };
        }

        // ==================== COLLAPSIBLE SECTIONS ====================
        const SECTION_IDS = ['sec-truss', 'sec-site', 'sec-flashings', 'sec-materials', 'sec-pricing'];
        const DEFAULT_COLLAPSED = ['sec-truss', 'sec-site', 'sec-flashings', 'sec-materials', 'sec-pricing'];

        function loadCollapseState() {
            try {
                const saved = localStorage.getItem('patioCollapseState');
                return saved ? JSON.parse(saved) : null;
            } catch(e) { return null; }
        }

        function saveCollapseState() {
            const state = {};
            SECTION_IDS.forEach(id => {
                const hdr = document.querySelector('#' + id + ' > .collapse-header');
                if (hdr) state[id] = hdr.classList.contains('collapsed');
            });
            localStorage.setItem('patioCollapseState', JSON.stringify(state));
        }

        function toggleSection(id) {
            const sec = document.getElementById(id);
            if (!sec) return;
            const hdr = sec.querySelector('.collapse-header');
            const body = sec.querySelector('.collapse-body');
            if (!hdr || !body) return;
            const isCollapsed = hdr.classList.contains('collapsed');
            if (isCollapsed) {
                // Expand
                hdr.classList.remove('collapsed');
                body.style.maxHeight = body.scrollHeight + 'px';
                body.classList.remove('shut');
                setTimeout(() => {
                    body.style.maxHeight = '';
                    if (id === 'sec-truss') { resizeTruss(); if (trussRend) trussRend.render(trussScene, trussCam); }
                    if (id === 'sec-flashings') { resizeFlashCanvas(); drawFlashCanvas(); }
                }, 350);
            } else {
                // Collapse
                body.style.maxHeight = body.scrollHeight + 'px';
                requestAnimationFrame(() => {
                    body.style.maxHeight = '0';
                    body.classList.add('shut');
                    hdr.classList.add('collapsed');
                });
            }
            saveCollapseState();
        }

        function initCollapseSections() {
            const saved = loadCollapseState();
            SECTION_IDS.forEach(id => {
                const sec = document.getElementById(id);
                if (!sec) return;
                const hdr = sec.querySelector('.collapse-header');
                const body = sec.querySelector('.collapse-body');
                if (!hdr || !body) return;
                const shouldCollapse = saved ? saved[id] : DEFAULT_COLLAPSED.includes(id);
                if (shouldCollapse) {
                    hdr.classList.add('collapsed');
                    body.classList.add('shut');
                    body.style.maxHeight = '0';
                } else {
                    hdr.classList.remove('collapsed');
                    body.classList.remove('shut');
                }
            });
        }

        // ==================== EDGE PANNING ====================
        function setupEdgePanning2D(canvas, panState, redrawFn) {
            var edgeThreshold = 50;
            var maxPanSpeed = 8;
            var animationId = null;

            function updatePan() {
                if (!panState.isHovering) return;
                var rect = canvas.getBoundingClientRect();
                var mouseX = panState.mouseX - rect.left;
                var mouseY = panState.mouseY - rect.top;
                var panX = 0, panY = 0;

                if (mouseX >= 0 && mouseX < edgeThreshold) {
                    panX = maxPanSpeed * (1 - mouseX / edgeThreshold);
                }
                if (mouseX > rect.width - edgeThreshold && mouseX <= rect.width) {
                    panX = -maxPanSpeed * (1 - (rect.width - mouseX) / edgeThreshold);
                }
                if (mouseY >= 0 && mouseY < edgeThreshold) {
                    panY = maxPanSpeed * (1 - mouseY / edgeThreshold);
                }
                if (mouseY > rect.height - edgeThreshold && mouseY <= rect.height) {
                    panY = -maxPanSpeed * (1 - (rect.height - mouseY) / edgeThreshold);
                }

                if (panX !== 0 || panY !== 0) {
                    panState.offsetX += panX;
                    panState.offsetY += panY;
                    if (redrawFn) redrawFn();
                }

                animationId = requestAnimationFrame(updatePan);
            }

            canvas.addEventListener('mouseenter', function() {
                panState.isHovering = true;
                updatePan();
            });
            canvas.addEventListener('mouseleave', function() {
                panState.isHovering = false;
                if (animationId) cancelAnimationFrame(animationId);
                animationId = null;
            });
            canvas.addEventListener('mousemove', function(e) {
                panState.mouseX = e.clientX;
                panState.mouseY = e.clientY;
            });
        }

        function setupEdgePanning3D(container, camera, controls) {
            var edgeThreshold = 50;
            var maxRotateSpeed = 0.02;
            var animationId = null;
            var mouseX = 0, mouseY = 0;
            var isHovering = false;

            function updatePan() {
                if (!isHovering) return;
                var rect = container.getBoundingClientRect();
                var localX = mouseX - rect.left;
                var localY = mouseY - rect.top;
                var rotateH = 0, rotateV = 0;

                if (localX >= 0 && localX < edgeThreshold) {
                    rotateH = maxRotateSpeed * (1 - localX / edgeThreshold);
                }
                if (localX > rect.width - edgeThreshold && localX <= rect.width) {
                    rotateH = -maxRotateSpeed * (1 - (rect.width - localX) / edgeThreshold);
                }
                if (localY >= 0 && localY < edgeThreshold) {
                    rotateV = maxRotateSpeed * (1 - localY / edgeThreshold);
                }
                if (localY > rect.height - edgeThreshold && localY <= rect.height) {
                    rotateV = -maxRotateSpeed * (1 - (rect.height - localY) / edgeThreshold);
                }

                if ((rotateH !== 0 || rotateV !== 0) && controls && camera) {
                    var spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position.clone().sub(controls.target));
                    spherical.theta += rotateH;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + rotateV));
                    camera.position.setFromSpherical(spherical).add(controls.target);
                    camera.lookAt(controls.target);
                }

                animationId = requestAnimationFrame(updatePan);
            }

            container.addEventListener('mouseenter', function() {
                isHovering = true;
                updatePan();
            });
            container.addEventListener('mouseleave', function() {
                isHovering = false;
                if (animationId) cancelAnimationFrame(animationId);
                animationId = null;
            });
            container.addEventListener('mousemove', function(e) {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
        }

        // ==================== FLASHING PROFILE EDITOR ====================
        let flashingProfiles = [];
        let flashingTemplates = [];
        let flashCurrentPoints = [];
        let flashUndoStack = [];
        let flashTool = 'draw';
        let flashColourSide = 'top';
        let flashDrawing = false;
        let flashPanOffset = { x: 0, y: 0 };
        let flashZoomLevel = 10; // mm per grid square
        let flashSelectedIdx = -1;
        let flashSelectedLeg = -1;
        let flashEditingId = null;
        let flashDragging = false;
        let flashDragStart = { x: 0, y: 0 };
        let flashPanStart = { x: 0, y: 0 };
        let flashHoverPoint = -1;
        let flashMouseMM = { x: 0, y: 0 };
        let flashSnapAngle = false;
        let flashNextId = 1;
        let flashStartTreatment = null; // null or { type: 'miniBreak', size: 10, angle: 45, direction: 'out' } or { type: 'hem' }
        let flashEndTreatment = null;

        const FLASH_GAUGES = [0.42, 0.48, 0.55];

        const FLASH_DEFAULT_TEMPLATES = [
            { name: 'Apron', points: [{x:0,y:0},{x:0,y:100},{x:270,y:100},{x:270,y:180}], colourSide: 'top', folder: 'Standard' },
            { name: 'Barge Roll', points: [{x:0,y:0},{x:0,y:30},{x:15,y:45},{x:15,y:200},{x:165,y:200}], colourSide: 'top', folder: 'Standard' },
            { name: 'Ridge Cap', points: [{x:0,y:150},{x:150,y:0},{x:300,y:150}], colourSide: 'top', folder: 'Standard' },
            { name: 'Receiver', points: [{x:0,y:0},{x:0,y:80},{x:25,y:80},{x:25,y:0}], colourSide: 'top', folder: 'Standard' },
            { name: 'Box Gutter', points: [{x:0,y:0},{x:0,y:100},{x:30,y:130},{x:170,y:130},{x:200,y:100},{x:200,y:0}], colourSide: 'bottom', folder: 'Standard' },
            { name: 'Drip Edge', points: [{x:0,y:0},{x:120,y:0},{x:120,y:50},{x:110,y:65}], colourSide: 'top', folder: 'Standard' },
            { name: 'Z-Flash', points: [{x:0,y:0},{x:0,y:60},{x:80,y:60},{x:80,y:120}], colourSide: 'top', folder: 'Standard' },
            // SolarSpan 50mm
            { name: 'Fascia', points: [{x:0,y:0},{x:0,y:50},{x:80,y:50},{x:80,y:130}], colourSide: 'top', folder: 'SolarSpan 50mm' },
            { name: 'Receiver', points: [{x:0,y:0},{x:0,y:50},{x:25,y:50},{x:25,y:0}], colourSide: 'top', folder: 'SolarSpan 50mm' },
            { name: 'Barge (side)', points: [{x:0,y:0},{x:0,y:50},{x:60,y:50},{x:60,y:0}], colourSide: 'top', folder: 'SolarSpan 50mm' },
            { name: 'Back Apron', points: [{x:0,y:0},{x:0,y:50},{x:200,y:50},{x:200,y:130}], colourSide: 'top', folder: 'SolarSpan 50mm' },
            // SolarSpan 75mm
            { name: 'Fascia', points: [{x:0,y:0},{x:0,y:75},{x:80,y:75},{x:80,y:155}], colourSide: 'top', folder: 'SolarSpan 75mm' },
            { name: 'Receiver', points: [{x:0,y:0},{x:0,y:75},{x:25,y:75},{x:25,y:0}], colourSide: 'top', folder: 'SolarSpan 75mm' },
            { name: 'Barge (side)', points: [{x:0,y:0},{x:0,y:75},{x:60,y:75},{x:60,y:0}], colourSide: 'top', folder: 'SolarSpan 75mm' },
            { name: 'Back Apron', points: [{x:0,y:0},{x:0,y:75},{x:200,y:75},{x:200,y:155}], colourSide: 'top', folder: 'SolarSpan 75mm' },
            // SolarSpan 100mm
            { name: 'Fascia', points: [{x:0,y:0},{x:0,y:100},{x:80,y:100},{x:80,y:180}], colourSide: 'top', folder: 'SolarSpan 100mm' },
            { name: 'Receiver', points: [{x:0,y:0},{x:0,y:100},{x:25,y:100},{x:25,y:0}], colourSide: 'top', folder: 'SolarSpan 100mm' },
            { name: 'Barge (side)', points: [{x:0,y:0},{x:0,y:100},{x:60,y:100},{x:60,y:0}], colourSide: 'top', folder: 'SolarSpan 100mm' },
            { name: 'Back Apron', points: [{x:0,y:0},{x:0,y:100},{x:200,y:100},{x:200,y:180}], colourSide: 'top', folder: 'SolarSpan 100mm' },
            // Gable Details
            { name: 'Ridge', points: [{x:0,y:150},{x:150,y:0},{x:300,y:150}], colourSide: 'top', folder: 'Gable Details' },
            { name: 'Valley', points: [{x:0,y:0},{x:150,y:120},{x:300,y:0}], colourSide: 'bottom', folder: 'Gable Details' },
            { name: 'Hip', points: [{x:0,y:0},{x:0,y:80},{x:150,y:0},{x:150,y:80}], colourSide: 'top', folder: 'Gable Details' },
            { name: 'Barge', points: [{x:0,y:0},{x:0,y:30},{x:15,y:45},{x:15,y:200},{x:165,y:200}], colourSide: 'top', folder: 'Gable Details' },
            // Skillion Details
            { name: 'Top Flashing (apron)', points: [{x:0,y:0},{x:0,y:100},{x:270,y:100},{x:270,y:180}], colourSide: 'top', folder: 'Skillion Details' },
            { name: 'Gutter Flashing (fascia)', points: [{x:0,y:0},{x:0,y:80},{x:100,y:80},{x:100,y:160}], colourSide: 'top', folder: 'Skillion Details' },
            { name: 'Barge Left', points: [{x:0,y:0},{x:0,y:30},{x:15,y:45},{x:15,y:200},{x:165,y:200}], colourSide: 'top', folder: 'Skillion Details' },
            { name: 'Barge Right', points: [{x:165,y:200},{x:15,y:200},{x:15,y:45},{x:0,y:30},{x:0,y:0}], colourSide: 'top', folder: 'Skillion Details' },
            // Custom
            { name: 'Custom', points: [], colourSide: 'top', folder: 'Standard' }
        ];

        function initFlashingEditor() {
            // Load saved templates from localStorage or use defaults
            var saved = localStorage.getItem('flashingTemplates');
            if (saved) {
                try { flashingTemplates = JSON.parse(saved); } catch(e) { flashingTemplates = []; }
            }
            // Ensure defaults always present
            FLASH_DEFAULT_TEMPLATES.forEach(function(dt) {
                if (!flashingTemplates.find(function(t) { return t.name === dt.name; })) {
                    flashingTemplates.push(JSON.parse(JSON.stringify(dt)));
                }
            });

            renderFlashTemplates();
            setupFlashCanvas();
            renderFlashJobTable();

            // Load template: default to Apron
            loadFlashTemplate(0);
        }

        var flashEdgePanState = { mouseX: 0, mouseY: 0, isHovering: false, offsetX: 0, offsetY: 0 };

        function setupFlashCanvas() {
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;

            canvas.addEventListener('mousedown', flashMouseDown);
            canvas.addEventListener('mousemove', flashMouseMove);
            canvas.addEventListener('mouseup', flashMouseUp);
            canvas.addEventListener('dblclick', flashDblClick);
            canvas.addEventListener('wheel', flashWheel, { passive: false });
            canvas.addEventListener('contextmenu', function(e) { e.preventDefault(); });

            document.addEventListener('keydown', flashKeyDown);

            // Edge panning for flashing canvas
            setupEdgePanning2D(canvas, flashEdgePanState, function() {
                flashPanOffset.x = flashEdgePanState.offsetX;
                flashPanOffset.y = flashEdgePanState.offsetY;
                drawFlashCanvas();
            });

            resizeFlashCanvas();
            drawFlashCanvas();
        }

        function resizeFlashCanvas() {
            var canvas = document.getElementById('flashCanvas');
            var vp = document.getElementById('flashViewport');
            if (!canvas || !vp) return;
            var w = vp.clientWidth || 600;
            var h = vp.clientHeight || 400;
            canvas.width = w;
            canvas.height = h;
        }

        // ---- Coordinate conversion ----
        function flashMMToCanvas(mx, my) {
            var canvas = document.getElementById('flashCanvas');
            var cw = canvas.width, ch = canvas.height;
            var scale = flashZoomLevel; // mm per grid cell, grid cell = 20px on screen
            var pxPerMM = 20 / scale;
            var cx = cw / 2 + flashPanOffset.x + mx * pxPerMM;
            var cy = ch / 2 + flashPanOffset.y - my * pxPerMM; // y inverted
            return { x: cx, y: cy };
        }

        function flashCanvasToMM(cx, cy) {
            var canvas = document.getElementById('flashCanvas');
            var cw = canvas.width, ch = canvas.height;
            var scale = flashZoomLevel;
            var pxPerMM = 20 / scale;
            var mx = (cx - cw / 2 - flashPanOffset.x) / pxPerMM;
            var my = -(cy - ch / 2 - flashPanOffset.y) / pxPerMM;
            return { x: mx, y: my };
        }

        function flashSnapToGrid(mm) {
            var snap = flashZoomLevel;
            return { x: Math.round(mm.x / snap) * snap, y: Math.round(mm.y / snap) * snap };
        }

        // ---- Drawing ----
        function drawFlashCanvas() {
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;
            // Sync edge pan state with flashPanOffset
            flashEdgePanState.offsetX = flashPanOffset.x;
            flashEdgePanState.offsetY = flashPanOffset.y;
            var ctx = canvas.getContext('2d');
            var cw = canvas.width, ch = canvas.height;
            ctx.clearRect(0, 0, cw, ch);

            // Background
            ctx.fillStyle = '#FAFBFC';
            ctx.fillRect(0, 0, cw, ch);

            var pxPerMM = 20 / flashZoomLevel;
            var gridPx = 20; // grid spacing in pixels

            // Draw grid
            ctx.strokeStyle = '#E8EAED';
            ctx.lineWidth = 0.5;
            var startX = ((cw / 2 + flashPanOffset.x) % gridPx);
            var startY = ((ch / 2 + flashPanOffset.y) % gridPx);
            for (var gx = startX; gx < cw; gx += gridPx) {
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, ch); ctx.stroke();
            }
            for (var gy = startY; gy < ch; gy += gridPx) {
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(cw, gy); ctx.stroke();
            }

            // Heavier lines every 5 grid squares
            ctx.strokeStyle = '#D0D4DA';
            ctx.lineWidth = 0.8;
            var majorPx = gridPx * 5;
            var mjStartX = ((cw / 2 + flashPanOffset.x) % majorPx);
            var mjStartY = ((ch / 2 + flashPanOffset.y) % majorPx);
            for (var gx2 = mjStartX; gx2 < cw; gx2 += majorPx) {
                ctx.beginPath(); ctx.moveTo(gx2, 0); ctx.lineTo(gx2, ch); ctx.stroke();
            }
            for (var gy2 = mjStartY; gy2 < ch; gy2 += majorPx) {
                ctx.beginPath(); ctx.moveTo(0, gy2); ctx.lineTo(cw, gy2); ctx.stroke();
            }

            // Origin crosshair
            var o = flashMMToCanvas(0, 0);
            ctx.strokeStyle = '#B0B8C0';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath(); ctx.moveTo(o.x, 0); ctx.lineTo(o.x, ch); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, o.y); ctx.lineTo(cw, o.y); ctx.stroke();
            ctx.setLineDash([]);

            // Draw profile
            var pts = flashCurrentPoints;
            if (pts.length > 0) {
                // Colour side indicator (thicker line on colour side)
                drawFlashProfile(ctx, pts, true);
                // Draw end treatments (mini break / hem)
                if (flashStartTreatment && pts.length >= 2) drawEndTreatment(ctx, pts, flashStartTreatment, true);
                if (flashEndTreatment && pts.length >= 2) drawEndTreatment(ctx, pts, flashEndTreatment, false);
            }

            // Draw active drawing line (from last point to mouse)
            if (flashTool === 'draw' && flashDrawing && pts.length > 0) {
                var lastPt = pts[pts.length - 1];
                var lp = flashMMToCanvas(lastPt.x, lastPt.y);
                var mp = flashMMToCanvas(flashMouseMM.x, flashMouseMM.y);
                ctx.strokeStyle = 'rgba(241,90,41,0.5)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([6, 4]);
                ctx.beginPath(); ctx.moveTo(lp.x, lp.y); ctx.lineTo(mp.x, mp.y); ctx.stroke();
                ctx.setLineDash([]);

                // Show dimension of active line
                var dx = flashMouseMM.x - lastPt.x;
                var dy = flashMouseMM.y - lastPt.y;
                var dist = Math.round(Math.sqrt(dx * dx + dy * dy));
                if (dist > 0) {
                    var midX = (lp.x + mp.x) / 2;
                    var midY = (lp.y + mp.y) / 2;
                    ctx.font = '11px SF Mono, monospace';
                    ctx.fillStyle = 'rgba(241,90,41,0.8)';
                    ctx.fillText(dist + 'mm', midX + 5, midY - 5);
                }
            }

            // Highlight hovered point
            if (flashHoverPoint >= 0 && flashHoverPoint < pts.length) {
                var hp = pts[flashHoverPoint];
                var hc = flashMMToCanvas(hp.x, hp.y);
                ctx.beginPath();
                ctx.arc(hc.x, hc.y, 7, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(241,90,41,0.2)';
                ctx.fill();
            }

            // Update info bar
            updateFlashInfo();
        }

        function drawFlashProfile(ctx, pts, showDims) {
            if (pts.length < 2) {
                if (pts.length === 1) {
                    var sp = flashMMToCanvas(pts[0].x, pts[0].y);
                    ctx.beginPath();
                    ctx.arc(sp.x, sp.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = var_sw_orange();
                    ctx.fill();
                }
                return;
            }

            // Draw main profile line
            ctx.strokeStyle = '#293C46';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            var fp = flashMMToCanvas(pts[0].x, pts[0].y);
            ctx.moveTo(fp.x, fp.y);
            for (var i = 1; i < pts.length; i++) {
                var pp = flashMMToCanvas(pts[i].x, pts[i].y);
                ctx.lineTo(pp.x, pp.y);
            }
            ctx.stroke();

            // Colour side indicator - thick coloured line offset to one side with hatching
            var csOffset = flashColourSide === 'top' ? -6 : 6;
            // Draw thick colour-side line
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3.5;
            ctx.globalAlpha = 0.55;
            ctx.beginPath();
            for (var j = 0; j < pts.length - 1; j++) {
                var a = pts[j], b = pts[j + 1];
                var ddx = b.x - a.x, ddy = b.y - a.y;
                var dl = Math.sqrt(ddx * ddx + ddy * ddy);
                if (dl === 0) continue;
                var nx = -ddy / dl * csOffset, ny = ddx / dl * csOffset;
                var pa = flashMMToCanvas(a.x, a.y);
                var pb = flashMMToCanvas(b.x, b.y);
                if (j === 0) ctx.moveTo(pa.x + nx, pa.y + ny);
                else ctx.lineTo(pa.x + nx, pa.y + ny);
                ctx.lineTo(pb.x + nx, pb.y + ny);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;

            // Draw hatching between profile and colour side line
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 0.6;
            ctx.globalAlpha = 0.25;
            for (var hj = 0; hj < pts.length - 1; hj++) {
                var ha = pts[hj], hb = pts[hj + 1];
                var hdx = hb.x - ha.x, hdy = hb.y - ha.y;
                var hLen = Math.sqrt(hdx * hdx + hdy * hdy);
                if (hLen === 0) continue;
                var hNx = -hdy / hLen * csOffset, hNy = hdx / hLen * csOffset;
                var hSteps = Math.max(2, Math.floor(hLen / 4));
                for (var hs = 0; hs <= hSteps; hs++) {
                    var t = hs / hSteps;
                    var hpx = ha.x + hdx * t, hpy = ha.y + hdy * t;
                    var hc = flashMMToCanvas(hpx, hpy);
                    ctx.beginPath();
                    ctx.moveTo(hc.x, hc.y);
                    ctx.lineTo(hc.x + hNx, hc.y + hNy);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;

            // "COLOUR" marker at start of profile
            var csStart = flashMMToCanvas(pts[0].x, pts[0].y);
            var csDir = flashColourSide === 'top' ? -1 : 1;
            var csDotY = csStart.y + csDir * 14;
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(csStart.x, csDotY, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.font = 'bold 8px sans-serif';
            ctx.fillStyle = '#e74c3c';
            ctx.textAlign = 'left';
            ctx.fillText('COLOUR', csStart.x + 7, csDotY + 3);

            // Draw points
            for (var k = 0; k < pts.length; k++) {
                var pt = flashMMToCanvas(pts[k].x, pts[k].y);
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 3.5, 0, Math.PI * 2);
                ctx.fillStyle = k === flashSelectedIdx ? var_sw_orange() : '#293C46';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            if (!showDims) return;

            // Dimension labels on each leg
            for (var m = 0; m < pts.length - 1; m++) {
                var p1 = pts[m], p2 = pts[m + 1];
                var dx2 = p2.x - p1.x, dy2 = p2.y - p1.y;
                var legLen = Math.round(Math.sqrt(dx2 * dx2 + dy2 * dy2));
                var c1 = flashMMToCanvas(p1.x, p1.y);
                var c2 = flashMMToCanvas(p2.x, p2.y);
                var mx2 = (c1.x + c2.x) / 2, my2 = (c1.y + c2.y) / 2;

                // Background pill for readability
                ctx.font = 'bold 10px SF Mono, monospace';
                var tw = ctx.measureText(legLen + 'mm').width;
                ctx.fillStyle = 'rgba(255,255,255,0.85)';
                ctx.fillRect(mx2 - tw / 2 - 3, my2 - 14, tw + 6, 16);
                ctx.fillStyle = '#293C46';
                ctx.textAlign = 'center';
                ctx.fillText(legLen + 'mm', mx2, my2 - 2);
                ctx.textAlign = 'left';

                // Draw angle arc at each bend
                if (m > 0) {
                    var prev = pts[m - 1], curr = pts[m], next = pts[m + 1];
                    var ang = calcBendAngle(prev, curr, next);
                    drawAngleArc(ctx, curr, prev, next, ang);
                }
            }
        }

        function var_sw_orange() { return '#F15A29'; }

        function calcBendAngle(a, b, c) {
            var v1x = a.x - b.x, v1y = a.y - b.y;
            var v2x = c.x - b.x, v2y = c.y - b.y;
            var dot = v1x * v2x + v1y * v2y;
            var cross = v1x * v2y - v1y * v2x;
            var angle = Math.atan2(Math.abs(cross), dot) * 180 / Math.PI;
            return angle;
        }

        function drawAngleArc(ctx, point, prevPoint, nextPoint, includedAngle) {
            var cp = flashMMToCanvas(point.x, point.y);
            var pxPerMM = 20 / flashZoomLevel;
            var arcRadius = Math.max(18, Math.min(30, 25 * pxPerMM / 2));

            // Calculate angles of both legs from the bend point (in canvas space, y inverted)
            var pp = flashMMToCanvas(prevPoint.x, prevPoint.y);
            var np = flashMMToCanvas(nextPoint.x, nextPoint.y);
            var angle1 = Math.atan2(pp.y - cp.y, pp.x - cp.x);
            var angle2 = Math.atan2(np.y - cp.y, np.x - cp.x);

            // Determine the inside of the bend (shorter arc)
            var diff = angle2 - angle1;
            while (diff > Math.PI) diff -= 2 * Math.PI;
            while (diff < -Math.PI) diff += 2 * Math.PI;
            var counterclockwise = diff > 0;

            // Draw the arc on the inside of the bend
            ctx.beginPath();
            ctx.arc(cp.x, cp.y, arcRadius, angle1, angle2, counterclockwise);
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Small tick marks at arc endpoints
            var tickLen = 5;
            ctx.beginPath();
            ctx.moveTo(cp.x + Math.cos(angle1) * (arcRadius - tickLen), cp.y + Math.sin(angle1) * (arcRadius - tickLen));
            ctx.lineTo(cp.x + Math.cos(angle1) * (arcRadius + tickLen), cp.y + Math.sin(angle1) * (arcRadius + tickLen));
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cp.x + Math.cos(angle2) * (arcRadius - tickLen), cp.y + Math.sin(angle2) * (arcRadius - tickLen));
            ctx.lineTo(cp.x + Math.cos(angle2) * (arcRadius + tickLen), cp.y + Math.sin(angle2) * (arcRadius + tickLen));
            ctx.stroke();

            // Position label at midpoint of arc, slightly outside
            var midAngle;
            if (counterclockwise) {
                // Going from angle1 to angle2 counterclockwise (negative direction)
                var arcSpan = angle1 - angle2;
                while (arcSpan < 0) arcSpan += 2 * Math.PI;
                midAngle = angle1 - arcSpan / 2;
            } else {
                var arcSpan2 = angle2 - angle1;
                while (arcSpan2 < 0) arcSpan2 += 2 * Math.PI;
                midAngle = angle1 + arcSpan2 / 2;
            }
            var labelRadius = arcRadius + 14;
            var labelX = cp.x + Math.cos(midAngle) * labelRadius;
            var labelY = cp.y + Math.sin(midAngle) * labelRadius;

            var angText = Math.round(includedAngle) + '\u00B0';
            ctx.font = '10px SF Mono, monospace';
            var atw = ctx.measureText(angText).width;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillRect(labelX - atw / 2 - 2, labelY - 7, atw + 4, 14);
            ctx.fillStyle = '#555';
            ctx.textAlign = 'center';
            ctx.fillText(angText, labelX, labelY + 4);
            ctx.textAlign = 'left';
        }

        function calcGirth(pts) {
            var total = 0;
            for (var i = 0; i < pts.length - 1; i++) {
                var dx = pts[i + 1].x - pts[i].x;
                var dy = pts[i + 1].y - pts[i].y;
                total += Math.sqrt(dx * dx + dy * dy);
            }
            return Math.round(total);
        }

        function calcLegs(pts) {
            var legs = [];
            for (var i = 0; i < pts.length - 1; i++) {
                var dx = pts[i + 1].x - pts[i].x;
                var dy = pts[i + 1].y - pts[i].y;
                var len = Math.round(Math.sqrt(dx * dx + dy * dy));
                var angle = null;
                if (i < pts.length - 2) {
                    angle = Math.round(calcBendAngle(pts[i], pts[i + 1], pts[i + 2]));
                }
                legs.push({ length: len, angle: angle });
            }
            return legs;
        }

        function updateFlashInfo() {
            var gEl = document.getElementById('flashGirth');
            var lEl = document.getElementById('flashLegs');
            var zEl = document.getElementById('flashZoom');
            if (gEl) gEl.textContent = calcGirth(flashCurrentPoints);
            if (lEl) lEl.textContent = Math.max(0, flashCurrentPoints.length - 1);
            if (zEl) zEl.textContent = flashZoomLevel;
        }

        // ---- Mouse handlers ----
        function getFlashCanvasPos(e) {
            var canvas = document.getElementById('flashCanvas');
            var rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function flashFindNearPoint(canvasPos, threshold) {
            threshold = threshold || 10;
            for (var i = 0; i < flashCurrentPoints.length; i++) {
                var cp = flashMMToCanvas(flashCurrentPoints[i].x, flashCurrentPoints[i].y);
                var dx = cp.x - canvasPos.x, dy = cp.y - canvasPos.y;
                if (Math.sqrt(dx * dx + dy * dy) < threshold) return i;
            }
            return -1;
        }

        function flashMouseDown(e) {
            var pos = getFlashCanvasPos(e);
            var mm = flashCanvasToMM(pos.x, pos.y);
            var snapped = flashSnapToGrid(mm);

            if (e.button === 2 || e.button === 1 || flashTool === 'move') {
                // Pan
                flashDragging = true;
                flashDragStart = pos;
                flashPanStart = { x: flashPanOffset.x, y: flashPanOffset.y };
                return;
            }

            if (flashTool === 'select') {
                var idx = flashFindNearPoint(pos);
                if (idx >= 0) {
                    flashSelectedIdx = idx;
                    flashDragging = true;
                    flashDragStart = pos;
                } else {
                    flashSelectedIdx = -1;
                }
                drawFlashCanvas();
                return;
            }

            if (flashTool === 'draw') {
                // Apply angle constraint if shift
                if (flashSnapAngle && flashCurrentPoints.length > 0) {
                    snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
                }

                flashUndoStack.push(JSON.parse(JSON.stringify(flashCurrentPoints)));
                flashCurrentPoints.push({ x: snapped.x, y: snapped.y });
                flashDrawing = true;
                drawFlashCanvas();
            }
        }

        function flashMouseMove(e) {
            var pos = getFlashCanvasPos(e);
            var mm = flashCanvasToMM(pos.x, pos.y);
            var snapped = flashSnapToGrid(mm);

            if (flashDragging && (flashTool === 'move' || e.button === 2 || e.buttons === 2 || e.buttons === 4)) {
                flashPanOffset.x = flashPanStart.x + (pos.x - flashDragStart.x);
                flashPanOffset.y = flashPanStart.y + (pos.y - flashDragStart.y);
                drawFlashCanvas();
                return;
            }

            if (flashDragging && flashTool === 'select' && flashSelectedIdx >= 0) {
                if (flashSnapAngle && flashSelectedIdx > 0) {
                    snapped = constrainAngle(flashCurrentPoints[flashSelectedIdx - 1], snapped);
                }
                flashCurrentPoints[flashSelectedIdx] = { x: snapped.x, y: snapped.y };
                drawFlashCanvas();
                return;
            }

            if (flashSnapAngle && flashCurrentPoints.length > 0 && flashTool === 'draw') {
                snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
            }
            flashMouseMM = snapped;
            flashHoverPoint = flashFindNearPoint(pos);
            drawFlashCanvas();
        }

        function flashMouseUp(e) {
            flashDragging = false;
        }

        function flashDblClick(e) {
            if (flashTool === 'draw' && flashCurrentPoints.length >= 2) {
                flashDrawing = false;
                drawFlashCanvas();
            }
            if (flashTool === 'select' && flashSelectedIdx >= 0) {
                // Open inline dimension edit
                var val = prompt('Enter leg dimension (mm):', '');
                if (val && !isNaN(+val) && +val > 0 && flashSelectedIdx < flashCurrentPoints.length - 1) {
                    var p1 = flashCurrentPoints[flashSelectedIdx];
                    var p2 = flashCurrentPoints[flashSelectedIdx + 1];
                    var dx = p2.x - p1.x, dy = p2.y - p1.y;
                    var oldLen = Math.sqrt(dx * dx + dy * dy);
                    if (oldLen > 0) {
                        var factor = +val / oldLen;
                        flashUndoStack.push(JSON.parse(JSON.stringify(flashCurrentPoints)));
                        // Move all points from selectedIdx+1 onwards
                        var ux = dx / oldLen, uy = dy / oldLen;
                        var shift = +val - oldLen;
                        for (var si = flashSelectedIdx + 1; si < flashCurrentPoints.length; si++) {
                            flashCurrentPoints[si].x += ux * shift;
                            flashCurrentPoints[si].y += uy * shift;
                        }
                    }
                    drawFlashCanvas();
                }
            }
        }

        function flashWheel(e) {
            e.preventDefault();
            var zoomLevels = [2, 5, 10, 20, 50];
            var curIdx = zoomLevels.indexOf(flashZoomLevel);
            if (curIdx === -1) curIdx = 2;
            if (e.deltaY < 0) {
                // Zoom in (smaller mm per grid)
                if (curIdx > 0) flashZoomLevel = zoomLevels[curIdx - 1];
            } else {
                // Zoom out
                if (curIdx < zoomLevels.length - 1) flashZoomLevel = zoomLevels[curIdx + 1];
            }
            drawFlashCanvas();
        }

        function flashKeyDown(e) {
            // Only process if flashing section is visible
            var sec = document.getElementById('sec-flashings');
            if (!sec || sec.querySelector('.collapse-body.shut')) return;

            if (e.key === 'Shift') { flashSnapAngle = true; return; }
            if (e.type === 'keyup' && e.key === 'Shift') { flashSnapAngle = false; return; }

            if (e.key === 'Enter') {
                flashDrawing = false;
                drawFlashCanvas();
            }
            if (e.key === 'Escape') {
                if (flashDrawing && flashCurrentPoints.length > 0) {
                    flashCurrentPoints.pop();
                    if (flashCurrentPoints.length === 0) flashDrawing = false;
                    drawFlashCanvas();
                }
            }
            if (e.key === 'Delete' && flashSelectedIdx >= 0 && flashTool === 'select') {
                flashUndoStack.push(JSON.parse(JSON.stringify(flashCurrentPoints)));
                flashCurrentPoints.splice(flashSelectedIdx, 1);
                flashSelectedIdx = -1;
                drawFlashCanvas();
            }
            if (e.ctrlKey && e.key === 'z') {
                flashUndo();
                e.preventDefault();
            }
            if (e.key === 'h' || e.key === 'H') flashFlipH();
            if (e.key === 'v' || e.key === 'V') flashFlipV();
        }

        document.addEventListener('keyup', function(e) {
            if (e.key === 'Shift') flashSnapAngle = false;
        });

        function constrainAngle(from, to) {
            var dx = to.x - from.x;
            var dy = to.y - from.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return to;
            var angle = Math.atan2(dy, dx) * 180 / Math.PI;
            // Snap to nearest 45
            var snapAngles = [0, 45, 90, 135, 180, -45, -90, -135, -180];
            var closest = 0, minDiff = 999;
            snapAngles.forEach(function(sa) {
                var diff = Math.abs(angle - sa);
                if (diff < minDiff) { minDiff = diff; closest = sa; }
            });
            // Also snap near 90 (within ±5°)
            if (Math.abs(angle - 90) <= 5) closest = 90;
            if (Math.abs(angle + 90) <= 5) closest = -90;
            if (Math.abs(angle) <= 5) closest = 0;
            if (Math.abs(Math.abs(angle) - 180) <= 5) closest = angle > 0 ? 180 : -180;

            var rad = closest * Math.PI / 180;
            var snappedDist = Math.round(dist / flashZoomLevel) * flashZoomLevel;
            if (snappedDist === 0) snappedDist = flashZoomLevel;
            return {
                x: from.x + Math.round(Math.cos(rad) * snappedDist),
                y: from.y + Math.round(Math.sin(rad) * snappedDist)
            };
        }

        // ---- Tool actions ----
        function setFlashTool(tool, btn) {
            flashTool = tool;
            document.querySelectorAll('.flash-tool-btn[data-tool]').forEach(function(b) { b.classList.remove('active'); });
            if (btn) btn.classList.add('active');
            var canvas = document.getElementById('flashCanvas');
            if (canvas) {
                canvas.className = tool === 'move' ? 'mode-move' : '';
            }
        }

        function setColourSide(side, btn) {
            flashColourSide = side;
            document.querySelectorAll('.flash-cs-btn').forEach(function(b) { b.classList.remove('active'); });
            if (btn) btn.classList.add('active');
            drawFlashCanvas();
        }

        function flashFlipH() {
            if (flashCurrentPoints.length < 2) return;
            flashUndoStack.push(JSON.parse(JSON.stringify(flashCurrentPoints)));
            var minX = Infinity, maxX = -Infinity;
            flashCurrentPoints.forEach(function(p) { if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x; });
            var cx = (minX + maxX) / 2;
            flashCurrentPoints.forEach(function(p) { p.x = 2 * cx - p.x; });
            drawFlashCanvas();
        }

        function flashFlipV() {
            if (flashCurrentPoints.length < 2) return;
            flashUndoStack.push(JSON.parse(JSON.stringify(flashCurrentPoints)));
            var minY = Infinity, maxY = -Infinity;
            flashCurrentPoints.forEach(function(p) { if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y; });
            var cy = (minY + maxY) / 2;
            flashCurrentPoints.forEach(function(p) { p.y = 2 * cy - p.y; });
            drawFlashCanvas();
        }

        function flashUndo() {
            if (flashUndoStack.length === 0) return;
            flashCurrentPoints = flashUndoStack.pop();
            drawFlashCanvas();
        }

        function flashClear() {
            flashUndoStack.push(JSON.parse(JSON.stringify(flashCurrentPoints)));
            flashCurrentPoints = [];
            flashDrawing = false;
            flashSelectedIdx = -1;
            flashEditingId = null;
            flashStartTreatment = null;
            flashEndTreatment = null;
            var stSel = document.getElementById('flashStartTreat');
            var enSel = document.getElementById('flashEndTreat');
            if (stSel) stSel.value = 'none';
            if (enSel) enSel.value = 'none';
            document.getElementById('flashTreatOpts').style.display = 'none';
            drawFlashCanvas();
        }

        // ---- End Treatment functions ----
        function updateFlashTreatment(which) {
            var sel = document.getElementById(which === 'start' ? 'flashStartTreat' : 'flashEndTreat');
            var val = sel.value;
            var treatment = null;
            if (val === 'miniBreak') {
                var size = parseInt(document.getElementById('flashTreatSize').value) || 10;
                var angle = parseInt(document.getElementById('flashTreatAngle').value) || 45;
                var dirOut = document.getElementById('flashTreatDirOut').classList.contains('active');
                treatment = { type: 'miniBreak', size: size, angle: angle, direction: dirOut ? 'out' : 'in' };
            } else if (val === 'hem') {
                treatment = { type: 'hem' };
            }
            if (which === 'start') flashStartTreatment = treatment;
            else flashEndTreatment = treatment;

            // Show/hide treatment options
            var hasMiniBrk = document.getElementById('flashStartTreat').value === 'miniBreak' || document.getElementById('flashEndTreat').value === 'miniBreak';
            document.getElementById('flashTreatOpts').style.display = hasMiniBrk ? 'flex' : 'none';
            drawFlashCanvas();
        }

        function setTreatDir(dir) {
            document.getElementById('flashTreatDirOut').classList.toggle('active', dir === 'out');
            document.getElementById('flashTreatDirIn').classList.toggle('active', dir === 'in');
            // Re-apply to whichever treatments are miniBreak
            if (flashStartTreatment && flashStartTreatment.type === 'miniBreak') flashStartTreatment.direction = dir;
            if (flashEndTreatment && flashEndTreatment.type === 'miniBreak') flashEndTreatment.direction = dir;
            drawFlashCanvas();
        }

        function drawEndTreatment(ctx, pts, treatment, isStart) {
            if (!treatment || pts.length < 2) return;
            var idx, prevIdx;
            if (isStart) { idx = 0; prevIdx = 1; }
            else { idx = pts.length - 1; prevIdx = pts.length - 2; }

            var pt = flashMMToCanvas(pts[idx].x, pts[idx].y);
            var prev = flashMMToCanvas(pts[prevIdx].x, pts[prevIdx].y);

            // Direction along the leg toward the end
            var dx = pt.x - prev.x, dy = pt.y - prev.y;
            var len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) return;
            var ux = dx / len, uy = dy / len; // unit vector along leg toward endpoint
            // Normal (perpendicular)
            var nx = -uy, ny = ux;

            var pxPerMM = 20 / flashZoomLevel;

            if (treatment.type === 'miniBreak') {
                var sz = (treatment.size || 10) * pxPerMM;
                var ang = (treatment.angle || 45) * Math.PI / 180;
                var dirSign = treatment.direction === 'in' ? -1 : 1;
                // Kick goes outward from the endpoint at the given angle
                var kickX = pt.x + (ux * Math.cos(ang) + nx * dirSign * Math.sin(ang)) * sz;
                var kickY = pt.y + (uy * Math.cos(ang) + ny * dirSign * Math.sin(ang)) * sz;

                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y);
                ctx.lineTo(kickX, kickY);
                ctx.strokeStyle = '#293C46';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                var lblX = (pt.x + kickX) / 2 + nx * dirSign * 10;
                var lblY = (pt.y + kickY) / 2 + ny * dirSign * 10;
                ctx.font = '8px SF Mono, monospace';
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.fillText('MB ' + (treatment.size || 10), lblX, lblY);
                ctx.textAlign = 'left';
            } else if (treatment.type === 'hem') {
                // Draw small U-loop at the end
                var hemSize = 6 * pxPerMM;
                var csDir = flashColourSide === 'top' ? -1 : 1;
                // Hem folds back on itself
                var hemEnd = { x: pt.x - ux * hemSize, y: pt.y - uy * hemSize };
                var hemMid = { x: pt.x + nx * csDir * hemSize * 0.5, y: pt.y + ny * csDir * hemSize * 0.5 };

                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y);
                ctx.quadraticCurveTo(hemMid.x + ux * hemSize * 0.3, hemMid.y + uy * hemSize * 0.3, hemEnd.x + nx * csDir * hemSize * 0.3, hemEnd.y + ny * csDir * hemSize * 0.3);
                ctx.strokeStyle = '#293C46';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.font = '8px SF Mono, monospace';
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.fillText('HEM', pt.x + nx * csDir * 14, pt.y + ny * csDir * 14);
                ctx.textAlign = 'left';
            }
        }

        // ---- Templates ----
        function getTemplateFolderState() {
            try { return JSON.parse(localStorage.getItem('flashFolderState') || '{}'); } catch(e) { return {}; }
        }
        function saveTemplateFolderState(state) {
            localStorage.setItem('flashFolderState', JSON.stringify(state));
        }
        function toggleTemplateFolder(folderId) {
            var state = getTemplateFolderState();
            state[folderId] = !state[folderId]; // true = collapsed
            saveTemplateFolderState(state);
            var contents = document.getElementById('folder-' + folderId);
            var icon = document.getElementById('ficon-' + folderId);
            if (contents) contents.classList.toggle('collapsed', state[folderId]);
            if (icon) icon.textContent = state[folderId] ? '\uD83D\uDCC1' : '\uD83D\uDCC2';
        }

        function renderFlashTemplates() {
            var container = document.getElementById('flashTemplates');
            if (!container) return;
            container.innerHTML = '';
            var folderState = getTemplateFolderState();

            // Group templates by folder
            var folders = {};
            var folderOrder = ['Standard', 'SolarSpan 50mm', 'SolarSpan 75mm', 'SolarSpan 100mm', 'Gable Details', 'Skillion Details'];
            flashingTemplates.forEach(function(tpl, idx) {
                var f = tpl.folder || 'Standard';
                if (!folders[f]) folders[f] = [];
                folders[f].push({ tpl: tpl, idx: idx });
            });

            // Render each folder
            folderOrder.forEach(function(folderName) {
                var items = folders[folderName];
                if (!items || items.length === 0) return;
                var fid = folderName.replace(/\s+/g, '-').toLowerCase();
                var isCollapsed = folderState[fid] || false;

                var folderDiv = document.createElement('div');
                folderDiv.className = 'template-folder';

                var header = document.createElement('div');
                header.className = 'folder-header';
                header.onclick = function() { toggleTemplateFolder(fid); };
                header.innerHTML = '<span class="folder-icon" id="ficon-' + fid + '">' + (isCollapsed ? '\uD83D\uDCC1' : '\uD83D\uDCC2') + '</span> ' + folderName;
                folderDiv.appendChild(header);

                var contents = document.createElement('div');
                contents.className = 'folder-contents' + (isCollapsed ? ' collapsed' : '');
                contents.id = 'folder-' + fid;

                items.forEach(function(item) {
                    var div = document.createElement('div');
                    div.className = 'flash-tpl';
                    div.onclick = function() { loadFlashTemplate(item.idx); };
                    var cvs = document.createElement('canvas');
                    cvs.width = 56; cvs.height = 34;
                    drawMiniProfile(cvs, item.tpl.points);
                    div.appendChild(cvs);
                    var nm = document.createElement('div');
                    nm.className = 'flash-tpl-name';
                    nm.textContent = item.tpl.name;
                    div.appendChild(nm);
                    contents.appendChild(div);
                });

                folderDiv.appendChild(contents);
                container.appendChild(folderDiv);
            });

            // Any custom/uncategorized templates
            var uncategorized = [];
            flashingTemplates.forEach(function(tpl, idx) {
                if (!tpl.folder || folderOrder.indexOf(tpl.folder) === -1) {
                    if (!folders['Standard'] || !folders['Standard'].find(function(i) { return i.idx === idx; })) {
                        uncategorized.push({ tpl: tpl, idx: idx });
                    }
                }
            });

            // Save new template button
            var saveDiv = document.createElement('div');
            saveDiv.style.padding = '4px 0';
            var saveBtn = document.createElement('div');
            saveBtn.className = 'flash-tpl';
            saveBtn.style.borderStyle = 'dashed';
            saveBtn.style.cursor = 'pointer';
            saveBtn.style.display = 'inline-block';
            saveBtn.onclick = saveFlashTemplate;
            saveBtn.innerHTML = '<div style="font-size:18px;color:var(--sw-text-sec);margin:4px 0">+</div><div class="flash-tpl-name">Save New</div>';
            saveDiv.appendChild(saveBtn);
            container.appendChild(saveDiv);
        }

        function drawMiniProfile(cvs, pts) {
            if (!pts || pts.length < 2) return;
            var ctx = cvs.getContext('2d');
            var w = cvs.width, h = cvs.height;
            var pad = 6;

            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            pts.forEach(function(p) {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
            });
            var rangeX = maxX - minX || 1;
            var rangeY = maxY - minY || 1;
            var scale = Math.min((w - pad * 2) / rangeX, (h - pad * 2) / rangeY);
            var ox = (w - rangeX * scale) / 2;
            var oy = (h - rangeY * scale) / 2;

            ctx.strokeStyle = '#293C46';
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            pts.forEach(function(p, i) {
                var px = ox + (p.x - minX) * scale;
                var py = oy + (maxY - p.y) * scale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();
        }

        function loadFlashTemplate(idx) {
            if (idx < 0 || idx >= flashingTemplates.length) return;
            var tpl = flashingTemplates[idx];
            flashCurrentPoints = JSON.parse(JSON.stringify(tpl.points));
            flashColourSide = tpl.colourSide || 'top';
            flashDrawing = false;
            flashEditingId = null;
            flashUndoStack = [];

            // Update colour side buttons
            document.querySelectorAll('.flash-cs-btn').forEach(function(b) {
                b.classList.toggle('active', b.dataset.cs === flashColourSide);
            });

            // Update template active state
            document.querySelectorAll('.flash-tpl').forEach(function(t, i) {
                t.classList.toggle('active', i === idx);
            });

            // Center view on profile
            centerFlashView();
            drawFlashCanvas();
        }

        function centerFlashView() {
            if (flashCurrentPoints.length === 0) {
                flashPanOffset = { x: 0, y: 0 };
                return;
            }
            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            flashCurrentPoints.forEach(function(p) {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
            });
            var cx = (minX + maxX) / 2;
            var cy = (minY + maxY) / 2;
            var pxPerMM = 20 / flashZoomLevel;
            flashPanOffset = { x: -cx * pxPerMM, y: cy * pxPerMM };
        }

        function saveFlashTemplate() {
            if (flashCurrentPoints.length < 2) { alert('Draw a profile first before saving as template.'); return; }
            var name = prompt('Template name:', document.getElementById('flashName').value || 'Custom');
            if (!name) return;
            flashingTemplates.push({
                name: name,
                points: JSON.parse(JSON.stringify(flashCurrentPoints)),
                colourSide: flashColourSide
            });
            localStorage.setItem('flashingTemplates', JSON.stringify(flashingTemplates));
            renderFlashTemplates();
        }

        // ---- Job flashings list ----
        function flashAddToJob() {
            if (flashCurrentPoints.length < 2) { alert('Draw a profile first.'); return; }
            var name = document.getElementById('flashName').value.trim() || 'Unnamed Flashing';
            var colour = document.getElementById('flashColour').value;
            var gauge = parseFloat(document.getElementById('flashGauge').value) || 0.42;
            var length = parseInt(document.getElementById('flashLength').value) || 3000;
            var qty = parseInt(document.getElementById('flashQty').value) || 1;
            var girth = calcGirth(flashCurrentPoints);
            var legs = calcLegs(flashCurrentPoints);

            if (flashEditingId) {
                // Update existing
                var existing = flashingProfiles.find(function(p) { return p.id === flashEditingId; });
                if (existing) {
                    existing.name = name;
                    existing.colour = colour;
                    existing.gauge = gauge;
                    existing.length = length;
                    existing.qty = qty;
                    existing.colourSide = flashColourSide;
                    existing.points = JSON.parse(JSON.stringify(flashCurrentPoints));
                    existing.girth = girth;
                    existing.legs = legs;
                    existing.startTreatment = flashStartTreatment ? JSON.parse(JSON.stringify(flashStartTreatment)) : null;
                    existing.endTreatment = flashEndTreatment ? JSON.parse(JSON.stringify(flashEndTreatment)) : null;
                }
                flashEditingId = null;
            } else {
                flashingProfiles.push({
                    id: 'flashing_' + String(flashNextId++).padStart(3, '0'),
                    name: name,
                    colour: colour,
                    gauge: gauge,
                    length: length,
                    qty: qty,
                    colourSide: flashColourSide,
                    points: JSON.parse(JSON.stringify(flashCurrentPoints)),
                    girth: girth,
                    legs: legs,
                    startTreatment: flashStartTreatment ? JSON.parse(JSON.stringify(flashStartTreatment)) : null,
                    endTreatment: flashEndTreatment ? JSON.parse(JSON.stringify(flashEndTreatment)) : null
                });
            }

            renderFlashJobTable();
            // Reset for next
            flashClear();
            document.getElementById('flashName').value = '';
            document.getElementById('flashLength').value = '4500';
            document.getElementById('flashQty').value = '1';
        }

        function renderFlashJobTable() {
            var tbody = document.getElementById('flashJobBody');
            var totalRow = document.getElementById('flashTotalRow');
            var totalArea = document.getElementById('flashTotalArea');
            if (!tbody) return;

            if (flashingProfiles.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align:center;color:var(--sw-text-sec);padding:16px;font-size:12px">No flashings added yet. Draw a profile above and click "+ Add to Job".</td></tr>';
                if (totalRow) totalRow.style.display = 'none';
                return;
            }

            var totalSqm = 0;
            tbody.innerHTML = flashingProfiles.map(function(p, i) {
                var area = (p.girth / 1000) * (p.length / 1000) * p.qty;
                totalSqm += area;
                return '<tr class="' + (flashEditingId === p.id ? 'selected' : '') + '">' +
                    '<td class="mono">' + (i + 1) + '</td>' +
                    '<td>' + esc(p.name) + '</td>' +
                    '<td class="r mono">' + p.girth + 'mm</td>' +
                    '<td class="r mono">' + p.length + 'mm<br><span style="font-size:9px;color:var(--sw-text-sec)" title="Order length includes +500mm allowance">order: ' + (p.length + 500) + '</span></td>' +
                    '<td class="r mono">' + p.qty + '</td>' +
                    '<td>' + esc(p.colour) + '</td>' +
                    '<td class="mono">' + p.gauge + 'mm</td>' +
                    '<td style="text-transform:uppercase;font-size:10px">' + p.colourSide + '</td>' +
                    '<td><div class="flash-row-actions">' +
                        '<button class="flash-row-btn" onclick="flashEditRow(' + i + ')" title="Edit">&#9998;</button>' +
                        '<button class="flash-row-btn" onclick="flashDupeRow(' + i + ')" title="Duplicate">&#10697;</button>' +
                        '<button class="flash-row-btn del" onclick="flashDeleteRow(' + i + ')" title="Delete">&times;</button>' +
                    '</div></td>' +
                '</tr>';
            }).join('');

            if (totalRow) {
                totalRow.style.display = '';
                if (totalArea) totalArea.textContent = totalSqm.toFixed(2);
            }
        }

        function esc(str) {
            var div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function flashEditRow(idx) {
            if (idx < 0 || idx >= flashingProfiles.length) return;
            var p = flashingProfiles[idx];
            flashEditingId = p.id;
            flashCurrentPoints = JSON.parse(JSON.stringify(p.points));
            flashColourSide = p.colourSide;
            flashDrawing = false;

            // Restore end treatments
            flashStartTreatment = p.startTreatment ? JSON.parse(JSON.stringify(p.startTreatment)) : null;
            flashEndTreatment = p.endTreatment ? JSON.parse(JSON.stringify(p.endTreatment)) : null;
            var stSel = document.getElementById('flashStartTreat');
            var enSel = document.getElementById('flashEndTreat');
            if (stSel) stSel.value = flashStartTreatment ? flashStartTreatment.type : 'none';
            if (enSel) enSel.value = flashEndTreatment ? flashEndTreatment.type : 'none';
            var hasMiniBrk = (flashStartTreatment && flashStartTreatment.type === 'miniBreak') || (flashEndTreatment && flashEndTreatment.type === 'miniBreak');
            document.getElementById('flashTreatOpts').style.display = hasMiniBrk ? 'flex' : 'none';
            if (hasMiniBrk) {
                var mb = (flashStartTreatment && flashStartTreatment.type === 'miniBreak') ? flashStartTreatment : flashEndTreatment;
                document.getElementById('flashTreatSize').value = mb.size || 10;
                document.getElementById('flashTreatAngle').value = mb.angle || 45;
                document.getElementById('flashTreatDirOut').classList.toggle('active', mb.direction === 'out');
                document.getElementById('flashTreatDirIn').classList.toggle('active', mb.direction === 'in');
            }

            document.getElementById('flashName').value = p.name;
            document.getElementById('flashColour').value = p.colour;
            document.getElementById('flashGauge').value = p.gauge;
            document.getElementById('flashLength').value = p.length;
            document.getElementById('flashQty').value = p.qty;

            document.querySelectorAll('.flash-cs-btn').forEach(function(b) {
                b.classList.toggle('active', b.dataset.cs === flashColourSide);
            });

            centerFlashView();
            drawFlashCanvas();
            renderFlashJobTable();
        }

        function flashDupeRow(idx) {
            if (idx < 0 || idx >= flashingProfiles.length) return;
            var orig = flashingProfiles[idx];
            var dupe = JSON.parse(JSON.stringify(orig));
            dupe.id = 'flashing_' + String(flashNextId++).padStart(3, '0');
            dupe.name = orig.name + ' (copy)';
            flashingProfiles.splice(idx + 1, 0, dupe);
            renderFlashJobTable();
        }

        function flashDeleteRow(idx) {
            if (idx < 0 || idx >= flashingProfiles.length) return;
            flashingProfiles.splice(idx, 1);
            if (flashEditingId && !flashingProfiles.find(function(p) { return p.id === flashEditingId; })) {
                flashEditingId = null;
            }
            renderFlashJobTable();
        }

        // ==================== EXPORT / IMPORT JOB DATA ====================
        function gatherJobData() {
            const c = calc;
            return {
                _version: 'PatioDesignerPro_V18',
                _exported: new Date().toISOString(),
                client: {
                    jobRef: (document.getElementById('jobRef')?.value || '').trim(),
                    name: (document.getElementById('clientName')?.value || '').trim(),
                    address: (document.getElementById('siteAddress')?.value || '').trim(),
                    phone: (document.getElementById('clientPhone')?.value || '').trim(),
                    email: (document.getElementById('clientEmail')?.value || '').trim(),
                    salesperson: (document.getElementById('salesperson')?.value || '')
                },
                config: {
                    roofStyle: document.getElementById('inRoofStyle')?.value,
                    orientation: document.getElementById('inOrientation')?.value,
                    projection: document.getElementById('inWidth')?.value,
                    length: document.getElementById('inLength')?.value,
                    pitch: document.getElementById('inPitch')?.value,
                    postHeight: document.getElementById('inPostHeight')?.value,
                    posts: document.getElementById('inPosts')?.value,
                    trusses: document.getElementById('inTrusses')?.value,
                    rafters: document.getElementById('inRafters')?.value,
                    roofing: document.getElementById('inRoofing')?.value,
                    infill: document.getElementById('inInfill')?.value,
                    connection: document.getElementById('inConnection')?.value,
                    fasciaHeight: document.getElementById('inFasciaHeight')?.value,
                    riserHeight: document.getElementById('inRiserHeight')?.value,
                    riserOffset: document.getElementById('inRiserOffset')?.value,
                    riserQty: document.getElementById('inRiserQty')?.value,
                    houseGutter: document.getElementById('inHouseGutter')?.value,
                    riserGutter: document.getElementById('inRiserGutter')?.value,
                    postFix: document.getElementById('inPostFix')?.value,
                    postSize: document.getElementById('inPostSize')?.value,
                    beamSize: document.getElementById('inBeamSize')?.value,
                    trussBase: document.getElementById('inTrussBase')?.value,
                    trussChord: document.getElementById('inTrussChord')?.value,
                    trussSteel: document.getElementById('inTrussSteel')?.value,
                    overhang: document.getElementById('inOverhang')?.value,
                    trussRiserLeft: {
                        enabled: document.getElementById('trussRiserOn')?.checked || false,
                        length: document.getElementById('riserLH')?.value || '200',
                        height: document.getElementById('riserLV')?.value || '150'
                    },
                    trussRiserRight: {
                        enabled: document.getElementById('trussRiserOn')?.checked || false,
                        length: document.getElementById('riserRH')?.value || '200',
                        height: document.getElementById('riserRV')?.value || '150'
                    },
                    trussRiserLocked: document.getElementById('trussRiserLock')?.checked || true,
                    trussExtender: {
                        enabled: document.getElementById('trussExtOn')?.checked || false,
                        length: document.getElementById('trussExtLen')?.value || '300'
                    },
                    sheetColor: sheetColor.name,
                    steelColor: steelColor.name,
                    polycarbEnabled: isPolycarbEnabled(),
                    polycarbBrand: document.getElementById('inPolycarbBrand')?.value,
                    polycarbTint: document.getElementById('inPolycarbTint')?.value,
                    polycarbPattern: document.getElementById('inPolycarbPattern')?.value,
                    polycarbCustom: document.getElementById('inPolycarbCustom')?.value,
                    ceilingFinish: document.getElementById('inCeilingFinish')?.value
                },
                extras: {
                    demo: document.getElementById('extraDemo')?.value || 'no',
                    demoCost: document.getElementById('extraDemoCost')?.value || '',
                    removal: document.getElementById('extraRemoval')?.value || 'no',
                    removalCost: document.getElementById('extraRemovalCost')?.value || '',
                    electrical: document.getElementById('extraElectrical')?.value || 'no',
                    electricalCost: document.getElementById('extraElectricalCost')?.value || '',
                    downlights: document.getElementById('extraDownlights')?.value || '0'
                },
                allowances: {
                    gutter: document.getElementById('allowGutter')?.value || '800',
                    flashings: document.getElementById('allowFlashings')?.value || '400'
                },
                pricing: {
                    addonRows: jobRows.filter(r => r.isAddon),
                    extrasRows: extrasRows,
                    labour: {
                        trades: document.getElementById('labTrades')?.value,
                        days: document.getElementById('labDays')?.value,
                        dayRate: document.getElementById('labDayRate')?.value,
                        sell: document.getElementById('labSellInput')?.value
                    }
                },
                complexity: {
                    build: document.getElementById('cxBuild')?.value,
                    access: document.getElementById('cxAccess')?.value,
                    distance: document.getElementById('cxDistance')?.value,
                    footing: document.getElementById('cxFooting')?.value,
                    height: document.getElementById('cxHeight')?.value
                },
                notes: {
                    jobNotes: (document.getElementById('jobNotes')?.value || '').trim(),
                    pricingNotes: (document.getElementById('pricingNotes')?.value || '').trim()
                },
                flashings: flashingProfiles.map(function(p) {
                    return { id: p.id, name: p.name, colour: p.colour, gauge: p.gauge, length: p.length, qty: p.qty, colourSide: p.colourSide, points: p.points, girth: p.girth, legs: p.legs, startTreatment: p.startTreatment || null, endTreatment: p.endTreatment || null };
                })
            };
        }

        function exportJobData() {
            const data = gatherJobData();
            const json = JSON.stringify(data, null, 2);

            // Copy to clipboard
            navigator.clipboard.writeText(json).then(() => {
                alert('Job data copied to clipboard!\n\nPaste this into GHL notes, email, or save as a file to reload later.');
            }).catch(() => {
                // Fallback: download as file
                downloadJobJSON(json, data.client.jobRef);
            });
        }

        function saveJobData() {
            var base = gatherJobData();
            var jobData = {
                version: '1.0',
                savedAt: new Date().toISOString(),
                customer: customer,
                siteDetails: siteDetails,
                client: base.client,
                config: base.config,
                pricing: base.pricing,
                complexity: base.complexity,
                notes: base.notes,
                specs: {
                    roofType: base.config.roofStyle,
                    width: base.config.length,
                    projection: base.config.projection,
                    height: base.config.postHeight,
                    pitch: base.config.pitch,
                    roofMaterial: base.config.roofing,
                    attachmentType: base.config.connection,
                    roofColour: base.config.sheetColor,
                    frameColour: base.config.steelColor
                },
                truss: {
                    base: base.config.trussBase,
                    chord: base.config.trussChord,
                    steel: base.config.trussSteel,
                    overhang: base.config.overhang,
                    riserLeft: base.config.trussRiserLeft,
                    riserRight: base.config.trussRiserRight,
                    riserLocked: base.config.trussRiserLocked,
                    extender: base.config.trussExtender
                },
                polycarb: {
                    enabled: base.config.polycarbEnabled,
                    brand: base.config.polycarbBrand,
                    tint: base.config.polycarbTint,
                    pattern: base.config.polycarbPattern,
                    custom: base.config.polycarbCustom
                },
                flashings: flashingProfiles.map(function(p) {
                    return { id: p.id, name: p.name, colour: p.colour, gauge: p.gauge, length: p.length, qty: p.qty, colourSide: p.colourSide, points: p.points, girth: p.girth, legs: p.legs, startTreatment: p.startTreatment || null, endTreatment: p.endTreatment || null };
                })
            };
            var json = JSON.stringify(jobData, null, 2);

            navigator.clipboard.writeText(json).then(function() {
                localStorage.setItem('patio-job-' + Date.now(), json);
                alert('Job data copied to clipboard! Paste into GHL notes.');
            }).catch(function() {
                localStorage.setItem('patio-job-' + Date.now(), json);
                alert('Job data saved locally. Clipboard access was blocked.');
            });
        }

        function showLoadJobModal() {
            document.getElementById('loadJobTextarea').value = '';
            document.getElementById('loadJobStatus').textContent = '';
            document.getElementById('loadJobModal').style.display = '';
        }

        function closeLoadJobModal() {
            document.getElementById('loadJobModal').style.display = 'none';
        }

        function loadJobData() {
            var raw = document.getElementById('loadJobTextarea').value.trim();
            var statusEl = document.getElementById('loadJobStatus');
            if (!raw) { statusEl.textContent = 'Please paste JSON data first.'; statusEl.style.color = '#FF3B30'; return; }

            var data;
            try {
                data = JSON.parse(raw);
            } catch(e) {
                statusEl.textContent = 'Invalid JSON. Please check and try again.';
                statusEl.style.color = '#FF3B30';
                return;
            }

            // Restore customer state + DOM
            if (data.customer) {
                customer = { name: data.customer.name || '', address: data.customer.address || '', phone: data.customer.phone || '' };
                document.getElementById('customerName').value = customer.name;
                document.getElementById('customerAddress').value = customer.address;
                document.getElementById('customerPhone').value = customer.phone;
            }

            // Restore siteDetails state + DOM
            if (data.siteDetails) {
                var sd = data.siteDetails;
                siteDetails = {
                    gutterProfile: sd.gutterProfile || 'unknown',
                    gutterManufacturer: sd.gutterManufacturer || 'unknown',
                    fasciaCondition: sd.fasciaCondition || 'unknown',
                    siteAccess: sd.siteAccess || 'unknown',
                    electrical: sd.electrical || 'tbd',
                    demo: sd.demo || 'tbd',
                    notes: sd.notes || ''
                };
                var setRadio = function(name, val) {
                    var el = document.querySelector('input[name="' + name + '"][value="' + val + '"]');
                    if (el) el.checked = true;
                };
                setRadio('gutterProfile', siteDetails.gutterProfile);
                setRadio('gutterManufacturer', siteDetails.gutterManufacturer);
                setRadio('fasciaCondition', siteDetails.fasciaCondition);
                setRadio('siteAccess', siteDetails.siteAccess);
                setRadio('electrical', siteDetails.electrical);
                setRadio('demo', siteDetails.demo);
                document.getElementById('siteNotes').value = siteDetails.notes;
            }

            // Restore client info (from existing format)
            if (data.client) {
                var cl = data.client;
                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                if (cl.name) { document.getElementById('clientName').value = cl.name; if (!data.customer || !data.customer.name) document.getElementById('customerName').value = cl.name; }
                if (cl.address) { document.getElementById('siteAddress').value = cl.address; if (!data.customer || !data.customer.address) document.getElementById('customerAddress').value = cl.address; }
                if (cl.phone) { document.getElementById('clientPhone').value = cl.phone; if (!data.customer || !data.customer.phone) document.getElementById('customerPhone').value = cl.phone; }
                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                if (cl.salesperson) document.getElementById('salesperson').value = cl.salesperson;
            }

            // Restore specs → config inputs
            var cfg = data.config || {};
            var specs = data.specs || {};
            var setVal = function(id, val) { var el = document.getElementById(id); if (el && val != null) el.value = val; };
            setVal('inRoofStyle', specs.roofType || cfg.roofStyle);
            setVal('inOrientation', cfg.orientation);
            // Convert legacy mm values to m for dimension inputs
            var projVal = specs.projection || cfg.projection;
            var lenVal = specs.width || cfg.length;
            var heightVal = specs.height || cfg.postHeight;
            if (projVal && parseFloat(projVal) > 100) projVal = (parseFloat(projVal) / 1000).toFixed(1);
            if (lenVal && parseFloat(lenVal) > 100) lenVal = (parseFloat(lenVal) / 1000).toFixed(1);
            if (heightVal && parseFloat(heightVal) > 100) heightVal = (parseFloat(heightVal) / 1000).toFixed(1);
            setVal('inWidth', projVal);
            setVal('inLength', lenVal);
            setVal('inPitch', specs.pitch || cfg.pitch);
            setVal('inPostHeight', heightVal);
            setVal('inPosts', cfg.posts);
            setVal('inTrusses', cfg.trusses);
            setVal('inRafters', cfg.rafters);
            // Convert legacy 'insulated' to 'solarspan75'
            var roofVal = specs.roofMaterial || cfg.roofing;
            if (roofVal === 'insulated') roofVal = 'solarspan75';
            setVal('inRoofing', roofVal);
            setVal('inInfill', cfg.infill);
            // Convert legacy 'fasciabeam' to 'riser'
            var connVal = specs.attachmentType || cfg.connection;
            if (connVal === 'fasciabeam') connVal = 'riser';
            setVal('inConnection', connVal);
            setVal('inFasciaHeight', cfg.fasciaHeight);
            setVal('inRiserHeight', cfg.riserHeight);
            setVal('inRiserOffset', cfg.riserOffset);
            setVal('inRiserQty', cfg.riserQty);
            setVal('inHouseGutter', cfg.houseGutter);
            setVal('inRiserGutter', cfg.riserGutter);
            setVal('inPostFix', cfg.postFix);
            setVal('inPostSize', cfg.postSize || '90x90');
            setVal('inBeamSize', cfg.beamSize || '100x50');
            setVal('inCeilingFinish', cfg.ceilingFinish);

            // Truss
            var truss = data.truss || {};
            // Legacy: map old trussStyle values to new trussBase
            const legacyBase = cfg.trussStyle === 'king' ? 'kingpost' : (cfg.trussStyle === 'queen' ? 'kingpost' : cfg.trussStyle);
            setVal('inTrussBase', truss.base || cfg.trussBase || legacyBase || 'kingpost');
            setVal('inTrussChord', truss.chord || cfg.trussChord || 'bottom');
            setVal('inTrussSteel', truss.steel || cfg.trussSteel);
            setVal('inOverhang', truss.overhang || cfg.overhang);

            // Truss options: extender + risers (L/R)
            const tExtender = truss.extender || cfg.trussExtender || {};
            const tRiserL = truss.riserLeft || cfg.trussRiserLeft || {};
            const tRiserR = truss.riserRight || cfg.trussRiserRight || {};
            // Legacy: migrate old riser/dogleg data
            const legacyRiser = truss.riser || cfg.trussRiser || {};
            if (tExtender.enabled) {
                document.getElementById('trussExtOn').checked = true;
                setVal('trussExtLen', tExtender.length || '300');
            }
            if (tRiserL.enabled || tRiserR.enabled || legacyRiser.enabled) {
                document.getElementById('trussRiserOn').checked = true;
                setVal('riserLH', tRiserL.length || legacyRiser.rx || '200');
                setVal('riserLV', tRiserL.height || legacyRiser.ry || '150');
                setVal('riserRH', tRiserR.length || legacyRiser.rx || '200');
                setVal('riserRV', tRiserR.height || legacyRiser.ry || '150');
            }
            if (truss.riserLocked !== undefined || cfg.trussRiserLocked !== undefined) {
                document.getElementById('trussRiserLock').checked = truss.riserLocked !== false && cfg.trussRiserLocked !== false;
            }
            toggleTrussOpt();

            // Extras & Allowances
            if (data.extras) {
                setVal('extraDemo', data.extras.demo);
                setVal('extraDemoCost', data.extras.demoCost);
                setVal('extraRemoval', data.extras.removal);
                setVal('extraRemovalCost', data.extras.removalCost);
                setVal('extraElectrical', data.extras.electrical);
                setVal('extraElectricalCost', data.extras.electricalCost);
                if (data.extras.downlights) setVal('extraDownlights', data.extras.downlights);
                toggleExtraCost('demo');
                toggleExtraCost('removal');
                toggleExtraCost('electrical');
            }
            if (data.allowances) {
                setVal('allowGutter', data.allowances.gutter);
                setVal('allowFlashings', data.allowances.flashings);
            }

            // Colours
            var roofColour = specs.roofColour || cfg.sheetColor;
            if (roofColour) {
                var sc = COLORS.find(function(c) { return c.name === roofColour; });
                if (sc) {
                    sheetColor = sc;
                    document.querySelectorAll('#sheetChips .color-chip').forEach(function(ch) { ch.classList.toggle('active', ch.title === sc.name); });
                    document.getElementById('sheetLabel').textContent = sc.name;
                }
            }
            var fColour = specs.frameColour || cfg.steelColor;
            if (fColour) {
                var sc2 = COLORS.find(function(c) { return c.name === fColour; });
                if (sc2) {
                    steelColor = sc2;
                    document.querySelectorAll('#steelChips .color-chip').forEach(function(ch) { ch.classList.toggle('active', ch.title === sc2.name); });
                    document.getElementById('steelLabel').textContent = sc2.name;
                }
            }

            // Polycarbonate
            var pc = data.polycarb || {};
            var pcEnabled = pc.enabled || cfg.polycarbEnabled;
            if (pcEnabled) {
                document.querySelector('input[name="polycarb"][value="yes"]').checked = true;
                document.getElementById('polycarbOptions').style.display = 'block';
                if (pc.brand || cfg.polycarbBrand) document.getElementById('inPolycarbBrand').value = pc.brand || cfg.polycarbBrand;
                updatePolycarbTints();
                if (pc.tint || cfg.polycarbTint) document.getElementById('inPolycarbTint').value = pc.tint || cfg.polycarbTint;
                if (pc.pattern || cfg.polycarbPattern) document.getElementById('inPolycarbPattern').value = pc.pattern || cfg.polycarbPattern;
                if (pc.custom || cfg.polycarbCustom) document.getElementById('inPolycarbCustom').value = pc.custom || cfg.polycarbCustom;
                updatePolycarbPreview();
            }

            // Pricing
            if (data.pricing) {
                var p = data.pricing;
                if (p.addonRows && Array.isArray(p.addonRows)) {
                    jobRows = jobRows.filter(function(r) { return !r.isAddon; });
                    p.addonRows.forEach(function(a) { a.isAddon = true; if (!a.unit) a.unit = 'each'; jobRows.push(a); });
                }
                if (p.extrasRows && Array.isArray(p.extrasRows)) extrasRows = p.extrasRows;
                if (p.labour) {
                    if (p.labour.trades != null) document.getElementById('labTrades').value = p.labour.trades;
                    if (p.labour.days != null) document.getElementById('labDays').value = p.labour.days;
                    if (p.labour.dayRate != null) document.getElementById('labDayRate').value = p.labour.dayRate;
                    if (p.labour.sell != null) document.getElementById('labSellInput').value = p.labour.sell;
                }
            }

            // Complexity
            if (data.complexity) {
                var cx = data.complexity;
                if (cx.build) document.getElementById('cxBuild').value = cx.build;
                if (cx.access) document.getElementById('cxAccess').value = cx.access;
                if (cx.distance) document.getElementById('cxDistance').value = cx.distance;
                if (cx.footing) document.getElementById('cxFooting').value = cx.footing;
                if (cx.height) document.getElementById('cxHeight').value = cx.height;
            }

            // Notes
            if (data.notes) {
                if (data.notes.jobNotes) document.getElementById('jobNotes').value = data.notes.jobNotes;
                if (data.notes.pricingNotes) document.getElementById('pricingNotes').value = data.notes.pricingNotes;
            }

            // Flashings
            if (data.flashings && Array.isArray(data.flashings)) {
                flashingProfiles = data.flashings.map(function(f) {
                    return {
                        id: f.id || 'flashing_' + String(flashNextId++).padStart(3, '0'),
                        name: f.name || 'Unnamed',
                        colour: f.colour || 'Monument',
                        gauge: f.gauge || 0.42,
                        length: f.length || 3000,
                        qty: f.qty || 1,
                        colourSide: f.colourSide || 'top',
                        points: f.points || [],
                        girth: f.girth || calcGirth(f.points || []),
                        legs: f.legs || calcLegs(f.points || [])
                    };
                });
                renderFlashJobTable();
            }

            // Rebuild everything
            updateUI();
            rebuildAll();
            renderExtras();
            updatePricing();
            updateHeaderBadge();

            closeLoadJobModal();
            var custName = (data.customer && data.customer.name) ? data.customer.name : (data.client && data.client.name) ? data.client.name : 'Unknown';
            var custAddr = (data.customer && data.customer.address) ? data.customer.address : (data.client && data.client.address) ? data.client.address : '';
            alert('Job loaded: ' + custName + (custAddr ? ', ' + custAddr : ''));
        }

        function downloadJobJSON(json, ref) {
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (ref || 'PatioJob') + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function showImportModal() {
            document.getElementById('importTextarea').value = '';
            document.getElementById('importStatus').textContent = '';
            document.getElementById('importModal').style.display = '';
        }

        function importJobData() {
            const raw = document.getElementById('importTextarea').value.trim();
            const statusEl = document.getElementById('importStatus');
            if (!raw) { statusEl.textContent = 'Please paste JSON data first.'; statusEl.style.color = '#FF3B30'; return; }
            let data;
            try {
                data = JSON.parse(raw);
            } catch(e) {
                statusEl.textContent = 'Invalid JSON. Check the data and try again.';
                statusEl.style.color = '#FF3B30';
                return;
            }

            // Populate client info
            if (data.client) {
                const cl = data.client;
                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                if (cl.name) document.getElementById('clientName').value = cl.name;
                if (cl.address) document.getElementById('siteAddress').value = cl.address;
                if (cl.phone) document.getElementById('clientPhone').value = cl.phone;
                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                if (cl.salesperson) document.getElementById('salesperson').value = cl.salesperson;
            }

            // Populate config
            if (data.config) {
                const cfg = data.config;
                const setVal = (id, val) => { const el = document.getElementById(id); if (el && val != null) el.value = val; };
                setVal('inRoofStyle', cfg.roofStyle);
                setVal('inOrientation', cfg.orientation);
                setVal('inWidth', cfg.projection);
                setVal('inLength', cfg.length);
                setVal('inPitch', cfg.pitch);
                setVal('inPostHeight', cfg.postHeight);
                setVal('inPosts', cfg.posts);
                setVal('inTrusses', cfg.trusses);
                setVal('inRafters', cfg.rafters);
                setVal('inRoofing', cfg.roofing);
                setVal('inInfill', cfg.infill);
                setVal('inConnection', cfg.connection);
                setVal('inFasciaHeight', cfg.fasciaHeight);
                setVal('inRiserHeight', cfg.riserHeight);
                setVal('inRiserOffset', cfg.riserOffset);
                setVal('inRiserQty', cfg.riserQty);
                setVal('inHouseGutter', cfg.houseGutter);
                setVal('inRiserGutter', cfg.riserGutter);
                setVal('inPostFix', cfg.postFix);
                setVal('inPostSize', cfg.postSize || '90x90');
                setVal('inBeamSize', cfg.beamSize || '100x50');
                const lb = cfg.trussStyle === 'king' ? 'kingpost' : (cfg.trussStyle === 'queen' ? 'kingpost' : cfg.trussStyle);
                setVal('inTrussBase', cfg.trussBase || lb || 'kingpost');
                setVal('inTrussChord', cfg.trussChord || 'bottom');
                setVal('inTrussSteel', cfg.trussSteel);
                setVal('inOverhang', cfg.overhang);

                // Truss options (handles both legacy and new format)
                if (cfg.trussExtender && cfg.trussExtender.enabled) {
                    document.getElementById('trussExtOn').checked = true;
                    setVal('trussExtLen', cfg.trussExtender.length || '300');
                }
                // New riser L/R format
                if (cfg.trussRiserLeft && cfg.trussRiserLeft.enabled) {
                    document.getElementById('trussRiserOn').checked = true;
                    setVal('riserLH', cfg.trussRiserLeft.length || '200');
                    setVal('riserLV', cfg.trussRiserLeft.height || '150');
                    setVal('riserRH', (cfg.trussRiserRight || {}).length || '200');
                    setVal('riserRV', (cfg.trussRiserRight || {}).height || '150');
                }
                // Legacy riser format (migrate to both sides)
                else if (cfg.trussRiser && cfg.trussRiser.enabled) {
                    document.getElementById('trussRiserOn').checked = true;
                    setVal('riserLH', cfg.trussRiser.rx || '200');
                    setVal('riserLV', cfg.trussRiser.ry || '150');
                    setVal('riserRH', cfg.trussRiser.rx || '200');
                    setVal('riserRV', cfg.trussRiser.ry || '150');
                }
                if (cfg.trussRiserLocked !== undefined) {
                    document.getElementById('trussRiserLock').checked = cfg.trussRiserLocked !== false;
                }
                toggleTrussOpt();

                // Colours
                if (cfg.sheetColor) {
                    const sc = COLORS.find(c => c.name === cfg.sheetColor);
                    if (sc) {
                        sheetColor = sc;
                        const chips = document.querySelectorAll('#sheetChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('sheetLabel').textContent = sc.name;
                    }
                }
                if (cfg.steelColor) {
                    const sc = COLORS.find(c => c.name === cfg.steelColor);
                    if (sc) {
                        steelColor = sc;
                        const chips = document.querySelectorAll('#steelChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('steelLabel').textContent = sc.name;
                    }
                }
                // Polycarbonate
                if (cfg.polycarbEnabled) {
                    document.querySelector('input[name="polycarb"][value="yes"]').checked = true;
                    document.getElementById('polycarbOptions').style.display = 'block';
                    if (cfg.polycarbBrand) document.getElementById('inPolycarbBrand').value = cfg.polycarbBrand;
                    updatePolycarbTints();
                    if (cfg.polycarbTint) document.getElementById('inPolycarbTint').value = cfg.polycarbTint;
                    if (cfg.polycarbPattern) document.getElementById('inPolycarbPattern').value = cfg.polycarbPattern;
                    if (cfg.polycarbCustom) document.getElementById('inPolycarbCustom').value = cfg.polycarbCustom;
                    updatePolycarbPreview();
                }
            }

            // Populate pricing
            if (data.pricing) {
                const p = data.pricing;
                if (p.addonRows && Array.isArray(p.addonRows)) {
                    jobRows = jobRows.filter(r => !r.isAddon);
                    p.addonRows.forEach(a => { a.isAddon = true; if (!a.unit) a.unit = 'each'; jobRows.push(a); });
                }
                // New extras format
                if (p.extrasRows && Array.isArray(p.extrasRows)) {
                    extrasRows = p.extrasRows;
                }
                // New labour card format
                if (p.labour) {
                    const l = p.labour;
                    if (l.trades != null) document.getElementById('labTrades').value = l.trades;
                    if (l.days != null) document.getElementById('labDays').value = l.days;
                    if (l.dayRate != null) document.getElementById('labDayRate').value = l.dayRate;
                    if (l.sell != null) document.getElementById('labSellInput').value = l.sell;
                }
                // Legacy: old labourRows format (backward compat)
                if (p.labourRows && Array.isArray(p.labourRows) && p.labourRows.length > 0 && !p.labour) {
                    const first = p.labourRows[0];
                    document.getElementById('labTrades').value = first.trades || 2;
                    document.getElementById('labDays').value = first.days || 1.5;
                    document.getElementById('labDayRate').value = first.dayRate || 400;
                    document.getElementById('labSellInput').value = first.sell || 0;
                }
                // Legacy: delivery as extras (backward compat)
                if (p.deliveryCost != null && parseFloat(p.deliveryCost) > 0 && !p.extrasRows) {
                    extrasRows.push({ desc: 'Delivery', qty: 1, unitCost: parseFloat(p.deliveryCost) || 0, unitSell: parseFloat(p.deliverySell) || 0, type: 'delivery' });
                }
            }

            // Complexity scores (still stored in hidden inputs)
            if (data.complexity) {
                const cx = data.complexity;
                if (cx.build) document.getElementById('cxBuild').value = cx.build;
                if (cx.access) document.getElementById('cxAccess').value = cx.access;
                if (cx.distance) document.getElementById('cxDistance').value = cx.distance;
                if (cx.footing) document.getElementById('cxFooting').value = cx.footing;
                if (cx.height) document.getElementById('cxHeight').value = cx.height;
            }

            // Notes
            if (data.notes) {
                if (data.notes.jobNotes) document.getElementById('jobNotes').value = data.notes.jobNotes;
                if (data.notes.pricingNotes) document.getElementById('pricingNotes').value = data.notes.pricingNotes;
            }

            // Flashings
            if (data.flashings && Array.isArray(data.flashings)) {
                flashingProfiles = data.flashings.map(function(f) {
                    return {
                        id: f.id || 'flashing_' + String(flashNextId++).padStart(3, '0'),
                        name: f.name || 'Unnamed',
                        colour: f.colour || 'Monument',
                        gauge: f.gauge || 0.42,
                        length: f.length || 3000,
                        qty: f.qty || 1,
                        colourSide: f.colourSide || 'top',
                        points: f.points || [],
                        girth: f.girth || calcGirth(f.points || []),
                        legs: f.legs || calcLegs(f.points || [])
                    };
                });
                renderFlashJobTable();
            }

            // Rebuild everything
            updateUI();
            rebuildAll();
            renderExtras();
            updatePricing();
            updateHeaderBadge();

            statusEl.textContent = 'Job loaded successfully! All fields populated.';
            statusEl.style.color = '#34C759';
            setTimeout(() => { document.getElementById('importModal').style.display = 'none'; }, 1200);
        }

        // ==================== JOB REF AUTO-GENERATE ====================
        function generateJobRef() {
            const d = new Date();
            const yy = String(d.getFullYear()).slice(-2);
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const seq = String(Math.floor(Math.random() * 99) + 1).padStart(2, '0');
            return 'SW' + yy + mm + dd + '-' + seq;
        }

        function initJobDetails() {
            const refEl = document.getElementById('jobRef');
            if (!refEl.value.trim()) refEl.value = generateJobRef();
            // Sync header badge on any field change
            ['jobRef', 'customerName'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', updateHeaderBadge);
            });
            updateHeaderBadge();
        }

        function updateHeaderBadge() {
            const ref = (document.getElementById('jobRef')?.value || '').trim();
            const name = (document.getElementById('customerName')?.value || '').trim();
            const badge = document.getElementById('headerBadge');
            if (badge) badge.innerHTML = '<strong>' + (ref || 'SW\u2014') + '</strong>' + (name ? ' &nbsp;' + name : '');
        }

        // ==================== PDF SHARED HELPERS ====================
        function getJobRef() {
            const el = document.getElementById('jobRef');
            return (el && el.value.trim()) || generateJobRef();
        }
        function getClientName() { return (document.getElementById('clientName')?.value || '').trim() || 'Client'; }
        function getSiteAddress() { return (document.getElementById('siteAddress')?.value || '').trim(); }
        function getClientPhone() { return (document.getElementById('clientPhone')?.value || '').trim(); }
        function getClientEmail() { return (document.getElementById('clientEmail')?.value || '').trim(); }
        function getSalesperson() { return (document.getElementById('salesperson')?.value || '').trim(); }
        function safeName(s) { return s.replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_'); }
        function todayStr() {
            const d = new Date();
            return d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();
        }
        function fmtDollars(v) { return '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ','); }

        function connectionLabel(conn) {
            const map = {freestanding:'Freestanding',fascia:'Fascia / Receiving',wall:'Wall Mount',riser:'Riser Beam',flyover:'Flyover'};
            return map[conn] || conn;
        }
        function roofingLabel(r) {
            const map = {corrugated:'Corrugated Colorbond',trimdek:'Trimdek',spandek:'Spandek',solarspan75:'SolarSpan 75mm',solarspan100:'SolarSpan 100mm',spanplus330:'SpanPlus 330'};
            return map[r] || r;
        }

        function buildScopeText() {
            const c = calc;
            const style = c.isGable ? 'Gable' : 'Skillion';
            const Lm = (c.lenInput / 1000).toFixed(1);
            const Wm = (c.projInput / 1000).toFixed(1);
            const conn = connectionLabel(c.connection);
            const roof = roofingLabel(c.roofing);
            let roofDesc = 'Roof: ' + roof + ' (' + sheetColor.name + ')';
            const pc = (c.roofing === 'trimdek') ? getPolycarbConfig() : null;
            if (pc) {
                const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
                roofDesc += ' with ' + brandLabel + ' ' + pc.tint + ' polycarbonate (every ' + pc.patternN + getSuffix(pc.patternN) + ' sheet)';
            }
            return 'Supply and install a ' + style + ' patio, ' + Lm + 'm x ' + Wm + 'm, attached via ' + conn + '. ' +
                   roofDesc + '. Steel: ' + steelColor.name + '. Including gutters, downpipes and flashings.';
        }
        function getSuffix(n) { return n === 2 ? 'nd' : n === 3 ? 'rd' : 'th'; }

        function capture3DImage() {
            try {
                if (asmRend && asmScene && asmCam) {
                    asmRend.render(asmScene, asmCam);
                    return asmRend.domElement.toDataURL('image/png');
                }
            } catch(e) { /* cross-origin or not ready */ }
            return null;
        }

        function getMaterialRows() {
            const rows = [];
            const els = document.querySelectorAll('#matList .mat-row');
            els.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length >= 2) {
                    const desc = row.dataset.desc || spans[0].textContent.trim();
                    const qty = parseInt(spans[1].textContent.trim().replace('×', '')) || 1;
                    const length = getItemLength(desc);
                    rows.push({ desc, qty, length });
                }
            });
            return rows;
        }

        // SW Orange accent
        const SW_ORANGE = [242, 101, 34];  // #F26522
        const SW_DARK = [41, 60, 70];      // #293C46

        function pdfHeader(doc, title, jobRef) {
            // Orange header bar
            doc.setFillColor(...SW_ORANGE);
            doc.rect(0, 0, 210, 28, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(18);
            doc.setTextColor(255, 255, 255);
            doc.text('SecureWorks WA', 14, 13);
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.text('Patios  •  Carports  •  Pergolas', 14, 20);
            // Job ref right side
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text(jobRef, 196, 13, { align: 'right' });
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.text(todayStr(), 196, 20, { align: 'right' });
            // Title below header
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text(title, 14, 38);
            return 46;
        }

        function pdfFooter(doc) {
            const pageH = doc.internal.pageSize.getHeight();
            doc.setDrawColor(200, 200, 200);
            doc.line(14, pageH - 16, 196, pageH - 16);
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(130, 130, 130);
            const sp = getSalesperson();
            const footerParts = ['SecureWorks WA', 'ABN: XX XXX XXX XXX', 'Phone: (08) XXXX XXXX'];
            if (sp && sp !== 'Other') footerParts.push('Sales: ' + sp);
            doc.text(footerParts.join('  |  '), 105, pageH - 10, { align: 'center' });
        }

        function pdfClientBlock(doc, y) {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(80, 80, 80);
            const name = getClientName();
            const addr = getSiteAddress();
            const phone = getClientPhone();
            const email = getClientEmail();
            if (name) { doc.text('Client: ' + name, 14, y); y += 5; }
            if (addr) { doc.text('Site: ' + addr, 14, y); y += 5; }
            const contactParts = [phone ? 'Phone: ' + phone : '', email ? 'Email: ' + email : ''].filter(Boolean);
            if (contactParts.length) { doc.text(contactParts.join('    |    '), 14, y); y += 5; }
            return y + 3;
        }

        // Simple table helper
        function pdfTable(doc, y, headers, rows, colWidths, opts) {
            opts = opts || {};
            const startX = opts.startX || 14;
            const rowH = opts.rowH || 6;
            const fontSize = opts.fontSize || 9;
            const headerBg = opts.headerBg || SW_DARK;
            const altBg = opts.altBg || [245, 245, 247];
            const totalW = colWidths.reduce((a, b) => a + b, 0);

            // Header row
            doc.setFillColor(...headerBg);
            doc.rect(startX, y, totalW, rowH + 1, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(fontSize - 1);
            doc.setTextColor(255, 255, 255);
            let cx = startX;
            headers.forEach((h, i) => {
                const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                doc.text(h, tx, y + rowH - 1, { align });
                cx += colWidths[i];
            });
            y += rowH + 1;

            // Data rows
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(fontSize);
            rows.forEach((row, ri) => {
                // Check page break
                if (y + rowH > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                if (ri % 2 === 1) {
                    doc.setFillColor(...altBg);
                    doc.rect(startX, y, totalW, rowH, 'F');
                }
                const isBold = row._bold;
                doc.setFont('helvetica', isBold ? 'bold' : 'normal');
                doc.setTextColor(...(isBold ? SW_DARK : [60, 60, 60]));
                cx = startX;
                row.forEach((cell, i) => {
                    const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                    const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                    doc.text(String(cell), tx, y + rowH - 1.5, { align });
                    cx += colWidths[i];
                });
                y += rowH;
            });
            return y + 2;
        }

        // ==================== PDF 1: QUOTE (Client) ====================
        function generateQuotePDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Quote', jobRef);
            y = pdfClientBlock(doc, y);

            // Date & validity
            doc.setFontSize(9);
            doc.setTextColor(100, 100, 100);
            doc.text('Date: ' + todayStr() + '    |    Quote valid for 30 days', 14, y);
            y += 8;

            // 3D render image
            const img = capture3DImage();
            if (img) {
                try {
                    doc.addImage(img, 'PNG', 14, y, 120, 68);
                    y += 72;
                } catch(e) { /* skip image */ }
            }

            // Scope description
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Scope of Works', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const scopeLines = doc.splitTextToSize(buildScopeText(), 178);
            doc.text(scopeLines, 14, y);
            y += scopeLines.length * 4.5 + 6;

            // Pricing table (sell only) - read from pricingState
            const ps = pricingState;
            const pFmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');

            const priceRows = [];
            priceRows.push(['Materials', pFmt(ps.matSell || 0)]);
            priceRows.push(['Installation', pFmt(ps.labSell || 0)]);
            if ((ps.extrasSell || 0) > 0) priceRows.push(['Extras', pFmt(ps.extrasSell)]);

            const subRow = ['Subtotal (ex GST)', pFmt(ps.totalSell || 0)]; subRow._bold = true;
            priceRows.push(subRow);
            const gstRow = ['GST (10%)', pFmt(ps.gst || 0)]; gstRow._bold = true;
            priceRows.push(gstRow);
            const totalRow = ['TOTAL (inc GST)', pFmt(ps.totalIncGST || 0)]; totalRow._bold = true;
            priceRows.push(totalRow);

            y = pdfTable(doc, y, ['Description', 'Amount'], priceRows, [120, 62]);

            // Terms & conditions
            y += 4;
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Terms & Conditions', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(8);
            doc.setTextColor(80, 80, 80);
            const terms = [
                '• 50% deposit required to confirm booking. Balance due on completion.',
                '• Quote valid for 30 days from date of issue.',
                '• Council permits not included unless specified.',
                '• Price excludes any electrical, plumbing or council works unless listed above.',
                '• All work completed to Australian Standards and BCA requirements.'
            ];
            terms.forEach(t => {
                doc.text(t, 14, y);
                y += 4;
            });

            pdfFooter(doc);
            doc.save('Quote_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Quote PDF: ' + e.message); console.error(e); }
        }

        // ==================== PDF 2: SUPPLIER ORDERS (Steel / Sheets & Flashings / Fabrication) ====================

        // Shared helper: delivery info block for supplier order PDFs
        function pdfDeliveryBlock(doc, y) {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(60, 60, 60);
            const addr = getSiteAddress();
            if (addr) { doc.text('Deliver to: ' + addr, 14, y); y += 5; }
            doc.text('Required by: ______________________', 14, y);
            y += 5;
            doc.text('Contact: ' + getClientName() + (getClientPhone() ? '  |  ' + getClientPhone() : ''), 14, y);
            y += 8;
            return y;
        }

        // Categorise a single material row into supplier groups
        function classifyMaterial(desc) {
            const d = desc.toLowerCase();
            if (/truss|dogleg|fabricat/.test(d)) return 'fabrication';
            if (/sheet|panel|gutter|downpipe|elbow|flashing|barge|ridge|channel|foam|infill|stop.?end|outlet/.test(d)) return 'sheets';
            if (/post|beam|rafter|purlin|strut|bracket|joiner|cap/.test(d)) return 'steel';
            return 'steel'; // default structural items to steel
        }

        // Build categorised material rows for supplier orders
        function buildSupplierRows() {
            const mats = getMaterialRows();
            const c = calc;
            const trussName = c.steel ? c.steel.name : '76\u00D738\u00D71.6';
            const beamLabel = c.frameBeam ? c.frameBeam.name : '100×50×2 RHS';
            const postLabel = c.framePost ? c.framePost.name : '90×90×2 SHS';
            const colour = steelColor.name;
            const sheetColour = sheetColor.name;

            const groups = { steel: [], sheets: [], fabrication: [] };

            mats.forEach(m => {
                const d = m.desc.toLowerCase();
                const lengthM = (m.length).toFixed(2) + 'm';
                const isSheetItem = /sheet|panel|gutter|downpipe|flashing|barge|ridge/.test(d);
                const col = isSheetItem ? sheetColour : colour;
                const group = classifyMaterial(m.desc);

                let size = '';
                if (group === 'steel') {
                    if (d.includes('post') || d.includes('strut') || d.includes('elbow')) size = postLabel;
                    else if (d.includes('beam')) size = beamLabel;
                    else size = trussName;
                } else if (d.includes('sheet') || d.includes('panel')) {
                    size = roofingLabel(c.roofing);
                }

                const row = [m.desc, size, lengthM, String(m.qty), col, ''];
                groups[group].push(row);
            });

            return groups;
        }

        // ── PDF 2a: STEEL & STRUCTURAL ORDER ──
        function generateSteelOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Steel & Structural Order', jobRef);

            // Supplier line
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(100, 100, 100);
            doc.text('Supplier: Metroll / Stratco', 14, y); y += 5;
            doc.setFont('helvetica', 'normal');

            y = pdfDeliveryBlock(doc, y);

            const groups = buildSupplierRows();
            const rows = groups.steel;

            if (rows.length === 0) {
                doc.setFontSize(10);
                doc.setTextColor(120, 120, 120);
                doc.text('No steel / structural items for this job.', 14, y);
            } else {
                // Sub-categorise steel items
                const subCats = {
                    'Posts': [],
                    'Beams': [],
                    'Battens & Purlins': [],
                    'Brackets & Fixings': []
                };
                rows.forEach(row => {
                    const d = row[0].toLowerCase();
                    if (d.includes('post')) subCats['Posts'].push(row);
                    else if (d.includes('beam') || d.includes('fascia')) subCats['Beams'].push(row);
                    else if (d.includes('purlin') || d.includes('batten') || d.includes('rafter') || d.includes('strut')) subCats['Battens & Purlins'].push(row);
                    else subCats['Brackets & Fixings'].push(row);
                });

                const colWidths = [50, 36, 22, 16, 30, 28];
                const tableHeaders = ['Item', 'Size', 'Length', 'Qty', 'Colour', 'Notes'];
                let totalItems = 0;

                Object.entries(subCats).forEach(([cat, catRows]) => {
                    if (catRows.length === 0) return;
                    if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc);
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...SW_ORANGE);
                    doc.text(cat, 14, y);
                    y += 4;
                    y = pdfTable(doc, y, tableHeaders, catRows, colWidths, { leftAlignAll: true });
                    y += 2;
                    totalItems += catRows.length;
                });

                // Section subtotal
                y += 2;
                doc.setFontSize(9);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text('Total line items: ' + totalItems, 14, y);
            }

            pdfFooter(doc);
            doc.save('SteelOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Steel Order PDF: ' + e.message); console.error(e); }
        }

        // ── PDF 2b: SHEET METAL & FLASHINGS ORDER ──
        function generateSheetsOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Sheet Metal & Flashings Order', jobRef);

            // Supplier line
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(100, 100, 100);
            doc.text('Supplier: Metroll / Stratco / Bondor', 14, y); y += 5;
            doc.setFont('helvetica', 'normal');

            y = pdfDeliveryBlock(doc, y);

            const groups = buildSupplierRows();
            const rows = groups.sheets;

            if (rows.length === 0) {
                doc.setFontSize(10);
                doc.setTextColor(120, 120, 120);
                doc.text('No sheet metal / flashing items for this job.', 14, y);
            } else {
                // Sub-categorise sheets items
                const subCats = {
                    'Roofing Sheets / Panels': [],
                    'Gutters & Downpipes': [],
                    'Flashings': [],
                    'Accessories': []
                };
                rows.forEach(row => {
                    const d = row[0].toLowerCase();
                    if (d.includes('sheet') || d.includes('panel')) subCats['Roofing Sheets / Panels'].push(row);
                    else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow')) subCats['Gutters & Downpipes'].push(row);
                    else if (d.includes('flashing') || d.includes('barge') || d.includes('ridge') || d.includes('channel')) subCats['Flashings'].push(row);
                    else subCats['Accessories'].push(row);
                });

                const colWidths = [50, 36, 22, 16, 30, 28];
                const tableHeaders = ['Item', 'Product', 'Length', 'Qty', 'Colour', 'Notes'];
                let totalItems = 0;

                Object.entries(subCats).forEach(([cat, catRows]) => {
                    if (catRows.length === 0) return;
                    if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc);
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...SW_ORANGE);
                    doc.text(cat, 14, y);
                    y += 4;
                    y = pdfTable(doc, y, tableHeaders, catRows, colWidths, { leftAlignAll: true });
                    y += 2;
                    totalItems += catRows.length;
                });

                // Flashing profiles section
                if (flashingProfiles.length > 0) {
                    if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc); doc.addPage(); y = 20;
                    }
                    y += 4;
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...SW_ORANGE);
                    doc.text('Flashing Profiles', 14, y);
                    y += 6;

                    flashingProfiles.forEach(function(fp) {
                        var blockH = 45;
                        if (y + blockH > doc.internal.pageSize.getHeight() - 25) {
                            pdfFooter(doc); doc.addPage(); y = 20;
                        }
                        // Name & specs
                        doc.setFontSize(9);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(...SW_DARK);
                        doc.text(fp.name, 14, y);
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(7);
                        doc.setTextColor(100, 100, 100);
                        var orderLen = fp.length + 500;
                        doc.text('Girth: ' + fp.girth + 'mm  |  Order Length: ' + orderLen + 'mm (' + fp.length + 'mm + 500mm allowance)  |  Qty: ' + fp.qty + '  |  Colour: ' + fp.colour + ' (' + fp.colourSide.toUpperCase() + ')  |  Gauge: ' + fp.gauge + 'mm', 14, y + 4);
                        y += 7;

                        // Draw profile in PDF
                        if (fp.points && fp.points.length >= 2) {
                            var pdfBoxW = 60, pdfBoxH = 28;
                            var bx = 14;
                            doc.setDrawColor(200, 200, 200);
                            doc.setLineWidth(0.2);
                            doc.rect(bx, y, pdfBoxW, pdfBoxH);

                            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                            fp.points.forEach(function(pt) { if(pt.x<minX)minX=pt.x;if(pt.x>maxX)maxX=pt.x;if(pt.y<minY)minY=pt.y;if(pt.y>maxY)maxY=pt.y; });
                            var rX = maxX - minX || 1, rY = maxY - minY || 1;
                            var sc = Math.min((pdfBoxW - 6) / rX, (pdfBoxH - 6) / rY);
                            var ox = bx + (pdfBoxW - rX * sc) / 2;
                            var oy = y + (pdfBoxH - rY * sc) / 2;

                            doc.setDrawColor(41, 60, 70);
                            doc.setLineWidth(0.5);
                            for (var pi = 0; pi < fp.points.length - 1; pi++) {
                                var pa = fp.points[pi], pb = fp.points[pi+1];
                                doc.line(ox + (pa.x - minX)*sc, oy + (maxY - pa.y)*sc, ox + (pb.x - minX)*sc, oy + (maxY - pb.y)*sc);
                            }

                            // Dimension labels on each leg
                            doc.setFontSize(5);
                            doc.setTextColor(80, 80, 80);
                            for (var li = 0; li < fp.points.length - 1; li++) {
                                var la = fp.points[li], lb = fp.points[li+1];
                                var ldx = lb.x - la.x, ldy = lb.y - la.y;
                                var llen = Math.round(Math.sqrt(ldx*ldx + ldy*ldy));
                                var lmx = ox + ((la.x + lb.x)/2 - minX)*sc;
                                var lmy = oy + (maxY - (la.y + lb.y)/2)*sc;
                                doc.text(llen + '', lmx + 1, lmy - 1);
                            }

                            y += pdfBoxH + 3;
                        }
                        y += 3;
                    });
                } else {
                    // Fallback: blank sketch boxes
                    if (y + 55 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc); doc.addPage(); y = 20;
                    }
                    y += 4;
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...SW_ORANGE);
                    doc.text('Flashing Sketches', 14, y);
                    y += 5;
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(130, 130, 130);
                    doc.text('Sketch flashing profiles below \u2014 hand draw dimensions and bends', 14, y);
                    y += 5;
                    var boxW = 42, boxH = 32, gap = 4;
                    var labels = ['Back Flashing', 'Barge Flashing L', 'Barge Flashing R', 'Other'];
                    labels.forEach(function(label, i) {
                        var bx2 = 14 + i * (boxW + gap);
                        doc.setDrawColor(180, 180, 180);
                        doc.setLineWidth(0.3);
                        doc.rect(bx2, y, boxW, boxH);
                        doc.setFontSize(7);
                        doc.setTextColor(130, 130, 130);
                        doc.text(label, bx2 + boxW / 2, y + boxH + 4, { align: 'center' });
                    });
                    y += boxH + 8;
                }

                // Section subtotal
                doc.setFontSize(9);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text('Total line items: ' + totalItems, 14, y);
            }

            pdfFooter(doc);
            doc.save('SheetsOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Sheets Order PDF: ' + e.message); console.error(e); }
        }

        // ── PDF 2c: FABRICATION ORDER ──
        function generateFabricationOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const c = calc;
            let y = pdfHeader(doc, 'Fabrication Order', jobRef);

            // Supplier line
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(100, 100, 100);
            doc.text('Supplier: CMI / JBS Patios Malaga', 14, y); y += 5;
            doc.setFont('helvetica', 'normal');

            y = pdfDeliveryBlock(doc, y);

            const groups = buildSupplierRows();
            const fabMatRows = groups.fabrication;

            // If gable with truss data, show detailed truss info (reuse exportTrussPDF style)
            if (c.isGable && c.trussData) {
                const td = c.trussData;

                // Truss image
                const img = captureTrussImage();
                if (img) {
                    try {
                        doc.addImage(img, 'PNG', 14, y, 110, 55);
                        y += 58;
                    } catch(e) { /* skip */ }
                }

                const lx = 14;
                const rw = 178;
                const lh = 5.5;

                function fabSec(title) {
                    if (y + 10 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc);
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFillColor(...SW_ORANGE);
                    doc.rect(lx, y, rw, 6, 'F');
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(9);
                    doc.setTextColor(255, 255, 255);
                    doc.text('  ' + title, lx + 2, y + 4.5);
                    y += 7;
                }
                function fabRow(label, value, bold) {
                    if (y + lh > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc);
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFont('helvetica', bold ? 'bold' : 'normal');
                    doc.setFontSize(10);
                    doc.setTextColor(...SW_DARK);
                    doc.text(label, lx + 4, y);
                    doc.text(String(value), lx + rw - 4, y, { align: 'right' });
                    y += lh;
                }

                fabSec('TRUSS STEEL');
                fabRow('Profile', td.steelName + ' RHS');
                fabRow('Colour', td.clr);
                fabRow('BMT', td.bmt + 'mm');
                fabRow('Quantity', td.nTruss + ' trusses');
                y += 2;

                fabSec('TRUSS DIMENSIONS');
                fabRow('Span', td.trussSpan + 'mm');
                fabRow('Height', td.rise + 'mm');
                fabRow('Pitch', td.pitch.toFixed(1) + '\u00B0');
                if (td.overhang > 0) fabRow('Overhang', td.overhang + 'mm');
                if (td.extender && td.extender.enabled) {
                    fabRow('Extender', td.extender.length + 'mm (each end)');
                }
                y += 2;

                fabSec('CUT LIST (per truss)');
                fabRow('Chord', '1 \u00D7 ' + td.chordCut + 'mm', true);
                if (td.extender && td.extender.enabled) {
                    fabRow('Extender', '2 \u00D7 ' + Math.round(td.extender.length) + 'mm');
                }
                fabRow('Rafters', '2 \u00D7 ' + td.rafterCut + 'mm', true);
                if (td.webMembers && td.webMembers.length > 0) {
                    for (var wi = 0; wi < td.webMembers.length; wi++) {
                        var wm = td.webMembers[wi];
                        fabRow(wm.type, wm.count + ' \u00D7 ' + wm.length + 'mm');
                    }
                }
                y += 2;

                fabSec('CUT ANGLES');
                fabRow('Apex Mitre', td.apexAngle.toFixed(1) + '\u00B0 (both rafters)');
                fabRow('Heel Mitre', td.heelAngle.toFixed(1) + '\u00B0 (rafter to chord)');
                y += 2;

                fabSec('MATERIAL REQUIRED');
                fabRow('Truss LM (each)', td.totalLM.toFixed(3) + ' LM');
                fabRow('All ' + td.nTruss + ' trusses', td.totalAllLM.toFixed(2) + ' LM', true);
                fabRow('Order length', td.totalSticks + ' \u00D7 6m sticks', true);

                // Risers (separate steel)
                if (td.riserLeft && td.riserLeft.enabled) {
                    y += 2;
                    fabSec('RISERS (separate steel \u2013 bolted to truss ends)');
                    fabRow('Left Riser', Math.round(td.riserLeft.length) + 'mm horiz + ' + Math.round(td.riserLeft.height) + 'mm vert');
                    fabRow('Right Riser', Math.round(td.riserRight.length) + 'mm horiz + ' + Math.round(td.riserRight.height) + 'mm vert');
                    fabRow('Riser steel (per pair)', (td.riserLeft.lm + td.riserRight.lm).toFixed(2) + ' LM');
                    fabRow('Riser steel (all)', td.riserTotalLM.toFixed(2) + ' LM (' + td.nTruss + ' sets)', true);
                }
                y += 4;
            }

            // Any other fabrication material rows (custom items etc.)
            if (fabMatRows.length > 0) {
                if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_ORANGE);
                doc.text('Other Fabricated Items', 14, y);
                y += 4;
                const colWidths = [50, 36, 22, 16, 30, 28];
                const tableHeaders = ['Item', 'Size', 'Length', 'Qty', 'Colour', 'Notes'];
                y = pdfTable(doc, y, tableHeaders, fabMatRows, colWidths, { leftAlignAll: true });
            }

            if (!c.isGable && fabMatRows.length === 0) {
                doc.setFontSize(10);
                doc.setTextColor(120, 120, 120);
                doc.text('No fabrication items for this job (skillion roof \u2013 no trusses).', 14, y);
            }

            pdfFooter(doc);
            doc.save('FabOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Fabrication Order PDF: ' + e.message); console.error(e); }
        }

        // Legacy wrapper - keep for any external calls
        function generateMaterialsOrderPDF() {
            generateSteelOrderPDF();
        }

        // ==================== PDF 3: WORK ORDER (Crew) ====================
        function generateWorkOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const c = calc;
            const pageW = 210, pageH = 297;
            const mx = 14, mr = 196; // margins
            const cw = mr - mx; // content width

            // ── Helpers ──
            const mm = v => Math.round(v) + 'mm';
            const styleLabel = c.roofStyle === 'hip' ? 'HIP' : (c.isGable ? 'GABLE' : 'SKILLION');
            const connLabel = connectionLabel(c.connection).toUpperCase();
            const roofLabel = roofingLabel(c.roofing);
            const sheetClr = sheetColor.name;
            const steelClr = steelColor.name;
            const Lmm = c.lenInput, Wmm = c.projInput;
            const Lm = Lmm / 1000, Wm = Wmm / 1000;
            const postHmm = c.postH;
            const riseMm = Math.round(c.rise);
            const ridgeH = Math.round(c.frontBeamY + c.rise);
            const backBeamH = Math.round(c.backBeamY);
            const frontBeamH = Math.round(c.frontBeamY);
            const nPosts = c.nPosts;
            const nTruss = c.nTruss;
            const postFix = (document.getElementById('inPostFix')?.value || 'concrete');
            const isConc = postFix === 'concrete';
            const postCut = isConc ? postHmm + 300 : postHmm;
            const postSpacing = Math.round(Lmm / (nPosts - 1));
            const trussSpacing = c.nTruss > 1 ? Math.round(Lmm / (c.nTruss - 1)) : Lmm;
            const diagonal = Math.round(Math.sqrt(Lmm * Lmm + Wmm * Wmm));
            const cosP = Math.cos(c.pitchRad);
            const sheetLen = c.isGable ? Math.round((Wmm / 2) / cosP + 50) : Math.round(Wmm / cosP + 50);
            const infill = c.infill || 'none';
            const downlights = parseInt(document.getElementById('extraDownlights')?.value) || 0;
            const hasElectrical = document.getElementById('extraElectrical')?.value === 'yes';
            const steelName = (STEEL[c.trussSteel] || STEEL['76x38']).name;
            const beamName = c.frameBeam ? c.frameBeam.name : '100×50×2 RHS';
            const postName = c.framePost ? c.framePost.name : '90×90×2 SHS';
            const totalPosts = c.isGable ? nPosts * 2 : nPosts;
            const sheetsPerSide = Math.ceil(Lmm / (c.sheetCoverage || 762));
            const totalSheets = c.isGable ? sheetsPerSide * 2 : sheetsPerSide;
            const purlinSpacing = isInsulated(c.roofing) ? 0 : 1000;
            const nPurlins = purlinSpacing > 0 ? Math.max(2, Math.ceil((Wmm / 2) / purlinSpacing)) : 0;
            const accessNotes = [
                (document.getElementById('jobNotes')?.value || '').trim(),
                (document.getElementById('siteNotes')?.value || '').trim()
            ].filter(Boolean).join('. ') || 'None noted';

            function woSectionTitle(title, yp) {
                doc.setFillColor(245, 245, 247);
                doc.rect(mx, yp, cw, 7, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(10);
                doc.setTextColor(...SW_DARK);
                doc.text(title, mx + 3, yp + 5);
                return yp + 9;
            }
            function woKeyVal(label, val, yp, xOff) {
                xOff = xOff || mx;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(120, 120, 120);
                doc.text(label, xOff, yp);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text(String(val), xOff, yp + 4);
                return yp;
            }
            function woCheckRow(text, yp) {
                doc.setDrawColor(180, 180, 180);
                doc.rect(mx + 1, yp - 2.5, 3, 3);
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(60, 60, 60);
                doc.text(text, mx + 7, yp);
                return yp + 5;
            }

            // ═══════════════════════════════════════
            // PAGE 1: JOB SUMMARY + VISUALS
            // ═══════════════════════════════════════
            let y = pdfHeader(doc, 'WORK ORDER', jobRef);

            // Client block with install date + crew blanks
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(60, 60, 60);
            var cName = getClientName(), cAddr = getSiteAddress(), cPhone = getClientPhone();
            doc.text('Client: ' + cName, mx, y);
            doc.text('Phone: ' + cPhone, 130, y);
            y += 5;
            if (cAddr) { doc.text('Address: ' + cAddr, mx, y); y += 5; }
            doc.text('Install Date: _______________', mx, y);
            doc.text('Crew: _______________', 130, y);
            y += 5;
            doc.setFontSize(8);
            doc.setTextColor(100, 100, 100);
            doc.text('ACCESS: ' + accessNotes, mx, y);
            y += 7;

            // THE BUILD box
            y = woSectionTitle('THE BUILD', y);
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(11);
            doc.setTextColor(...SW_ORANGE);
            doc.text(styleLabel + ' PATIO \u2014 ' + connLabel + ' Attachment', mx + 3, y + 1);
            y += 6;
            // Key-value grid
            var kvY = y;
            woKeyVal('Width', mm(Lmm), kvY, mx + 3);
            woKeyVal('Projection', mm(Wmm), kvY, mx + 42);
            woKeyVal('Pitch', c.pitch.toFixed(1) + '\u00B0', kvY, mx + 82);
            woKeyVal('Post Height', mm(postHmm) + ' above FFL', kvY, mx + 112);
            y = kvY + 10;
            woKeyVal('Roofing', roofLabel + ' \u2014 ' + sheetClr, y, mx + 3);
            woKeyVal('Frame', steelClr, y, mx + 82);
            woKeyVal('Post Fixing', isConc ? 'Concrete footings' : 'Baseplate', y, mx + 112);
            y += 10;
            if (c.isGable && infill !== 'none') {
                woKeyVal('Gable Infill', infill.charAt(0).toUpperCase() + infill.slice(1), y, mx + 3);
                y += 10;
            } else { y += 2; }

            // ── PLAN VIEW DIAGRAM ──
            y = woSectionTitle('PLAN VIEW', y);
            var planH = 56, planY = y + 2;
            var planMx = mx + 10, planMr = mr - 40;
            var planW = planMr - planMx;
            var planDepth = planH - 16;
            // Scale
            var scX = planW / Lmm, scY = planDepth / Wmm;
            var sc = Math.min(scX, scY) * 0.85;
            var drawW = Lmm * sc, drawD = Wmm * sc;
            var ox = planMx + (planW - drawW) / 2;
            var oy = planY + (planDepth - drawD) / 2 + 3;

            doc.setDrawColor(180, 180, 180);
            doc.setLineWidth(0.2);
            // House wall
            doc.setFillColor(220, 210, 195);
            doc.rect(ox - 2, oy - 5, drawW + 4, 4, 'F');
            doc.setFontSize(6);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(120, 120, 120);
            if (c.isAttached) doc.text('HOUSE', ox + drawW / 2, oy - 2, { align: 'center' });

            // Patio outline
            doc.setDrawColor(...SW_DARK);
            doc.setLineWidth(0.4);
            doc.rect(ox, oy, drawW, drawD);

            // Ridge line for gable
            if (c.isGable) {
                doc.setDrawColor(...SW_ORANGE);
                doc.setLineWidth(0.2);
                // Dashed ridge line
                var rdY = oy + drawD / 2;
                for (var dx = ox; dx < ox + drawW; dx += 3) {
                    doc.line(dx, rdY, Math.min(dx + 1.5, ox + drawW), rdY);
                }
                doc.setFontSize(5);
                doc.setTextColor(...SW_ORANGE);
                doc.text('RIDGE', ox + drawW + 2, oy + drawD / 2 + 1);
            }

            // Posts
            doc.setFillColor(...SW_DARK);
            var postR = 1.2;
            for (var pi = 0; pi < nPosts; pi++) {
                var px = ox + (pi / (nPosts - 1)) * drawW;
                // Back row
                doc.circle(px, oy, postR, 'F');
                // Front row (or same row for skillion)
                if (c.isGable) {
                    doc.circle(px, oy + drawD, postR, 'F');
                } else {
                    doc.circle(px, oy + drawD, postR, 'F');
                }
            }

            // Dimension labels
            doc.setFontSize(6);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(80, 80, 80);
            // Width
            doc.text(mm(Lmm), ox + drawW / 2, oy + drawD + 6, { align: 'center' });
            // Depth
            doc.text(mm(Wmm), ox - 5, oy + drawD / 2 + 1, { align: 'center', angle: 90 });
            // Post spacing
            if (nPosts > 1) {
                doc.setFontSize(5);
                doc.text(mm(postSpacing) + ' ctrs', ox + drawW / (nPosts - 1) / 2, oy + drawD + 10, { align: 'center' });
            }
            // Annotation
            doc.setFontSize(6);
            doc.setTextColor(120, 120, 120);
            doc.text('BACK BEAM ' + mm(Lmm) + ' (house side)', planMr + 5, oy + 2);
            doc.text('FRONT BEAM ' + mm(Lmm) + ' (post side)', planMr + 5, oy + drawD);
            doc.text(totalPosts + ' posts total', planMr + 5, oy + drawD / 2);
            y = planY + planH + 2;

            // ── CROSS SECTION DIAGRAM ──
            y = woSectionTitle('CROSS SECTION (looking along ridge)', y);
            var csH = 56, csY = y + 2;
            var csMx = mx + 25, csMr = mr - 25;
            var csW = csMr - csMx;
            // Scaled drawing area
            var maxH = Math.max(ridgeH, backBeamH, frontBeamH + (c.isGable ? c.rise : 0));
            var csScX = csW / Wmm;
            var csScY = (csH - 14) / maxH;
            var cssc = Math.min(csScX, csScY) * 0.8;
            var csOx = csMx + (csW - Wmm * cssc) / 2;
            var csGround = csY + csH - 6;

            doc.setDrawColor(160, 160, 160);
            doc.setLineWidth(0.3);
            // Ground line
            doc.setLineWidth(0.6);
            doc.line(csOx - 10, csGround, csOx + Wmm * cssc + 10, csGround);
            doc.setFontSize(5);
            doc.setTextColor(120, 120, 120);
            doc.text('FFL', csOx + Wmm * cssc + 12, csGround + 1);
            doc.setLineWidth(0.3);

            if (c.isGable) {
                // Left post
                var lpx = csOx;
                var lpy = csGround - frontBeamH * cssc;
                doc.setDrawColor(...SW_DARK);
                doc.line(lpx, csGround, lpx, lpy);
                // Right post
                var rpx = csOx + Wmm * cssc;
                doc.line(rpx, csGround, rpx, lpy);
                // Beams
                doc.setLineWidth(0.5);
                doc.line(lpx - 3, lpy, rpx + 3, lpy);
                // Ridge
                var ridgeX = csOx + (Wmm / 2) * cssc;
                var ridgeY = csGround - ridgeH * cssc;
                // Roof slopes
                doc.setDrawColor(...SW_ORANGE);
                doc.setLineWidth(0.4);
                doc.line(lpx, lpy, ridgeX, ridgeY);
                doc.line(rpx, lpy, ridgeX, ridgeY);
                // Ridge cap dot
                doc.setFillColor(...SW_ORANGE);
                doc.circle(ridgeX, ridgeY, 0.8, 'F');
                // Labels
                doc.setFontSize(5);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(80, 80, 80);
                doc.text(mm(postHmm), lpx - 5, csGround - postHmm * cssc / 2, { align: 'center', angle: 90 });
                doc.text(mm(Wmm), csOx + Wmm * cssc / 2, csGround + 4, { align: 'center' });
                doc.text(c.pitch.toFixed(1) + '\u00B0', ridgeX + 8, ridgeY + 6);
                doc.setTextColor(...SW_ORANGE);
                doc.text('RIDGE ' + mm(ridgeH), ridgeX, ridgeY - 2, { align: 'center' });
                doc.text(roofLabel, csOx + Wmm * cssc / 4, lpy - 3, { align: 'center' });
            } else {
                // Skillion
                var lpx2 = csOx;
                var rpx2 = csOx + Wmm * cssc;
                var frontY = csGround - frontBeamH * cssc;
                var backY = csGround - backBeamH * cssc;
                doc.setDrawColor(...SW_DARK);
                // Posts
                doc.line(rpx2, csGround, rpx2, frontY);
                doc.line(lpx2, csGround, lpx2, backY);
                // Beams
                doc.setLineWidth(0.5);
                doc.line(lpx2 - 3, backY, lpx2 + 3, backY);
                doc.line(rpx2 - 3, frontY, rpx2 + 3, frontY);
                // Roof
                doc.setDrawColor(...SW_ORANGE);
                doc.setLineWidth(0.4);
                doc.line(lpx2, backY, rpx2, frontY);
                // Labels
                doc.setFontSize(5);
                doc.setTextColor(80, 80, 80);
                doc.text(mm(postHmm), rpx2 + 4, csGround - postHmm * cssc / 2);
                doc.text(mm(Wmm), csOx + Wmm * cssc / 2, csGround + 4, { align: 'center' });
                doc.text(c.pitch.toFixed(1) + '\u00B0', csOx + Wmm * cssc / 2, Math.min(backY, frontY) - 2, { align: 'center' });
                doc.setTextColor(...SW_ORANGE);
                doc.text(roofLabel, csOx + Wmm * cssc / 2, (backY + frontY) / 2 - 2, { align: 'center' });
                doc.text('BACK ' + mm(backBeamH), lpx2 - 5, backY, { align: 'right' });
                doc.text('FRONT ' + mm(frontBeamH), rpx2 + 5, frontY);
            }

            pdfFooter(doc);

            // ═══════════════════════════════════════
            // PAGE 2: MATERIALS + CRITICAL DIMENSIONS
            // ═══════════════════════════════════════
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Materials & Dimensions', jobRef);

            // Materials checklist
            y = woSectionTitle('MATERIALS CHECKLIST \u2014 Check off when loaded', y);

            const mats = getMaterialRows();
            // Group materials by category
            var matGroups = { 'STRUCTURE': [], 'ROOFING': [], 'DRAINAGE': [], 'FINISHING': [], 'FIXINGS': [] };
            mats.forEach(m => {
                var d = m.desc.toLowerCase();
                if (d.includes('post') || d.includes('beam') || d.includes('truss') || d.includes('purlin') || d.includes('rafter') || d.includes('riser') || d.includes('bracket'))
                    matGroups['STRUCTURE'].push(m);
                else if (d.includes('sheet') || d.includes('ridge') || d.includes('solarspan') || d.includes('spanplus') || d.includes('trimdek') || d.includes('corrugat'))
                    matGroups['ROOFING'].push(m);
                else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow') || d.includes('dp '))
                    matGroups['DRAINAGE'].push(m);
                else
                    matGroups['FINISHING'].push(m);
            });
            // Always add fixings
            matGroups['FIXINGS'].push({ desc: 'Tek screws, rivets, clips, brackets', qty: 1, length: 0 });
            matGroups['FIXINGS'].push({ desc: 'Silicone (clear + colour match)', qty: 1, length: 0 });
            if (hasElectrical && downlights > 0)
                matGroups['FINISHING'].push({ desc: 'LED Downlights', qty: downlights, length: 0 });
            // Add flashings from profile editor
            if (flashingProfiles.length > 0) {
                flashingProfiles.forEach(function(fp) {
                    matGroups['FINISHING'].push({ desc: fp.name + ' (' + fp.girth + 'mm girth, ' + fp.colour + ')', qty: fp.qty, length: fp.length / 1000 });
                });
            }

            Object.entries(matGroups).forEach(function(entry) {
                var cat = entry[0], items = entry[1];
                if (!items.length) return;
                if (y + 8 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(7);
                doc.setTextColor(...SW_ORANGE);
                doc.text(cat, mx + 6, y);
                y += 4;
                items.forEach(function(m) {
                    if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                    var lenStr = m.length >= 0.1 ? Math.round(m.length * 1000) + 'mm' : '';
                    y = woCheckRow(m.qty + '\u00D7  ' + m.desc + (lenStr ? '    ' + lenStr : ''), y);
                });
                y += 2;
            });
            y += 4;

            // Critical dimensions
            if (y + 60 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
            y = woSectionTitle('CRITICAL DIMENSIONS (pre-calculated)', y);
            doc.setFont('courier', 'normal');
            doc.setFontSize(8);
            doc.setTextColor(...SW_DARK);
            var dimRows = [
                ['Post Cut Length', mm(postCut) + (isConc ? ' (' + mm(postHmm) + ' above FFL + 300 in ground)' : ' (above FFL)')],
                ['Front Beam Height', mm(frontBeamH) + ' above FFL'],
                ['Back Beam Height', mm(backBeamH) + ' above FFL']
            ];
            if (c.isGable) {
                dimRows.push(['Ridge Height', mm(ridgeH) + ' above FFL']);
                dimRows.push(['Rise', mm(riseMm) + ' (' + mm(Wmm) + ' \u00D7 tan ' + c.pitch.toFixed(1) + '\u00B0 \u00F7 2)']);
            } else {
                dimRows.push(['Rise (total)', mm(riseMm)]);
            }
            dimRows.push(['Sheet Length', mm(sheetLen)]);
            dimRows.push(['Post Spacing', mm(postSpacing) + ' centres']);
            if (c.isGable) dimRows.push(['Truss Spacing', mm(trussSpacing) + ' centres']);
            if (nPurlins > 0) dimRows.push(['Purlin Spacing', mm(purlinSpacing) + ' centres']);
            if (isConc) dimRows.push(['Footing Size', '450\u00D7450\u00D7600mm deep']);
            dimRows.push(['Diagonal Check', mm(diagonal) + ' (for square)']);

            dimRows.forEach(function(r) {
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(8);
                doc.setTextColor(100, 100, 100);
                doc.text(r[0] + ':', mx + 3, y);
                doc.setFont('courier', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text(r[1], mx + 55, y);
                y += 5;
            });

            pdfFooter(doc);

            // ═══════════════════════════════════════
            // PAGE 3: BUILD SEQUENCE
            // ═══════════════════════════════════════
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Build Sequence', jobRef);

            var steps = [];

            // 1. Set out
            steps.push({
                title: 'SET OUT',
                items: [
                    'Mark post positions from house wall',
                    'Front row: ' + mm(Wmm) + ' out from house',
                    'Spacing: ' + (function() { var s = []; for (var i = 0; i < nPosts; i++) s.push(mm(Math.round(i * postSpacing))); return s.join(', '); })() + ' from left',
                    'Check square: diagonal = ' + mm(diagonal)
                ]
            });

            // 2. Footings / baseplates
            if (isConc) {
                steps.push({
                    title: 'FOOTINGS',
                    items: [
                        'Dig ' + totalPosts + '\u00D7 holes: 450\u00D7450\u00D7600mm',
                        'Check depths, clear loose soil',
                        'Mix: 1 bag per hole'
                    ]
                });
            } else {
                steps.push({
                    title: 'BASEPLATES',
                    items: [
                        'Mark and drill ' + totalPosts + '\u00D7 baseplate positions',
                        'Fix with dynabolts to slab',
                        'Check alignment before tightening'
                    ]
                });
            }

            // 3. Posts
            steps.push({
                title: 'POSTS',
                items: isConc ? [
                    'Set ' + totalPosts + '\u00D7 posts in wet concrete',
                    'Plumb in both directions',
                    'Top of post: ' + mm(postHmm) + ' above FFL (measure twice)',
                    'Brace and allow to set'
                ] : [
                    'Fix ' + totalPosts + '\u00D7 posts to baseplates',
                    'Plumb in both directions',
                    'Top of post: ' + mm(postHmm) + ' above FFL'
                ]
            });

            // 4. Back beam
            if (c.isAttached) {
                var backDesc = c.connection === 'riser' ? 'Fix riser brackets at ' + mm(backBeamH) + ' above FFL' :
                               c.connection === 'flyover' ? 'Fix beam above house roof at ' + mm(backBeamH) + ' above FFL' :
                               'Fix to house at ' + mm(backBeamH) + ' above FFL';
                steps.push({
                    title: 'BACK BEAM (house connection)',
                    items: [
                        backDesc,
                        'Beam: ' + beamName + ' \u00D7 ' + mm(Lmm),
                        'Check level across full length'
                    ]
                });
            }

            // 5. Front beam
            steps.push({
                title: 'FRONT BEAM',
                items: [
                    'Beam: ' + beamName + ' \u00D7 ' + mm(Lmm),
                    'Fix to top of posts',
                    'Height: ' + mm(frontBeamH) + ' above FFL',
                    'Check level' + (c.isAttached ? ', check fall matches back beam' : '')
                ]
            });

            // 6. Trusses (gable/hip) or skip
            if (c.isGable) {
                steps.push({
                    title: 'TRUSSES',
                    items: [
                        nTruss + '\u00D7 trusses at ' + mm(trussSpacing) + ' centres',
                        'Fix to top of beams',
                        'Check plumb, apex aligned',
                        'Ridge height: ' + mm(ridgeH) + ' above FFL'
                    ]
                });
            }

            // 7. Purlins (if needed)
            if (nPurlins > 0) {
                steps.push({
                    title: 'PURLINS',
                    items: [
                        nPurlins + '\u00D7 purlins per ' + (c.isGable ? 'side' : 'slope') + ' at ' + mm(purlinSpacing) + ' centres',
                        'Run parallel to beams, across ' + (c.isGable ? 'trusses' : 'rafters'),
                        'Fix with tek screws'
                    ]
                });
            }

            // 8. Sheets
            steps.push({
                title: 'ROOFING SHEETS',
                items: [
                    totalSheets + '\u00D7 sheets @ ' + mm(sheetLen) + ' long',
                    'Start from left, work right',
                    '50mm overhang into gutter',
                    c.isGable ? '15mm gap at ridge for cap' : 'Fix with appropriate fasteners',
                    isInsulated(c.roofing) ? 'Fix with SolarSpan clips' : 'Fix with tek screws to purlins'
                ]
            });

            // 9. Ridge cap (gable only)
            if (c.isGable) {
                steps.push({
                    title: 'RIDGE CAP',
                    items: [
                        mm(Lmm + 100) + ' ridge cap',
                        'Seal both ends',
                        'Fix through to purlins/trusses'
                    ]
                });
            }

            // 10. Gable infill
            if (c.isGable && infill !== 'none') {
                steps.push({
                    title: 'GABLE INFILL',
                    items: [
                        infill.charAt(0).toUpperCase() + infill.slice(1) + ' infill',
                        'Cut to match pitch',
                        'Fix to end trusses',
                        'Seal edges with silicone'
                    ]
                });
            }

            // 11. Gutters
            steps.push({
                title: 'GUTTERS & DOWNPIPES',
                items: [
                    'Gutter: ' + mm(Lmm + 200) + ' with fall',
                    'Downpipe at end',
                    'Check water flows to DP'
                ]
            });

            // 12. Flashings
            var flashSteps = [];
            if (flashingProfiles.length > 0) {
                flashingProfiles.forEach(function(fp) {
                    flashSteps.push(fp.name + ' \u2014 ' + fp.girth + 'mm girth \u00D7 ' + fp.length + 'mm \u00D7 ' + fp.qty + ' (' + fp.colour + ', ' + fp.colourSide.toUpperCase() + ')');
                });
                flashSteps.push('Seal all junctions');
            } else {
                flashSteps = c.isGable ? [
                    'Barge rolls both ends',
                    'Apron at house wall',
                    'Seal all junctions'
                ] : [
                    'Back flashing at house wall',
                    'Barge rolls both ends',
                    'Seal all junctions'
                ];
            }
            steps.push({
                title: 'FLASHINGS',
                items: flashSteps
            });

            // 13. Electrical (if applicable)
            if (hasElectrical && downlights > 0) {
                steps.push({
                    title: 'ELECTRICAL',
                    items: [
                        downlights + '\u00D7 downlights as marked',
                        'Electrician to connect'
                    ]
                });
            }

            // 14. Final
            steps.push({
                title: 'FINAL',
                items: [
                    'Check all fixings tight',
                    'Clean up site',
                    'Take completion photos',
                    'Customer walkthrough'
                ]
            });

            // Render steps
            steps.forEach(function(step, si) {
                var needed = 8 + step.items.length * 4.5;
                if (y + needed > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }

                // Step number + title
                doc.setFillColor(245, 245, 247);
                doc.rect(mx, y, cw, 6, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(8);
                doc.setTextColor(...SW_DARK);
                doc.text((si + 1) + '. ' + step.title, mx + 3, y + 4);
                // Done checkbox on right
                doc.setDrawColor(180, 180, 180);
                doc.rect(mr - 15, y + 1, 3, 3);
                doc.setFontSize(6);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(150, 150, 150);
                doc.text('Done', mr - 11, y + 3.5);
                y += 8;

                // Items
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(60, 60, 60);
                step.items.forEach(function(item) {
                    doc.text('\u2022 ' + item, mx + 5, y);
                    y += 4.5;
                });
                y += 2;
            });

            pdfFooter(doc);

            // ═══════════════════════════════════════
            // PAGE 4: SIGN-OFF
            // ═══════════════════════════════════════
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Sign-Off', jobRef);

            // Completion checklist
            y = woSectionTitle('COMPLETION CHECKLIST', y);
            var checks = [
                'Structure plumb and level',
                'All fixings secure',
                'Roof sheets correctly lapped',
                c.isGable ? 'Ridge cap sealed' : 'Roof sealed at house junction',
                'Gutters fall to downpipe',
                'No visible gaps or defects',
                'Flashings sealed',
                'Site clean, rubbish removed',
                'Before photos taken',
                'After photos taken',
                'Customer walkthrough completed'
            ];
            checks.forEach(function(item) { y = woCheckRow(item, y); });
            y += 6;

            // Notes / Issues
            y = woSectionTitle('NOTES / ISSUES', y);
            doc.setDrawColor(200, 200, 200);
            for (var li = 0; li < 6; li++) {
                doc.line(mx + 3, y + 1, mr - 3, y + 1);
                y += 7;
            }
            y += 4;

            // Sign-off
            y = woSectionTitle('SIGN-OFF', y);
            y += 4;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(80, 80, 80);
            doc.text('Installer: ___________________________   Sign: _______________   Date: __________', mx + 3, y);
            y += 12;
            doc.text('Customer: ___________________________   Sign: _______________   Date: __________', mx + 3, y);
            y += 8;
            doc.setFontSize(8);
            doc.setTextColor(120, 120, 120);
            doc.setFont('helvetica', 'italic');
            doc.text('"I confirm the work has been completed to my satisfaction"', mx + 3, y);

            pdfFooter(doc);
            doc.save('WorkOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Work Order PDF: ' + e.message); console.error(e); }
        }

        // ==================== PDF: TRUSS ORDER ====================
        function exportTrussPDF() {
            if (!calc.isGable || !calc.trussData) {
                alert('Truss data only available for Gable roofs. Switch to Gable first.');
                return;
            }
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const td = calc.trussData;
            let y = pdfHeader(doc, 'Truss Fabrication Order', jobRef);
            y = pdfClientBlock(doc, y);

            // Truss image capture
            const img = captureTrussImage();
            if (img) {
                try {
                    doc.addImage(img, 'PNG', 14, y, 110, 55);
                    y += 58;
                } catch(e) { /* skip */ }
            }

            const lx = 14;
            const rw = 178;
            const lh = 5.5;

            function fabSection(title) {
                doc.setFillColor(...SW_ORANGE);
                doc.rect(lx, y, rw, 6, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                doc.setTextColor(255, 255, 255);
                doc.text('  ' + title, lx + 2, y + 4.5);
                y += 7;
            }
            function fabRow(label, value, bold) {
                doc.setFont('helvetica', bold ? 'bold' : 'normal');
                doc.setFontSize(10);
                doc.setTextColor(...SW_DARK);
                doc.text(label, lx + 4, y);
                doc.text(String(value), lx + rw - 4, y, { align: 'right' });
                y += lh;
            }

            fabSection('STEEL');
            fabRow('Profile', td.steelName + ' RHS');
            fabRow('Colour', td.clr);
            fabRow('BMT', td.bmt + 'mm');
            fabRow('Quantity', td.nTruss + ' trusses');
            y += 2;

            fabSection('DIMENSIONS');
            fabRow('SP (Span)', td.trussSpan + 'mm');
            fabRow('HT (Height)', td.rise + 'mm');
            fabRow('Pitch', td.pitch.toFixed(1) + '\u00B0');
            if (td.overhang > 0) fabRow('Overhang', td.overhang + 'mm');
            if (td.extender && td.extender.enabled) {
                fabRow('Extender', td.extender.length + 'mm (each end)');
            }
            y += 2;

            fabSection('CUT LIST (per truss)');
            fabRow('Chord', '1 \u00D7 ' + td.chordCut + 'mm', true);
            if (td.extender && td.extender.enabled) {
                fabRow('Extender', '2 \u00D7 ' + Math.round(td.extender.length) + 'mm');
            }
            fabRow('Rafters', '2 \u00D7 ' + td.rafterCut + 'mm', true);
            if (td.webMembers && td.webMembers.length > 0) {
                for (var wi = 0; wi < td.webMembers.length; wi++) {
                    var wm = td.webMembers[wi];
                    fabRow(wm.type, wm.count + ' \u00D7 ' + wm.length + 'mm');
                }
            }
            y += 2;

            fabSection('CUT ANGLES');
            fabRow('Apex Mitre', td.apexAngle.toFixed(1) + '\u00B0 (both rafters)');
            fabRow('Heel Mitre', td.heelAngle.toFixed(1) + '\u00B0 (rafter to chord)');
            y += 2;

            fabSection('MATERIAL REQUIRED');
            fabRow('Truss LM (each)', td.totalLM.toFixed(3) + ' LM');
            fabRow('All ' + td.nTruss + ' trusses', td.totalAllLM.toFixed(2) + ' LM', true);
            fabRow('Order length', td.totalSticks + ' \u00D7 6m sticks', true);

            // Risers (separate steel, bolted to truss ends)
            if (td.riserLeft && td.riserLeft.enabled) {
                y += 2;
                fabSection('RISERS (separate steel \u2013 bolted to truss ends)');
                fabRow('Left Riser', Math.round(td.riserLeft.length) + 'mm horiz + ' + Math.round(td.riserLeft.height) + 'mm vert');
                fabRow('Right Riser', Math.round(td.riserRight.length) + 'mm horiz + ' + Math.round(td.riserRight.height) + 'mm vert');
                fabRow('Riser steel (per pair)', (td.riserLeft.lm + td.riserRight.lm).toFixed(2) + ' LM');
                fabRow('Riser steel (all)', td.riserTotalLM.toFixed(2) + ' LM (' + td.nTruss + ' sets)', true);
            }

            pdfFooter(doc);
            doc.save('TrussOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Truss Order PDF: ' + e.message); console.error(e); }
        }

        function captureTrussImage() {
            try {
                if (trussRend && trussScene && trussCam) {
                    trussRend.render(trussScene, trussCam);
                    return trussRend.domElement.toDataURL('image/png');
                }
            } catch(e) {}
            return null;
        }

        function initPricing() {
            loadRates();
            renderRatesPanel();
            buildJobRows();
            // Set default labour day rate from stored rates
            const drEl = document.getElementById('labDayRate');
            if (drEl && storedRates['Skilled Trade']) drEl.value = storedRates['Skilled Trade'];
            updatePricing();
        }

        function rebuildAll() {
            getInputs();
            draw2DPlan();
            buildTruss3D();
            buildAsm3D();
            buildJobRows();
            updatePricing();
            updateEstimate();
            updateRightPanelSummary();
        }

        function exportOrder() {
            if (!window.jspdf) {
                alert('PDF library not loaded. Please check your internet connection and reload the page.');
                return;
            }
            const c = calc;
            if (!c.roofStyle) {
                alert('No design loaded. Please configure a patio design first.');
                return;
            }
            // Generate all key documents (each has its own error handling)
            generateQuotePDF();
            generateSteelOrderPDF();
            generateSheetsOrderPDF();
            generateFabricationOrderPDF();
            generateWorkOrderPDF();
        }

        // ==================== INIT ====================
        function resizeAsm() {
            const ac = document.getElementById('asmViewport');
            if (asmCam && asmRend && ac && !ac.classList.contains('fullscreen')) {
                var w = ac.clientWidth, h = ac.clientHeight;
                if (w > 0 && h > 0) {
                    asmCam.aspect = w / h;
                    asmCam.updateProjectionMatrix();
                    asmRend.setSize(w, h);
                }
            }
        }
        function resizeTruss() {
            const tc = document.getElementById('trussViewport');
            if (trussCam && trussRend && tc) {
                var w = tc.clientWidth, h = tc.clientHeight;
                if (w > 0 && h > 0) {
                    trussCam.aspect = w / h;
                    trussCam.updateProjectionMatrix();
                    trussRend.setSize(w, h);
                }
            }
        }
        window.addEventListener('resize', () => {
            resizeTruss();
            resizeAsm();
            draw2DPlan();
            resizeFlashCanvas();
            drawFlashCanvas();
        });
        // ResizeObserver for container-specific resize (layout changes, panel toggle)
        if (typeof ResizeObserver !== 'undefined') {
            var ro = new ResizeObserver(function() {
                resizeAsm();
                resizeTruss();
                draw2DPlan();
                resizeFlashCanvas();
                drawFlashCanvas();
            });
            var asmEl = document.getElementById('asmViewport');
            var trussEl = document.getElementById('trussViewport');
            var rpEl = document.getElementById('panelRight');
            var flashEl = document.getElementById('flashViewport');
            if (asmEl) ro.observe(asmEl);
            if (trussEl) ro.observe(trussEl);
            if (rpEl) ro.observe(rpEl);
            if (flashEl) ro.observe(flashEl);
        }

        // ==================== LAYOUT TOGGLE ====================
        function toggleLayout() {
            var main = document.getElementById('mainLayout');
            var btn = document.getElementById('layoutToggle');
            var isFullWidth = main.classList.toggle('full-width');
            btn.innerHTML = isFullWidth ? '&#9704; Show Preview' : '&#9703; Full Width';
            localStorage.setItem('patioLayout', isFullWidth ? 'full' : 'split');
            // Resize canvases after layout change — multiple delays for CSS transition
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 50);
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 200);
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 500);
        }

        function initLayout() {
            var pref = localStorage.getItem('patioLayout');
            if (pref === 'full') {
                document.getElementById('mainLayout').classList.add('full-width');
                document.getElementById('layoutToggle').innerHTML = '&#9704; Show Preview';
            }
        }

        // initRightPanel3D removed — single renderer now in right panel via initAsm3D

        function updateRightPanelSummary() {
            var c = calc;
            if (!c || !c.L) return;
            var rpDims = document.getElementById('rpDims');
            var rpRoof = document.getElementById('rpRoofType');
            var rpMat = document.getElementById('rpMaterial');
            var rpClr = document.getElementById('rpColour');
            if (rpDims) rpDims.textContent = (c.lenInput / 1000).toFixed(1) + 'm × ' + (c.projInput / 1000).toFixed(1) + 'm';
            if (rpRoof) rpRoof.textContent = c.roofStyle === 'hip' ? 'Hip' : (c.isGable ? 'Gable' : 'Skillion');
            if (rpMat) rpMat.textContent = (ROOFING_TYPES[c.roofing] || ROOFING_TYPES.corrugated).name;
            if (rpClr) rpClr.textContent = sheetColor.name;

            // Estimate now writes directly to rpEstSqm/rpEstRange via updateEstimate()
        }

        // Initialize
        initLayout();
        initCollapseSections();
        initJobDetails();
        updateUI();
        initTruss3D();
        initAsm3D();
        initPricing();
        initFlashingEditor();
        rebuildAll();
        // Deferred resize to ensure renderers sync after DOM settles
        function deferredResize() {
            resizeAsm(); resizeTruss(); draw2DPlan(); resizeFlashCanvas(); drawFlashCanvas();
        }
        requestAnimationFrame(deferredResize);
        setTimeout(deferredResize, 200);
        setTimeout(deferredResize, 500);
    </script>
</body>
</html>
