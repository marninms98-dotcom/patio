
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureWorks WA - Patio Designer Pro V18</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js"></script>
    <style>
        :root {
            --sw-orange: #F15A29;
            --sw-blue-dark: #293C46;
            --sw-white: #FFFFFF;
            --sw-bg: #F5F5F7;
            --sw-border: #E5E5E5;
            --sw-text: #1D1D1F;
            --sw-text-sec: #86868B;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: var(--sw-bg);
            color: var(--sw-text);
        }
        .header {
            background: var(--sw-white);
            border-bottom: 1px solid var(--sw-border);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo { display: flex; align-items: center; gap: 8px; }
        .logo-icon {
            width: 32px; height: 32px;
            background: var(--sw-orange);
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
        }
        .logo-icon svg { width: 18px; height: 18px; fill: white; }
        .logo-text { font-size: 16px; font-weight: 600; }
        .logo-text span { color: var(--sw-orange); }
        .job-badge { background: var(--sw-bg); padding: 6px 14px; border-radius: 16px; font-size: 13px; }
        .job-badge strong { color: var(--sw-orange); }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }
        .btn-primary { background: var(--sw-orange); color: white; }
        .btn-secondary { background: var(--sw-bg); color: var(--sw-text); border: 1px solid var(--sw-border); }
        .main { max-width: 1400px; margin: 0 auto; padding: 24px; display: flex; gap: 24px; align-items: flex-start; }
        .panel-left { flex: 0 0 45%; min-width: 0; overflow-y: auto; max-height: calc(100vh - 80px); }
        .panel-right { flex: 0 0 calc(55% - 24px); position: sticky; top: 80px; max-height: calc(100vh - 100px); overflow-y: auto; height: fit-content; }
        .main.full-width .panel-left { flex: 0 0 100%; max-height: none; }
        .main.full-width .panel-right { display: none; }
        /* Right panel cards */
        .rp-card { background: var(--sw-white); border-radius: 12px; box-shadow: 0 1px 8px rgba(0,0,0,0.04); overflow: hidden; margin-bottom: 16px; }
        .rp-card-hdr { padding: 12px 16px; border-bottom: 1px solid var(--sw-border); font-size: 14px; font-weight: 600; }
        .rp-card-body { padding: 16px; }
        .rp-summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .rp-summary-item { background: var(--sw-bg); border-radius: 8px; padding: 8px 10px; }
        .rp-summary-label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); }
        .rp-summary-value { font-size: 14px; font-weight: 600; font-family: 'SF Mono', monospace; }
        .rp-est-range { font-size: 20px; font-weight: 700; font-family: 'SF Mono', monospace; text-align: center; padding: 8px 0; }
        .rp-est-label { font-size: 11px; color: var(--sw-text-sec); text-align: center; }
        .rp-est-btn { margin-top: 12px; }
        .rp-est-btn .btn { width: 100%; text-align: center; }
        .section {
            background: var(--sw-white);
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 1px 8px rgba(0,0,0,0.04);
            overflow: hidden;
        }
        .section-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--sw-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .section-title { font-size: 14px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        .section-subtitle { font-size: 12px; color: var(--sw-text-sec); }
        .section-body { padding: 16px; }

        /* Basics section (always expanded) */
        .basics-hdr { padding: 12px 16px; border-bottom: 1px solid var(--sw-border); display: flex; justify-content: space-between; align-items: center; }
        .basics-group { margin-bottom: 0; }
        .basics-group-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .basics-divider { height: 1px; background: var(--sw-border); margin: 14px 0; }
        .basics-grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        .basics-grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .basics-grid-4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 8px; }
        .basics-field label { font-size: 11px; font-weight: 500; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .basics-field input, .basics-field select, .basics-field textarea { width: 100%; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 12px; }
        .basics-field input:focus, .basics-field select:focus { outline: none; border-color: var(--sw-orange); }
        .basics-colours { display: flex; gap: 24px; align-items: flex-start; }
        .basics-colour-block { flex: 1; }
        .basics-colour-label { font-size: 10px; color: var(--sw-text-sec); margin-bottom: 4px; }
        .extras-cost { margin-top: 6px; }
        .extras-cost label { font-size: 10px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .extras-cost input { width: 100%; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 12px; }

        .setup-grid { display: grid; grid-template-columns: 320px 1fr 280px; gap: 20px; }
        .options-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 16px; }
        .setup-card { background: var(--sw-bg); border-radius: 10px; padding: 14px; }
        .setup-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 10px; }
        .field { margin-bottom: 10px; }
        .field-label { display: flex; justify-content: space-between; font-size: 12px; font-weight: 500; margin-bottom: 3px; }
        .field-unit { font-size: 10px; color: var(--sw-text-sec); }
        .field-input { width: 100%; padding: 7px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; }
        .field-input:focus { outline: none; border-color: var(--sw-orange); }
        .field-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .plan-2d { background: #EEF1F4; border-radius: 8px; height: 220px; }
        .plan-2d canvas { width: 100%; height: 100%; }
        .color-chips { display: flex; flex-wrap: wrap; gap: 5px; }
        .color-chip { width: 24px; height: 24px; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
        .color-chip.active { border-color: var(--sw-text); }
        .color-label { font-size: 11px; color: var(--sw-text-sec); margin-top: 6px; }
        .calc-display { background: var(--sw-blue-dark); border-radius: 8px; padding: 10px; margin-top: 10px; color: white; }
        .calc-row { display: flex; justify-content: space-between; font-size: 11px; padding: 3px 0; }
        .calc-label { opacity: 0.7; }
        .calc-value { font-weight: 600; font-family: 'SF Mono', monospace; color: var(--sw-orange); }

        .truss-viewport { background: linear-gradient(180deg, #E0E4E8 0%, #CED4DA 100%); border-radius: 10px; height: 320px; position: relative; }
        .truss-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .truss-viewport canvas:active { cursor: grabbing; }
        .truss-view-btns { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.9); padding: 3px; border-radius: 6px; }
        .truss-view-btn { padding: 5px 10px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .truss-view-btn.active { background: var(--sw-blue-dark); color: white; }
        .truss-panel-vertical { display: flex; flex-direction: column; gap: 12px; margin-top: 12px; }
        .truss-cards-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        .truss-card { background: var(--sw-bg); border-radius: 10px; padding: 12px; }
        .truss-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .spec-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .spec-item { background: white; border-radius: 6px; padding: 8px; text-align: center; }
        .spec-label { font-size: 9px; color: var(--sw-text-sec); }
        .spec-value { font-size: 15px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .spec-value.hl { color: var(--sw-orange); }
        .fab-box { background: var(--sw-blue-dark); border-radius: 10px; padding: 12px; color: white; }
        .fab-box h4 { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; margin-bottom: 8px; }
        .fab-line { font-family: 'SF Mono', monospace; font-size: 11px; padding: 4px 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-bottom: 2px; }
        .truss-config { display: flex; gap: 12px; padding: 8px 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; }
        .truss-config-item { display: flex; align-items: center; gap: 6px; }
        .truss-config-item > label { font-size: 11px; font-weight: 600; color: var(--sw-text); display: flex; align-items: center; gap: 4px; cursor: pointer; white-space: nowrap; }
        .truss-config-item input[type="checkbox"] { accent-color: var(--sw-orange); }
        .truss-opt-fields { display: flex; gap: 6px; align-items: center; }
        .truss-opt-fields label { font-size: 10px; color: var(--sw-text-sec); display: flex; align-items: center; gap: 3px; white-space: nowrap; }
        .truss-opt-fields input[type="number"] { width: 52px; font-size: 11px; padding: 2px 4px; border: 1px solid var(--sw-border); border-radius: 4px; }
        .truss-opt-fields span { font-size: 9px; color: var(--sw-text-sec); }

        .asm-viewport { height: 520px; background: linear-gradient(180deg, #D4D9E0 0%, #BCC4CC 100%); border-radius: 10px; position: relative; }
        .asm-viewport canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        .asm-viewport canvas:active { cursor: grabbing; }
        .asm-viewport.fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100vw; height: 100vh; z-index: 1000; border-radius: 0; }
        .layer-panel { position: absolute; top: 12px; left: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; min-width: 140px; }
        .layer-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .layer-item { display: flex; align-items: center; gap: 6px; padding: 4px 0; cursor: pointer; font-size: 11px; }
        .layer-check { width: 14px; height: 14px; border: 2px solid var(--sw-border); border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 9px; color: white; }
        .layer-item.active .layer-check { background: var(--sw-orange); border-color: var(--sw-orange); }
        .layer-item.active .layer-check::after { content: '✓'; }
        .mat-panel { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; width: 200px; }
        .mat-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .mat-row { display: flex; justify-content: space-between; font-size: 10px; padding: 3px 0; border-bottom: 1px solid var(--sw-border); }
        .mat-row:last-child { border-bottom: none; }
        .mat-qty { font-weight: 600; color: var(--sw-orange); }
        .view-panel { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.95); padding: 3px; border-radius: 6px; }
        .view-btn { padding: 5px 12px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .view-btn.active { background: var(--sw-blue-dark); color: white; }
        .fullscreen-btn { position: absolute; top: 12px; right: 230px; background: rgba(255,255,255,0.95); border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; font-size: 11px; }
        .tooltip { position: absolute; background: rgba(41,60,70,0.95); color: white; padding: 10px 14px; border-radius: 8px; font-size: 11px; pointer-events: none; opacity: 0; transition: opacity 0.15s; z-index: 50; max-width: 240px; }
        .tooltip.visible { opacity: 1; }
        .tooltip-title { font-weight: 600; font-size: 12px; color: var(--sw-orange); margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .tooltip-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .tooltip-label { opacity: 0.7; }
        .tooltip-value { font-weight: 500; font-family: 'SF Mono', monospace; }

        /* Polycarb preview blocks */
        .pc-block { width: 16px; height: 20px; border-radius: 2px; border: 1px solid #ccc; }
        .pc-block.steel { background: #6B7B8D; border-color: #5A6A7C; }
        .pc-block.polycarb { border-color: #8ECAE6; }

        /* Pricing Section - Card Layout */
        .pricing-cards-container { display: flex; flex-direction: column; gap: 24px; }
        .q-card { background: #fff; border-radius: 8px; padding: 20px 24px; box-shadow: 0 1px 4px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04); }
        .q-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .q-card-title { font-size: 15px; font-weight: 600; color: var(--sw-text); display: flex; align-items: center; gap: 8px; }
        .q-card-title .status-ok { color: #34C759; }
        .q-card-title .status-warn { color: #FF9500; }
        .q-card-amount { font-size: 22px; font-weight: 700; font-family: 'SF Mono', monospace; color: var(--sw-text); }
        .q-card-sub { font-size: 13px; color: var(--sw-text-sec); margin-bottom: 0; }
        .q-card-edit { font-size: 13px; color: var(--sw-orange); cursor: pointer; font-weight: 500; background: none; border: none; padding: 0; }
        .q-card-edit:hover { text-decoration: underline; }
        /* Labour inline */
        .labour-inline { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
        .labour-inline .li-input { width: 60px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: center; }
        .labour-inline .li-input:focus { outline: none; border-color: var(--sw-orange); }
        .labour-inline .li-input.wide { width: 80px; }
        .labour-inline .li-label { font-size: 13px; color: var(--sw-text-sec); }
        .labour-inline .li-equals { font-size: 14px; font-weight: 600; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .labour-sell-row { display: flex; align-items: center; gap: 10px; margin-top: 10px; padding-top: 10px; border-top: 1px solid #f0f0f0; }
        .labour-sell-row label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .labour-sell-row input { width: 120px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: right; }
        .labour-sell-row input:focus { outline: none; border-color: var(--sw-orange); }
        /* Extras pills & rows */
        .extras-pills { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
        .extras-pill { padding: 7px 14px; border-radius: 20px; border: 1px solid var(--sw-border); background: #fff; font-size: 13px; cursor: pointer; color: var(--sw-text); transition: all 0.15s; }
        .extras-pill:hover { border-color: var(--sw-orange); color: var(--sw-orange); background: #FFF5F0; }
        .extras-rows { margin-top: 16px; display: flex; flex-direction: column; gap: 8px; }
        .extras-row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #f9f9f9; border-radius: 6px; border: 1px solid #f0f0f0; }
        .extras-row .ex-desc { flex: 1; font-size: 13px; font-weight: 500; color: var(--sw-text); }
        .extras-row .ex-field { display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--sw-text-sec); }
        .extras-row .ex-input { width: 80px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: right; }
        .extras-row .ex-input:focus { outline: none; border-color: var(--sw-orange); }
        .extras-row .ex-input.desc-input { width: 160px; text-align: left; font-family: inherit; }
        .extras-row .ex-remove { background: none; border: none; color: #ccc; cursor: pointer; font-size: 18px; padding: 0 4px; line-height: 1; transition: color 0.15s; }
        .extras-row .ex-remove:hover { color: #FF3B30; }
        /* Total card */
        .total-card { background: #fff; border-radius: 8px; padding: 28px 24px; box-shadow: 0 1px 4px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04); text-align: center; }
        .total-amount { font-size: 32px; font-weight: 800; font-family: 'SF Mono', monospace; color: var(--sw-text); letter-spacing: -0.5px; }
        .total-label { font-size: 13px; color: var(--sw-text-sec); margin-top: 2px; }
        .total-margin { font-size: 14px; font-weight: 600; margin-top: 10px; font-family: 'SF Mono', monospace; }
        .total-margin.margin-green { color: #34C759; }
        .total-margin.margin-orange { color: #FF9500; }
        .total-margin.margin-red { color: #FF3B30; }
        .btn-generate-quote { display: block; width: 100%; padding: 14px; border: none; border-radius: 8px; background: #F26522; color: white; font-size: 15px; font-weight: 600; cursor: pointer; margin-top: 20px; letter-spacing: 0.3px; transition: background 0.15s; }
        .btn-generate-quote:hover { background: #e05a1a; }
        .total-links { display: flex; justify-content: center; gap: 24px; margin-top: 14px; }
        .total-links a { font-size: 13px; color: var(--sw-text-sec); cursor: pointer; text-decoration: none; }
        .total-links a:hover { color: var(--sw-orange); }
        /* Settings gear */
        .settings-gear { background: none; border: none; cursor: pointer; font-size: 16px; color: var(--sw-text-sec); padding: 4px; transition: color 0.15s; }
        .settings-gear:hover { color: var(--sw-orange); }
        /* Materials modal */
        .mat-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .mat-modal { background: white; border-radius: 12px; padding: 24px; max-width: 800px; width: 95%; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .mat-modal h3 { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
        .mat-modal-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; }
        .mat-modal-controls label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .mat-modal-controls input { width: 60px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: center; }
        .mat-modal-controls input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-controls .btn-apply { padding: 6px 14px; border-radius: 6px; border: 1px solid var(--sw-orange); background: #FFF5F0; color: var(--sw-orange); font-size: 12px; font-weight: 500; cursor: pointer; }
        .mat-modal-controls .btn-apply:hover { background: var(--sw-orange); color: white; }
        .mat-modal-controls .toggle-wrap { display: flex; align-items: center; gap: 6px; margin-left: auto; }
        .mat-modal-controls .toggle-wrap input[type="checkbox"] { accent-color: var(--sw-orange); }
        .mat-modal-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .mat-modal-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 8px 8px; border-bottom: 2px solid var(--sw-border); }
        .mat-modal-table th.r { text-align: right; }
        .mat-modal-table td { padding: 6px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; vertical-align: middle; }
        .mat-modal-table td.r { text-align: right; }
        .mat-modal-table td.mono { font-family: 'SF Mono', monospace; font-size: 12px; }
        .mat-modal-table tr:last-child td { border-bottom: none; }
        .mat-modal-table input { width: 80px; padding: 5px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .mat-modal-table input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-table .markup-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 500; background: #E8F5E9; color: #2E7D32; }
        .mat-modal-table .markup-badge.custom { background: #FFF3E0; color: #E65100; }
        .mat-modal-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--sw-border); }
        .mat-modal-footer .mat-total { font-size: 16px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .mat-modal-footer .btn-done { padding: 10px 28px; border-radius: 6px; border: none; background: var(--sw-orange); color: white; font-size: 14px; font-weight: 500; cursor: pointer; }
        .mat-modal-footer .btn-done:hover { background: #e05a1a; }
        .mat-modal-footer .btn-add-custom { padding: 8px 16px; border-radius: 6px; border: 1px dashed var(--sw-border); background: none; font-size: 12px; color: var(--sw-text-sec); cursor: pointer; }
        .mat-modal-footer .btn-add-custom:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        /* Rates modal */
        .rates-modal { background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .rates-modal h3 { font-size: 16px; font-weight: 600; margin-bottom: 16px; }
        .rate-input { width: 80px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .rate-input:focus { outline: none; border-color: var(--sw-orange); }
        .pricing-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .pricing-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 6px 8px; border-bottom: 2px solid var(--sw-border); }
        .pricing-table td { padding: 5px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; }
        .pricing-table th.r, .pricing-table td.r { text-align: right; }
        .pricing-table tr:last-child td { border-bottom: none; }
        /* Hidden elements for PDF compatibility */
        .pdf-data { display: none; }
        /* Collapsible sections */
        .collapse-header { padding: 12px 20px; border-bottom: 1px solid var(--sw-border); display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
        .collapse-header:hover { background: var(--sw-bg); }
        .collapse-header .section-title { font-size: 15px; font-weight: 600; }
        .collapse-header .section-subtitle { font-size: 11px; color: var(--sw-text-sec); }
        .collapse-arrow { font-size: 12px; color: var(--sw-text-sec); transition: transform 0.25s ease; flex-shrink: 0; margin-left: 12px; }
        .collapse-header.collapsed .collapse-arrow { transform: rotate(-90deg); }
        .collapse-header.collapsed { border-bottom: none; }
        .collapse-body { overflow: hidden; transition: max-height 0.35s ease, opacity 0.25s ease; max-height: 2000px; opacity: 1; }
        .collapse-body.shut { max-height: 0; opacity: 0; padding-top: 0; padding-bottom: 0; }
        /* Import/Export modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .modal-box { background: white; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .modal-box h3 { font-size: 16px; margin-bottom: 12px; }
        .modal-box textarea { width: 100%; height: 200px; font-family: 'SF Mono', monospace; font-size: 11px; border: 1px solid var(--sw-border); border-radius: 6px; padding: 10px; resize: vertical; }
        .modal-box textarea:focus { outline: none; border-color: var(--sw-orange); }
        .modal-btns { display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end; }
        .modal-status { font-size: 12px; color: #34C759; margin-top: 8px; min-height: 18px; }
        .job-details-grid { display: grid; grid-template-columns: 140px 1fr 1fr 150px 150px 140px; gap: 10px; align-items: end; }
        .job-details-grid label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .job-details-grid input, .job-details-grid select { width: 100%; font-size: 12px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-family: inherit; }
        .job-details-grid input:focus, .job-details-grid select:focus { outline: none; border-color: var(--sw-orange); }
        .job-ref-input { font-family: 'SF Mono', monospace !important; font-weight: 600; color: var(--sw-orange); }
        /* Notes card */
        .notes-inline { margin-top: 12px; }
        .notes-inline textarea { width: 100%; padding: 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; min-height: 60px; }
        .notes-inline textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Customer details section */
        .customer-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
        .customer-grid label { font-size: 12px; font-weight: 500; margin-bottom: 4px; display: block; }
        .customer-grid input { width: 100%; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; }
        .customer-grid input:focus { outline: none; border-color: var(--sw-orange); }
        /* Site details subsection */
        .site-details { background: var(--sw-bg); border-radius: 10px; padding: 16px 20px; margin-top: 16px; }
        .site-details-label { font-size: 13px; font-weight: 600; margin-bottom: 4px; }
        .site-details-hint { font-size: 11px; color: var(--sw-text-sec); margin-bottom: 14px; }
        .site-details-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 14px; }
        .radio-group-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .radio-options { display: flex; flex-wrap: wrap; gap: 4px; }
        .radio-pill input[type="radio"] { display: none; }
        .radio-pill span { display: inline-block; padding: 4px 10px; font-size: 12px; border: 1px solid var(--sw-border); border-radius: 16px; cursor: pointer; background: var(--sw-white); transition: all 0.15s; }
        .radio-pill input[type="radio"]:checked + span { background: var(--sw-orange); color: white; border-color: var(--sw-orange); }
        .site-notes-wrap { grid-column: 1 / -1; }
        .site-notes-wrap textarea { width: 100%; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; }
        .site-notes-wrap textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Estimate Options section */
        .estimate-cards { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .est-card { border-radius: 10px; padding: 20px; display: flex; flex-direction: column; }
        .est-card--quick { background: var(--sw-bg); }
        .est-card--full { background: var(--sw-white); border: 1px solid var(--sw-border); }
        .est-card-icon { font-size: 20px; margin-bottom: 4px; }
        .est-card-title { font-size: 15px; font-weight: 700; margin-bottom: 2px; }
        .est-card-desc { font-size: 12px; color: var(--sw-text-sec); line-height: 1.4; }
        .est-card-divider { border: none; border-top: 1px solid var(--sw-border); margin: 14px 0; }
        .est-card-stat { font-size: 13px; color: var(--sw-text-sec); margin-bottom: 2px; }
        .est-card-range { font-size: 22px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .est-card-gst { font-size: 11px; color: var(--sw-text-sec); }
        .est-card-btn { margin-top: auto; padding-top: 16px; }
        .est-card-btn .btn { width: 100%; text-align: center; }
        .est-hint { font-size: 12px; color: var(--sw-text-sec); margin-top: 16px; }
        /* Detailed Configuration groups */
        .cfg-group { border: 1px solid var(--sw-border); border-radius: 8px; margin-bottom: 8px; overflow: hidden; }
        .cfg-group:last-child { margin-bottom: 0; }
        .cfg-group-hdr { display: flex; align-items: center; gap: 8px; padding: 10px 14px; cursor: pointer; user-select: none; background: var(--sw-bg); font-size: 13px; font-weight: 600; }
        .cfg-group-hdr:hover { background: #ECECEE; }
        .cfg-group-arrow { font-size: 10px; color: var(--sw-text-sec); transition: transform 0.2s; }
        .cfg-group-arrow.open { transform: rotate(90deg); }
        .cfg-group-num { color: var(--sw-text-sec); font-size: 11px; font-weight: 500; }
        .cfg-group-body { display: none; }
        .cfg-group-body.open { display: block; }
        .cfg-group-body .mat-hdr { display: grid; grid-template-columns: 1fr 50px 130px 60px 120px; gap: 4px; padding: 5px 14px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); border-bottom: 1px solid var(--sw-border); }
        .cfg-group-body .mat-row { display: grid; grid-template-columns: 1fr 50px 130px 60px 120px; gap: 4px; font-size: 12px; padding: 6px 14px; border-bottom: 1px solid #f0f0f0; align-items: baseline; }
        .cfg-group-body .mat-row:last-child { border-bottom: none; }
        .cfg-group-body .mat-qty { font-weight: 600; color: var(--sw-orange); font-family: 'SF Mono', monospace; font-size: 11px; text-align: right; }
        .cfg-group-body .mat-size { font-size: 11px; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .cfg-group-body .mat-len { font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; }
        .cfg-group-body .mat-clr { font-size: 11px; color: var(--sw-text-sec); }
        .cfg-group-empty { padding: 10px 14px; font-size: 12px; color: var(--sw-text-sec); font-style: italic; }
        /* Pre-order checks */
        .preorder-box { background: var(--sw-bg); border-radius: 8px; padding: 12px 16px; margin-bottom: 16px; }
        .preorder-title { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .preorder-item { font-size: 13px; padding: 3px 0; display: flex; align-items: center; gap: 6px; }
        .preorder-ok { color: #22c55e; }
        .preorder-warn { color: #f59e0b; }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon"><svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg></div>
            <div class="logo-text">Secure<span>Works</span> WA</div>
        </div>
        <div class="job-badge" id="headerBadge"><strong>SW—</strong></div>
        <div style="display:flex;gap:8px">
            <button class="btn btn-secondary" id="layoutToggle" onclick="toggleLayout()">&#9703; Full Width</button>
            <button class="btn btn-secondary" onclick="showLoadJobModal()">Load Job</button>
            <button class="btn btn-primary" onclick="exportOrder()">Export Order</button>
        </div>
    </header>

    <main class="main" id="mainLayout">
        <div class="panel-left">

        <!-- ============ SECTION: BASICS (always expanded) ============ -->
        <div class="section" id="sec-basics">
            <div class="basics-hdr">
                <div class="section-title">Basics</div>
                <div style="display:flex;gap:6px">
                    <button class="btn btn-secondary" style="font-size:11px;padding:5px 10px" onclick="exportJobData()">Export</button>
                    <button class="btn btn-secondary" style="font-size:11px;padding:5px 10px" onclick="showImportModal()">Import</button>
                </div>
            </div>
            <div class="section-body">

                <!-- ROW 1: Job Details -->
                <div class="basics-group">
                    <div class="basics-group-title">Job Details</div>
                    <div class="basics-grid-3">
                        <div class="basics-field">
                            <label>Job Ref</label>
                            <input type="text" id="jobRef" placeholder="SW250208-01">
                        </div>
                        <div class="basics-field">
                            <label>Salesperson</label>
                            <select id="salesperson">
                                <option value="Nithin">Nithin</option>
                                <option value="Marnin">Marnin</option>
                                <option value="Other">Other</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Email</label>
                            <input type="text" id="clientEmail" placeholder="client@email.com">
                        </div>
                    </div>
                    <div class="basics-grid-4" style="margin-top:6px">
                        <div class="basics-field">
                            <label>Customer Name</label>
                            <input type="text" id="customerName" placeholder="Full name" oninput="updateCustomer()">
                        </div>
                        <div class="basics-field" style="grid-column:span 2">
                            <label>Address</label>
                            <input type="text" id="customerAddress" placeholder="Street, suburb, postcode" oninput="updateCustomer()">
                        </div>
                        <div class="basics-field">
                            <label>Phone</label>
                            <input type="text" id="customerPhone" placeholder="0412 345 678" oninput="updateCustomer()">
                        </div>
                    </div>
                    <!-- Hidden fields for save/load compatibility -->
                    <input type="hidden" id="clientName"><input type="hidden" id="siteAddress"><input type="hidden" id="clientPhone">
                </div>

                <div class="basics-divider"></div>

                <!-- ROW 2: Patio Size -->
                <div class="basics-group">
                    <div class="basics-group-title">Patio Size</div>
                    <div class="basics-grid-4">
                        <div class="basics-field">
                            <label>Projection <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                            <input type="number" id="inWidth" value="3" step="0.1" oninput="rebuildAll()">
                        </div>
                        <div class="basics-field">
                            <label>Length <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                            <input type="number" id="inLength" value="6" step="0.1" oninput="rebuildAll()">
                        </div>
                        <div class="basics-field">
                            <label>Post Height <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                            <input type="number" id="inPostHeight" value="2.4" step="0.1" oninput="rebuildAll()">
                        </div>
                        <div class="basics-field" id="pitchField">
                            <label>Pitch <span style="color:var(--sw-text-sec);font-size:9px">&deg;</span></label>
                            <input type="number" id="inPitch" value="10" step="0.5" oninput="rebuildAll()">
                        </div>
                    </div>
                </div>

                <div class="basics-divider"></div>

                <!-- ROW 3: Build Type -->
                <div class="basics-group">
                    <div class="basics-group-title">Build Type</div>
                    <div class="basics-grid-4">
                        <div class="basics-field">
                            <label>Roof Style</label>
                            <select id="inRoofStyle" onchange="updateUI(); rebuildAll()">
                                <option value="gable">Gable</option>
                                <option value="skillion">Skillion</option>
                                <option value="hip">Hip</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Attachment</label>
                            <select id="inConnection" onchange="updateUI(); rebuildAll()">
                                <option value="riser">Riser Beam</option>
                                <option value="flyover">Flyover</option>
                                <option value="freestanding">Freestanding</option>
                                <option value="fascia">Fascia / Receiving</option>
                                <option value="wall">Wall Mount</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Material</label>
                            <select id="inRoofing" onchange="updateUI(); rebuildAll()">
                                <option value="solarspan75">SolarSpan 75mm</option>
                                <option value="solarspan100">SolarSpan 100mm</option>
                                <option value="trimdek">Trimdek</option>
                                <option value="corrugated">Corrugated</option>
                                <option value="spanplus330">SpanPlus 330</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Post Fixing</label>
                            <select id="inPostFix">
                                <option value="concrete">In-ground (concrete footings)</option>
                                <option value="baseplate">Baseplate (bolt to slab)</option>
                            </select>
                        </div>
                    </div>
                    <!-- Conditional: Ceiling Finish (SolarSpan only) -->
                    <div class="basics-grid-4" style="margin-top:6px">
                        <div class="basics-field" id="ceilingFinishField" style="display:none">
                            <label>Ceiling Finish</label>
                            <select id="inCeilingFinish" onchange="rebuildAll()">
                                <option value="plain">Plain</option>
                                <option value="vj">VJ</option>
                            </select>
                        </div>
                        <div class="basics-field" id="gableInfillField" style="display:none">
                            <label>Gable Infill</label>
                            <select id="inInfill" onchange="rebuildAll()">
                                <option value="colorbond">Colorbond</option>
                                <option value="polycarbonate">Polycarbonate</option>
                                <option value="louvre">Louvre</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="basics-divider"></div>

                <!-- ROW 4: Extras -->
                <div class="basics-group">
                    <div class="basics-group-title">Extras</div>
                    <div class="basics-grid-3">
                        <div class="basics-field extras-toggle">
                            <label>Demo Required?</label>
                            <select id="extraDemo" onchange="toggleExtraCost('demo')">
                                <option value="no">No</option>
                                <option value="yes">Yes</option>
                            </select>
                            <div class="extras-cost" id="demoCostWrap" style="display:none">
                                <label>Demo Cost</label>
                                <input type="number" id="extraDemoCost" value="" placeholder="$" min="0" step="50" oninput="updatePricing()">
                            </div>
                        </div>
                        <div class="basics-field extras-toggle">
                            <label>Removal Required?</label>
                            <select id="extraRemoval" onchange="toggleExtraCost('removal')">
                                <option value="no">No</option>
                                <option value="yes">Yes</option>
                            </select>
                            <div class="extras-cost" id="removalCostWrap" style="display:none">
                                <label>Removal Cost</label>
                                <input type="number" id="extraRemovalCost" value="" placeholder="$" min="0" step="50" oninput="updatePricing()">
                            </div>
                        </div>
                        <div class="basics-field extras-toggle">
                            <label>Electrical?</label>
                            <select id="extraElectrical" onchange="toggleExtraCost('electrical')">
                                <option value="no">No</option>
                                <option value="yes">Yes</option>
                            </select>
                            <div class="extras-cost" id="electricalCostWrap" style="display:none">
                                <label>Electrical Cost</label>
                                <input type="number" id="extraElectricalCost" value="" placeholder="$" min="0" step="50" oninput="updatePricing()">
                                <label style="margin-top:4px">Downlights</label>
                                <input type="number" id="extraDownlights" value="4" min="0" step="1" placeholder="0">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="basics-divider"></div>

                <!-- ROW 5: Allowances -->
                <div class="basics-group">
                    <div class="basics-group-title">Allowances</div>
                    <div class="basics-grid-2">
                        <div class="basics-field">
                            <label>Gutter &amp; Downpipes</label>
                            <input type="number" id="allowGutter" value="800" min="0" step="50" oninput="updatePricing()">
                        </div>
                        <div class="basics-field">
                            <label>Flashings &amp; Finishing</label>
                            <input type="number" id="allowFlashings" value="400" min="0" step="50" oninput="updatePricing()">
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- ============ SECTION: TRUSS CALCULATOR (gable only, collapsed) ============ -->
        <div class="section" id="sec-truss" style="display:none">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-truss')">
                <div>
                    <div class="section-title">Gable Truss Calculator</div>
                    <div class="section-subtitle">Truss design, dimensions &amp; fabrication order</div>
                </div>
                <div style="display:flex;align-items:center;gap:8px">
                    <label style="font-size:10px;color:var(--sw-text-sec)" onclick="event.stopPropagation()">Overhang</label>
                    <input type="number" class="field-input" id="inOverhang" value="0" min="0" step="10" style="width:55px;font-size:11px;padding:3px 6px" oninput="rebuildAll()" onclick="event.stopPropagation()">
                    <span style="font-size:10px;color:var(--sw-text-sec)">mm</span>
                    <button class="btn btn-secondary" style="padding:4px 8px;font-size:10px" onclick="event.stopPropagation();exportTrussPDF()">PDF</button>
                    <span class="collapse-arrow">&#9662;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="padding:0">
                    <div class="truss-config">
                        <div class="truss-config-item">
                            <label><input type="checkbox" id="trussRiserOn" onchange="toggleTrussOpt();rebuildAll()"> Riser</label>
                            <div class="truss-opt-fields" id="trussRiserInputs" style="display:none">
                                <label>RX <input type="number" id="trussRX" value="200" min="0" max="650" step="10" oninput="rebuildAll()"><span>mm</span></label>
                                <label>RY <input type="number" id="trussRY" value="150" min="0" max="500" step="10" oninput="rebuildAll()"><span>mm</span></label>
                            </div>
                        </div>
                        <div class="truss-config-item">
                            <label><input type="checkbox" id="trussDoglegOn" onchange="toggleTrussOpt();rebuildAll()"> Dogleg</label>
                            <div class="truss-opt-fields" id="trussDoglegInputs" style="display:none">
                                <label>LX <input type="number" id="trussLX" value="200" min="0" step="10" oninput="rebuildAll()"><span>mm</span></label>
                                <label>LY <input type="number" id="trussLY" value="150" min="0" step="10" oninput="rebuildAll()"><span>mm</span></label>
                            </div>
                        </div>
                        <div class="truss-config-item">
                            <label><input type="checkbox" id="trussExtOn" onchange="toggleTrussOpt();rebuildAll()"> Extender</label>
                            <div class="truss-opt-fields" id="trussExtInputs" style="display:none">
                                <label>Length <input type="number" id="trussExtLen" value="300" min="0" step="10" oninput="rebuildAll()"><span>mm</span></label>
                            </div>
                        </div>
                    </div>
                    <div style="padding:12px">
                        <div class="truss-viewport" id="trussViewport">
                            <canvas id="trussCanvas"></canvas>
                            <div class="truss-view-btns">
                                <button class="truss-view-btn" onclick="setTrussView('3d',this)">3D</button>
                                <button class="truss-view-btn active" onclick="setTrussView('front',this)">Front</button>
                                <button class="truss-view-btn" onclick="setTrussView('side',this)">Side</button>
                            </div>
                        </div>
                        <div class="truss-panel-vertical">
                            <div class="truss-cards-row">
                                <div class="truss-card">
                                    <h4>Truss Dimensions</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">SP: Span</div><div class="spec-value" id="specA">3000</div></div>
                                        <div class="spec-item"><div class="spec-label">HT: Height</div><div class="spec-value" id="specB">264</div></div>
                                        <div class="spec-item"><div class="spec-label">Rafter</div><div class="spec-value hl" id="specC">1523</div></div>
                                        <div class="spec-item"><div class="spec-label">Pitch</div><div class="spec-value" id="specD">10&deg;</div></div>
                                        <div class="spec-item" id="specRXitem" style="display:none"><div class="spec-label">RX</div><div class="spec-value" id="specRX">200</div></div>
                                        <div class="spec-item" id="specRYitem" style="display:none"><div class="spec-label">RY</div><div class="spec-value" id="specRY">150</div></div>
                                        <div class="spec-item" id="specLXitem" style="display:none"><div class="spec-label">LX</div><div class="spec-value" id="specLX">200</div></div>
                                        <div class="spec-item" id="specLYitem" style="display:none"><div class="spec-label">LY</div><div class="spec-value" id="specLY">150</div></div>
                                        <div class="spec-item" id="specExtItem" style="display:none"><div class="spec-label">Extender</div><div class="spec-value" id="specExt">300</div></div>
                                    </div>
                                </div>
                                <div class="truss-card">
                                    <h4>Cut Lengths</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">Bottom Chord (cut)</div><div class="spec-value hl" id="specChordCut">--</div></div>
                                        <div class="spec-item"><div class="spec-label">Rafter (cut)</div><div class="spec-value hl" id="specRafterCut">--</div></div>
                                        <div class="spec-item"><div class="spec-label">Total LM / truss</div><div class="spec-value" id="specLMper">--</div></div>
                                        <div class="spec-item"><div class="spec-label">Total LM all</div><div class="spec-value" id="specLMall">--</div></div>
                                    </div>
                                </div>
                                <div class="truss-card">
                                    <h4>Cut Angles</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">Apex Mitre</div><div class="spec-value" id="angleApex">80&deg;</div></div>
                                        <div class="spec-item"><div class="spec-label">Heel Mitre</div><div class="spec-value" id="angleBase">10&deg;</div></div>
                                    </div>
                                </div>
                            </div>
                            <div class="truss-card" id="webCard" style="display:none">
                                <h4>Web Members</h4>
                                <div class="spec-grid">
                                    <div class="spec-item"><div class="spec-label">King Post</div><div class="spec-value" id="webKing">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Queen Posts</div><div class="spec-value" id="webQueen">--</div></div>
                                </div>
                            </div>
                            <div class="fab-box" id="fabOrder" style="white-space:pre;font-family:'SF Mono',monospace;font-size:10px;line-height:1.5;padding:12px;overflow-x:auto"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============ SECTION: SITE DETAILS (collapsed) ============ -->
        <div class="section" id="sec-site">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-site')">
                <div><div class="section-title">Site Details</div><div class="section-subtitle">Technical config, colours &amp; site survey</div></div>
                <span class="collapse-arrow">&#9662;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">

                    <!-- Technical Configuration -->
                    <div class="basics-group">
                        <div class="basics-group-title">Technical Configuration</div>
                        <div class="basics-grid-4">
                            <div class="basics-field" id="orientationField">
                                <label>Ridge Direction</label>
                                <select id="inOrientation" onchange="rebuildAll()">
                                    <option value="lengthways">Along House</option>
                                    <option value="perpendicular">Away from House</option>
                                </select>
                            </div>
                            <div class="basics-field">
                                <label>Posts (per side)</label>
                                <input type="number" id="inPosts" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="trussField">
                                <label>Trusses</label>
                                <input type="number" id="inTrusses" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="rafterField" style="display:none">
                                <label>Rafters</label>
                                <input type="number" id="inRafters" value="5" min="2" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="basics-grid-4" style="margin-top:6px">
                            <div class="basics-field">
                                <label>Steel Size</label>
                                <select id="inTrussSteel" onchange="rebuildAll()">
                                    <option value="76x38">76 &times; 38 &times; 1.6mm RHS</option>
                                    <option value="75x50">75 &times; 50 &times; 2.0mm RHS</option>
                                    <option value="100x50">100 &times; 50 &times; 2.0mm RHS</option>
                                </select>
                            </div>
                            <div class="basics-field" id="trussBaseField">
                                <label>Truss Base</label>
                                <select id="inTrussBase" onchange="rebuildAll()">
                                    <option value="kingpost">King Post</option>
                                    <option value="open">Open</option>
                                </select>
                            </div>
                            <div class="basics-field" id="trussChordField">
                                <label>Chord</label>
                                <select id="inTrussChord" onchange="rebuildAll()">
                                    <option value="bottom">Bottom</option>
                                    <option value="mid">Mid</option>
                                    <option value="none">None</option>
                                </select>
                            </div>
                            <div class="basics-field" id="fasciaHeightField" style="display:none">
                                <label>Fascia Height <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inFasciaHeight" value="2700" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="houseGutterField" style="display:none">
                                <label>House Gutter</label>
                                <select id="inHouseGutter" onchange="rebuildAll()">
                                    <option value="quad">Existing Quad Gutter</option>
                                    <option value="box">Replace with Box Gutter</option>
                                </select>
                            </div>
                        </div>
                        <div class="basics-grid-4" style="margin-top:6px">
                            <div class="basics-field" id="riserHeightField" style="display:none">
                                <label>Riser Height <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inRiserHeight" value="400" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserOffsetField" style="display:none">
                                <label>Riser Offset <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inRiserOffset" value="150" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserQtyField" style="display:none">
                                <label>Riser Brackets</label>
                                <input type="number" id="inRiserQty" value="" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserGutterField" style="display:none">
                                <label>Riser Gutter</label>
                                <select id="inRiserGutter" onchange="rebuildAll()">
                                    <option value="none">None</option>
                                    <option value="quad">Quad Gutter on Riser Beam</option>
                                </select>
                            </div>
                        </div>
                        <div class="calc-display" id="calcDisplay" style="margin-top:8px">
                            <div class="calc-row"><span class="calc-label">Rise:</span><span class="calc-value" id="calcRise">--</span></div>
                            <div class="calc-row"><span class="calc-label">Rafter TRUE:</span><span class="calc-value" id="calcRafter">--</span></div>
                            <div class="calc-row" id="calcPitchRow" style="display:none"><span class="calc-label">Actual Pitch:</span><span class="calc-value" id="calcPitch">--</span></div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- Colours -->
                    <div class="basics-group">
                        <div class="basics-group-title">Colours</div>
                        <div class="basics-colours">
                            <div class="basics-colour-block">
                                <div class="basics-colour-label">Sheets</div>
                                <div class="color-chips" id="sheetChips"></div>
                                <div class="color-label" id="sheetLabel">Monument</div>
                            </div>
                            <div class="basics-colour-block">
                                <div class="basics-colour-label">Steel</div>
                                <div class="color-chips" id="steelChips"></div>
                                <div class="color-label" id="steelLabel">Monument</div>
                            </div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- Polycarbonate (Trimdek only) -->
                    <div id="polycarbField" style="display:none">
                        <div class="basics-group">
                            <div class="basics-group-title">Polycarbonate</div>
                            <div style="display:flex;align-items:center;gap:12px;margin-bottom:6px">
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="no" checked onchange="updatePolycarbUI();rebuildAll()"> No
                                </label>
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="yes" onchange="updatePolycarbUI();rebuildAll()"> Yes
                                </label>
                            </div>
                            <div id="polycarbOptions" style="display:none">
                                <div class="basics-grid-3" style="gap:6px">
                                    <div class="basics-field">
                                        <label>Brand</label>
                                        <select id="inPolycarbBrand" onchange="updatePolycarbTints();rebuildAll()">
                                            <option value="ampelite">Ampelite Solasafe</option>
                                            <option value="laserlite">Laserlite 2000</option>
                                        </select>
                                    </div>
                                    <div class="basics-field">
                                        <label>Tint</label>
                                        <select id="inPolycarbTint" onchange="rebuildAll()"></select>
                                    </div>
                                    <div class="basics-field">
                                        <label>Pattern</label>
                                        <select id="inPolycarbPattern" onchange="updatePolycarbPreview();rebuildAll()">
                                            <option value="2">Every 2nd (1:1)</option>
                                            <option value="3" selected>Every 3rd (2:1)</option>
                                            <option value="4">Every 4th (3:1)</option>
                                            <option value="custom">Custom</option>
                                        </select>
                                    </div>
                                </div>
                                <div id="polycarbCustomField" style="display:none;margin-top:4px">
                                    <div class="basics-field" style="max-width:140px">
                                        <label>Colorbond per 1 polycarb</label>
                                        <input type="number" id="inPolycarbCustom" value="3" min="1" max="20" step="1" oninput="updatePolycarbPreview();rebuildAll()">
                                    </div>
                                </div>
                                <div style="margin-top:6px">
                                    <div style="font-size:10px;color:var(--sw-text-sec);margin-bottom:3px">Preview</div>
                                    <div id="polycarbPreview" style="display:flex;gap:2px;flex-wrap:wrap"></div>
                                    <div style="font-size:9px;color:var(--sw-text-sec);margin-top:3px">&#9632;=steel &#9633;=polycarb</div>
                                </div>
                            </div>
                        </div>
                        <div class="basics-divider"></div>
                    </div>

                    <!-- Site Survey -->
                    <div class="basics-group">
                        <div class="basics-group-title">Site Survey</div>
                        <div class="site-details-grid">
                            <div>
                                <div class="radio-group-title">Existing Gutter Profile</div>
                                <div class="radio-options">
                                    <label class="radio-pill"><input type="radio" name="gutterProfile" value="quad115" onchange="updateSiteDetails()"><span>Quad 115</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterProfile" value="og125" onchange="updateSiteDetails()"><span>OG 125</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterProfile" value="fascia" onchange="updateSiteDetails()"><span>Fascia</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterProfile" value="unknown" checked onchange="updateSiteDetails()"><span>Unknown</span></label>
                                </div>
                            </div>
                            <div>
                                <div class="radio-group-title">Gutter Manufacturer</div>
                                <div class="radio-options">
                                    <label class="radio-pill"><input type="radio" name="gutterManufacturer" value="stratco" onchange="updateSiteDetails()"><span>Stratco</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterManufacturer" value="lysaght" onchange="updateSiteDetails()"><span>Lysaght</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterManufacturer" value="metroll" onchange="updateSiteDetails()"><span>Metroll</span></label>
                                    <label class="radio-pill"><input type="radio" name="gutterManufacturer" value="unknown" checked onchange="updateSiteDetails()"><span>Unknown</span></label>
                                </div>
                            </div>
                            <div>
                                <div class="radio-group-title">Fascia Condition</div>
                                <div class="radio-options">
                                    <label class="radio-pill"><input type="radio" name="fasciaCondition" value="good" onchange="updateSiteDetails()"><span>Good</span></label>
                                    <label class="radio-pill"><input type="radio" name="fasciaCondition" value="needs_repair" onchange="updateSiteDetails()"><span>Needs Repair</span></label>
                                    <label class="radio-pill"><input type="radio" name="fasciaCondition" value="unknown" checked onchange="updateSiteDetails()"><span>Unknown</span></label>
                                </div>
                            </div>
                            <div>
                                <div class="radio-group-title">Site Access</div>
                                <div class="radio-options">
                                    <label class="radio-pill"><input type="radio" name="siteAccess" value="easy" onchange="updateSiteDetails()"><span>Easy</span></label>
                                    <label class="radio-pill"><input type="radio" name="siteAccess" value="restricted" onchange="updateSiteDetails()"><span>Restricted</span></label>
                                    <label class="radio-pill"><input type="radio" name="siteAccess" value="unknown" checked onchange="updateSiteDetails()"><span>Unknown</span></label>
                                </div>
                            </div>
                            <div class="site-notes-wrap">
                                <div class="radio-group-title">Notes</div>
                                <textarea id="siteNotes" rows="2" placeholder="Any additional site notes..." oninput="updateSiteDetails()"></textarea>
                            </div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- Job Notes -->
                    <div class="basics-group">
                        <div class="basics-group-title">Job Notes</div>
                        <textarea id="jobNotes" rows="2" placeholder="Job notes..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                    </div>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: MATERIALS (collapsed) ============ -->
        <div class="section" id="sec-materials">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-materials')">
                <div><div class="section-title">Materials</div><div class="section-subtitle">Detailed configuration &amp; specifications</div></div>
                <span class="collapse-arrow">&#9662;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div style="padding:16px 20px">
                    <div id="preOrderChecks"></div>
                    <div id="matList"></div>
                </div>
            </div>
        </div>

        <!-- ============ SECTION: PRICING (collapsed) ============ -->
        <div class="section" id="sec-pricing">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-pricing')">
                <div><div class="section-title">Pricing &amp; Costs</div><div class="section-subtitle">Quote builder</div></div>
                <div style="display:flex;align-items:center;gap:8px">
                    <button class="settings-gear" onclick="event.stopPropagation();openRatesModal()" title="Stored Rates">&#9881;</button>
                    <span class="collapse-arrow">&#9662;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="background:#f5f5f5;padding:24px;border-radius:0 0 12px 12px">
                <div class="pricing-cards-container">

                    <!-- CARD 1: MATERIALS -->
                    <div class="q-card" id="materialsCard">
                        <div class="q-card-header">
                            <div>
                                <div class="q-card-title"><span id="matStatusIcon" class="status-ok">&#10003;</span> Materials</div>
                                <div class="q-card-sub"><span id="matItemCount">0 items</span> &bull; <span id="matMarkupPct">35%</span> markup</div>
                            </div>
                            <div style="display:flex;align-items:center;gap:16px">
                                <span class="q-card-amount" id="matSellDisplay">$0</span>
                                <button class="q-card-edit" onclick="openMaterialsModal()">Edit</button>
                            </div>
                        </div>
                    </div>

                    <!-- CARD 2: LABOUR -->
                    <div class="q-card" id="labourCard">
                        <div class="q-card-title">Labour</div>
                        <div class="labour-inline">
                            <input type="number" class="li-input" id="labTrades" value="2" min="1" step="1" oninput="updatePricing()">
                            <span class="li-label">trades</span>
                            <span class="li-label">&times;</span>
                            <input type="number" class="li-input" id="labDays" value="1.5" min="0.5" step="0.5" oninput="updatePricing()">
                            <span class="li-label">days</span>
                            <span class="li-label">&times;</span>
                            <span class="li-label">$</span>
                            <input type="number" class="li-input wide" id="labDayRate" value="400" min="0" step="10" oninput="updatePricing()">
                            <span class="li-label">/day</span>
                            <span class="li-label">=</span>
                            <span class="li-equals" id="labCostDisplay">$1,200</span>
                            <span class="li-label">cost</span>
                        </div>
                        <div class="labour-sell-row">
                            <label>Sell:</label>
                            <input type="number" id="labSellInput" value="2000" min="0" step="50" oninput="updatePricing()" placeholder="0.00">
                        </div>
                    </div>

                    <!-- CARD 3: EXTRAS -->
                    <div class="q-card" id="extrasCard">
                        <div class="q-card-title">Extras</div>
                        <div class="extras-pills">
                            <button class="extras-pill" onclick="addExtra('footings')">+ Footings</button>
                            <button class="extras-pill" onclick="addExtra('electrical')">+ Electrical</button>
                            <button class="extras-pill" onclick="addExtra('downlights')">+ Downlights</button>
                            <button class="extras-pill" onclick="addExtra('demo')">+ Demo</button>
                            <button class="extras-pill" onclick="addExtra('delivery')">+ Delivery</button>
                            <button class="extras-pill" onclick="addExtra('other')">+ Other</button>
                        </div>
                        <div class="extras-rows" id="extrasRowsContainer"></div>
                    </div>

                    <!-- CARD 4: TOTAL -->
                    <div class="total-card" id="totalCard">
                        <div class="total-amount" id="totalAmountDisplay">TOTAL $0 inc GST</div>
                        <div class="total-margin" id="totalMarginDisplay">Margin: $0 (0%)</div>
                        <button class="btn-generate-quote" onclick="generateQuotePDF()">GENERATE QUOTE</button>
                        <div class="total-links">
                            <a onclick="generateMaterialsOrderPDF()">Materials Order</a>
                            <a onclick="generateWorkOrderPDF()">Work Order</a>
                            <a onclick="saveJobData()">Save Job Data</a>
                        </div>
                    </div>

                    <!-- Job Notes (compact) -->
                    <div class="q-card">
                        <div class="q-card-title">Job Notes</div>
                        <div class="notes-inline">
                            <textarea id="pricingNotes" placeholder="Install notes, access issues, special requirements..." rows="2"></textarea>
                        </div>
                    </div>

                </div>
                </div>
            </div>
        </div>

        </div><!-- end panel-left -->

        <div class="panel-right" id="panelRight">

            <!-- 2D Site Plan -->
            <div class="rp-card">
                <div class="rp-card-hdr">Site Plan</div>
                <div class="rp-card-body" style="padding:8px">
                    <div class="plan-2d" style="height:200px"><canvas id="plan2d"></canvas></div>
                </div>
            </div>

            <!-- 3D Assembly Preview -->
            <div class="rp-card">
                <div class="rp-card-hdr">3D Preview</div>
                <div class="asm-viewport" id="asmViewport" style="height:360px;border-radius:0">
                    <canvas id="asmCanvas"></canvas>
                    <button class="fullscreen-btn" onclick="toggleFullscreen()">&#x26F6; Fullscreen</button>
                    <div class="layer-panel">
                        <div class="layer-title">Layers</div>
                        <div class="layer-item active" data-layer="steel" onclick="toggleLayer('steel',this)"><span class="layer-check"></span>Steel</div>
                        <div class="layer-item active" data-layer="roof" onclick="toggleLayer('roof',this)"><span class="layer-check"></span>Roofing</div>
                        <div class="layer-item active" data-layer="acc" onclick="toggleLayer('acc',this)"><span class="layer-check"></span>Gutters/DP</div>
                        <div class="layer-item active" data-layer="house" onclick="toggleLayer('house',this)"><span class="layer-check"></span>House</div>
                    </div>
                    <div class="tooltip" id="tooltip"><div class="tooltip-title" id="ttTitle"></div><div id="ttContent"></div></div>
                    <div class="view-panel">
                        <button class="view-btn active" onclick="setAsmView('3d',this)">3D</button>
                        <button class="view-btn" onclick="setAsmView('front',this)">Front</button>
                        <button class="view-btn" onclick="setAsmView('side',this)">Side</button>
                        <button class="view-btn" onclick="setAsmView('top',this)">Top</button>
                    </div>
                </div>
            </div>

            <!-- Summary -->
            <div class="rp-card">
                <div class="rp-card-hdr">Summary</div>
                <div class="rp-card-body">
                    <div class="rp-summary-grid">
                        <div class="rp-summary-item">
                            <div class="rp-summary-label">Dimensions</div>
                            <div class="rp-summary-value" id="rpDims">6.0m × 3.0m</div>
                        </div>
                        <div class="rp-summary-item">
                            <div class="rp-summary-label">Roof Type</div>
                            <div class="rp-summary-value" id="rpRoofType">Gable</div>
                        </div>
                        <div class="rp-summary-item">
                            <div class="rp-summary-label">Material</div>
                            <div class="rp-summary-value" id="rpMaterial">Corrugated</div>
                        </div>
                        <div class="rp-summary-item">
                            <div class="rp-summary-label">Colour</div>
                            <div class="rp-summary-value" id="rpColour">Monument</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Quick Scope Estimate -->
            <div class="rp-card">
                <div class="rp-card-hdr">Quick Scope Estimate</div>
                <div class="rp-card-body">
                    <div class="rp-est-label" id="rpEstSqm">—</div>
                    <div class="rp-est-range" id="rpEstRange">—</div>
                    <div class="rp-est-btn">
                        <button class="btn btn-primary" onclick="copyEstimate()">Copy Estimate</button>
                    </div>
                </div>
            </div>

        </div><!-- end panel-right -->

        <!-- Hidden: Complexity scores preserved for export/import -->
        <div style="display:none">
            <input type="number" id="cxBuild" value="3"><input type="number" id="cxAccess" value="3">
            <input type="number" id="cxDistance" value="2"><input type="number" id="cxFooting" value="3"><input type="number" id="cxHeight" value="2">
        </div>

        <!-- Materials Edit Modal -->
        <div id="materialsModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)closeMaterialsModal()">
            <div class="mat-modal">
                <h3>Materials &amp; Pricing</h3>
                <div class="mat-modal-controls">
                    <label>Markup:</label>
                    <input type="number" id="globalMarkupPct" value="35" min="0" max="200" step="1">
                    <span style="font-size:13px;color:var(--sw-text-sec)">%</span>
                    <button class="btn-apply" onclick="applyMarkupAll()">Apply to All</button>
                    <div class="toggle-wrap">
                        <input type="checkbox" id="showCostToggle" onchange="renderMaterialsModal()">
                        <label for="showCostToggle" style="font-size:12px;color:var(--sw-text-sec);cursor:pointer">Show cost prices</label>
                    </div>
                </div>
                <table class="mat-modal-table">
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Qty</th>
                            <th class="r cost-col" style="display:none">Cost</th>
                            <th class="r">Sell Price</th>
                            <th class="r">Markup</th>
                            <th style="width:24px"></th>
                        </tr>
                    </thead>
                    <tbody id="matModalBody"></tbody>
                </table>
                <div class="mat-modal-footer">
                    <div>
                        <button class="btn-add-custom" onclick="addCustomMaterialRow()">+ Add Custom Item</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:16px">
                        <span>Total: <span class="mat-total" id="matModalTotal">$0.00</span></span>
                        <button class="btn-done" onclick="closeMaterialsModal()">Done</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Rates Settings Modal -->
        <div id="ratesModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
            <div class="rates-modal">
                <h3>Stored Rates</h3>
                <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:12px">Default $/LM rates &amp; day rates. Saved to browser.</p>
                <table class="pricing-table">
                    <thead><tr><th>Material / Role</th><th class="r">Rate $</th></tr></thead>
                    <tbody id="ratesBody"></tbody>
                </table>
                <div style="text-align:right;margin-top:16px">
                    <button class="btn-done" style="padding:8px 20px;border-radius:6px;border:none;background:var(--sw-orange);color:white;font-size:13px;cursor:pointer" onclick="document.getElementById('ratesModal').style.display='none'">Done</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Import Modal -->
    <div id="importModal" class="modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
        <div class="modal-box">
            <h3>Import Job Data</h3>
            <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:8px">Paste previously exported JSON data below, then click Load Job.</p>
            <textarea id="importTextarea" placeholder="Paste job JSON here..."></textarea>
            <div class="modal-status" id="importStatus"></div>
            <div class="modal-btns">
                <button class="btn btn-secondary" onclick="document.getElementById('importModal').style.display='none'">Cancel</button>
                <button class="btn btn-primary" onclick="importJobData()">Load Job</button>
            </div>
        </div>
    </div>

    <div id="loadJobModal" class="modal-overlay" style="display:none" onclick="if(event.target===this)closeLoadJobModal()">
        <div class="modal-box" style="max-width:500px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
                <h3 style="margin:0">Load Job</h3>
                <span style="cursor:pointer;font-size:18px;color:var(--sw-text-sec);padding:4px" onclick="closeLoadJobModal()">&times;</span>
            </div>
            <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:8px">Paste job data JSON:</p>
            <textarea id="loadJobTextarea" rows="6" placeholder="Paste job JSON here..." style="height:auto"></textarea>
            <div class="modal-status" id="loadJobStatus"></div>
            <div class="modal-btns">
                <button class="btn btn-secondary" onclick="closeLoadJobModal()">Cancel</button>
                <button class="btn btn-primary" onclick="loadJobData()">Load Job</button>
            </div>
        </div>
    </div>

    <script>
        /*
         * V18 FIXES:
         * 1. Downpipes - now extend from ground to actual gutter height (not postH)
         * 2. Gable sheets perpendicular - complete rotation rewrite for proper roof alignment
         * 3. Carry beam condition - removed for gable+fascia (trusses sit on fascia beam directly)
         * 4. Gable+riser beam stacking - riser beam now sits ON TOP of risers correctly
         */

        // ==================== CONFIG ====================
        const COLORS = [
            {name:'Monument',hex:'#2D3436'},{name:'Woodland Grey',hex:'#4B5D52'},{name:'Paperbark',hex:'#C4BAA2'},
            {name:'Surfmist',hex:'#E8E6E0'},{name:'Basalt',hex:'#5C5C5C'},{name:'Manor Red',hex:'#6B2D2D'},
            {name:'Deep Ocean',hex:'#1E3A4C'},{name:'Windspray',hex:'#7D8B8A'}
        ];
        const STEEL = {'76x38':{w:0.076,h:0.038,name:'76×38×1.6',bmt:1.6},'75x50':{w:0.075,h:0.05,name:'75×50×2',bmt:2.0},'100x50':{w:0.1,h:0.05,name:'100×50×2',bmt:2.0}};

        const SHEET_COVERAGE = {
            corrugated: 762,
            trimdek: 762,
            spandek: 762,
            solarspan75: 1000,
            solarspan100: 1000,
            spanplus330: 330
        };

        const SPAN_TABLES = {
            corrugated: { maxSpan: 1100, endSpan: 900, needsPurlins: true },
            trimdek: { maxSpan: 2100, endSpan: 1500, needsPurlins: true },
            spandek: { maxSpan: 2400, endSpan: 1800, needsPurlins: true },
            solarspan75: { maxSpan: 6000, endSpan: 6000, needsPurlins: false },
            solarspan100: { maxSpan: 6000, endSpan: 6000, needsPurlins: false },
            spanplus330: { maxSpan: 1800, endSpan: 1200, needsPurlins: true }
        };

        function isInsulated(roofing) {
            return roofing === 'solarspan75' || roofing === 'solarspan100';
        }

        const ROOFING_TYPES = {
            solarspan75:  { name: 'SolarSpan 75mm',  coverWidth: 1000, costPerLm: 110.00, sqmRate: 520 },
            solarspan100: { name: 'SolarSpan 100mm', coverWidth: 1000, costPerLm: 130.00, sqmRate: 560 },
            trimdek:      { name: 'Trimdek',         coverWidth: 762,  costPerLm: 15.00,  sqmRate: 420 },
            corrugated:   { name: 'Corrugated',      coverWidth: 762,  costPerLm: 12.04,  sqmRate: 380 },
            spanplus330:  { name: 'SpanPlus 330',    coverWidth: 330,  costPerLm: 12.04,  sqmRate: 400 }
        };

        const SPANPLUS_COLOURS = [
            'Basalt','Classic Cream','Cottage Green','Deep Ocean','Domain','Dune',
            'Evening Haze','Ironstone','Jasper','Manor Red','Monument',
            'Pale Eucalypt','Paperbark','Shale Grey','Surfmist','Woodland Grey'
        ];

        // Polycarbonate tint options per brand
        const POLYCARB_TINTS = {
            ampelite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Light Bronze',color:'rgba(180,150,100,0.4)'},
                {name:'Grey',       color:'rgba(160,160,165,0.45)'},
                {name:'Dark Tint',  color:'rgba(80,80,85,0.55)'},
                {name:'Smooth Cream',color:'rgba(245,235,210,0.5)'}
            ],
            laserlite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Cream',      color:'rgba(245,235,210,0.5)'},
                {name:'Bronze Tint',color:'rgba(170,140,90,0.45)'},
                {name:'Grey Tint',  color:'rgba(150,150,155,0.45)'}
            ]
        };

        // Three.js tint colours for polycarb 3D rendering
        const POLYCARB_3D_TINTS = {
            'Clear':        {color: 0x88CCEE, opacity: 0.5},
            'Opal':         {color: 0xE8E8F0, opacity: 0.6},
            'Light Bronze': {color: 0xB49664, opacity: 0.55},
            'Grey':         {color: 0x909098, opacity: 0.55},
            'Dark Tint':    {color: 0x505055, opacity: 0.65},
            'Smooth Cream': {color: 0xF0E4C8, opacity: 0.55},
            'Cream':        {color: 0xF0E4C8, opacity: 0.55},
            'Bronze Tint':  {color: 0xAA8C5A, opacity: 0.55},
            'Grey Tint':    {color: 0x868690, opacity: 0.55}
        };

        let sheetColor = COLORS[0];
        let steelColor = COLORS[0];
        let calc = {};

        // ==================== CUSTOMER STATE ====================
        let customer = { name: '', address: '', phone: '' };
        function updateCustomer() {
            customer = {
                name: document.getElementById('customerName').value,
                address: document.getElementById('customerAddress').value,
                phone: document.getElementById('customerPhone').value
            };
            // Sync hidden client fields for save/load compatibility
            document.getElementById('clientName').value = customer.name;
            document.getElementById('siteAddress').value = customer.address;
            document.getElementById('clientPhone').value = customer.phone;
        }

        // ==================== SITE DETAILS STATE ====================
        let siteDetails = {
            gutterProfile: 'unknown',
            gutterManufacturer: 'unknown',
            fasciaCondition: 'unknown',
            siteAccess: 'unknown',
            electrical: 'tbd',
            demo: 'tbd',
            notes: ''
        };
        function updateSiteDetails() {
            var gp = document.querySelector('input[name="gutterProfile"]:checked');
            var gm = document.querySelector('input[name="gutterManufacturer"]:checked');
            var fc = document.querySelector('input[name="fasciaCondition"]:checked');
            var sa = document.querySelector('input[name="siteAccess"]:checked');
            siteDetails = {
                gutterProfile: gp ? gp.value : 'unknown',
                gutterManufacturer: gm ? gm.value : 'unknown',
                fasciaCondition: fc ? fc.value : 'unknown',
                siteAccess: sa ? sa.value : 'unknown',
                electrical: document.getElementById('extraElectrical') ? document.getElementById('extraElectrical').value : 'no',
                demo: document.getElementById('extraDemo') ? document.getElementById('extraDemo').value : 'no',
                notes: document.getElementById('siteNotes') ? document.getElementById('siteNotes').value : ''
            };
        }

        // ==================== EXTRAS TOGGLE ====================
        function toggleExtraCost(type) {
            var sel = document.getElementById('extra' + type.charAt(0).toUpperCase() + type.slice(1));
            var wrap = document.getElementById(type + 'CostWrap');
            if (sel && wrap) wrap.style.display = sel.value === 'yes' ? 'block' : 'none';
        }

        function toggleTrussOpt() {
            var rOn = document.getElementById('trussRiserOn').checked;
            var dOn = document.getElementById('trussDoglegOn').checked;
            var eOn = document.getElementById('trussExtOn').checked;
            document.getElementById('trussRiserInputs').style.display = rOn ? 'flex' : 'none';
            document.getElementById('trussDoglegInputs').style.display = dOn ? 'flex' : 'none';
            document.getElementById('trussExtInputs').style.display = eOn ? 'flex' : 'none';
        }

        // ==================== QUICK SCOPE ESTIMATE ====================
        function updateEstimate() {
            const projM = parseFloat(document.getElementById('inWidth').value) || 3;
            const lenM = parseFloat(document.getElementById('inLength').value) || 6;
            const roofing = document.getElementById('inRoofing').value;
            const roofStyle = document.getElementById('inRoofStyle').value;
            const connection = document.getElementById('inConnection').value;
            const sqm = projM * lenM;

            const roofKey = roofing;
            const baseRate = (ROOFING_TYPES[roofKey] || ROOFING_TYPES.corrugated).sqmRate;

            let modifier = 1.0;
            if (roofStyle === 'gable') modifier *= 1.12;
            if (roofStyle === 'hip') modifier *= 1.15;
            if (connection === 'flyover') modifier *= 1.08;
            if (connection === 'freestanding') modifier *= 1.18;

            const base = sqm * baseRate * modifier;
            const low = Math.round((base * 0.95 * 1.1) / 500) * 500;
            const high = Math.round((base * 1.10 * 1.1) / 500) * 500;

            var rpSqm = document.getElementById('rpEstSqm');
            var rpRange = document.getElementById('rpEstRange');
            if (rpSqm) rpSqm.textContent = sqm.toFixed(0) + ' sqm';
            if (rpRange) rpRange.textContent = '~$' + low.toLocaleString() + ' \u2013 $' + high.toLocaleString() + ' (inc GST)';
        }

        function copyEstimate() {
            const projM = parseFloat(document.getElementById('inWidth').value) || 3;
            const lenM = parseFloat(document.getElementById('inLength').value) || 6;
            const roofStyle = document.getElementById('inRoofStyle').value;
            const roofing = document.getElementById('inRoofing').value;
            const roofName = (ROOFING_TYPES[roofing] || ROOFING_TYPES.corrugated).name;
            const styleName = roofStyle.charAt(0).toUpperCase() + roofStyle.slice(1);

            const rangeEl = document.getElementById('rpEstRange');
            const rangeText = rangeEl ? rangeEl.textContent : '';
            const text = 'SecureWorks Patio Estimate\n' +
                lenM.toFixed(1) + 'm \u00D7 ' + projM.toFixed(1) + 'm ' + styleName + ' - ' + roofName + '\n' +
                'Approximately ' + rangeText.replace('~', '') + ' inc GST\n\n' +
                'This is a preliminary estimate only.\nFinal price confirmed after detailed scope.';

            navigator.clipboard.writeText(text).then(function() {
                var btn = document.querySelector('.rp-est-btn .btn');
                if (!btn) return;
                var orig = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(function() { btn.textContent = orig; }, 1500);
            });
        }

        // ==================== COLOR CHIPS ====================
        function initColorChips(containerId, labelId, setFn) {
            const container = document.getElementById(containerId);
            COLORS.forEach((c,i) => {
                const el = document.createElement('div');
                el.className = 'color-chip' + (i===0?' active':'');
                el.style.background = c.hex;
                el.title = c.name;
                el.onclick = () => {
                    setFn(c);
                    container.querySelectorAll('.color-chip').forEach(x=>x.classList.remove('active'));
                    el.classList.add('active');
                    document.getElementById(labelId).textContent = c.name;
                    rebuildAll();
                };
                container.appendChild(el);
            });
        }
        initColorChips('sheetChips', 'sheetLabel', c => sheetColor = c);
        initColorChips('steelChips', 'steelLabel', c => steelColor = c);

        // ==================== POLYCARBONATE ====================
        function isPolycarbEnabled() {
            return document.querySelector('input[name="polycarb"][value="yes"]')?.checked || false;
        }

        function getPolycarbConfig() {
            if (!isPolycarbEnabled()) return null;
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintEl = document.getElementById('inPolycarbTint');
            const tint = tintEl.value || 'Clear';
            const patternSel = document.getElementById('inPolycarbPattern').value;
            let steelPerPoly;
            if (patternSel === 'custom') {
                steelPerPoly = parseInt(document.getElementById('inPolycarbCustom').value) || 3;
            } else {
                steelPerPoly = parseInt(patternSel) - 1; // "Every 3rd" = 2 steel per 1 poly
            }
            return { brand, tint, steelPerPoly, patternN: steelPerPoly + 1 };
        }

        function getPolycarbSheetSplit(totalSheets) {
            const pc = getPolycarbConfig();
            if (!pc) return { colorbond: totalSheets, polycarb: 0 };
            const patternN = pc.patternN;
            const fullGroups = Math.floor(totalSheets / patternN);
            const remainder = totalSheets % patternN;
            const polycarb = fullGroups + (remainder >= patternN ? 1 : 0);
            const colorbond = totalSheets - polycarb;
            return { colorbond, polycarb };
        }

        function updatePolycarbUI() {
            const enabled = isPolycarbEnabled();
            document.getElementById('polycarbOptions').style.display = enabled ? 'block' : 'none';
            if (enabled) {
                updatePolycarbTints();
                updatePolycarbPreview();
            }
        }

        function updatePolycarbTints() {
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintSelect = document.getElementById('inPolycarbTint');
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const currentVal = tintSelect.value;
            tintSelect.innerHTML = tints.map(t =>
                `<option value="${t.name}">${t.name}</option>`
            ).join('');
            // Restore previous selection if still valid
            if (tints.some(t => t.name === currentVal)) {
                tintSelect.value = currentVal;
            }
            updatePolycarbPreview();
        }

        function updatePolycarbPreview() {
            const container = document.getElementById('polycarbPreview');
            if (!container) return;
            const patternSel = document.getElementById('inPolycarbPattern').value;
            document.getElementById('polycarbCustomField').style.display = patternSel === 'custom' ? 'block' : 'none';
            const pc = getPolycarbConfig();
            if (!pc) { container.innerHTML = ''; return; }

            // Get tint colour for preview
            const brand = pc.brand;
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const tintObj = tints.find(t => t.name === pc.tint) || tints[0];
            const tintColor = tintObj.color;

            // Show ~12 blocks as preview
            const previewCount = Math.min(12, Math.max(6, pc.patternN * 3));
            let html = '';
            for (let i = 0; i < previewCount; i++) {
                const isPoly = ((i + 1) % pc.patternN) === 0;
                if (isPoly) {
                    html += `<div class="pc-block polycarb" style="background:${tintColor}"></div>`;
                } else {
                    html += `<div class="pc-block steel"></div>`;
                }
            }
            container.innerHTML = html;
        }

        // Init polycarb tints on load
        updatePolycarbTints();

        // ==================== UI UPDATES ====================
        function updateUI() {
            const roofSelect = document.getElementById('inRoofStyle');
            const connSelect = document.getElementById('inConnection');
            const roofingSelect = document.getElementById('inRoofing');
            let conn = connSelect.value;
            const roofing = roofingSelect.value;
            const style = roofSelect.value;
            const isGable = style === 'gable' || style === 'hip';
            const isHip = style === 'hip';

            // === RESTRICTION: Wall mount only works with skillion ===
            const gableOption = roofSelect.querySelector('option[value="gable"]');
            const hipOption = roofSelect.querySelector('option[value="hip"]');
            if (conn === 'wall') {
                if (isGable) roofSelect.value = 'skillion';
                if (gableOption) gableOption.disabled = true;
                if (hipOption) hipOption.disabled = true;
            } else {
                if (gableOption) gableOption.disabled = false;
                if (hipOption) hipOption.disabled = false;
            }

            // === RESTRICTION: Gable/Hip restrict connection types ===
            const fasciaOption = connSelect.querySelector('option[value="fascia"]');
            const wallOption = connSelect.querySelector('option[value="wall"]');
            if (isGable) {
                if (conn === 'fascia' || conn === 'wall') { connSelect.value = 'riser'; conn = 'riser'; }
                if (fasciaOption) fasciaOption.disabled = true;
                if (wallOption) wallOption.disabled = true;
            } else {
                if (fasciaOption) fasciaOption.disabled = false;
                if (wallOption) wallOption.disabled = false;
            }

            // === RESTRICTION: Flyover only works with SolarSpan + skillion ===
            const flyoverOption = connSelect.querySelector('option[value="flyover"]');
            if (!isInsulated(roofing) || isGable) {
                if (conn === 'flyover') { connSelect.value = 'riser'; conn = 'riser'; }
                if (flyoverOption) flyoverOption.disabled = true;
            } else {
                if (flyoverOption) flyoverOption.disabled = false;
            }

            const isAttached = conn !== 'freestanding';

            // Truss calculator (gable only, not hip)
            document.getElementById('sec-truss').style.display = (style === 'gable') ? 'block' : 'none';
            // Technical config fields
            document.getElementById('orientationField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussField').style.display = isGable ? 'block' : 'none';
            document.getElementById('rafterField').style.display = isGable ? 'none' : 'block';
            document.getElementById('trussBaseField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussChordField').style.display = isGable ? 'block' : 'none';

            // Gable infill in BASICS (gable or hip)
            document.getElementById('gableInfillField').style.display = isGable ? 'block' : 'none';

            // Ceiling finish (SolarSpan only)
            document.getElementById('ceilingFinishField').style.display = isInsulated(roofing) ? 'block' : 'none';

            const showPitchInput = isGable || !isAttached;
            document.getElementById('pitchField').style.display = showPitchInput ? 'block' : 'none';
            document.getElementById('calcPitchRow').style.display = (!isGable && isAttached) ? 'flex' : 'none';

            // Connection sub-fields (in Site Details)
            document.getElementById('fasciaHeightField').style.display = isAttached ? 'block' : 'none';
            const showRiserOptions = conn === 'riser';
            document.getElementById('riserHeightField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserOffsetField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserQtyField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('houseGutterField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserGutterField').style.display = (showRiserOptions && isGable) ? 'block' : 'none';

            // Polycarbonate: only for Trimdek
            const showPolycarb = roofing === 'trimdek';
            document.getElementById('polycarbField').style.display = showPolycarb ? 'block' : 'none';
            if (!showPolycarb) {
                const noRadio = document.querySelector('input[name="polycarb"][value="no"]');
                if (noRadio) noRadio.checked = true;
                var pcOpts = document.getElementById('polycarbOptions');
                if (pcOpts) pcOpts.style.display = 'none';
            }
        }

        // ==================== GET INPUTS & CALCULATE ====================
        function getInputs() {
            const roofStyle = document.getElementById('inRoofStyle').value;
            const orientation = document.getElementById('inOrientation').value;
            const projInput = (parseFloat(document.getElementById('inWidth').value) || 3) * 1000;
            const lenInput = (parseFloat(document.getElementById('inLength').value) || 6) * 1000;
            const userPitch = parseFloat(document.getElementById('inPitch').value) || 10;
            const postH = (parseFloat(document.getElementById('inPostHeight').value) || 2.4) * 1000;
            const nPosts = parseInt(document.getElementById('inPosts').value) || 3;
            const nTruss = parseInt(document.getElementById('inTrusses').value) || 3;
            const nRafters = parseInt(document.getElementById('inRafters').value) || 5;
            const trussStyle = document.getElementById('inTrussBase').value;
            const trussChord = document.getElementById('inTrussChord').value;
            const trussSteel = document.getElementById('inTrussSteel').value;

            // Truss options: riser, dogleg, extender
            const trussRiserOn = document.getElementById('trussRiserOn')?.checked || false;
            const trussRX = trussRiserOn ? (parseFloat(document.getElementById('trussRX').value) || 200) : 0;
            const trussRY = trussRiserOn ? (parseFloat(document.getElementById('trussRY').value) || 150) : 0;
            const trussDoglegOn = document.getElementById('trussDoglegOn')?.checked || false;
            const trussLX = trussDoglegOn ? (parseFloat(document.getElementById('trussLX').value) || 200) : 0;
            const trussLY = trussDoglegOn ? (parseFloat(document.getElementById('trussLY').value) || 150) : 0;
            const trussExtOn = document.getElementById('trussExtOn')?.checked || false;
            const trussExtLen = trussExtOn ? (parseFloat(document.getElementById('trussExtLen').value) || 300) : 0;
            const roofing = document.getElementById('inRoofing').value;
            const infill = document.getElementById('inInfill').value;
            const connection = document.getElementById('inConnection').value;
            const fasciaH = parseFloat(document.getElementById('inFasciaHeight').value) || 2700;
            const riserH = parseFloat(document.getElementById('inRiserHeight').value) || 400;
            const riserOffset = parseFloat(document.getElementById('inRiserOffset').value) || 150;
            const riserQtyInput = parseInt(document.getElementById('inRiserQty').value);
            const houseGutter = document.getElementById('inHouseGutter').value;
            const riserGutter = document.getElementById('inRiserGutter').value;

            const isGable = roofStyle === 'gable' || roofStyle === 'hip';
            const isAttached = connection !== 'freestanding';
            const hasFascia = (connection === 'fascia' || connection === 'riser' || connection === 'flyover');
            const isRecvChan = (connection === 'fascia' || connection === 'wall');

            let W, L;
            if (isGable && orientation === 'perpendicular') {
                W = lenInput;
                L = projInput;
            } else {
                W = projInput;
                L = lenInput;
            }

            // ========== V18 FIX: BEAM HEIGHTS - Proper stacking for gable+riser ==========
            let frontBeamY = postH;
            const beamH = 50;  // 50mm beam height
            const riserMemberSize = 75;  // 75mm SHS riser members
            // Patio attaches at rafter level (fasciaH = wall top / rafter base)
            // This is ABOVE the fascia board and gutter which hang below

            let backBeamY, fasciaBeamY;
            if (isGable) {
                if (connection === 'riser') {
                    // Gable + Riser: fascia beam sits below house gutter, against lower house fascia
                    // Gutter front face 76mm + 5mm gap ≈ beam top 50mm below fascia top
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    const elevatedBeamY = fasciaH + beamH + riserMemberSize + riserH;
                    frontBeamY = elevatedBeamY;
                    backBeamY = elevatedBeamY;
                } else if (connection === 'fascia' || connection === 'wall') {
                    // Gable + Fascia/Wall: both beams lowered for sheet clearance
                    fasciaBeamY = (connection === 'fascia') ? (fasciaH) : null;
                    frontBeamY = fasciaH;
                    backBeamY = fasciaH;
                } else if (connection === 'flyover') {
                    // Gable + Flyover: beams above existing house roof
                    fasciaBeamY = fasciaH;
                    // Calculate actual house roof rise: 1.5m depth at 15° pitch
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150; // 150mm clearance above roof ridge
                    const flyoverBeamY = fasciaH + houseRoofRise + flyoverClearance;
                    frontBeamY = flyoverBeamY;
                    backBeamY = flyoverBeamY;
                } else {
                    // Freestanding - back beam at post height
                    backBeamY = postH;
                    fasciaBeamY = null;
                }
            } else {
                // SKILLION
                if (connection === 'freestanding') {
                    const rise = W * Math.tan(userPitch * Math.PI / 180);
                    backBeamY = postH + rise;
                    fasciaBeamY = null;
                } else if (connection === 'riser') {
                    // Fascia beam sits below house gutter, against lower house fascia
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    backBeamY = fasciaH + beamH + riserMemberSize + riserH;
                } else if (connection === 'flyover') {
                    fasciaBeamY = fasciaH;
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150;
                    backBeamY = fasciaH + houseRoofRise + flyoverClearance;
                } else {
                    // fascia or wall
                    fasciaBeamY = (connection === 'fascia') ? (fasciaH) : null;
                    backBeamY = fasciaH;
                }
            }

            // ========== PITCH & RISE CALCULATION ==========
            let pitch, pitchRad, rise, rafter, trussSpan;

            if (isGable) {
                pitch = userPitch;
                pitchRad = pitch * Math.PI / 180;
                trussSpan = W;
                rise = (W / 2) * Math.tan(pitchRad);
                rafter = Math.sqrt((W / 2) ** 2 + rise ** 2);
            } else {
                rise = backBeamY - frontBeamY;
                pitch = Math.atan(rise / W) * 180 / Math.PI;
                pitchRad = pitch * Math.PI / 180;
                rafter = Math.sqrt(W ** 2 + rise ** 2);
                trussSpan = W;
            }

            calc = {
                roofStyle, orientation, W, L, projInput, lenInput, userPitch, pitch, pitchRad,
                postH, nPosts, nTruss, nRafters, trussStyle, trussChord, trussSteel, trussSpan,
                roofing, infill, connection, fasciaH, riserH, riserOffset, houseGutter, riserGutter,
                riserQty: riserQtyInput || Math.max(2, Math.ceil(L / 1200)),
                rise, rafter, isGable, isAttached, hasFascia, isRecvChan,
                frontBeamY, backBeamY, fasciaBeamY,
                steel: STEEL[trussSteel],
                sheetCoverage: SHEET_COVERAGE[roofing],
                trussRiser: { enabled: trussRiserOn, rx: trussRX, ry: trussRY },
                trussDogleg: { enabled: trussDoglegOn, lx: trussLX, ly: trussLY },
                trussExtender: { enabled: trussExtOn, length: trussExtLen }
            };

            document.getElementById('calcRise').textContent = Math.round(rise) + 'mm';
            document.getElementById('calcRafter').textContent = Math.round(rafter) + 'mm';
            document.getElementById('calcPitch').textContent = pitch.toFixed(1) + '°';
            // Set riser qty placeholder to show calculated default
            document.getElementById('inRiserQty').placeholder = Math.max(2, Math.ceil(L / 1200));

            if (isGable) {
                const steelW = STEEL[trussSteel].w * 1000;
                const steelH = STEEL[trussSteel].h * 1000;
                const bmt = STEEL[trussSteel].bmt;
                const overhang = parseFloat(document.getElementById('inOverhang')?.value) || 0;
                const apexAngle = 90 - pitch;
                const heelAngle = pitch;
                const cosP = Math.cos(pitchRad);
                const sinP = Math.sin(pitchRad);

                // Bottom chord cut length: span minus steel depth projection at each heel
                const heelDeduct = steelH / Math.tan(pitchRad + Math.PI/2 - pitchRad);
                const chordCut = Math.round(trussSpan - 2 * steelH * cosP);

                // Rafter cut length: from heel face to apex face
                const apexDeduct = steelH / (2 * sinP);
                const heelAllowance = steelH * cosP;
                const rafterCut = Math.round(rafter - apexDeduct - heelAllowance + overhang);

                // Base steel per truss (chord + 2 rafters)
                let baseLM = (chordCut + 2 * rafterCut) / 1000;
                const stickLength = 6000;

                // Additional steel from truss options
                let riserLM = 0, doglegLM = 0, extLM = 0;
                if (trussRiserOn) {
                    // Riser adds vertical piece (RY) + horizontal step (RX) each side
                    riserLM = (2 * (trussRX + trussRY)) / 1000;
                }
                if (trussDoglegOn) {
                    // Dogleg adds diagonal kink piece each side
                    const doglegLen = Math.sqrt(trussLX * trussLX + trussLY * trussLY);
                    doglegLM = (2 * doglegLen) / 1000;
                }
                if (trussExtOn) {
                    // Extender adds horizontal chord extension each side
                    extLM = (2 * trussExtLen) / 1000;
                }

                const lmPerTruss = baseLM + riserLM + doglegLM + extLM;
                const lmAll = lmPerTruss * nTruss;
                const sticksNeeded = Math.ceil((lmAll * 1000) / stickLength);

                const kingPostH = rise - steelH;

                // Web member lengths
                let webLM = 0;
                let webText = '';
                const showWeb = trussStyle === 'kingpost';
                document.getElementById('webCard').style.display = showWeb ? 'block' : 'none';
                if (trussStyle === 'kingpost') {
                    const kh = Math.round(kingPostH);
                    document.getElementById('webKing').textContent = kh + 'mm';
                    document.getElementById('webQueen').textContent = '--';
                    webLM = kh / 1000;
                    webText = '  King Post:     1 × ' + kh + 'mm';
                }

                const totalLM = lmPerTruss + webLM;
                const totalAllLM = totalLM * nTruss;
                const totalSticks = Math.ceil((totalAllLM * 1000) / stickLength);

                // Update spec cards
                document.getElementById('specA').textContent = Math.round(trussSpan);
                document.getElementById('specB').textContent = Math.round(rise);
                document.getElementById('specC').textContent = Math.round(rafter);
                document.getElementById('specD').textContent = pitch.toFixed(1) + '°';

                // Conditional dimension items
                document.getElementById('specRXitem').style.display = trussRiserOn ? 'block' : 'none';
                document.getElementById('specRYitem').style.display = trussRiserOn ? 'block' : 'none';
                document.getElementById('specLXitem').style.display = trussDoglegOn ? 'block' : 'none';
                document.getElementById('specLYitem').style.display = trussDoglegOn ? 'block' : 'none';
                document.getElementById('specExtItem').style.display = trussExtOn ? 'block' : 'none';
                if (trussRiserOn) {
                    document.getElementById('specRX').textContent = Math.round(trussRX);
                    document.getElementById('specRY').textContent = Math.round(trussRY);
                }
                if (trussDoglegOn) {
                    document.getElementById('specLX').textContent = Math.round(trussLX);
                    document.getElementById('specLY').textContent = Math.round(trussLY);
                }
                if (trussExtOn) {
                    document.getElementById('specExt').textContent = Math.round(trussExtLen);
                }

                document.getElementById('specChordCut').textContent = chordCut;
                document.getElementById('specRafterCut').textContent = rafterCut + (overhang > 0 ? ' (+' + overhang + ')' : '');
                document.getElementById('specLMper').textContent = totalLM.toFixed(2);
                document.getElementById('specLMall').textContent = totalAllLM.toFixed(1);

                document.getElementById('angleApex').textContent = apexAngle.toFixed(1) + '°';
                document.getElementById('angleBase').textContent = heelAngle.toFixed(1) + '°';

                // Build CMI format order text
                const steelName = STEEL[trussSteel].name;
                const clr = steelColor.name;

                // Line 1: Qty + description
                const baseName = trussStyle === 'kingpost' ? 'King Post' : 'Open';
                const chordName = trussChord === 'bottom' ? 'Bottom Chord' : (trussChord === 'mid' ? 'Mid Chord' : 'No Chord');
                let extras = '';
                if (trussRiserOn) extras += ' + Riser';
                if (trussDoglegOn) extras += ' + Dogleg';
                if (trussExtOn) extras += ' + Extender';
                const line1 = nTruss + '\u00D7 Gable Truss - ' + baseName + ', ' + chordName + extras;

                // Line 2: Dimensions
                let dims = 'SP: ' + Math.round(trussSpan) + '  HT: ' + Math.round(rise);
                if (trussRiserOn) dims += '  RX: ' + Math.round(trussRX) + '  RY: ' + Math.round(trussRY);
                if (trussDoglegOn) dims += '  LX: ' + Math.round(trussLX) + '  LY: ' + Math.round(trussLY);
                if (trussExtOn) dims += '  Ext: ' + Math.round(trussExtLen);

                // Line 3: Steel spec
                const line3 = steelName + ' RHS - ' + clr;

                let fab = line1 + '\n ' + dims + '\n ' + line3;

                // Detailed cut info below
                fab += '\n\n\u2500\u2500 Cut List (per truss) \u2500\u2500';
                fab += '\n Bottom Chord: 1 \u00D7 ' + chordCut + 'mm';
                fab += '\n Rafters:      2 \u00D7 ' + rafterCut + 'mm';
                if (trussStyle === 'kingpost') fab += '\n King Post:    1 \u00D7 ' + Math.round(kingPostH) + 'mm';
                fab += '\n Apex Mitre:   ' + apexAngle.toFixed(1) + '\u00B0';
                fab += '\n Heel Mitre:   ' + heelAngle.toFixed(1) + '\u00B0';
                fab += '\n\n\u2500\u2500 Material \u2500\u2500';
                fab += '\n Per truss: ' + totalLM.toFixed(3) + ' LM';
                fab += '\n All:       ' + totalAllLM.toFixed(2) + ' LM';
                fab += '\n Order:     ' + totalSticks + ' \u00D7 6m sticks';

                document.getElementById('fabOrder').textContent = fab;

                // Store truss data for PDF export
                calc.trussData = {
                    steelName, bmt, clr, nTruss, trussSpan: Math.round(trussSpan),
                    rise: Math.round(rise), pitch, overhang, chordCut, rafterCut,
                    apexAngle, heelAngle, webText, totalLM, totalAllLM, totalSticks,
                    trussStyle, trussChord, kingPostH: Math.round(kingPostH),
                    riser: { enabled: trussRiserOn, rx: trussRX, ry: trussRY },
                    dogleg: { enabled: trussDoglegOn, lx: trussLX, ly: trussLY },
                    extender: { enabled: trussExtOn, length: trussExtLen }
                };
            }

            return calc;
        }

        // ==================== 2D PLAN ====================
        function draw2DPlan() {
            const canvas = document.getElementById('plan2d');
            const p = canvas.parentElement;
            canvas.width = p.clientWidth; canvas.height = p.clientHeight;
            const ctx = canvas.getContext('2d');
            const c = calc;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            const planL = c.lenInput;
            const planW = c.projInput;

            const scale = Math.min((canvas.width-60)/planL, (canvas.height-60)/planW) * 0.85;
            const ox = (canvas.width - planL*scale)/2;
            const oy = (canvas.height - planW*scale)/2 + 10;

            if (c.connection !== 'freestanding') {
                ctx.fillStyle = '#D4C4B0';
                ctx.fillRect(ox-5, oy-20, planL*scale+10, 18);
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('HOUSE', ox+planL*scale/2, oy-6);
            }

            ctx.strokeStyle = steelColor.hex;
            ctx.lineWidth = 2;
            ctx.strokeRect(ox, oy, planL*scale, planW*scale);

            ctx.strokeStyle = '#F15A29';
            ctx.lineWidth = 2;
            if (c.isGable) {
                if (c.orientation === 'lengthways') {
                    ctx.beginPath();
                    ctx.moveTo(ox, oy + planW*scale/2);
                    ctx.lineTo(ox + planL*scale, oy + planW*scale/2);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.fillText('RIDGE', ox + planL*scale/2, oy + planW*scale/2 - 5);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(ox + planL*scale/2, oy);
                    ctx.lineTo(ox + planL*scale/2, oy + planW*scale);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.save();
                    ctx.translate(ox + planL*scale/2 + 12, oy + planW*scale/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.fillText('RIDGE', 0, 0);
                    ctx.restore();
                }
            } else {
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2, oy + 15);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2 - 6, oy + planW*scale - 25);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.lineTo(ox + planL*scale/2 + 6, oy + planW*scale - 25);
                ctx.stroke();
                ctx.fillStyle = '#F15A29';
                ctx.font = '9px sans-serif';
                ctx.fillText('FALL ' + calc.pitch.toFixed(1) + '°', ox + planL*scale/2 + 30, oy + planW*scale/2);
            }

            ctx.fillStyle = steelColor.hex;
            for (let i = 0; i < c.nPosts; i++) {
                const x = ox + (planL*scale/(c.nPosts-1)) * i;
                ctx.fillRect(x-4, oy + planW*scale - 4, 8, 8);
            }

            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = ox + (planL*scale/(c.nPosts-1)) * i;
                    ctx.fillRect(x-4, oy - 4, 8, 8);
                }
            }

            if (c.isAttached) {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.lineTo(ox + planL*scale, oy);
                ctx.stroke();
                ctx.fillStyle = '#666';
                ctx.font = '8px sans-serif';
                ctx.fillText('FASCIA', ox + planL*scale/2, oy + 10);
            }

            ctx.fillStyle = '#333';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(planL + 'mm', ox + planL*scale/2, oy + planW*scale + 20);
            ctx.save();
            ctx.translate(ox - 15, oy + planW*scale/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText(planW + 'mm', 0, 0);
            ctx.restore();
        }

        // ==================== TRUSS 3D (Section 2) ====================
        let trussScene, trussCam, trussRend, trussGroup;
        // Truss camera: orbit around Y axis
        let tCamT = 0, tCamP = 0.15, tCamD = 3;
        let tCamTarget = new THREE.Vector3(0, 0.15, 0);
        let tDrag = false, tLast = {x:0,y:0};

        function initTruss3D() {
            const container = document.getElementById('trussViewport');
            const canvas = document.getElementById('trussCanvas');
            var w = container.clientWidth || 600;
            var h = container.clientHeight || 420;
            trussScene = new THREE.Scene();
            trussScene.background = new THREE.Color(0xE4E7EB);
            trussCam = new THREE.PerspectiveCamera(35, w/h, 0.01, 50);
            trussRend = new THREE.WebGLRenderer({canvas, antialias: true});
            trussRend.setSize(w, h);
            trussRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            trussScene.add(new THREE.AmbientLight(0xffffff, 0.65));
            const light = new THREE.DirectionalLight(0xffffff, 0.7);
            light.position.set(3, 5, 4);
            trussScene.add(light);

            trussGroup = new THREE.Group();
            trussScene.add(trussGroup);

            canvas.addEventListener('mousedown', e => { tDrag = true; tLast = {x:e.clientX,y:e.clientY}; });
            canvas.addEventListener('mousemove', e => {
                if (!tDrag) return;
                tCamT -= (e.clientX - tLast.x) * 0.01;
                tCamP = Math.max(-0.3, Math.min(1.2, tCamP - (e.clientY - tLast.y) * 0.008));
                updateTrussCam();
                tLast = {x:e.clientX, y:e.clientY};
            });
            canvas.addEventListener('mouseup', () => tDrag = false);
            canvas.addEventListener('mouseleave', () => tDrag = false);
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                tCamD = Math.max(1, Math.min(10, tCamD + e.deltaY * 0.003));
                updateTrussCam();
            }, {passive: false});

            // Default to front view
            setTrussView('front', document.querySelector('.truss-view-btn.active'));
            buildTruss3D();
            animateTruss();
        }

        function updateTrussCam() {
            // Camera orbits in XZ plane, looking at target (center of truss)
            trussCam.position.set(
                tCamTarget.x + tCamD * Math.sin(tCamT) * Math.cos(tCamP),
                tCamTarget.y + tCamD * Math.sin(tCamP),
                tCamTarget.z + tCamD * Math.cos(tCamT) * Math.cos(tCamP)
            );
            trussCam.lookAt(tCamTarget);
        }

        // Truss is built in XY plane: X = span (horizontal), Y = rise (vertical), Z = depth
        function buildTruss3D() {
            while (trussGroup.children.length) trussGroup.remove(trussGroup.children[0]);
            if (!calc.isGable) return;

            const c = calc;
            const span = c.trussSpan / 1000;
            const rise = c.rise / 1000;
            const halfSpan = span / 2;
            const tw = c.steel.w;
            const th = c.steel.h;
            const overhang = (parseFloat(document.getElementById('inOverhang')?.value) || 0) / 1000;
            const mat = new THREE.MeshStandardMaterial({color: new THREE.Color(steelColor.hex), metalness: 0.75, roughness: 0.35});

            // Truss options (mm → m)
            const riserOn = c.trussRiser.enabled;
            const rx = c.trussRiser.rx / 1000;
            const ry = c.trussRiser.ry / 1000;
            const doglegOn = c.trussDogleg.enabled;
            const lx = c.trussDogleg.lx / 1000;
            const ly = c.trussDogleg.ly / 1000;
            const extOn = c.trussExtender.enabled;
            const extLen = c.trussExtender.length / 1000;
            const chordType = c.trussChord;
            const apexY = th + rise;

            tCamTarget.set(0, apexY * 0.45, 0);

            // Helper: box member between two 2D points
            function mbr(x1, y1, x2, y2) {
                const dx = x2 - x1, dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len < 0.001) return;
                const geo = new THREE.BoxGeometry(len, th, tw);
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.position.set((x1 + x2) / 2, (y1 + y2) / 2, 0);
                mesh.rotation.z = Math.atan2(dy, dx);
                trussGroup.add(mesh);
            }

            // --- Chord ---
            if (chordType === 'bottom') {
                const cLen = span + (extOn ? extLen * 2 : 0);
                mbr(-cLen / 2, th / 2, cLen / 2, th / 2);
            } else if (chordType === 'mid') {
                const rsX = riserOn ? (halfSpan - rx) : halfSpan;
                const rsY = riserOn ? (th + ry) : th;
                const midY = th + rise / 3;
                const midHX = rsX * (apexY - midY) / (apexY - rsY);
                mbr(-midHX, midY, midHX, midY);
            }
            // chord='none': no chord

            // --- Extender stubs (when chord is not bottom) ---
            if (extOn && chordType !== 'bottom') {
                mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2);
                mbr(halfSpan, th / 2, halfSpan + extLen, th / 2);
            }

            // --- Risers + Rafters (both sides) ---
            for (const side of [-1, 1]) {
                let rbX = side * halfSpan;
                let rbY = th;

                // Riser: vertical + horizontal step
                if (riserOn) {
                    mbr(rbX, th, rbX, th + ry);
                    const stepEnd = side * (halfSpan - rx);
                    mbr(rbX, th + ry, stepEnd, th + ry);
                    rbX = stepEnd;
                    rbY = th + ry;
                }

                if (doglegOn) {
                    const dgX = rbX - side * lx;
                    const dgY = rbY + ly;
                    // Overhang extends past rafter base in opposite direction of dogleg
                    if (overhang > 0) {
                        const ddx = dgX - rbX, ddy = dgY - rbY;
                        const dd = Math.sqrt(ddx * ddx + ddy * ddy);
                        mbr(rbX - (ddx / dd) * overhang, rbY - (ddy / dd) * overhang, rbX, rbY);
                    }
                    mbr(rbX, rbY, dgX, dgY);
                    mbr(dgX, dgY, 0, apexY);
                } else {
                    // Simple rafter with optional overhang extension
                    const rdx = 0 - rbX, rdy = apexY - rbY;
                    const rd = Math.sqrt(rdx * rdx + rdy * rdy);
                    const startX = overhang > 0 ? rbX - (rdx / rd) * overhang : rbX;
                    const startY = overhang > 0 ? rbY - (rdy / rd) * overhang : rbY;
                    mbr(startX, startY, 0, apexY);
                }
            }

            // --- King Post ---
            if (c.trussStyle === 'kingpost') {
                const kBottom = chordType === 'mid' ? (th + rise / 3 + th / 2) : th;
                const kTop = apexY - th;
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop);
                }
            }

            // --- Dimension annotations ---
            const dimMat = new THREE.LineBasicMaterial({color: 0xF15A29});
            const off = 0.08;

            // SP: Span
            addDimLine(-halfSpan, -off, halfSpan, -off, dimMat);
            addTrussLabel('SP: ' + Math.round(c.trussSpan) + 'mm', 0, -off - 0.07);

            // HT: Height
            const htX = halfSpan + off * 1.5;
            addDimLine(htX, th, htX, apexY, dimMat);
            addTrussLabel('HT: ' + Math.round(c.rise) + 'mm', htX + 0.15, th + rise / 2);

            // Rafter label
            const rsX0 = riserOn ? (halfSpan - rx) : halfSpan;
            const rsY0 = riserOn ? (th + ry) : th;
            const rMidX = -rsX0 * 0.55;
            const rMidY = rsY0 + (apexY - rsY0) * 0.55;
            addTrussLabel('Rafter: ' + Math.round(c.rafter) + 'mm', rMidX - 0.18, rMidY + 0.05);

            // RX, RY dimension labels (right side, blue)
            if (riserOn) {
                const rxMat = new THREE.LineBasicMaterial({color: 0x2196F3});
                addDimLine(halfSpan - rx, th + ry + off * 0.8, halfSpan, th + ry + off * 0.8, rxMat);
                addSmallLabel('RX: ' + Math.round(c.trussRiser.rx), halfSpan - rx / 2, th + ry + off * 1.6);
                addDimLine(halfSpan + off * 0.8, th, halfSpan + off * 0.8, th + ry, rxMat);
                addSmallLabel('RY: ' + Math.round(c.trussRiser.ry), halfSpan + off * 2, th + ry / 2);
            }

            // LX, LY dimension labels (right side, green)
            if (doglegOn) {
                const lMat = new THREE.LineBasicMaterial({color: 0x4CAF50});
                const dgBX = riserOn ? (halfSpan - rx) : halfSpan;
                const dgBY = riserOn ? (th + ry) : th;
                addDimLine(dgBX - lx, dgBY - off * 0.5, dgBX, dgBY - off * 0.5, lMat);
                addSmallLabel('LX: ' + Math.round(c.trussDogleg.lx), dgBX - lx / 2, dgBY - off * 1.3);
                addDimLine(dgBX + off * 0.5, dgBY, dgBX + off * 0.5, dgBY + ly, lMat);
                addSmallLabel('LY: ' + Math.round(c.trussDogleg.ly), dgBX + off * 1.5, dgBY + ly / 2);
            }

            // Extender label (right side, orange)
            if (extOn) {
                const eMat = new THREE.LineBasicMaterial({color: 0xFF9800});
                addDimLine(halfSpan, -off * 0.5, halfSpan + extLen, -off * 0.5, eMat);
                addSmallLabel('Ext: ' + Math.round(c.trussExtender.length), halfSpan + extLen / 2, -off * 1.5);
            }

            // Pitch angle arc at heel
            addAngleArc(halfSpan, th, 0.15, c.pitchRad, dimMat);
            addSmallLabel(c.pitch.toFixed(1) + '\u00B0', halfSpan - 0.06, th + 0.07);

            // Apex angle arc
            addAngleArc(0, apexY, 0.1, Math.PI / 2 - c.pitchRad, dimMat, true);
            addSmallLabel((90 - c.pitch).toFixed(1) + '\u00B0', 0, apexY + 0.08);

            // Cut markers
            addCutMarker(0, apexY, 'APEX');
            addCutMarker(-halfSpan, th, 'HEEL');
            addCutMarker(halfSpan, th, 'HEEL');

            updateTrussCam();
        }

        function addDimLine(x1, y1, x2, y2, mat) {
            const pts = [new THREE.Vector3(x1, y1, 0), new THREE.Vector3(x2, y2, 0)];
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            trussGroup.add(new THREE.Line(geo, mat));
            const tick = 0.025;
            const isVert = Math.abs(y2 - y1) > Math.abs(x2 - x1);
            [pts[0], pts[1]].forEach(p => {
                const t = isVert
                    ? [new THREE.Vector3(p.x - tick, p.y, 0), new THREE.Vector3(p.x + tick, p.y, 0)]
                    : [new THREE.Vector3(p.x, p.y - tick, 0), new THREE.Vector3(p.x, p.y + tick, 0)];
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(t), mat));
            });
        }

        function addAngleArc(cx, cy, radius, angle, mat, isApex) {
            const pts = [];
            const segs = 20;
            for (let i = 0; i <= segs; i++) {
                const a = (i / segs) * angle;
                if (isApex) {
                    // Arc from vertical down to rafter angle
                    const startAngle = Math.PI/2 + angle;
                    const aa = startAngle - (i / segs) * angle;
                    pts.push(new THREE.Vector3(cx + radius * Math.cos(aa), cy + radius * Math.sin(aa), 0));
                } else {
                    // Arc from horizontal up to rafter angle (at right heel)
                    pts.push(new THREE.Vector3(cx - radius * Math.cos(a), cy + radius * Math.sin(a), 0));
                }
            }
            trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
        }

        function addCutMarker(x, y, label) {
            const markerMat = new THREE.MeshBasicMaterial({color: 0xFF6B35, transparent: true, opacity: 0.8});
            const marker = new THREE.Mesh(new THREE.CircleGeometry(0.02, 12), markerMat);
            marker.position.set(x, y, 0.01);
            trussGroup.add(marker);
        }

        function addSmallLabel(text, x, y) {
            const cv = document.createElement('canvas');
            cv.width = 100; cv.height = 22;
            const ctx = cv.getContext('2d');
            ctx.fillStyle = 'rgba(80,80,80,0.85)';
            ctx.beginPath(); ctx.roundRect(0, 1, 100, 20, 3); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(text, 50, 15);
            const tex = new THREE.CanvasTexture(cv);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
            sprite.scale.set(0.14, 0.035, 1);
            sprite.position.set(x, y, 0.02);
            trussGroup.add(sprite);
        }

        function addTrussLabel(text, x, y) {
            const cv = document.createElement('canvas');
            cv.width = 220; cv.height = 36;
            const ctx = cv.getContext('2d');
            ctx.fillStyle = '#F15A29';
            ctx.beginPath(); ctx.roundRect(0, 3, 220, 30, 4); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(text, 110, 24);
            const tex = new THREE.CanvasTexture(cv);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
            sprite.scale.set(0.3, 0.06, 1);
            sprite.position.set(x, y, 0.02);
            trussGroup.add(sprite);
        }

        function setTrussView(v, btn) {
            document.querySelectorAll('.truss-view-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            const span = (calc.trussSpan || 3000) / 1000;
            const rise = (calc.rise || 264) / 1000;
            const baseDist = Math.max(2.5, span * 0.75);
            if (v === '3d') {
                tCamT = 0.5; tCamP = 0.35; tCamD = baseDist;
            } else if (v === 'front') {
                // Looking straight down Z axis → sees XY triangle
                tCamT = 0; tCamP = 0; tCamD = baseDist;
            } else if (v === 'side') {
                // Looking from side → down X axis
                tCamT = Math.PI/2; tCamP = 0.05; tCamD = baseDist * 0.5;
            }
            updateTrussCam();
        }

        function animateTruss() {
            requestAnimationFrame(animateTruss);
            if (trussRend && trussScene && trussCam) {
                trussRend.render(trussScene, trussCam);
            }
        }

        // ==================== ASSEMBLY 3D (Section 3) ====================
        let asmScene, asmCam, asmRend, asmRay, asmMouse;
        // rpRend removed — single renderer now lives in right panel as asmRend
        let steelGrp, roofGrp, accGrp, houseGrp;
        let compData = new Map();
        let hovered = null;
        let aCamT = 0.5, aCamP = 0.4, aCamD = 12;
        let aCamTarget = new THREE.Vector3(0, 1.5, 0); // updated dynamically after build
        let aDrag = false, aLast = {x:0,y:0};

        function initAsm3D() {
            const container = document.getElementById('asmViewport');
            const canvas = document.getElementById('asmCanvas');
            var w = container.clientWidth || 600;
            var h = container.clientHeight || 360;
            asmScene = new THREE.Scene();
            asmScene.background = new THREE.Color(0xC4CCD4);
            asmCam = new THREE.PerspectiveCamera(35, w/h, 0.1, 100);
            updateAsmCam();
            asmRend = new THREE.WebGLRenderer({canvas, antialias: true});
            asmRend.setSize(w, h);
            asmRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            asmRend.shadowMap.enabled = true;

            asmRay = new THREE.Raycaster();
            asmMouse = new THREE.Vector2();

            asmScene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(5, 10, 7);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            asmScene.add(sun);

            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshStandardMaterial({color: 0xA8A090, roughness: 0.9})
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            asmScene.add(ground);

            steelGrp = new THREE.Group();
            roofGrp = new THREE.Group();
            accGrp = new THREE.Group();
            houseGrp = new THREE.Group();
            asmScene.add(steelGrp);
            asmScene.add(roofGrp);
            asmScene.add(accGrp);
            asmScene.add(houseGrp);

            canvas.addEventListener('mousedown', e => { aDrag = true; aLast = {x:e.clientX,y:e.clientY}; });
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                asmMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                asmMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                checkHover(e.clientX - rect.left, e.clientY - rect.top);
                if (aDrag) {
                    aCamT -= (e.clientX - aLast.x) * 0.008;
                    aCamP = Math.max(0.1, Math.min(1.4, aCamP - (e.clientY - aLast.y) * 0.006));
                    updateAsmCam();
                    aLast = {x:e.clientX, y:e.clientY};
                }
            });
            canvas.addEventListener('mouseup', () => { aDrag = false; });
            canvas.addEventListener('mouseleave', () => { aDrag = false; clearHover(); });
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                aCamD = Math.max(4, Math.min(30, aCamD + e.deltaY * 0.01));
                updateAsmCam();
            }, {passive: false});

            buildAsm3D();
            animateAsm();
        }

        function updateAsmCam() {
            asmCam.position.set(
                aCamTarget.x + aCamD * Math.sin(aCamT) * Math.cos(aCamP),
                aCamTarget.y + aCamD * Math.sin(aCamP),
                aCamTarget.z + aCamD * Math.cos(aCamT) * Math.cos(aCamP)
            );
            asmCam.lookAt(aCamTarget);
        }

        function createCorrugatedGeometry(width, length, segments = 20) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const waveHeight = 0.012;
            const waveFreq = 15;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                pos.setZ(i, Math.sin(x * waveFreq * Math.PI) * waveHeight);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createTrimdekGeometry(width, length, segments = 30) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const ribHeight = 0.025;
            const ribWidth = 0.04;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const phase = ((x / ribWidth) % 1 + 1) % 1;
                let z = 0;
                if (phase < 0.3) z = ribHeight * (phase / 0.3);
                else if (phase < 0.7) z = ribHeight;
                else z = ribHeight * (1 - (phase - 0.7) / 0.3);
                pos.setZ(i, z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createInsulatedGeometry(width, length) {
            return new THREE.BoxGeometry(width, length, 0.05);
        }

        function buildAsm3D() {
            if (!steelGrp || !calc.W) return;
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => { while(g.children.length) g.remove(g.children[0]); });
            compData.clear();

            const c = calc;
            const W = c.W / 1000;
            const L = c.L / 1000;
            const postH = c.postH / 1000;
            const rise = c.rise / 1000;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;
            const th = c.steel.h;
            const frontBeamY = c.frontBeamY / 1000;
            const backBeamY = c.backBeamY / 1000;
            const fasciaBeamY = c.fasciaBeamY ? c.fasciaBeamY / 1000 : null;

            const steelCol = new THREE.Color(steelColor.hex);
            const sheetCol = new THREE.Color(sheetColor.hex);
            const sMat = () => new THREE.MeshStandardMaterial({color: steelCol, metalness: 0.8, roughness: 0.3});
            const rMat = () => new THREE.MeshStandardMaterial({color: sheetCol, metalness: 0.5, roughness: 0.4, side: THREE.DoubleSide});

            const fasciaCol = new THREE.Color(steelColor.hex).offsetHSL(0, -0.1, 0.15);
            const fasciaMat = () => new THREE.MeshStandardMaterial({color: fasciaCol, metalness: 0.7, roughness: 0.4});

            const riserCol = new THREE.Color(0x8B4513);
            const riserMat = () => new THREE.MeshStandardMaterial({color: riserCol, metalness: 0.6, roughness: 0.5});

            const beamW = 0.1, beamH = 0.05, postW = 0.09;

            const isPerpendicular = c.isGable && c.orientation === 'perpendicular';

            // ===== FRONT POSTS (Gutter side) =====
            const fpostH = frontBeamY;  // May be elevated for gable+riser
            for (let i = 0; i < c.nPosts; i++) {
                const x = -L/2 + (L / (c.nPosts - 1)) * i;
                const post = new THREE.Mesh(new THREE.BoxGeometry(postW, fpostH, postW), sMat());
                if (isPerpendicular) {
                    post.position.set(W/2, fpostH/2, x);
                } else {
                    post.position.set(x, fpostH/2, W/2);
                }
                post.castShadow = true;
                steelGrp.add(post);
                regComp(post, 'Front Post ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(fpostH*1000) + 'mm'});
            }

            // ===== BACK POSTS (freestanding only) =====
            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = -L/2 + (L / (c.nPosts - 1)) * i;
                    const bpostH = backBeamY;
                    const post = new THREE.Mesh(new THREE.BoxGeometry(postW, bpostH, postW), sMat());
                    if (isPerpendicular) {
                        post.position.set(-W/2, bpostH/2, x);
                    } else {
                        post.position.set(x, bpostH/2, -W/2);
                    }
                    post.castShadow = true;
                    steelGrp.add(post);
                    regComp(post, 'Back Post ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(bpostH*1000) + 'mm'});
                }
            }

            // ===== GUTTER BEAM (Front beam on posts) =====
            const gutterBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamH, beamW), sMat());
            if (isPerpendicular) {
                gutterBeam.rotation.y = Math.PI / 2;
                gutterBeam.position.set(W/2, frontBeamY + beamH/2, 0);
            } else {
                gutterBeam.position.set(0, frontBeamY + beamH/2, W/2);
            }
            gutterBeam.castShadow = true;
            steelGrp.add(gutterBeam);
            regComp(gutterBeam, 'Gutter Beam', {'Size': '100×50×2 RHS', 'Length': c.L + 'mm'});

            // ===== FASCIA BEAM (on house - for attached only) =====
            // Against house fascia board face, below gutter in exposed fascia zone
            if (c.isAttached && fasciaBeamY !== null) {
                const fasciaBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamW * 1.1, beamH * 1.2), fasciaMat());
                // Z: against house fascia face (wall face + fascia board thickness offset)
                const fbmZ = -W/2 - 0.02;
                if (isPerpendicular) {
                    fasciaBeam.rotation.y = Math.PI / 2;
                    fasciaBeam.position.set(fbmZ, fasciaBeamY + beamW/2, 0);
                } else {
                    fasciaBeam.position.set(0, fasciaBeamY + beamW/2, fbmZ);
                }
                fasciaBeam.castShadow = true;
                steelGrp.add(fasciaBeam);
                regComp(fasciaBeam, 'Fascia Beam', {'Size': '100×50×2 RHS', 'Length': c.L + 'mm', 'Height': c.fasciaH + 'mm', 'Note': 'House connection'});
            }

            // ===== RAFTER BRACKETS (for fascia connections only) =====
            if (c.connection === 'fascia') {
                const bracketLen = 0.5;
                const bracketH = 0.006;
                const bracketW = 0.05;
                const bracketCount = Math.max(3, Math.ceil(L / 1.0));
                for (let i = 0; i < bracketCount; i++) {
                    const x = -L/2 + (L / (bracketCount - 1)) * i;
                    const bracket = new THREE.Mesh(
                        new THREE.BoxGeometry(bracketW, bracketH, bracketLen),
                        sMat()
                    );
                    if (isPerpendicular) {
                        bracket.rotation.y = Math.PI / 2;
                        bracket.position.set(-W/2 - bracketLen/2 - 0.08, fasciaBeamY + beamH + 0.1, x);
                    } else {
                        bracket.position.set(x, fasciaBeamY + beamH + 0.1, -W/2 - bracketLen/2 - 0.08);
                    }
                    steelGrp.add(bracket);
                }
            }

            // ===== V18 FIX: RISERS with correct stacking =====
            if (c.connection === 'riser') {
                // V18: Riser beam sits ON TOP of risers
                const riserOff = c.riserOffset / 1000;
                const riserSize = 0.075;
                const count = c.riserQty;

                // Calculate actual vertical rise of risers
                // Span from fascia beam top (horiz piece) up to riser beam bottom (backBeamY)
                const actualRiserH = backBeamY - (fasciaBeamY + beamH + riserSize);

                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;

                    // HORIZONTAL piece (comes out from fascia beam)
                    const horizPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, riserSize, riserOff),
                        riserMat()
                    );

                    // VERTICAL piece (rises up)
                    const vertPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, actualRiserH, riserSize),
                        riserMat()
                    );

                    if (isPerpendicular) {
                        horizPiece.rotation.y = Math.PI / 2;
                        horizPiece.position.set(-W/2 + riserOff/2, fasciaBeamY + beamH + riserSize/2, x);
                        vertPiece.position.set(-W/2 + riserOff, fasciaBeamY + beamH + riserSize + actualRiserH/2, x);
                    } else {
                        horizPiece.position.set(x, fasciaBeamY + beamH + riserSize/2, -W/2 + riserOff/2);
                        vertPiece.position.set(x, fasciaBeamY + beamH + riserSize + actualRiserH/2, -W/2 + riserOff);
                    }

                    horizPiece.castShadow = true;
                    vertPiece.castShadow = true;
                    steelGrp.add(horizPiece);
                    steelGrp.add(vertPiece);
                    regComp(vertPiece, 'Riser Elbow ' + (i+1), {
                        'Size': '75×75×2 SHS',
                        'Offset': c.riserOffset + 'mm',
                        'Rise': Math.round(actualRiserH * 1000) + 'mm',
                        'Note': '90° elbow clears house gutter'
                    });
                }

                // Riser brackets – threaded rod through house fascia, clamps fascia beam tight
                // Strip lays along rafter top, threaded rod pokes through fascia board
                const galvMat = () => new THREE.MeshStandardMaterial({color: 0xC0C0C0, metalness: 0.7, roughness: 0.4});
                const fasciaHmR = c.fasciaH / 1000; // rafter base Y (independent of fascia beam)
                const fasciaBdH = 0.15; // house fascia board height
                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;
                    const stripLen = 0.45;   // 450mm long
                    const stripW = 0.03;     // 30mm wide
                    const stripT = 0.006;    // 6mm thick galv plate
                    // Y: vertically centred on house fascia board
                    const bkY = fasciaHmR - fasciaBdH / 2;
                    // House fascia front face is 50mm behind patio edge
                    // Fascia beam front face is 10mm past patio edge
                    const fasciaFaceOff = -0.05; // house fascia front face relative to -W/2
                    const fbmFrontOff = 0.01;    // fascia beam front face relative to -W/2
                    // Threaded rod: from fascia face through to fascia beam front face
                    const rodLen = fbmFrontOff - fasciaFaceOff; // 60mm
                    const rodD = 0.012; // M12 threaded rod
                    // Strip: mostly behind wall, tip at house fascia face
                    const strip = new THREE.Mesh(
                        new THREE.BoxGeometry(stripW, stripT, stripLen),
                        galvMat()
                    );
                    // Threaded rod: pokes through fascia, does NOT protrude past fascia beam
                    const bolt = new THREE.Mesh(
                        new THREE.BoxGeometry(rodD, rodD, rodLen),
                        galvMat()
                    );
                    if (isPerpendicular) {
                        strip.rotation.y = Math.PI / 2;
                        strip.position.set(-W/2 + fasciaFaceOff - stripLen/2, bkY, x);
                        bolt.rotation.y = Math.PI / 2;
                        bolt.position.set(-W/2 + fasciaFaceOff + rodLen/2, bkY, x);
                    } else {
                        strip.position.set(x, bkY, -W/2 + fasciaFaceOff - stripLen/2);
                        bolt.position.set(x, bkY, -W/2 + fasciaFaceOff + rodLen/2);
                    }
                    steelGrp.add(strip);
                    steelGrp.add(bolt);
                    regComp(strip, 'Riser Bracket ' + (i+1), {'Size': '450×30×6mm Galv Flat Bar', 'Rod': 'M12 threaded rod', 'Note': 'Threaded rod through fascia, clamps fascia beam tight'});
                }

                // Box gutter (if selected) - sits in gap between house wall and riser beam
                if (c.houseGutter === 'box') {
                    // Width sized to fit the gap between house fascia and riser beam
                    const boxGutterW = riserOff;
                    const boxGutterD = 0.1;       // inner wall height (house side)
                    const boxGutterOuter = 0.12;  // outer wall height (riser side, taller to catch water)
                    const wallT = 0.01;

                    // U-shaped cross-section: X=0 is house side, X=boxGutterW is riser side
                    const gutterShape = new THREE.Shape();
                    gutterShape.moveTo(0, 0);
                    gutterShape.lineTo(boxGutterW, 0);
                    gutterShape.lineTo(boxGutterW, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, wallT);
                    gutterShape.lineTo(wallT, wallT);
                    gutterShape.lineTo(wallT, boxGutterD);
                    gutterShape.lineTo(0, boxGutterD);
                    gutterShape.closePath();

                    const extrudeSettings = { depth: L, bevelEnabled: false };
                    const gutterGeo = new THREE.ExtrudeGeometry(gutterShape, extrudeSettings);
                    const boxGutter = new THREE.Mesh(gutterGeo, sMat());

                    // Y: gutter bottom sits ON TOP of the riser elbow horizontal pieces
                    // horiz piece top = fasciaBeamY + beamH + riserSize
                    const boxGutterY = fasciaBeamY + beamH + riserSize;

                    if (isPerpendicular) {
                        // House wall at X = -W/2, riser beam at X = -W/2 + riserOff
                        // rotation.y = π: local X → world -X, local +Z → world -Z
                        // Shape X=0 (house side) → world X = position.x (riser beam)
                        // Shape X=gutterW (riser side) → world X = position.x - gutterW = -W/2 (house)
                        // So we need to flip: position at -W/2, no extra rotation for X direction
                        // Use rotation.y = 0: local X → world +X, local Z → world +Z
                        // Shape X=0 (house side) at world X = -W/2, X=gutterW at -W/2 + riserOff
                        boxGutter.rotation.y = 0;
                        boxGutter.position.set(-W/2, boxGutterY, -L/2);
                    } else {
                        // House wall at Z = -W/2, riser beam at Z = -W/2 + riserOff
                        // rotation.y = -π/2: local X → world +Z, local +Z → world -X
                        // Shape X=0 (house side) at world Z = -W/2
                        // Shape X=gutterW (riser side) at world Z = -W/2 + riserOff
                        // Extrusion goes -X, so position at X = +L/2
                        boxGutter.rotation.y = -Math.PI / 2;
                        boxGutter.position.set(L/2, boxGutterY, -W/2);
                    }
                    accGrp.add(boxGutter);
                    regComp(boxGutter, 'Box Gutter', {'Width': Math.round(riserOff*1000)+'mm', 'Inner Depth': '100mm', 'Outer Depth': '120mm'});
                }

                // Patio gutter on riser beam (gable only) - catches back slope water
                if (c.isGable && c.riserGutter === 'quad') {
                    const rgW = 0.115;     // 115mm quad gutter
                    const rgFront = 0.076; // 76mm front face
                    const rgBack = 0.045;  // 45mm back face
                    const rgT = 0.001;     // 1mm sheet steel
                    const rgs = new THREE.Shape();
                    rgs.moveTo(0, 0);
                    rgs.lineTo(rgW, 0);
                    rgs.lineTo(rgW, rgFront);
                    rgs.lineTo(rgW - rgT, rgFront);
                    rgs.lineTo(rgW - rgT, rgT);
                    rgs.lineTo(rgT, rgT);
                    rgs.lineTo(rgT, rgBack);
                    rgs.lineTo(0, rgBack);
                    rgs.closePath();
                    const rgGeo = new THREE.ExtrudeGeometry(rgs, { depth: L, bevelEnabled: false });
                    const riserGutterMesh = new THREE.Mesh(rgGeo, sMat());
                    // Sits on top of riser beam
                    const riserBeamTop = backBeamY + 0.1; // riser beam height = 0.1
                    if (isPerpendicular) {
                        riserGutterMesh.position.set(-W/2 + riserOff - rgW/2, riserBeamTop, -L/2);
                    } else {
                        riserGutterMesh.rotation.y = -Math.PI / 2;
                        riserGutterMesh.position.set(L/2, riserBeamTop, -W/2 + riserOff - rgW/2);
                    }
                    accGrp.add(riserGutterMesh);
                    regComp(riserGutterMesh, 'Riser Beam Gutter', {'Type': '115mm Quad', 'Length': c.L + 'mm', 'Note': 'Catches gable back slope water'});
                }
            }

            // ===== CARRY / BACK BEAM - NOT for receiving channel (fascia/wall use channel instead) =====
            if (c.connection !== 'fascia' && c.connection !== 'wall') {
                const isRiser = c.connection === 'riser';
                const isFlyover = c.connection === 'flyover';
                const beamHeight = isRiser ? 0.1 : (isFlyover ? 0.05 : beamH);
                const beamWidth = isRiser ? 0.05 : (isFlyover ? 0.15 : beamW);
                const riserOff = isRiser ? c.riserOffset/1000 : 0;

                const carryBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamHeight, beamWidth), sMat());
                if (isPerpendicular) {
                    carryBeam.rotation.y = Math.PI / 2;
                    carryBeam.position.set(-W/2 + riserOff, backBeamY + beamHeight/2, 0);
                } else {
                    carryBeam.position.set(0, backBeamY + beamHeight/2, -W/2 + riserOff);
                }
                carryBeam.castShadow = true;
                steelGrp.add(carryBeam);
                const beamName = isRiser ? 'Riser Beam' : (isFlyover ? 'Flyover Beam' : 'Back Beam');
                const beamSpec = isRiser ? '100×50×2 RHS (on edge)' : (isFlyover ? '150×50×2 RHS' : '100×50×2 RHS');
                regComp(carryBeam, beamName, {'Size': beamSpec, 'Length': c.L + 'mm', 'Height': Math.round(backBeamY*1000) + 'mm'});
            }

            // ===== FLYOVER VERTICAL STRUTS - sit ON TOP of house roof =====
            // Struts penetrate through roof sheets and bolt to house rafters
            if (c.connection === 'flyover') {
                const fasciaHm = c.fasciaH / 1000;
                const hRafterH = 0.09; // house rafter height
                // Struts positioned on house roof near the eave, directly under the flyover beam
                // Roof surface at the eave = rafter top = fasciaHm + hRafterH
                const roofSurfaceY = fasciaHm + hRafterH;
                const strutSize = 0.09; // 90x90 SHS
                const strutH = Math.max(0.15, backBeamY - roofSurfaceY);
                const strutCount = Math.max(2, Math.ceil(L / 1.2));
                // Struts are at same Z as the flyover beam (at patio back edge)
                // They go through the roof/fascia and bolt to the house rafters below

                for (let i = 0; i < strutCount; i++) {
                    const x = -L/2 + (L / (strutCount - 1)) * i;
                    const strut = new THREE.Mesh(
                        new THREE.BoxGeometry(strutSize, strutH, strutSize),
                        sMat()
                    );
                    if (isPerpendicular) {
                        strut.position.set(-W/2, roofSurfaceY + strutH/2, x);
                    } else {
                        strut.position.set(x, roofSurfaceY + strutH/2, -W/2);
                    }
                    strut.castShadow = true;
                    steelGrp.add(strut);
                    regComp(strut, 'Flyover Strut ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(strutH*1000) + 'mm'});
                }
            }

            // ===== ROOF STRUCTURE =====
            const frontTop = frontBeamY + beamH;
            const backTop = backBeamY + beamH;
            const sheetW = c.sheetCoverage / 1000;

            // V18: Calculate actual gutter height for downpipes
            let gutterY;

            if (c.isGable) {
                // ========== GABLE ROOF ==========
                const trussBaseY = (frontTop + backTop) / 2;
                const tiltAngle = Math.atan2(backTop - frontTop, W);
                gutterY = frontTop - 0.04;

                // Trusses (peak from internal geometry; tilt spans between beams when heights differ)
                for (let i = 0; i < c.nTruss; i++) {
                    const x = -L/2 + (L / (c.nTruss - 1)) * i;
                    const truss = createTrussUnit(W, rise, rafter, tw, th, sMat(), c);
                    if (isPerpendicular) {
                        truss.rotation.order = 'ZYX';
                        truss.rotation.y = Math.PI / 2;
                        truss.rotation.z = -tiltAngle;
                        truss.position.set(0, trussBaseY, x);
                    } else {
                        truss.rotation.x = tiltAngle;
                        truss.position.set(x, trussBaseY, 0);
                    }
                    steelGrp.add(truss);
                    regComp(truss, 'Truss ' + (i+1), {'Span': Math.round(c.trussSpan) + 'mm', 'Rise': Math.round(c.rise) + 'mm'});

                    // Gable infill
                    if ((i === 0 || i === c.nTruss - 1) && c.infill !== 'none') {
                        const shape = new THREE.Shape();
                        shape.moveTo(-W/2, th);
                        shape.lineTo(0, rise + th);
                        shape.lineTo(W/2, th);
                        shape.closePath();
                        const isTransparent = c.infill === 'polycarbonate';
                        const isLouvre = c.infill === 'louvre';
                        const infillMat = new THREE.MeshStandardMaterial({
                            color: isTransparent ? 0xDDEEEE : (isLouvre ? 0xCCCCCC : sheetCol),
                            transparent: isTransparent,
                            opacity: isTransparent ? 0.6 : 1,
                            side: THREE.DoubleSide
                        });
                        const infillMesh = new THREE.Mesh(new THREE.ShapeGeometry(shape), infillMat);

                        if (isPerpendicular) {
                            infillMesh.rotation.y = x > 0 ? Math.PI : 0;
                            infillMesh.position.set(0, trussBaseY, x);
                        } else {
                            infillMesh.rotation.y = Math.PI / 2;
                            infillMesh.position.set(x, trussBaseY, 0);
                        }
                        roofGrp.add(infillMesh);
                        const infillLabel = {colorbond:'Colorbond', polycarbonate:'Polycarbonate', louvre:'Louvre'}[c.infill] || c.infill;
                        regComp(infillMesh, 'Gable Infill', {'Material': infillLabel});
                    }
                }

                // Purlins
                const purlinCount = Math.max(2, Math.ceil(rafter / 0.8));
                for (let side = -1; side <= 1; side += 2) {
                    for (let p = 1; p <= purlinCount; p++) {
                        const frac = p / (purlinCount + 1);
                        const zPos = (W/2) * frac * side;
                        const yPos = trussBaseY + th + rise * (1 - frac);
                        const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                        if (isPerpendicular) {
                            purlin.rotation.y = Math.PI / 2;
                            purlin.position.set(zPos, yPos, 0);
                        } else {
                            purlin.position.set(0, yPos, zPos);
                        }
                        steelGrp.add(purlin);
                    }
                }

                // V18 FIX: Roof sheets - corrected rotation for perpendicular mode
                const numSheets = Math.ceil(L / sheetW);
                const gablePc = (c.roofing === 'trimdek') ? getPolycarbConfig() : null;
                for (let side = -1; side <= 1; side += 2) {
                    for (let s = 0; s < numSheets; s++) {
                        const sheetPos = -L/2 + sheetW/2 + s * sheetW;
                        const isPolySheet = gablePc && ((s + 1) % gablePc.patternN === 0);
                        let sheetGeo;
                        if (c.roofing === 'corrugated') {
                            sheetGeo = createCorrugatedGeometry(sheetW, rafter + 0.05);
                        } else if (c.roofing === 'trimdek') {
                            sheetGeo = createTrimdekGeometry(sheetW, rafter + 0.05);
                        } else {
                            sheetGeo = createInsulatedGeometry(sheetW, rafter + 0.05);
                        }

                        let sheetMat;
                        if (isPolySheet) {
                            const tintData = POLYCARB_3D_TINTS[gablePc.tint] || POLYCARB_3D_TINTS['Clear'];
                            sheetMat = new THREE.MeshStandardMaterial({
                                color: tintData.color, transparent: true, opacity: tintData.opacity,
                                metalness: 0.1, roughness: 0.15, side: THREE.DoubleSide
                            });
                        } else {
                            sheetMat = rMat();
                        }
                        const sheet = new THREE.Mesh(sheetGeo, sheetMat);

                        if (isPerpendicular) {
                            sheet.rotation.order = 'YXZ';
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                            sheet.rotation.y = Math.PI / 2;

                            const midHeight = trussBaseY + th + rise/2;
                            sheet.position.set(side * W/4, midHeight + th/2 + 0.02, sheetPos);
                        } else {
                            sheet.position.set(sheetPos, trussBaseY + th + th/2 + rise/2 + 0.01, side * W/4);
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                        }
                        sheet.castShadow = !isPolySheet;
                        roofGrp.add(sheet);
                        const sideLabel = side === -1 ? 'A' : 'B';
                        const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                        regComp(sheet, 'Roof Sheet ' + sideLabel + (s+1), {'Profile': sheetType, 'Length': Math.round((rafter + 0.05)*1000) + 'mm', 'Side': side === -1 ? 'Left slope' : 'Right slope'});
                    }
                }

                // Ridge capping
                const ridge = new THREE.Mesh(new THREE.BoxGeometry(L, 0.04, 0.3), rMat());
                if (isPerpendicular) {
                    ridge.rotation.y = Math.PI / 2;
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                } else {
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                }
                accGrp.add(ridge);
                regComp(ridge, 'Ridge Cap', {'Length': c.L + 'mm'});

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                if (isPerpendicular) {
                    gutter.rotation.y = Math.PI / 2;
                    gutter.position.set(W/2 + 0.07, gutterY, 0);
                } else {
                    gutter.position.set(0, gutterY, W/2 + 0.07);
                }
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.L + 'mm'});

                // Gable barges
                const bargeThick = 0.003;
                const bargeWidth = 0.15;
                const bargeLen = rafter + 0.05;

                if (isPerpendicular) {
                    [-L/2, L/2].forEach((zEnd) => {
                        const bargeL = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeL.position.set(-W/4, trussBaseY + th + rise/2, zEnd);
                        bargeL.rotation.z = c.pitchRad;
                        accGrp.add(bargeL);

                        const bargeR = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeR.position.set(W/4, trussBaseY + th + rise/2, zEnd);
                        bargeR.rotation.z = -c.pitchRad;
                        accGrp.add(bargeR);
                    });
                } else {
                    [-L/2, L/2].forEach((xEnd) => {
                        const bargeHouse = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeHouse.position.set(xEnd, trussBaseY + th + rise/2, -W/4);
                        bargeHouse.rotation.x = -c.pitchRad;
                        accGrp.add(bargeHouse);

                        const bargeGutter = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeGutter.position.set(xEnd, trussBaseY + th + rise/2, W/4);
                        bargeGutter.rotation.x = c.pitchRad;
                        accGrp.add(bargeGutter);
                    });
                }

            } else {
                // ========== SKILLION ROOF ==========
                gutterY = frontTop - 0.04;  // V18: Store gutter Y for downpipes

                const riserOff = c.connection === 'riser' ? c.riserOffset / 1000 : 0;
                const backEdgeZ = -W/2 + riserOff;

                // Rafters
                for (let i = 0; i < c.nRafters; i++) {
                    const x = -L/2 + (L / (c.nRafters - 1)) * i;
                    const rafterGeo = new THREE.BoxGeometry(tw, th, rafter);
                    rafterGeo.translate(0, 0, rafter/2);
                    const raft = new THREE.Mesh(rafterGeo, sMat());
                    raft.position.set(x, backTop + th/2, backEdgeZ);
                    raft.rotation.x = c.pitchRad;
                    steelGrp.add(raft);
                    regComp(raft, 'Rafter ' + (i+1), {'Size': c.steel.name, 'Length': Math.round(c.rafter) + 'mm'});
                }

                // Purlins
                const effectiveW = W - riserOff;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9));
                for (let p = 0; p <= purlinCount; p++) {
                    const frac = p / purlinCount;
                    const zPos = backEdgeZ + effectiveW * frac;
                    const yPos = backTop + th - (backTop - frontTop) * frac;
                    const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                    purlin.position.set(0, yPos, zPos);
                    steelGrp.add(purlin);
                }

                // Roof sheets
                const sheetInset = c.isRecvChan ? 0.03 : 0; // 30mm into channel
                const numSheets = Math.ceil(L / sheetW);
                const skillPc = (c.roofing === 'trimdek') ? getPolycarbConfig() : null;
                for (let s = 0; s < numSheets; s++) {
                    const xPos = -L/2 + sheetW/2 + s * sheetW;
                    const isPolySheet = skillPc && ((s + 1) % skillPc.patternN === 0);
                    let sheetGeo;
                    if (c.roofing === 'corrugated') {
                        sheetGeo = createCorrugatedGeometry(sheetW, rafter);
                    } else if (c.roofing === 'trimdek') {
                        sheetGeo = createTrimdekGeometry(sheetW, rafter);
                    } else {
                        sheetGeo = createInsulatedGeometry(sheetW, rafter);
                    }
                    sheetGeo.translate(0, rafter/2, 0);

                    let sheetMat;
                    if (isPolySheet) {
                        const tintData = POLYCARB_3D_TINTS[skillPc.tint] || POLYCARB_3D_TINTS['Clear'];
                        sheetMat = new THREE.MeshStandardMaterial({
                            color: tintData.color, transparent: true, opacity: tintData.opacity,
                            metalness: 0.1, roughness: 0.15, side: THREE.DoubleSide
                        });
                    } else {
                        sheetMat = rMat();
                    }
                    const sheet = new THREE.Mesh(sheetGeo, sheetMat);
                    sheet.position.set(xPos, backTop + th + th/2 + 0.01, backEdgeZ - sheetInset);
                    sheet.rotation.x = Math.PI/2 + c.pitchRad;
                    sheet.castShadow = !isPolySheet;
                    roofGrp.add(sheet);
                    const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                    regComp(sheet, 'Roof Sheet ' + (s+1), {'Profile': sheetType, 'Length': Math.round(rafter*1000) + 'mm'});
                }

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                gutter.position.set(0, gutterY, W/2 + 0.07);
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.lenInput + 'mm'});

                // Back flashing - skip for riser+box gutter AND receiving channel (channel acts as flashing)
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    const flash = new THREE.Mesh(new THREE.BoxGeometry(L, 0.15, 0.003), sMat());
                    flash.position.set(0, backTop + 0.08, backEdgeZ - 0.05);
                    flash.rotation.x = -0.3;
                    accGrp.add(flash);
                    regComp(flash, 'Back Flashing', {'Length': c.lenInput + 'mm'});
                }

                // Barge flashings
                [-L/2, L/2].forEach((xPos, idx) => {
                    const barge = new THREE.Mesh(new THREE.BoxGeometry(0.1, rafter, 0.003), sMat());
                    barge.position.set(xPos, (backTop + frontTop)/2 + th, 0);
                    barge.rotation.x = -(Math.PI/2 - c.pitchRad);
                    accGrp.add(barge);
                });
            }

            // ===== V18 FIX: DOWNPIPES - Use actual gutter height =====
            let dpPositions;
            if (isPerpendicular) {
                dpPositions = [[W/2 + 0.1, -L/2 + 0.1], [W/2 + 0.1, L/2 - 0.1]];
            } else {
                dpPositions = [[-L/2 + 0.1, W/2 + 0.1], [L/2 - 0.1, W/2 + 0.1]];
            }
            dpPositions.forEach((pos, idx) => {
                // V18 FIX: Downpipe height = from ground to gutter, not postH
                const dpHeight = gutterY + 0.04;  // Gutter bottom + 40mm into gutter
                const dp = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, dpHeight, 12), sMat());
                dp.position.set(pos[0], dpHeight/2, pos[1]);
                accGrp.add(dp);
                regComp(dp, 'Downpipe ' + (idx+1), {'Size': '90mm Round', 'Height': Math.round(dpHeight*1000) + 'mm'});
            });

            // ===== HOUSE / WALL REPRESENTATION =====
            // riser, fascia, flyover: house with wall + fascia board + Colorbond roof
            // wall: flat wall only (receiving channel bolts to wall surface)
            // freestanding: no wall
            if (c.isAttached) {
                const fasciaHm = c.fasciaH / 1000;
                const wallThick = 0.15;
                const wallLen = L + 0.2;
                const wallMat = new THREE.MeshStandardMaterial({color: 0xD4C4B0, roughness: 0.9});
                const fasciaTimberMat = new THREE.MeshStandardMaterial({color: 0x8B7355, roughness: 0.8});
                // Monument colour (#3C3C3C) for existing house Colorbond roof
                const roofColorbondMat = new THREE.MeshStandardMaterial({color: 0x3C3C3C, roughness: 0.5, metalness: 0.4});

                if (c.connection === 'wall') {
                    // === WALL MODE: just a flat brick/render wall ===
                    const wallH = Math.max(backBeamY + 0.5, fasciaHm + 0.5);
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                } else {
                    // === HOUSE MODE (riser, fascia, flyover): wall + fascia + roof ===
                    // Wall: only up to fascia height (roof sits above)
                    const wallH = fasciaHm;
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                    // Fascia board (timber) covers the full rafter end face
                    if (fasciaHm > 0) {
                        const fasciaBoardH = 0.15;   // 150mm tall
                        const fasciaBoardT = 0.025;  // 25mm thick
                        const fasciaBoard = new THREE.Mesh(
                            new THREE.BoxGeometry(wallLen, fasciaBoardH, fasciaBoardT),
                            fasciaTimberMat
                        );
                        // Fascia board top aligns with rafter bottom (fasciaHm)
                        // Gutter sits against fascia front face at the top half
                        const fbZ = -W/2 - wallThick/2 + fasciaBoardT/2;
                        const fbY = fasciaHm - fasciaBoardH/2; // center of board, top at rafter bottom
                        if (isPerpendicular) {
                            fasciaBoard.rotation.y = Math.PI / 2;
                            fasciaBoard.position.set(fbZ, fbY, 0);
                        } else {
                            fasciaBoard.position.set(0, fbY, fbZ);
                        }
                        fasciaBoard.castShadow = true;
                        houseGrp.add(fasciaBoard);
                        regComp(fasciaBoard, 'House Fascia Board', {'Size': '150×25mm Timber', 'Height': c.fasciaH + 'mm'});
                    }

                    // House roof: timber rafters + individual Colorbond sheets
                    const roofDepth = 1.5;       // 1.5m visible depth
                    const roofPitch = 15 * Math.PI / 180;
                    const roofRise = roofDepth * Math.tan(roofPitch);
                    const roofBaseY = fasciaHm;  // rafters sit on wall top plate
                    const roofCenterY = roofBaseY + roofRise / 2;
                    const roofZCenter = -W/2 - wallThick/2 - roofDepth/2;

                    // Timber rafters (45×90mm) at 600mm spacing
                    const rafterW = 0.045, rafterH = 0.09, rafterSpacing = 0.6;
                    const rafterCount = Math.max(2, Math.ceil(wallLen / rafterSpacing) + 1);
                    for (let i = 0; i < rafterCount; i++) {
                        const pos = -wallLen/2 + (wallLen / (rafterCount - 1)) * i;
                        const rafter = new THREE.Mesh(
                            new THREE.BoxGeometry(rafterW, rafterH, roofDepth),
                            fasciaTimberMat
                        );
                        if (isPerpendicular) {
                            rafter.rotation.order = 'YXZ';
                            rafter.rotation.y = Math.PI / 2;
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(roofZCenter, roofCenterY, pos);
                        } else {
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(pos, roofCenterY, roofZCenter);
                        }
                        rafter.castShadow = true;
                        houseGrp.add(rafter);
                    }
                    // Register first rafter for tooltip
                    if (houseGrp.children.length > 0) {
                        const lastRafter = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastRafter, 'House Rafter', {'Size': '45×90mm Timber', 'Spacing': '600mm', 'Qty': rafterCount});
                    }

                    // Individual Colorbond roof sheets on top of rafters
                    // Sheets overhang 50mm past fascia into gutter
                    const hSheetW = 0.762;  // corrugated sheet cover width
                    const hSheetT = 0.001;  // ~1mm Colorbond
                    const hOverhang = 0.05; // 50mm overhang past fascia
                    const hSheetDepth = roofDepth + hOverhang;
                    const hSheetZCenter = roofZCenter + hOverhang/2; // shift toward fascia
                    const hSheetCount = Math.max(1, Math.ceil(wallLen / hSheetW));
                    const hSheetCenterY = roofCenterY + rafterH/2 + hSheetT/2;
                    for (let i = 0; i < hSheetCount; i++) {
                        const sw = (i === hSheetCount - 1) ? (wallLen - hSheetW * i) : hSheetW;
                        const pos = -wallLen/2 + hSheetW * i + sw/2;
                        const hSheet = new THREE.Mesh(
                            new THREE.BoxGeometry(sw, hSheetT, hSheetDepth),
                            roofColorbondMat.clone()
                        );
                        if (isPerpendicular) {
                            hSheet.rotation.order = 'YXZ';
                            hSheet.rotation.y = Math.PI / 2;
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(hSheetZCenter, hSheetCenterY, pos);
                        } else {
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(pos, hSheetCenterY, hSheetZCenter);
                        }
                        hSheet.castShadow = true;
                        hSheet.receiveShadow = true;
                        houseGrp.add(hSheet);
                    }
                    const roofLabel = c.connection === 'flyover' ? 'Existing House Roof (Flyover)' : 'Existing House Roof';
                    if (houseGrp.children.length > 0) {
                        const lastSheet = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastSheet, roofLabel, {'Pitch': '15°', 'Material': 'Colorbond', 'Sheets': hSheetCount});
                    }

                    // House quad gutter – sits against front face of fascia, at the top half
                    // Hidden when box gutter is selected (box gutter replaces it)
                    const showHouseGutter = !(c.connection === 'riser' && c.houseGutter === 'box');
                    if (showHouseGutter) {
                    const hGutterW = 0.115;    // 115mm wide
                    const hGutterFront = 0.076; // 76mm front face
                    const hGutterBack = 0.045;  // 45mm back face
                    const hGutterT = 0.001;     // 1mm sheet steel
                    const hgs = new THREE.Shape();
                    hgs.moveTo(0, 0);
                    hgs.lineTo(hGutterW, 0);
                    hgs.lineTo(hGutterW, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterBack);
                    hgs.lineTo(0, hGutterBack);
                    hgs.closePath();
                    const hGutterGeo = new THREE.ExtrudeGeometry(hgs, { depth: L, bevelEnabled: false });
                    const hGutter = new THREE.Mesh(hGutterGeo, roofColorbondMat.clone());
                    // Back lip top at fasciaHm – gutter against top half of fascia face
                    const hGutterY = fasciaHm - hGutterBack;
                    const hGutterZ = -W/2 - wallThick/2 + 0.025; // at fascia board front face
                    if (isPerpendicular) {
                        // extrude along +Z; rotation.y=0 keeps local Z=world Z
                        hGutter.position.set(hGutterZ, hGutterY, -L/2);
                    } else {
                        // rotation.y=-π/2: local +Z → world -X, shape X → world +Z
                        hGutter.rotation.y = -Math.PI / 2;
                        hGutter.position.set(L/2, hGutterY, hGutterZ);
                    }
                    houseGrp.add(hGutter);
                    regComp(hGutter, 'House Quad Gutter', {'Size': '115mm Quad', 'Front': '76mm', 'Back': '45mm'});
                    } // end showHouseGutter
                }

                // C-Channel - for receiving channel modes (fascia and wall only)
                if (c.isRecvChan) {
                    const chanW = 0.075;  // 75mm wide – captures sheet edges
                    const chanH = 0.03;   // 30mm tall
                    const chanT = 0.003;  // 3mm steel thickness
                    // C-channel profile (U-shape opening toward patio)
                    const chanShape = new THREE.Shape();
                    chanShape.moveTo(0, 0);
                    chanShape.lineTo(chanW, 0);
                    chanShape.lineTo(chanW, chanT);
                    chanShape.lineTo(chanT, chanT);
                    chanShape.lineTo(chanT, chanH - chanT);
                    chanShape.lineTo(chanW, chanH - chanT);
                    chanShape.lineTo(chanW, chanH);
                    chanShape.lineTo(0, chanH);
                    chanShape.closePath();

                    const chanGeo = new THREE.ExtrudeGeometry(chanShape, { depth: L, bevelEnabled: false });
                    const channel = new THREE.Mesh(chanGeo, sMat());

                    if (c.connection === 'fascia') {
                        // On fascia board face, at fascia beam height
                        const chanY = fasciaHm + beamH/2 - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    } else {
                        // Wall mode: on wall surface at connection height
                        const chanY = fasciaHm - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    }
                    steelGrp.add(channel);
                    regComp(channel, 'Receiving Channel', {'Size': '75×30mm C-Channel', 'Length': c.L + 'mm', 'Type': c.connection === 'fascia' ? 'Fascia mount' : 'Wall mount'});
                }
            }

            updateMatList();

            // Update camera orbit target to center of combined patio + house
            const bbox = new THREE.Box3();
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => {
                if (g.children.length > 0) bbox.expandByObject(g);
            });
            if (!bbox.isEmpty()) {
                bbox.getCenter(aCamTarget);
            }
            updateAsmCam();
        }

        function createTrussUnit(W, rise, rafter, tw, th, mat, c) {
            const g = new THREE.Group();
            const halfW = W / 2;
            const apexY = th + rise;

            const riserOn = c.trussRiser.enabled;
            const rx = c.trussRiser.rx / 1000;
            const ry = c.trussRiser.ry / 1000;
            const doglegOn = c.trussDogleg.enabled;
            const lx = c.trussDogleg.lx / 1000;
            const ly = c.trussDogleg.ly / 1000;
            const extOn = c.trussExtender.enabled;
            const extLen = c.trussExtender.length / 1000;
            const chordType = c.trussChord;
            const style = c.trussStyle;

            // Helper: box member between two ZY points (Z = span, Y = height)
            function mbr(z1, y1, z2, y2) {
                const dz = z2 - z1, dy = y2 - y1;
                const len = Math.sqrt(dz * dz + dy * dy);
                if (len < 0.001) return;
                const geo = new THREE.BoxGeometry(tw, th, len);
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.position.set(0, (y1 + y2) / 2, (z1 + z2) / 2);
                mesh.rotation.x = -Math.atan2(dy, dz);
                g.add(mesh);
            }

            // --- Chord ---
            if (chordType === 'bottom') {
                const cLen = W + (extOn ? extLen * 2 : 0);
                mbr(-cLen / 2, th / 2, cLen / 2, th / 2);
            } else if (chordType === 'mid') {
                const rsZ = riserOn ? (halfW - rx) : halfW;
                const rsY = riserOn ? (th + ry) : th;
                const midY = th + rise / 3;
                const midHZ = rsZ * (apexY - midY) / (apexY - rsY);
                mbr(-midHZ, midY, midHZ, midY);
            }

            // --- Extender stubs (when chord is not bottom) ---
            if (extOn && chordType !== 'bottom') {
                mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                mbr(halfW, th / 2, halfW + extLen, th / 2);
            }

            // --- Risers + Rafters (both sides) ---
            for (const side of [-1, 1]) {
                let rbZ = side * halfW;
                let rbY = th;

                if (riserOn) {
                    mbr(rbZ, th, rbZ, th + ry);
                    const stepEnd = side * (halfW - rx);
                    mbr(rbZ, th + ry, stepEnd, th + ry);
                    rbZ = stepEnd;
                    rbY = th + ry;
                }

                if (doglegOn) {
                    const dgZ = rbZ - side * lx;
                    const dgY = rbY + ly;
                    mbr(rbZ, rbY, dgZ, dgY);
                    mbr(dgZ, dgY, 0, apexY);
                } else {
                    mbr(rbZ, rbY, 0, apexY);
                }
            }

            // --- King Post ---
            if (style === 'kingpost') {
                const kBottom = chordType === 'mid' ? (th + rise / 3 + th / 2) : th;
                const kTop = apexY - th;
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop);
                }
            }

            return g;
        }

        function regComp(mesh, name, specs) {
            compData.set(mesh.uuid, {name, specs});
        }

        function checkHover(mx, my) {
            asmRay.setFromCamera(asmMouse, asmCam);
            const all = [];
            if (steelGrp.visible) all.push(...steelGrp.children);
            if (roofGrp.visible) all.push(...roofGrp.children);
            if (accGrp.visible) all.push(...accGrp.children);
            if (houseGrp.visible) all.push(...houseGrp.children);
            const hits = asmRay.intersectObjects(all, true);
            if (hits.length > 0) {
                let obj = hits[0].object;
                while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;
                if (compData.has(obj.uuid)) {
                    if (hovered !== obj) { clearHover(); hovered = obj; highlight(obj); }
                    showTooltip(mx, my, compData.get(obj.uuid));
                    return;
                }
            }
            clearHover();
        }

        function highlight(mesh) {
            const hl = new THREE.Color(0xF15A29);
            if (mesh.material) { mesh.material.emissive = hl; mesh.material.emissiveIntensity = 0.3; }
            mesh.traverse(c => { if (c.material) { c.material.emissive = hl; c.material.emissiveIntensity = 0.3; }});
        }

        function clearHover() {
            if (hovered) {
                if (hovered.material) { hovered.material.emissive = new THREE.Color(0); hovered.material.emissiveIntensity = 0; }
                hovered.traverse(c => { if (c.material) { c.material.emissive = new THREE.Color(0); c.material.emissiveIntensity = 0; }});
                hovered = null;
            }
            hideTooltip();
        }

        function showTooltip(x, y, data) {
            const tt = document.getElementById('tooltip');
            document.getElementById('ttTitle').textContent = data.name;
            document.getElementById('ttContent').innerHTML = Object.entries(data.specs)
                .map(([k,v]) => `<div class="tooltip-row"><span class="tooltip-label">${k}</span><span class="tooltip-value">${v}</span></div>`).join('');
            tt.style.left = (x + 15) + 'px';
            tt.style.top = (y + 15) + 'px';
            tt.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function toggleLayer(layer, el) {
            el.classList.toggle('active');
            const vis = el.classList.contains('active');
            if (layer === 'steel') steelGrp.visible = vis;
            if (layer === 'roof') roofGrp.visible = vis;
            if (layer === 'acc') accGrp.visible = vis;
            if (layer === 'house') houseGrp.visible = vis;
        }

        function setAsmView(v, btn) {
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            if (v === '3d') { aCamT = 0.5; aCamP = 0.4; aCamD = 12; }
            else if (v === 'front') { aCamT = 0; aCamP = 0.25; aCamD = 10; }
            else if (v === 'side') { aCamT = Math.PI/2; aCamP = 0.3; aCamD = 12; }
            else if (v === 'top') { aCamT = 0; aCamP = 1.4; aCamD = 15; }
            updateAsmCam();
        }

        function toggleFullscreen() {
            const el = document.getElementById('asmViewport');
            el.classList.toggle('fullscreen');
            setTimeout(() => {
                asmCam.aspect = el.clientWidth / el.clientHeight;
                asmCam.updateProjectionMatrix();
                asmRend.setSize(el.clientWidth, el.clientHeight);
            }, 100);
        }

        function getSheetMatEntries(numSheets, roofing) {
            const pc = (roofing === 'trimdek') ? getPolycarbConfig() : null;
            if (!pc) return [{d: roofing + ' Sheets', q: numSheets}];
            const split = getPolycarbSheetSplit(numSheets);
            const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
            const colorbondColour = sheetColor ? sheetColor.name : '';
            const entries = [];
            if (split.colorbond > 0) entries.push({d: 'Trimdek Colorbond' + (colorbondColour ? ' ' + colorbondColour : '') + ' Sheets', q: split.colorbond});
            if (split.polycarb > 0) entries.push({d: 'Trimdek Polycarb ' + brandLabel + ' ' + pc.tint + ' Sheets', q: split.polycarb});
            return entries;
        }

        function updateMatList() {
            const c = calc;
            let mats = [];
            const sheetCover = c.sheetCoverage;

            if (c.isGable) {
                const numSheets = Math.ceil(c.L / sheetCover) * 2;
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                const riserCount = c.riserQty;
                // Beam count depends on connection type
                let beamCount;
                if (c.connection === 'freestanding') {
                    beamCount = 2;  // Gutter beam + back beam
                } else if (c.connection === 'riser') {
                    beamCount = 3;  // Gutter beam + fascia beam + riser beam
                } else {
                    beamCount = 2;  // Gutter beam + fascia/back beam
                }
                const purlinCount = Math.max(2, Math.ceil(c.rafter / 1000 / 0.8)) * 2;
                mats = [
                    {d: 'Posts 90×90×2', q: postCount},
                    {d: 'Beams 100×50×2', q: beamCount},
                    {d: 'Trusses ' + c.steel.name, q: c.nTruss},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Ridge Cap', q: 1},
                    {d: 'Gable Barges', q: 4},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                if (c.infill !== 'none') mats.push({d: 'Gable Infill', q: 2});
                if (c.connection === 'riser') {
                    mats.push({d: 'Riser Elbows 75×75', q: riserCount});
                    mats.push({d: 'Riser Beam 100×50', q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                    if (c.riserGutter === 'quad') {
                        mats.push({d: 'Riser Beam Gutter 115mm Quad', q: 1});
                    }
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            } else {
                const numSheets = Math.ceil(c.L / sheetCover);
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                let beamCount;
                if (c.connection === 'riser') {
                    beamCount = 3;  // gutter + fascia + riser beam
                } else if (c.isRecvChan) {
                    beamCount = 1;  // gutter beam only (channel replaces back beam)
                } else {
                    beamCount = 2;  // gutter + back/flyover beam
                }
                const riserCount = c.riserQty;
                const effectiveW = (c.W - (c.connection === 'riser' ? c.riserOffset : 0)) / 1000;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9)) + 1;
                mats = [
                    {d: 'Posts 90×90×2', q: postCount},
                    {d: 'Beams 100×50×2', q: beamCount},
                    {d: 'Rafters ' + c.steel.name, q: c.nRafters},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Barge Flashings', q: 2},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                // Back flashing - skip for riser+box gutter AND receiving channel
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    mats.splice(5, 0, {d: 'Back Flashing', q: 1});
                }
                if (c.connection === 'riser') {
                    mats.splice(2, 0, {d: 'Riser Elbows 75×75', q: riserCount});
                    mats.splice(3, 0, {d: 'Riser Beam 100×50', q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                }
                if (c.connection === 'flyover') {
                    const strutCount = Math.max(2, Math.ceil(c.L / 1200));
                    mats.push({d: 'Flyover Struts 90×90', q: strutCount});
                    mats.push({d: 'Flyover Beam 150×50', q: 1});
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                    mats.push({d: 'Foam Backfill Strips (' + c.roofing + ')', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            }

            // Group materials by build sequence
            const groups = [
                { id: 'cfg-structure',  num: '1', name: 'Structure',  items: [] },
                { id: 'cfg-roofing',    num: '2', name: 'Roofing',    items: [] },
                { id: 'cfg-drainage',   num: '3', name: 'Drainage',   items: [] },
                { id: 'cfg-finishing',   num: '4', name: 'Finishing',  items: [] },
                { id: 'cfg-fixings',    num: '5', name: 'Fixings',    items: [] }
            ];

            mats.forEach(function(m) {
                const d = m.d.toLowerCase();
                if (d.includes('post') || d.includes('90×90') || d.includes('100×100') ||
                    d.includes('beam') || d.includes('100×50') || d.includes('150×50') ||
                    d.includes('purlin') || d.includes('truss') || d.includes('rafter') ||
                    d.includes('riser elbow') || d.includes('strut')) {
                    groups[0].items.push(m);
                } else if (d.includes('sheet') || d.includes('solarspan') || d.includes('trimdek') ||
                           d.includes('corrugated') || d.includes('spanplus') || d.includes('ridge cap') ||
                           d.includes('polycarb')) {
                    groups[1].items.push(m);
                } else if (d.includes('gutter') || d.includes('downpipe') || d.includes('box gutter')) {
                    groups[2].items.push(m);
                } else if (d.includes('barge') || d.includes('infill') || d.includes('flashing') ||
                           d.includes('fascia') || d.includes('channel') || d.includes('foam')) {
                    groups[3].items.push(m);
                } else {
                    groups[4].items.push(m);
                }
            });

            // Helpers to extract size, display name, length, colour for each material
            function matSize(desc) {
                var d = desc.toLowerCase();
                if (d.includes('90×90'))    return '90×90×2 SHS';
                if (d.includes('100×100'))  return '100×100×2 SHS';
                if (d.includes('150×50'))   return '150×50×2 RHS';
                if (d.includes('100×50'))   return '100×50×2 RHS';
                if (d.includes('75×50'))    return '75×50×2 RHS';
                if (d.includes('76×38'))    return '76×38×1.6 RHS';
                if (d.includes('75×75'))    return '75×75 Elbow';
                if (d.includes('solarspan'))return 'Insulated Panel';
                if (d.includes('trimdek'))  return 'Trimdek';
                if (d.includes('corrugated'))return 'Corrugated';
                if (d.includes('spanplus')) return 'SpanPlus 330';
                if (d.includes('115mm'))    return '115mm Quad';
                return '\u2014';
            }
            function matName(desc) {
                var d = desc.toLowerCase();
                if (d.includes('post'))         return 'Posts';
                if (d.includes('riser beam gutter')) return 'Riser Beam Gutter';
                if (d.includes('riser beam'))   return 'Riser Beam';
                if (d.includes('riser elbow'))  return 'Riser Elbows';
                if (d.includes('flyover beam')) return 'Flyover Beam';
                if (d.includes('flyover strut'))return 'Flyover Struts';
                if (d.includes('beam'))         return 'Beams';
                if (d.includes('truss'))        return 'Trusses';
                if (d.includes('rafter'))       return 'Rafters';
                if (d.includes('purlin'))       return 'Purlins';
                if (d.includes('ridge cap'))    return 'Ridge Cap';
                if (d.includes('downpipe'))     return 'Downpipes';
                if (d.includes('box gutter'))   return 'Box Gutter';
                if (d.includes('gutter'))       return 'Gutter';
                if (d.includes('barge'))        return 'Barge Flashings';
                if (d.includes('back flashing'))return 'Back Flashing';
                if (d.includes('infill'))       return 'Gable Infill';
                if (d.includes('fascia board')) return 'House Fascia Board';
                if (d.includes('channel'))      return 'Receiving Channel';
                if (d.includes('foam'))         return 'Foam Backfill';
                if (d.includes('polycarb'))     return 'Polycarb Sheets';
                if (d.includes('sheet'))        return 'Sheets';
                return desc;
            }
            function matLen(desc) {
                var len = getItemLength(desc);
                return len > 0 ? len.toFixed(1) + 'm' : '\u2014';
            }
            function matColour(desc) {
                var d = desc.toLowerCase();
                if (d.includes('post') || d.includes('beam') || d.includes('purlin') ||
                    d.includes('truss') || d.includes('rafter') || d.includes('strut') ||
                    d.includes('75×75') || d.includes('barge') || d.includes('gutter') ||
                    d.includes('downpipe') || d.includes('ridge') || d.includes('flashing') ||
                    d.includes('channel')) return steelColor.name;
                if (d.includes('polycarb')) return '\u2014';
                if (d.includes('sheet') || d.includes('infill')) return sheetColor.name;
                return '\u2014';
            }

            var hdrRow = '<div class="mat-hdr"><span>Item</span><span style="text-align:right">Qty</span><span>Size</span><span style="text-align:right">Length</span><span>Colour</span></div>';

            let html = '';
            groups.forEach(function(g, idx) {
                const isOpen = idx === 0;
                var rows = '';
                if (g.items.length > 0) {
                    rows = hdrRow + g.items.map(function(m) {
                        return '<div class="mat-row" data-desc="' + m.d.replace(/"/g, '&quot;') + '">' +
                            '<span>' + matName(m.d) + '</span>' +
                            '<span class="mat-qty">' + m.q + '×</span>' +
                            '<span class="mat-size">' + matSize(m.d) + '</span>' +
                            '<span class="mat-len">' + matLen(m.d) + '</span>' +
                            '<span class="mat-clr">' + matColour(m.d) + '</span>' +
                            '</div>';
                    }).join('');
                }
                const body = g.items.length > 0 ? rows : '<div class="cfg-group-empty">No items in this category</div>';
                html += '<div class="cfg-group">' +
                    '<div class="cfg-group-hdr" onclick="toggleCfgGroup(\'' + g.id + '\')">' +
                        '<span class="cfg-group-arrow' + (isOpen ? ' open' : '') + '" id="' + g.id + '-arrow">&#9654;</span>' +
                        '<span class="cfg-group-num">' + g.num + '.</span> ' + g.name +
                    '</div>' +
                    '<div class="cfg-group-body' + (isOpen ? ' open' : '') + '" id="' + g.id + '-body">' + body + '</div>' +
                '</div>';
            });

            document.getElementById('matList').innerHTML = html;

            // Pre-order validation checks
            var checks = [];

            // 1. Sheet coverage check
            var totalSheets = 0;
            mats.forEach(function(m) {
                if (m.d.toLowerCase().includes('sheet')) totalSheets += m.q;
            });
            // For gable, sheets cover one side; coverage = sheets/2 * coverWidth vs L
            var coverageMm, requiredMm;
            if (c.isGable) {
                coverageMm = Math.floor(totalSheets / 2) * sheetCover;
                requiredMm = c.L;
            } else {
                coverageMm = totalSheets * sheetCover;
                requiredMm = c.L;
            }
            if (coverageMm < requiredMm) {
                var shortBy = requiredMm - coverageMm;
                checks.push({ ok: false, text: 'May be short by ' + Math.round(shortBy) + 'mm \u2014 check sheet count' });
            } else {
                checks.push({ ok: true, text: 'Sheet coverage OK' });
            }

            // 2. Gutter overhang check
            var sheetLenMm = c.isGable ? c.rafter : c.rafter;
            var projMm = c.W;
            var overhangNeeded = projMm + 50;
            if (sheetLenMm < overhangNeeded) {
                checks.push({ ok: false, text: 'Add 50mm for gutter overhang' });
            } else {
                checks.push({ ok: true, text: 'Gutter overhang OK' });
            }

            // 3. Downpipe count
            var dpCount = 0;
            mats.forEach(function(m) {
                if (m.d.toLowerCase().includes('downpipe')) dpCount += m.q;
            });
            var widthMm = c.L;
            if (widthMm > 12000 && dpCount < 2) {
                checks.push({ ok: false, text: 'Consider 2 downpipes for 12m+ gutter' });
            } else {
                checks.push({ ok: true, text: 'Downpipe count OK' });
            }

            var checksHtml = '<div class="preorder-box"><div class="preorder-title">Pre-Order Checks</div>';
            checks.forEach(function(ch) {
                if (ch.ok) {
                    checksHtml += '<div class="preorder-item preorder-ok">\u2713 ' + ch.text + '</div>';
                } else {
                    checksHtml += '<div class="preorder-item preorder-warn">\u26A0\uFE0F ' + ch.text + '</div>';
                }
            });
            checksHtml += '</div>';
            document.getElementById('preOrderChecks').innerHTML = checksHtml;
        }

        function toggleCfgGroup(id) {
            var body = document.getElementById(id + '-body');
            var arrow = document.getElementById(id + '-arrow');
            body.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        function animateAsm() {
            requestAnimationFrame(animateAsm);
            if (asmRend && asmScene && asmCam) {
                asmRend.render(asmScene, asmCam);
            }
        }

        // ==================== PRICING ====================
        const DEFAULT_RATES = {
            // Steel ($/LM)
            '90×90×2 RHS':     35.50,
            '76×38×1.6 RHS':   15.50,
            '75×50×2 RHS':     26.00,
            '100×50×2 RHS':    30.00,
            '150×50×2 RHS':    39.05,
            // Roofing ($/LM)
            'Solarspan 75mm':  110.00,
            'Corrugated Colorbond': 12.04,
            'Trimdek Colorbond':   14.00,
            'Ampelite Solasafe 5-Rib': 25.00,
            'Laserlite 2000 5-Rib':    27.00,
            // Flashings ($/LM)
            'Ridge Cap':       15.00,
            'Barge Flashing':  12.00,
            'Back Flashing':   14.00,
            'Gutter Flashing': 10.00,
            // Gutters & Drainage ($/LM)
            'Quad Gutter 115mm': 18.00,
            'Box Gutter':      45.00,
            'Downpipe 90mm':   12.00,
            // Extras
            'Gable Infill (sqm)': 45.00,
            'Riser Bracket (ea)': 12.00,
            'Fixings ($/sqm)': 2.50,
            'Foam Strip':      3.00,
            // Labour ($/day)
            'Skilled Trade':   400.00,
            'Labourer':        250.00,
            'Electrician':     450.00
        };

        const DEFAULT_SELL_MARKUP = 1.35; // 35% default markup on cost for sell price
        let storedRates = {};
        let jobRows = [];      // {desc, qty, length, unitCost, unitSell, isAddon}
        let labourRows = [];   // {desc, trades, days, dayRate, sell}
        let extrasRows = [];   // {desc, qty, unitCost, unitSell, type}
        let pricingState = {}; // cached pricing calcs for PDF access

        function loadRates() {
            try {
                const saved = localStorage.getItem('patioRates');
                storedRates = saved ? JSON.parse(saved) : { ...DEFAULT_RATES };
                // Merge in any new default keys missing from saved data
                Object.keys(DEFAULT_RATES).forEach(k => {
                    if (!(k in storedRates)) storedRates[k] = DEFAULT_RATES[k];
                });
            } catch (e) {
                storedRates = { ...DEFAULT_RATES };
            }
        }

        function saveRates() {
            localStorage.setItem('patioRates', JSON.stringify(storedRates));
        }

        function renderRatesPanel() {
            const body = document.getElementById('ratesBody');
            body.innerHTML = Object.entries(storedRates).map(([k, v]) =>
                `<tr><td>${k}</td><td><input type="number" class="rate-input" step="0.01" value="${v.toFixed(2)}" onchange="updateRate('${k}', this.value)"></td></tr>`
            ).join('');
        }

        function updateRate(key, val) {
            storedRates[key] = parseFloat(val) || 0;
            saveRates();
            buildJobRows();
            // Update labour day rate if applicable
            if (key === 'Skilled Trade') {
                const el = document.getElementById('labDayRate');
                if (el && parseFloat(el.value) === 400) el.value = storedRates[key];
            }
            updatePricing();
        }

        function openRatesModal() {
            renderRatesPanel();
            document.getElementById('ratesModal').style.display = '';
        }


        function matchRate(desc) {
            const d = desc.toLowerCase();
            // Steel
            if (d.includes('90×90') || d.includes('90x90')) return storedRates['90×90×2 RHS'] || 0;
            if (d.includes('76×38') || d.includes('76x38')) return storedRates['76×38×1.6 RHS'] || 0;
            if (d.includes('75×50') || d.includes('75x50') || d.includes('75×75') || d.includes('75x75')) return storedRates['75×50×2 RHS'] || 0;
            if (d.includes('150×50') || d.includes('150x50')) return storedRates['150×50×2 RHS'] || 0;
            if (d.includes('100×50') || d.includes('100x50')) return storedRates['100×50×2 RHS'] || 0;
            // Roofing
            if (d.includes('solarspan')) return storedRates['Solarspan 75mm'] || 0;
            if (d.includes('polycarb') && d.includes('laserlite')) return storedRates['Laserlite 2000 5-Rib'] || 0;
            if (d.includes('polycarb') && d.includes('ampelite')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('polycarb')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('trimdek') && d.includes('sheet')) return storedRates['Trimdek Colorbond'] || 0;
            if (d.includes('sheet') && !d.includes('solarspan')) return storedRates['Corrugated Colorbond'] || 0;
            // Flashings
            if (d.includes('ridge cap') || d.includes('ridge flash')) return storedRates['Ridge Cap'] || 0;
            if (d.includes('barge')) return storedRates['Barge Flashing'] || 0;
            if (d.includes('back flash') || d.includes('wall flash')) return storedRates['Back Flashing'] || 0;
            if (d.includes('gutter flash')) return storedRates['Gutter Flashing'] || 0;
            // Gutters & drainage
            if (d.includes('box gutter')) return storedRates['Box Gutter'] || 0;
            if (d.includes('gutter') && !d.includes('box') && !d.includes('downpipe') && !d.includes('flash')) return storedRates['Quad Gutter 115mm'] || 0;
            if (d.includes('downpipe')) return storedRates['Downpipe 90mm'] || 0;
            // Extras
            if (d.includes('infill')) return storedRates['Gable Infill (sqm)'] || 0;
            if (d.includes('riser') && d.includes('bracket')) return storedRates['Riser Bracket (ea)'] || 0;
            if (d.includes('foam')) return storedRates['Foam Strip'] || 0;
            if (d.includes('channel') && !d.includes('gutter')) return storedRates['Back Flashing'] || 0;
            if (d.includes('strut')) return storedRates['76×38×1.6 RHS'] || 0;
            if (d.includes('elbow')) return storedRates['Downpipe 90mm'] || 0;
            if (d.includes('fascia board')) return storedRates['Barge Flashing'] || 0;
            return 0;
        }

        function getItemLength(desc) {
            const c = calc;
            const d = desc.toLowerCase();
            const Lm = c.L / 1000;
            const Wm = c.W / 1000;
            if (d.includes('post')) return c.postH / 1000;
            if (d.includes('beam') || d.includes('ridge') || d.includes('barge') || d.includes('flashing') || d.includes('channel') || d.includes('gutter') || d.includes('fascia board')) return Lm;
            if (d.includes('truss') || d.includes('rafter')) return c.rafter / 1000;
            if (d.includes('purlin')) return Lm;
            if (d.includes('sheet') && d.includes('solarspan')) return Wm;
            if (d.includes('sheet')) return c.rafter / 1000;
            if (d.includes('downpipe')) return c.postH / 1000;
            if (d.includes('strut')) return 0.5;
            if (d.includes('riser elbow')) return 0.5;
            if (d.includes('infill')) return c.rafter / 1000;
            if (d.includes('foam')) return Lm;
            return 1;
        }

        // Build jobRows from the materials list (called after rebuildAll)
        function buildJobRows() {
            const matRowEls = document.querySelectorAll('#matList .mat-row');
            // Preserve existing addon rows
            const addons = jobRows.filter(r => r.isAddon);
            jobRows = [];
            matRowEls.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length < 2) return;
                const desc = row.dataset.desc || spans[0].textContent.trim();
                const qty = parseInt(spans[1].textContent.trim().replace('×', '')) || 1;
                const length = getItemLength(desc);
                const unitCost = matchRate(desc);
                const unitSell = +(unitCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc, qty, length, unit: 'LM', unitCost, unitSell, isAddon: false });
            });
            // Auto-add fixings estimate based on patio area
            const c = calc;
            if (c.L && c.W) {
                const areaSqm = (c.L / 1000) * (c.W / 1000);
                const fixCost = storedRates['Fixings ($/sqm)'] || 2.50;
                const fixSell = +(fixCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc: 'Fixings (screws, anchors, silicone, foam)', qty: +areaSqm.toFixed(1), length: 1, unit: 'sqm', unitCost: fixCost, unitSell: fixSell, isAddon: false });
            }
            // Re-append addons
            addons.forEach(a => { if (!a.unit) a.unit = 'each'; jobRows.push(a); });
        }

        const UNIT_OPTIONS = ['each', 'LM', 'sqm', 'hours', 'days', 'lot'];

        // Keep renderJobTable for compatibility (materials modal uses it internally)
        function renderJobTable() { /* now handled by materials modal */ }

        // Extras presets
        function addExtra(type) {
            const nPosts = calc.nPosts ? calc.nPosts * 2 : 6;
            const presets = {
                footings:    { desc: 'Concrete Footings', qty: nPosts, unitCost: 85,  unitSell: 150, type: 'footings' },
                electrical:  { desc: 'Electrical',        qty: 1,      unitCost: 0,   unitSell: 0,   type: 'electrical' },
                downlights:  { desc: 'Downlights',        qty: 4,      unitCost: 50,  unitSell: 85,  type: 'downlights' },
                demo:        { desc: 'Demo/Removal',      qty: 1,      unitCost: 0,   unitSell: 0,   type: 'demo' },
                delivery:    { desc: 'Delivery',           qty: 1,      unitCost: 200, unitSell: 350, type: 'delivery' },
                other:       { desc: '',                   qty: 1,      unitCost: 0,   unitSell: 0,   type: 'other' }
            };
            const p = presets[type];
            if (!p) return;
            extrasRows.push({ ...p });
            renderExtras();
            updatePricing();
        }

        function removeExtra(idx) {
            extrasRows.splice(idx, 1);
            renderExtras();
            updatePricing();
        }

        function renderExtras() {
            const container = document.getElementById('extrasRowsContainer');
            if (extrasRows.length === 0) {
                container.innerHTML = '';
                return;
            }
            container.innerHTML = extrasRows.map((r, i) => {
                const totalCost = r.qty * r.unitCost;
                const totalSell = r.qty * r.unitSell;
                const fmt = v => '$' + v.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                const descInput = r.type === 'other'
                    ? `<input type="text" class="ex-input desc-input" value="${r.desc}" placeholder="Description" onchange="extrasRows[${i}].desc=this.value">`
                    : `<span>${r.desc}${r.qty > 1 ? ' (' + r.qty + ')' : ''}</span>`;
                return `<div class="extras-row">
                    <div class="ex-desc">${descInput}</div>
                    ${r.type === 'downlights' || r.type === 'footings' ? `<div class="ex-field">Qty: <input type="number" class="ex-input" style="width:50px" value="${r.qty}" min="1" step="1" onchange="extrasRows[${i}].qty=parseFloat(this.value)||1;renderExtras();updatePricing()"></div>` : ''}
                    <div class="ex-field">Cost: <input type="number" class="ex-input" value="${totalCost.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitCost=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <div class="ex-field">Sell: <input type="number" class="ex-input" value="${totalSell.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitSell=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <button class="ex-remove" onclick="removeExtra(${i})">&times;</button>
                </div>`;
            }).join('');
        }

        // Legacy addon compat: migrate old addon rows to extras on import
        function addSmartAddon(type) {
            const typeMap = { concrete: 'footings', electrical: 'electrical', downlights: 'downlights', demo: 'demo', fan: 'other', fascia: 'other', posts: 'other', permit: 'other' };
            addExtra(typeMap[type] || 'other');
        }
        function addCustomLine() { addExtra('other'); }
        function removeJobRow(idx) { jobRows.splice(idx, 1); updatePricing(); }

        // Labour — read from inline card inputs
        function getLabourFromCard() {
            const trades = parseFloat(document.getElementById('labTrades').value) || 0;
            const days = parseFloat(document.getElementById('labDays').value) || 0;
            const dayRate = parseFloat(document.getElementById('labDayRate').value) || 0;
            const sell = parseFloat(document.getElementById('labSellInput').value) || 0;
            const cost = trades * days * dayRate;
            return { trades, days, dayRate, cost, sell };
        }

        // Sync labourRows from card for PDF/export compat
        function syncLabourRows() {
            const l = getLabourFromCard();
            labourRows = [{ role: 'Skilled (Patio Install)', trades: l.trades, days: l.days, dayRate: l.dayRate, sell: l.sell }];
        }

        // Kept for export/import compat
        function renderLabourTable() {}
        function addLabourRole() {}
        function matchDayRate(role) {
            const r = role.toLowerCase();
            if (r.includes('electrician')) return storedRates['Electrician'] || 450;
            if (r.includes('labourer')) return storedRates['Labourer'] || 250;
            return storedRates['Skilled Trade'] || 400;
        }

        // Complexity — kept for export/import compat (hidden inputs)
        function updateComplexity() {}

        // ==================== MATERIALS MODAL ====================
        function openMaterialsModal() {
            renderMaterialsModal();
            document.getElementById('materialsModal').style.display = '';
        }

        function closeMaterialsModal() {
            document.getElementById('materialsModal').style.display = 'none';
            updatePricing();
        }

        function renderMaterialsModal() {
            const showCost = document.getElementById('showCostToggle').checked;
            const body = document.getElementById('matModalBody');
            // Show only non-addon material rows
            const matRows = jobRows.filter(r => !r.isAddon);
            let totalSell = 0;

            body.innerHTML = matRows.map((r, realIdx) => {
                const i = jobRows.indexOf(r);
                const mult = r.unit === 'LM' ? r.length : 1;
                const lineCost = r.qty * mult * r.unitCost;
                const lineSell = r.qty * mult * r.unitSell;
                totalSell += lineSell;
                const markupPct = r.unitCost > 0 ? ((r.unitSell - r.unitCost) / r.unitCost * 100) : 0;
                const globalMk = parseFloat(document.getElementById('globalMarkupPct').value) || 35;
                const isCustom = Math.abs(markupPct - globalMk) > 1;
                const qtyStr = r.qty + (r.unit === 'LM' && r.length > 0 ? ' \u00D7 ' + r.length.toFixed(1) + 'm' : r.unit !== 'LM' ? ' ' + r.unit : '');

                return `<tr>
                    <td>${r.desc}</td>
                    <td>${qtyStr}</td>
                    ${showCost ? `<td class="r mono">$${lineCost.toFixed(2)}</td>` : `<td class="r cost-col" style="display:none"></td>`}
                    <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" onchange="updateMatSellFromModal(${i},this.value)" style="width:90px"></td>
                    <td class="r"><span class="markup-badge${isCustom ? ' custom' : ''}">${markupPct.toFixed(0)}%${isCustom ? '*' : ''}</span></td>
                    <td></td>
                </tr>`;
            }).join('');

            // Also show custom addon rows in modal
            const addonRows = jobRows.filter(r => r.isAddon);
            if (addonRows.length > 0) {
                body.innerHTML += `<tr><td colspan="6" style="font-size:11px;font-weight:600;text-transform:uppercase;color:var(--sw-text-sec);padding-top:12px;border-bottom:1px solid var(--sw-border)">Custom Items</td></tr>`;
                body.innerHTML += addonRows.map(r => {
                    const i = jobRows.indexOf(r);
                    const mult = r.unit === 'LM' ? r.length : 1;
                    const lineSell = r.qty * mult * r.unitSell;
                    totalSell += lineSell;
                    return `<tr>
                        <td><input type="text" value="${r.desc}" style="width:160px;padding:4px 6px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px" onchange="jobRows[${i}].desc=this.value"></td>
                        <td><input type="number" value="${r.qty}" min="0" step="1" style="width:50px;padding:4px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px;text-align:center" onchange="jobRows[${i}].qty=parseFloat(this.value)||0;renderMaterialsModal()"></td>
                        ${showCost ? `<td class="r"><input type="number" value="${(r.qty*mult*r.unitCost).toFixed(2)}" min="0" step="1" style="width:80px" onchange="jobRows[${i}].unitCost=parseFloat(this.value)/(jobRows[${i}].qty*(jobRows[${i}].unit==='LM'?jobRows[${i}].length:1)||1);renderMaterialsModal()"></td>` : `<td style="display:none"></td>`}
                        <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" style="width:90px" onchange="updateMatSellFromModal(${i},this.value)"></td>
                        <td class="r"></td>
                        <td><button style="background:none;border:none;color:#ccc;cursor:pointer;font-size:16px" onclick="jobRows.splice(${i},1);renderMaterialsModal()" onmouseover="this.style.color='#FF3B30'" onmouseout="this.style.color='#ccc'">&times;</button></td>
                    </tr>`;
                }).join('');
            }

            // Update cost column visibility (header + all cost cells)
            document.querySelectorAll('.mat-modal-table .cost-col').forEach(el => el.style.display = showCost ? '' : 'none');

            document.getElementById('matModalTotal').textContent = '$' + totalSell.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        function updateMatSellFromModal(idx, val) {
            const r = jobRows[idx];
            const mult = r.unit === 'LM' ? r.length : 1;
            const totalQty = r.qty * mult;
            r.unitSell = totalQty > 0 ? parseFloat(val) / totalQty : 0;
            renderMaterialsModal();
        }

        function applyMarkupAll() {
            const pct = parseFloat(document.getElementById('globalMarkupPct').value) || 35;
            jobRows.forEach(r => {
                if (!r.isAddon) {
                    r.unitSell = +(r.unitCost * (1 + pct / 100)).toFixed(2);
                }
            });
            renderMaterialsModal();
            updatePricing();
        }

        function addCustomMaterialRow() {
            jobRows.push({ desc: 'Custom item', qty: 1, length: 1, unit: 'each', unitCost: 0, unitSell: 0, isAddon: true });
            renderMaterialsModal();
        }

        // ==================== MAIN PRICING UPDATE ====================
        function updatePricing() {
            const fmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            const fmtShort = v => '$' + Math.round(v).toLocaleString();

            // Materials from jobRows (non-addon = materials, addon = custom material items included in materials total)
            let matCost = 0, matSell = 0;
            let matItemCount = 0;
            jobRows.forEach(r => {
                const mult = r.unit === 'LM' ? r.length : 1;
                matCost += r.qty * mult * r.unitCost;
                matSell += r.qty * mult * r.unitSell;
                matItemCount++;
            });

            // Materials card update
            const matMarkup = matCost > 0 ? ((matSell - matCost) / matCost * 100) : 0;
            document.getElementById('matSellDisplay').textContent = fmtShort(matSell);
            document.getElementById('matItemCount').textContent = matItemCount + ' item' + (matItemCount !== 1 ? 's' : '');
            document.getElementById('matMarkupPct').textContent = matMarkup.toFixed(0) + '%';

            // Validation: warn if any item has $0 sell
            const hasZero = jobRows.some(r => !r.isAddon && r.unitSell === 0 && r.unitCost > 0);
            const iconEl = document.getElementById('matStatusIcon');
            if (hasZero) {
                iconEl.textContent = '\u26A0';
                iconEl.className = 'status-warn';
            } else {
                iconEl.textContent = '\u2713';
                iconEl.className = 'status-ok';
            }

            // Labour from card inputs
            const lab = getLabourFromCard();
            const labCost = lab.cost;
            const labSell = lab.sell;

            // Update labour cost display
            document.getElementById('labCostDisplay').textContent = fmtShort(labCost);

            // Sync labourRows for PDF/export
            syncLabourRows();

            // Extras
            let extrasCost = 0, extrasSell = 0;
            extrasRows.forEach(r => {
                extrasCost += r.qty * r.unitCost;
                extrasSell += r.qty * r.unitSell;
            });

            // Totals
            const totalCost = matCost + labCost + extrasCost;
            const totalSell = matSell + labSell + extrasSell;
            const gst = totalSell * 0.10;
            const totalIncGST = totalSell + gst;
            const margin = totalSell - totalCost;
            const marginPct = totalSell > 0 ? (margin / totalSell * 100) : 0;

            // Total card
            document.getElementById('totalAmountDisplay').textContent = 'TOTAL ' + fmtShort(totalIncGST) + ' inc GST';

            const marginEl = document.getElementById('totalMarginDisplay');
            const marginIcon = marginPct > 20 ? '  \u2713' : marginPct >= 10 ? '' : '  \u2717';
            marginEl.textContent = 'Margin ' + fmtShort(margin) + ' (' + marginPct.toFixed(1) + '%)' + marginIcon;
            if (marginPct > 20) {
                marginEl.className = 'total-margin margin-green';
            } else if (marginPct >= 10) {
                marginEl.className = 'total-margin margin-orange';
            } else {
                marginEl.className = 'total-margin margin-red';
            }

            // Cache pricing state for PDF generators
            pricingState = {
                matCost, matSell, labCost, labSell, extrasCost, extrasSell,
                totalCost, totalSell, gst, totalIncGST, margin, marginPct,
                fmt
            };
        }

        // ==================== COLLAPSIBLE SECTIONS ====================
        const SECTION_IDS = ['sec-truss', 'sec-site', 'sec-materials', 'sec-pricing'];
        const DEFAULT_COLLAPSED = ['sec-truss', 'sec-site', 'sec-materials', 'sec-pricing'];

        function loadCollapseState() {
            try {
                const saved = localStorage.getItem('patioCollapseState');
                return saved ? JSON.parse(saved) : null;
            } catch(e) { return null; }
        }

        function saveCollapseState() {
            const state = {};
            SECTION_IDS.forEach(id => {
                const hdr = document.querySelector('#' + id + ' > .collapse-header');
                if (hdr) state[id] = hdr.classList.contains('collapsed');
            });
            localStorage.setItem('patioCollapseState', JSON.stringify(state));
        }

        function toggleSection(id) {
            const sec = document.getElementById(id);
            if (!sec) return;
            const hdr = sec.querySelector('.collapse-header');
            const body = sec.querySelector('.collapse-body');
            if (!hdr || !body) return;
            const isCollapsed = hdr.classList.contains('collapsed');
            if (isCollapsed) {
                // Expand
                hdr.classList.remove('collapsed');
                body.style.maxHeight = body.scrollHeight + 'px';
                body.classList.remove('shut');
                setTimeout(() => {
                    body.style.maxHeight = '';
                    if (id === 'sec-truss') { resizeTruss(); if (trussRend) trussRend.render(trussScene, trussCam); }
                }, 350);
            } else {
                // Collapse
                body.style.maxHeight = body.scrollHeight + 'px';
                requestAnimationFrame(() => {
                    body.style.maxHeight = '0';
                    body.classList.add('shut');
                    hdr.classList.add('collapsed');
                });
            }
            saveCollapseState();
        }

        function initCollapseSections() {
            const saved = loadCollapseState();
            SECTION_IDS.forEach(id => {
                const sec = document.getElementById(id);
                if (!sec) return;
                const hdr = sec.querySelector('.collapse-header');
                const body = sec.querySelector('.collapse-body');
                if (!hdr || !body) return;
                const shouldCollapse = saved ? saved[id] : DEFAULT_COLLAPSED.includes(id);
                if (shouldCollapse) {
                    hdr.classList.add('collapsed');
                    body.classList.add('shut');
                    body.style.maxHeight = '0';
                } else {
                    hdr.classList.remove('collapsed');
                    body.classList.remove('shut');
                }
            });
        }

        // ==================== EXPORT / IMPORT JOB DATA ====================
        function gatherJobData() {
            const c = calc;
            return {
                _version: 'PatioDesignerPro_V18',
                _exported: new Date().toISOString(),
                client: {
                    jobRef: (document.getElementById('jobRef')?.value || '').trim(),
                    name: (document.getElementById('clientName')?.value || '').trim(),
                    address: (document.getElementById('siteAddress')?.value || '').trim(),
                    phone: (document.getElementById('clientPhone')?.value || '').trim(),
                    email: (document.getElementById('clientEmail')?.value || '').trim(),
                    salesperson: (document.getElementById('salesperson')?.value || '')
                },
                config: {
                    roofStyle: document.getElementById('inRoofStyle')?.value,
                    orientation: document.getElementById('inOrientation')?.value,
                    projection: document.getElementById('inWidth')?.value,
                    length: document.getElementById('inLength')?.value,
                    pitch: document.getElementById('inPitch')?.value,
                    postHeight: document.getElementById('inPostHeight')?.value,
                    posts: document.getElementById('inPosts')?.value,
                    trusses: document.getElementById('inTrusses')?.value,
                    rafters: document.getElementById('inRafters')?.value,
                    roofing: document.getElementById('inRoofing')?.value,
                    infill: document.getElementById('inInfill')?.value,
                    connection: document.getElementById('inConnection')?.value,
                    fasciaHeight: document.getElementById('inFasciaHeight')?.value,
                    riserHeight: document.getElementById('inRiserHeight')?.value,
                    riserOffset: document.getElementById('inRiserOffset')?.value,
                    riserQty: document.getElementById('inRiserQty')?.value,
                    houseGutter: document.getElementById('inHouseGutter')?.value,
                    riserGutter: document.getElementById('inRiserGutter')?.value,
                    postFix: document.getElementById('inPostFix')?.value,
                    trussBase: document.getElementById('inTrussBase')?.value,
                    trussChord: document.getElementById('inTrussChord')?.value,
                    trussSteel: document.getElementById('inTrussSteel')?.value,
                    overhang: document.getElementById('inOverhang')?.value,
                    trussRiser: {
                        enabled: document.getElementById('trussRiserOn')?.checked || false,
                        rx: document.getElementById('trussRX')?.value || '200',
                        ry: document.getElementById('trussRY')?.value || '150'
                    },
                    trussDogleg: {
                        enabled: document.getElementById('trussDoglegOn')?.checked || false,
                        lx: document.getElementById('trussLX')?.value || '200',
                        ly: document.getElementById('trussLY')?.value || '150'
                    },
                    trussExtender: {
                        enabled: document.getElementById('trussExtOn')?.checked || false,
                        length: document.getElementById('trussExtLen')?.value || '300'
                    },
                    sheetColor: sheetColor.name,
                    steelColor: steelColor.name,
                    polycarbEnabled: isPolycarbEnabled(),
                    polycarbBrand: document.getElementById('inPolycarbBrand')?.value,
                    polycarbTint: document.getElementById('inPolycarbTint')?.value,
                    polycarbPattern: document.getElementById('inPolycarbPattern')?.value,
                    polycarbCustom: document.getElementById('inPolycarbCustom')?.value,
                    ceilingFinish: document.getElementById('inCeilingFinish')?.value
                },
                extras: {
                    demo: document.getElementById('extraDemo')?.value || 'no',
                    demoCost: document.getElementById('extraDemoCost')?.value || '',
                    removal: document.getElementById('extraRemoval')?.value || 'no',
                    removalCost: document.getElementById('extraRemovalCost')?.value || '',
                    electrical: document.getElementById('extraElectrical')?.value || 'no',
                    electricalCost: document.getElementById('extraElectricalCost')?.value || '',
                    downlights: document.getElementById('extraDownlights')?.value || '0'
                },
                allowances: {
                    gutter: document.getElementById('allowGutter')?.value || '800',
                    flashings: document.getElementById('allowFlashings')?.value || '400'
                },
                pricing: {
                    addonRows: jobRows.filter(r => r.isAddon),
                    extrasRows: extrasRows,
                    labour: {
                        trades: document.getElementById('labTrades')?.value,
                        days: document.getElementById('labDays')?.value,
                        dayRate: document.getElementById('labDayRate')?.value,
                        sell: document.getElementById('labSellInput')?.value
                    }
                },
                complexity: {
                    build: document.getElementById('cxBuild')?.value,
                    access: document.getElementById('cxAccess')?.value,
                    distance: document.getElementById('cxDistance')?.value,
                    footing: document.getElementById('cxFooting')?.value,
                    height: document.getElementById('cxHeight')?.value
                },
                notes: {
                    jobNotes: (document.getElementById('jobNotes')?.value || '').trim(),
                    pricingNotes: (document.getElementById('pricingNotes')?.value || '').trim()
                }
            };
        }

        function exportJobData() {
            const data = gatherJobData();
            const json = JSON.stringify(data, null, 2);

            // Copy to clipboard
            navigator.clipboard.writeText(json).then(() => {
                alert('Job data copied to clipboard!\n\nPaste this into GHL notes, email, or save as a file to reload later.');
            }).catch(() => {
                // Fallback: download as file
                downloadJobJSON(json, data.client.jobRef);
            });
        }

        function saveJobData() {
            var base = gatherJobData();
            var jobData = {
                version: '1.0',
                savedAt: new Date().toISOString(),
                customer: customer,
                siteDetails: siteDetails,
                client: base.client,
                config: base.config,
                pricing: base.pricing,
                complexity: base.complexity,
                notes: base.notes,
                specs: {
                    roofType: base.config.roofStyle,
                    width: base.config.length,
                    projection: base.config.projection,
                    height: base.config.postHeight,
                    pitch: base.config.pitch,
                    roofMaterial: base.config.roofing,
                    attachmentType: base.config.connection,
                    roofColour: base.config.sheetColor,
                    frameColour: base.config.steelColor
                },
                truss: {
                    base: base.config.trussBase,
                    chord: base.config.trussChord,
                    steel: base.config.trussSteel,
                    overhang: base.config.overhang,
                    riser: base.config.trussRiser,
                    dogleg: base.config.trussDogleg,
                    extender: base.config.trussExtender
                },
                polycarb: {
                    enabled: base.config.polycarbEnabled,
                    brand: base.config.polycarbBrand,
                    tint: base.config.polycarbTint,
                    pattern: base.config.polycarbPattern,
                    custom: base.config.polycarbCustom
                }
            };
            var json = JSON.stringify(jobData, null, 2);

            navigator.clipboard.writeText(json).then(function() {
                localStorage.setItem('patio-job-' + Date.now(), json);
                alert('Job data copied to clipboard! Paste into GHL notes.');
            }).catch(function() {
                localStorage.setItem('patio-job-' + Date.now(), json);
                alert('Job data saved locally. Clipboard access was blocked.');
            });
        }

        function showLoadJobModal() {
            document.getElementById('loadJobTextarea').value = '';
            document.getElementById('loadJobStatus').textContent = '';
            document.getElementById('loadJobModal').style.display = '';
        }

        function closeLoadJobModal() {
            document.getElementById('loadJobModal').style.display = 'none';
        }

        function loadJobData() {
            var raw = document.getElementById('loadJobTextarea').value.trim();
            var statusEl = document.getElementById('loadJobStatus');
            if (!raw) { statusEl.textContent = 'Please paste JSON data first.'; statusEl.style.color = '#FF3B30'; return; }

            var data;
            try {
                data = JSON.parse(raw);
            } catch(e) {
                statusEl.textContent = 'Invalid JSON. Please check and try again.';
                statusEl.style.color = '#FF3B30';
                return;
            }

            // Restore customer state + DOM
            if (data.customer) {
                customer = { name: data.customer.name || '', address: data.customer.address || '', phone: data.customer.phone || '' };
                document.getElementById('customerName').value = customer.name;
                document.getElementById('customerAddress').value = customer.address;
                document.getElementById('customerPhone').value = customer.phone;
            }

            // Restore siteDetails state + DOM
            if (data.siteDetails) {
                var sd = data.siteDetails;
                siteDetails = {
                    gutterProfile: sd.gutterProfile || 'unknown',
                    gutterManufacturer: sd.gutterManufacturer || 'unknown',
                    fasciaCondition: sd.fasciaCondition || 'unknown',
                    siteAccess: sd.siteAccess || 'unknown',
                    electrical: sd.electrical || 'tbd',
                    demo: sd.demo || 'tbd',
                    notes: sd.notes || ''
                };
                var setRadio = function(name, val) {
                    var el = document.querySelector('input[name="' + name + '"][value="' + val + '"]');
                    if (el) el.checked = true;
                };
                setRadio('gutterProfile', siteDetails.gutterProfile);
                setRadio('gutterManufacturer', siteDetails.gutterManufacturer);
                setRadio('fasciaCondition', siteDetails.fasciaCondition);
                setRadio('siteAccess', siteDetails.siteAccess);
                setRadio('electrical', siteDetails.electrical);
                setRadio('demo', siteDetails.demo);
                document.getElementById('siteNotes').value = siteDetails.notes;
            }

            // Restore client info (from existing format)
            if (data.client) {
                var cl = data.client;
                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                if (cl.name) { document.getElementById('clientName').value = cl.name; if (!data.customer || !data.customer.name) document.getElementById('customerName').value = cl.name; }
                if (cl.address) { document.getElementById('siteAddress').value = cl.address; if (!data.customer || !data.customer.address) document.getElementById('customerAddress').value = cl.address; }
                if (cl.phone) { document.getElementById('clientPhone').value = cl.phone; if (!data.customer || !data.customer.phone) document.getElementById('customerPhone').value = cl.phone; }
                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                if (cl.salesperson) document.getElementById('salesperson').value = cl.salesperson;
            }

            // Restore specs → config inputs
            var cfg = data.config || {};
            var specs = data.specs || {};
            var setVal = function(id, val) { var el = document.getElementById(id); if (el && val != null) el.value = val; };
            setVal('inRoofStyle', specs.roofType || cfg.roofStyle);
            setVal('inOrientation', cfg.orientation);
            // Convert legacy mm values to m for dimension inputs
            var projVal = specs.projection || cfg.projection;
            var lenVal = specs.width || cfg.length;
            var heightVal = specs.height || cfg.postHeight;
            if (projVal && parseFloat(projVal) > 100) projVal = (parseFloat(projVal) / 1000).toFixed(1);
            if (lenVal && parseFloat(lenVal) > 100) lenVal = (parseFloat(lenVal) / 1000).toFixed(1);
            if (heightVal && parseFloat(heightVal) > 100) heightVal = (parseFloat(heightVal) / 1000).toFixed(1);
            setVal('inWidth', projVal);
            setVal('inLength', lenVal);
            setVal('inPitch', specs.pitch || cfg.pitch);
            setVal('inPostHeight', heightVal);
            setVal('inPosts', cfg.posts);
            setVal('inTrusses', cfg.trusses);
            setVal('inRafters', cfg.rafters);
            // Convert legacy 'insulated' to 'solarspan75'
            var roofVal = specs.roofMaterial || cfg.roofing;
            if (roofVal === 'insulated') roofVal = 'solarspan75';
            setVal('inRoofing', roofVal);
            setVal('inInfill', cfg.infill);
            // Convert legacy 'fasciabeam' to 'riser'
            var connVal = specs.attachmentType || cfg.connection;
            if (connVal === 'fasciabeam') connVal = 'riser';
            setVal('inConnection', connVal);
            setVal('inFasciaHeight', cfg.fasciaHeight);
            setVal('inRiserHeight', cfg.riserHeight);
            setVal('inRiserOffset', cfg.riserOffset);
            setVal('inRiserQty', cfg.riserQty);
            setVal('inHouseGutter', cfg.houseGutter);
            setVal('inRiserGutter', cfg.riserGutter);
            setVal('inPostFix', cfg.postFix);
            setVal('inCeilingFinish', cfg.ceilingFinish);

            // Truss
            var truss = data.truss || {};
            // Legacy: map old trussStyle values to new trussBase
            const legacyBase = cfg.trussStyle === 'king' ? 'kingpost' : (cfg.trussStyle === 'queen' ? 'kingpost' : cfg.trussStyle);
            setVal('inTrussBase', truss.base || cfg.trussBase || legacyBase || 'kingpost');
            setVal('inTrussChord', truss.chord || cfg.trussChord || 'bottom');
            setVal('inTrussSteel', truss.steel || cfg.trussSteel);
            setVal('inOverhang', truss.overhang || cfg.overhang);

            // Truss options: riser, dogleg, extender
            const tRiser = truss.riser || cfg.trussRiser || {};
            const tDogleg = truss.dogleg || cfg.trussDogleg || {};
            const tExtender = truss.extender || cfg.trussExtender || {};
            if (tRiser.enabled) {
                document.getElementById('trussRiserOn').checked = true;
                setVal('trussRX', tRiser.rx || '200');
                setVal('trussRY', tRiser.ry || '150');
            }
            if (tDogleg.enabled) {
                document.getElementById('trussDoglegOn').checked = true;
                setVal('trussLX', tDogleg.lx || '200');
                setVal('trussLY', tDogleg.ly || '150');
            }
            if (tExtender.enabled) {
                document.getElementById('trussExtOn').checked = true;
                setVal('trussExtLen', tExtender.length || '300');
            }
            toggleTrussOpt();

            // Extras & Allowances
            if (data.extras) {
                setVal('extraDemo', data.extras.demo);
                setVal('extraDemoCost', data.extras.demoCost);
                setVal('extraRemoval', data.extras.removal);
                setVal('extraRemovalCost', data.extras.removalCost);
                setVal('extraElectrical', data.extras.electrical);
                setVal('extraElectricalCost', data.extras.electricalCost);
                if (data.extras.downlights) setVal('extraDownlights', data.extras.downlights);
                toggleExtraCost('demo');
                toggleExtraCost('removal');
                toggleExtraCost('electrical');
            }
            if (data.allowances) {
                setVal('allowGutter', data.allowances.gutter);
                setVal('allowFlashings', data.allowances.flashings);
            }

            // Colours
            var roofColour = specs.roofColour || cfg.sheetColor;
            if (roofColour) {
                var sc = COLORS.find(function(c) { return c.name === roofColour; });
                if (sc) {
                    sheetColor = sc;
                    document.querySelectorAll('#sheetChips .color-chip').forEach(function(ch) { ch.classList.toggle('active', ch.title === sc.name); });
                    document.getElementById('sheetLabel').textContent = sc.name;
                }
            }
            var fColour = specs.frameColour || cfg.steelColor;
            if (fColour) {
                var sc2 = COLORS.find(function(c) { return c.name === fColour; });
                if (sc2) {
                    steelColor = sc2;
                    document.querySelectorAll('#steelChips .color-chip').forEach(function(ch) { ch.classList.toggle('active', ch.title === sc2.name); });
                    document.getElementById('steelLabel').textContent = sc2.name;
                }
            }

            // Polycarbonate
            var pc = data.polycarb || {};
            var pcEnabled = pc.enabled || cfg.polycarbEnabled;
            if (pcEnabled) {
                document.querySelector('input[name="polycarb"][value="yes"]').checked = true;
                document.getElementById('polycarbOptions').style.display = 'block';
                if (pc.brand || cfg.polycarbBrand) document.getElementById('inPolycarbBrand').value = pc.brand || cfg.polycarbBrand;
                updatePolycarbTints();
                if (pc.tint || cfg.polycarbTint) document.getElementById('inPolycarbTint').value = pc.tint || cfg.polycarbTint;
                if (pc.pattern || cfg.polycarbPattern) document.getElementById('inPolycarbPattern').value = pc.pattern || cfg.polycarbPattern;
                if (pc.custom || cfg.polycarbCustom) document.getElementById('inPolycarbCustom').value = pc.custom || cfg.polycarbCustom;
                updatePolycarbPreview();
            }

            // Pricing
            if (data.pricing) {
                var p = data.pricing;
                if (p.addonRows && Array.isArray(p.addonRows)) {
                    jobRows = jobRows.filter(function(r) { return !r.isAddon; });
                    p.addonRows.forEach(function(a) { a.isAddon = true; if (!a.unit) a.unit = 'each'; jobRows.push(a); });
                }
                if (p.extrasRows && Array.isArray(p.extrasRows)) extrasRows = p.extrasRows;
                if (p.labour) {
                    if (p.labour.trades != null) document.getElementById('labTrades').value = p.labour.trades;
                    if (p.labour.days != null) document.getElementById('labDays').value = p.labour.days;
                    if (p.labour.dayRate != null) document.getElementById('labDayRate').value = p.labour.dayRate;
                    if (p.labour.sell != null) document.getElementById('labSellInput').value = p.labour.sell;
                }
            }

            // Complexity
            if (data.complexity) {
                var cx = data.complexity;
                if (cx.build) document.getElementById('cxBuild').value = cx.build;
                if (cx.access) document.getElementById('cxAccess').value = cx.access;
                if (cx.distance) document.getElementById('cxDistance').value = cx.distance;
                if (cx.footing) document.getElementById('cxFooting').value = cx.footing;
                if (cx.height) document.getElementById('cxHeight').value = cx.height;
            }

            // Notes
            if (data.notes) {
                if (data.notes.jobNotes) document.getElementById('jobNotes').value = data.notes.jobNotes;
                if (data.notes.pricingNotes) document.getElementById('pricingNotes').value = data.notes.pricingNotes;
            }

            // Rebuild everything
            updateUI();
            rebuildAll();
            renderExtras();
            updatePricing();
            updateHeaderBadge();

            closeLoadJobModal();
            var custName = (data.customer && data.customer.name) ? data.customer.name : (data.client && data.client.name) ? data.client.name : 'Unknown';
            var custAddr = (data.customer && data.customer.address) ? data.customer.address : (data.client && data.client.address) ? data.client.address : '';
            alert('Job loaded: ' + custName + (custAddr ? ', ' + custAddr : ''));
        }

        function downloadJobJSON(json, ref) {
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (ref || 'PatioJob') + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function showImportModal() {
            document.getElementById('importTextarea').value = '';
            document.getElementById('importStatus').textContent = '';
            document.getElementById('importModal').style.display = '';
        }

        function importJobData() {
            const raw = document.getElementById('importTextarea').value.trim();
            const statusEl = document.getElementById('importStatus');
            if (!raw) { statusEl.textContent = 'Please paste JSON data first.'; statusEl.style.color = '#FF3B30'; return; }
            let data;
            try {
                data = JSON.parse(raw);
            } catch(e) {
                statusEl.textContent = 'Invalid JSON. Check the data and try again.';
                statusEl.style.color = '#FF3B30';
                return;
            }

            // Populate client info
            if (data.client) {
                const cl = data.client;
                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                if (cl.name) document.getElementById('clientName').value = cl.name;
                if (cl.address) document.getElementById('siteAddress').value = cl.address;
                if (cl.phone) document.getElementById('clientPhone').value = cl.phone;
                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                if (cl.salesperson) document.getElementById('salesperson').value = cl.salesperson;
            }

            // Populate config
            if (data.config) {
                const cfg = data.config;
                const setVal = (id, val) => { const el = document.getElementById(id); if (el && val != null) el.value = val; };
                setVal('inRoofStyle', cfg.roofStyle);
                setVal('inOrientation', cfg.orientation);
                setVal('inWidth', cfg.projection);
                setVal('inLength', cfg.length);
                setVal('inPitch', cfg.pitch);
                setVal('inPostHeight', cfg.postHeight);
                setVal('inPosts', cfg.posts);
                setVal('inTrusses', cfg.trusses);
                setVal('inRafters', cfg.rafters);
                setVal('inRoofing', cfg.roofing);
                setVal('inInfill', cfg.infill);
                setVal('inConnection', cfg.connection);
                setVal('inFasciaHeight', cfg.fasciaHeight);
                setVal('inRiserHeight', cfg.riserHeight);
                setVal('inRiserOffset', cfg.riserOffset);
                setVal('inRiserQty', cfg.riserQty);
                setVal('inHouseGutter', cfg.houseGutter);
                setVal('inRiserGutter', cfg.riserGutter);
                setVal('inPostFix', cfg.postFix);
                const lb = cfg.trussStyle === 'king' ? 'kingpost' : (cfg.trussStyle === 'queen' ? 'kingpost' : cfg.trussStyle);
                setVal('inTrussBase', cfg.trussBase || lb || 'kingpost');
                setVal('inTrussChord', cfg.trussChord || 'bottom');
                setVal('inTrussSteel', cfg.trussSteel);
                setVal('inOverhang', cfg.overhang);

                // Truss options (legacy)
                if (cfg.trussRiser && cfg.trussRiser.enabled) {
                    document.getElementById('trussRiserOn').checked = true;
                    setVal('trussRX', cfg.trussRiser.rx || '200');
                    setVal('trussRY', cfg.trussRiser.ry || '150');
                }
                if (cfg.trussDogleg && cfg.trussDogleg.enabled) {
                    document.getElementById('trussDoglegOn').checked = true;
                    setVal('trussLX', cfg.trussDogleg.lx || '200');
                    setVal('trussLY', cfg.trussDogleg.ly || '150');
                }
                if (cfg.trussExtender && cfg.trussExtender.enabled) {
                    document.getElementById('trussExtOn').checked = true;
                    setVal('trussExtLen', cfg.trussExtender.length || '300');
                }
                toggleTrussOpt();

                // Colours
                if (cfg.sheetColor) {
                    const sc = COLORS.find(c => c.name === cfg.sheetColor);
                    if (sc) {
                        sheetColor = sc;
                        const chips = document.querySelectorAll('#sheetChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('sheetLabel').textContent = sc.name;
                    }
                }
                if (cfg.steelColor) {
                    const sc = COLORS.find(c => c.name === cfg.steelColor);
                    if (sc) {
                        steelColor = sc;
                        const chips = document.querySelectorAll('#steelChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('steelLabel').textContent = sc.name;
                    }
                }
                // Polycarbonate
                if (cfg.polycarbEnabled) {
                    document.querySelector('input[name="polycarb"][value="yes"]').checked = true;
                    document.getElementById('polycarbOptions').style.display = 'block';
                    if (cfg.polycarbBrand) document.getElementById('inPolycarbBrand').value = cfg.polycarbBrand;
                    updatePolycarbTints();
                    if (cfg.polycarbTint) document.getElementById('inPolycarbTint').value = cfg.polycarbTint;
                    if (cfg.polycarbPattern) document.getElementById('inPolycarbPattern').value = cfg.polycarbPattern;
                    if (cfg.polycarbCustom) document.getElementById('inPolycarbCustom').value = cfg.polycarbCustom;
                    updatePolycarbPreview();
                }
            }

            // Populate pricing
            if (data.pricing) {
                const p = data.pricing;
                if (p.addonRows && Array.isArray(p.addonRows)) {
                    jobRows = jobRows.filter(r => !r.isAddon);
                    p.addonRows.forEach(a => { a.isAddon = true; if (!a.unit) a.unit = 'each'; jobRows.push(a); });
                }
                // New extras format
                if (p.extrasRows && Array.isArray(p.extrasRows)) {
                    extrasRows = p.extrasRows;
                }
                // New labour card format
                if (p.labour) {
                    const l = p.labour;
                    if (l.trades != null) document.getElementById('labTrades').value = l.trades;
                    if (l.days != null) document.getElementById('labDays').value = l.days;
                    if (l.dayRate != null) document.getElementById('labDayRate').value = l.dayRate;
                    if (l.sell != null) document.getElementById('labSellInput').value = l.sell;
                }
                // Legacy: old labourRows format (backward compat)
                if (p.labourRows && Array.isArray(p.labourRows) && p.labourRows.length > 0 && !p.labour) {
                    const first = p.labourRows[0];
                    document.getElementById('labTrades').value = first.trades || 2;
                    document.getElementById('labDays').value = first.days || 1.5;
                    document.getElementById('labDayRate').value = first.dayRate || 400;
                    document.getElementById('labSellInput').value = first.sell || 0;
                }
                // Legacy: delivery as extras (backward compat)
                if (p.deliveryCost != null && parseFloat(p.deliveryCost) > 0 && !p.extrasRows) {
                    extrasRows.push({ desc: 'Delivery', qty: 1, unitCost: parseFloat(p.deliveryCost) || 0, unitSell: parseFloat(p.deliverySell) || 0, type: 'delivery' });
                }
            }

            // Complexity scores (still stored in hidden inputs)
            if (data.complexity) {
                const cx = data.complexity;
                if (cx.build) document.getElementById('cxBuild').value = cx.build;
                if (cx.access) document.getElementById('cxAccess').value = cx.access;
                if (cx.distance) document.getElementById('cxDistance').value = cx.distance;
                if (cx.footing) document.getElementById('cxFooting').value = cx.footing;
                if (cx.height) document.getElementById('cxHeight').value = cx.height;
            }

            // Notes
            if (data.notes) {
                if (data.notes.jobNotes) document.getElementById('jobNotes').value = data.notes.jobNotes;
                if (data.notes.pricingNotes) document.getElementById('pricingNotes').value = data.notes.pricingNotes;
            }

            // Rebuild everything
            updateUI();
            rebuildAll();
            renderExtras();
            updatePricing();
            updateHeaderBadge();

            statusEl.textContent = 'Job loaded successfully! All fields populated.';
            statusEl.style.color = '#34C759';
            setTimeout(() => { document.getElementById('importModal').style.display = 'none'; }, 1200);
        }

        // ==================== JOB REF AUTO-GENERATE ====================
        function generateJobRef() {
            const d = new Date();
            const yy = String(d.getFullYear()).slice(-2);
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const seq = String(Math.floor(Math.random() * 99) + 1).padStart(2, '0');
            return 'SW' + yy + mm + dd + '-' + seq;
        }

        function initJobDetails() {
            const refEl = document.getElementById('jobRef');
            if (!refEl.value.trim()) refEl.value = generateJobRef();
            // Sync header badge on any field change
            ['jobRef', 'customerName'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', updateHeaderBadge);
            });
            updateHeaderBadge();
        }

        function updateHeaderBadge() {
            const ref = (document.getElementById('jobRef')?.value || '').trim();
            const name = (document.getElementById('customerName')?.value || '').trim();
            const badge = document.getElementById('headerBadge');
            if (badge) badge.innerHTML = '<strong>' + (ref || 'SW\u2014') + '</strong>' + (name ? ' &nbsp;' + name : '');
        }

        // ==================== PDF SHARED HELPERS ====================
        function getJobRef() {
            const el = document.getElementById('jobRef');
            return (el && el.value.trim()) || generateJobRef();
        }
        function getClientName() { return (document.getElementById('clientName')?.value || '').trim() || 'Client'; }
        function getSiteAddress() { return (document.getElementById('siteAddress')?.value || '').trim(); }
        function getClientPhone() { return (document.getElementById('clientPhone')?.value || '').trim(); }
        function getClientEmail() { return (document.getElementById('clientEmail')?.value || '').trim(); }
        function getSalesperson() { return (document.getElementById('salesperson')?.value || '').trim(); }
        function safeName(s) { return s.replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_'); }
        function todayStr() {
            const d = new Date();
            return d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();
        }
        function fmtDollars(v) { return '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ','); }

        function connectionLabel(conn) {
            const map = {freestanding:'Freestanding',fascia:'Fascia / Receiving',wall:'Wall Mount',riser:'Riser Beam',flyover:'Flyover'};
            return map[conn] || conn;
        }
        function roofingLabel(r) {
            const map = {corrugated:'Corrugated Colorbond',trimdek:'Trimdek',spandek:'Spandek',solarspan75:'SolarSpan 75mm',solarspan100:'SolarSpan 100mm',spanplus330:'SpanPlus 330'};
            return map[r] || r;
        }

        function buildScopeText() {
            const c = calc;
            const style = c.isGable ? 'Gable' : 'Skillion';
            const Lm = (c.lenInput / 1000).toFixed(1);
            const Wm = (c.projInput / 1000).toFixed(1);
            const conn = connectionLabel(c.connection);
            const roof = roofingLabel(c.roofing);
            let roofDesc = 'Roof: ' + roof + ' (' + sheetColor.name + ')';
            const pc = (c.roofing === 'trimdek') ? getPolycarbConfig() : null;
            if (pc) {
                const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
                roofDesc += ' with ' + brandLabel + ' ' + pc.tint + ' polycarbonate (every ' + pc.patternN + getSuffix(pc.patternN) + ' sheet)';
            }
            return 'Supply and install a ' + style + ' patio, ' + Lm + 'm x ' + Wm + 'm, attached via ' + conn + '. ' +
                   roofDesc + '. Steel: ' + steelColor.name + '. Including gutters, downpipes and flashings.';
        }
        function getSuffix(n) { return n === 2 ? 'nd' : n === 3 ? 'rd' : 'th'; }

        function capture3DImage() {
            try {
                if (asmRend && asmScene && asmCam) {
                    asmRend.render(asmScene, asmCam);
                    return asmRend.domElement.toDataURL('image/png');
                }
            } catch(e) { /* cross-origin or not ready */ }
            return null;
        }

        function getMaterialRows() {
            const rows = [];
            const els = document.querySelectorAll('#matList .mat-row');
            els.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length >= 2) {
                    const desc = row.dataset.desc || spans[0].textContent.trim();
                    const qty = parseInt(spans[1].textContent.trim().replace('×', '')) || 1;
                    const length = getItemLength(desc);
                    rows.push({ desc, qty, length });
                }
            });
            return rows;
        }

        // SW Orange accent
        const SW_ORANGE = [242, 101, 34];  // #F26522
        const SW_DARK = [41, 60, 70];      // #293C46

        function pdfHeader(doc, title, jobRef) {
            // Orange header bar
            doc.setFillColor(...SW_ORANGE);
            doc.rect(0, 0, 210, 28, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(18);
            doc.setTextColor(255, 255, 255);
            doc.text('SecureWorks WA', 14, 13);
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.text('Patios  •  Carports  •  Pergolas', 14, 20);
            // Job ref right side
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text(jobRef, 196, 13, { align: 'right' });
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.text(todayStr(), 196, 20, { align: 'right' });
            // Title below header
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text(title, 14, 38);
            return 46;
        }

        function pdfFooter(doc) {
            const pageH = doc.internal.pageSize.getHeight();
            doc.setDrawColor(200, 200, 200);
            doc.line(14, pageH - 16, 196, pageH - 16);
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(130, 130, 130);
            const sp = getSalesperson();
            const footerParts = ['SecureWorks WA', 'ABN: XX XXX XXX XXX', 'Phone: (08) XXXX XXXX'];
            if (sp && sp !== 'Other') footerParts.push('Sales: ' + sp);
            doc.text(footerParts.join('  |  '), 105, pageH - 10, { align: 'center' });
        }

        function pdfClientBlock(doc, y) {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(80, 80, 80);
            const name = getClientName();
            const addr = getSiteAddress();
            const phone = getClientPhone();
            const email = getClientEmail();
            if (name) { doc.text('Client: ' + name, 14, y); y += 5; }
            if (addr) { doc.text('Site: ' + addr, 14, y); y += 5; }
            const contactParts = [phone ? 'Phone: ' + phone : '', email ? 'Email: ' + email : ''].filter(Boolean);
            if (contactParts.length) { doc.text(contactParts.join('    |    '), 14, y); y += 5; }
            return y + 3;
        }

        // Simple table helper
        function pdfTable(doc, y, headers, rows, colWidths, opts) {
            opts = opts || {};
            const startX = opts.startX || 14;
            const rowH = opts.rowH || 6;
            const fontSize = opts.fontSize || 9;
            const headerBg = opts.headerBg || SW_DARK;
            const altBg = opts.altBg || [245, 245, 247];
            const totalW = colWidths.reduce((a, b) => a + b, 0);

            // Header row
            doc.setFillColor(...headerBg);
            doc.rect(startX, y, totalW, rowH + 1, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(fontSize - 1);
            doc.setTextColor(255, 255, 255);
            let cx = startX;
            headers.forEach((h, i) => {
                const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                doc.text(h, tx, y + rowH - 1, { align });
                cx += colWidths[i];
            });
            y += rowH + 1;

            // Data rows
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(fontSize);
            rows.forEach((row, ri) => {
                // Check page break
                if (y + rowH > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                if (ri % 2 === 1) {
                    doc.setFillColor(...altBg);
                    doc.rect(startX, y, totalW, rowH, 'F');
                }
                const isBold = row._bold;
                doc.setFont('helvetica', isBold ? 'bold' : 'normal');
                doc.setTextColor(...(isBold ? SW_DARK : [60, 60, 60]));
                cx = startX;
                row.forEach((cell, i) => {
                    const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                    const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                    doc.text(String(cell), tx, y + rowH - 1.5, { align });
                    cx += colWidths[i];
                });
                y += rowH;
            });
            return y + 2;
        }

        // ==================== PDF 1: QUOTE (Client) ====================
        function generateQuotePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Quote', jobRef);
            y = pdfClientBlock(doc, y);

            // Date & validity
            doc.setFontSize(9);
            doc.setTextColor(100, 100, 100);
            doc.text('Date: ' + todayStr() + '    |    Quote valid for 30 days', 14, y);
            y += 8;

            // 3D render image
            const img = capture3DImage();
            if (img) {
                try {
                    doc.addImage(img, 'PNG', 14, y, 120, 68);
                    y += 72;
                } catch(e) { /* skip image */ }
            }

            // Scope description
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Scope of Works', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const scopeLines = doc.splitTextToSize(buildScopeText(), 178);
            doc.text(scopeLines, 14, y);
            y += scopeLines.length * 4.5 + 6;

            // Pricing table (sell only) - read from pricingState
            const ps = pricingState;
            const pFmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');

            const priceRows = [];
            priceRows.push(['Materials', pFmt(ps.matSell || 0)]);
            priceRows.push(['Installation', pFmt(ps.labSell || 0)]);
            if ((ps.extrasSell || 0) > 0) priceRows.push(['Extras', pFmt(ps.extrasSell)]);

            const subRow = ['Subtotal (ex GST)', pFmt(ps.totalSell || 0)]; subRow._bold = true;
            priceRows.push(subRow);
            const gstRow = ['GST (10%)', pFmt(ps.gst || 0)]; gstRow._bold = true;
            priceRows.push(gstRow);
            const totalRow = ['TOTAL (inc GST)', pFmt(ps.totalIncGST || 0)]; totalRow._bold = true;
            priceRows.push(totalRow);

            y = pdfTable(doc, y, ['Description', 'Amount'], priceRows, [120, 62]);

            // Terms & conditions
            y += 4;
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Terms & Conditions', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(8);
            doc.setTextColor(80, 80, 80);
            const terms = [
                '• 50% deposit required to confirm booking. Balance due on completion.',
                '• Quote valid for 30 days from date of issue.',
                '• Council permits not included unless specified.',
                '• Price excludes any electrical, plumbing or council works unless listed above.',
                '• All work completed to Australian Standards and BCA requirements.'
            ];
            terms.forEach(t => {
                doc.text(t, 14, y);
                y += 4;
            });

            pdfFooter(doc);
            doc.save('Quote_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        // ==================== PDF 2: MATERIALS ORDER (Supplier) ====================
        function generateMaterialsOrderPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Materials Order', jobRef);

            // Delivery info
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(60, 60, 60);
            const addr = getSiteAddress();
            if (addr) { doc.text('Deliver to: ' + addr, 14, y); y += 5; }
            doc.text('Required by: ______________________', 14, y);
            y += 5;
            doc.text('Contact: ' + getClientName() + (getClientPhone() ? '  |  ' + getClientPhone() : ''), 14, y);
            y += 8;

            // Build materials grouped by category
            const mats = getMaterialRows();
            const c = calc;
            const steelName = c.steel ? c.steel.name : '76×38×1.6';
            const colour = steelColor.name;
            const sheetColour = sheetColor.name;

            // Categorise materials
            const categories = {
                'Steel': [],
                'Roofing': [],
                'Flashings & Trim': [],
                'Gutters & Drainage': [],
                'Fixings & Other': []
            };

            mats.forEach(m => {
                const d = m.desc.toLowerCase();
                const lengthM = (m.length).toFixed(2) + 'm';
                const col = d.includes('sheet') || d.includes('gutter') || d.includes('downpipe') || d.includes('flashing') || d.includes('barge') || d.includes('ridge') ? sheetColour : colour;
                const row = [m.desc, steelName, lengthM, String(m.qty), col, ''];

                if (d.includes('post') || d.includes('beam') || d.includes('rafter') || d.includes('truss') || d.includes('purlin') || d.includes('strut') || d.includes('riser')) {
                    row[1] = steelName;
                    categories['Steel'].push(row);
                } else if (d.includes('sheet')) {
                    row[1] = roofingLabel(c.roofing);
                    categories['Roofing'].push(row);
                } else if (d.includes('flashing') || d.includes('barge') || d.includes('ridge') || d.includes('channel') || d.includes('foam') || d.includes('infill')) {
                    row[1] = '';
                    categories['Flashings & Trim'].push(row);
                } else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow')) {
                    row[1] = '';
                    categories['Gutters & Drainage'].push(row);
                } else {
                    row[1] = '';
                    categories['Fixings & Other'].push(row);
                }
            });

            const colWidths = [50, 36, 22, 16, 30, 28];
            const tableHeaders = ['Item', 'Size', 'Length', 'Qty', 'Colour', 'Notes'];

            Object.entries(categories).forEach(([cat, rows]) => {
                if (rows.length === 0) return;
                // Check page break for category header + at least 2 rows
                if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_ORANGE);
                doc.text(cat, 14, y);
                y += 4;
                y = pdfTable(doc, y, tableHeaders, rows, colWidths, { leftAlignAll: true });
                y += 2;
            });

            // Flashing sketch section
            if (y + 55 > doc.internal.pageSize.getHeight() - 25) {
                pdfFooter(doc);
                doc.addPage();
                y = 20;
            }
            y += 4;
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_ORANGE);
            doc.text('Flashing Sketches', 14, y);
            y += 5;
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(130, 130, 130);
            doc.text('Sketch flashing profiles below — hand draw dimensions and bends', 14, y);
            y += 5;

            const boxW = 42;
            const boxH = 32;
            const gap = 4;
            const labels = ['Back Flashing', 'Barge Flashing L', 'Barge Flashing R', 'Other'];
            labels.forEach((label, i) => {
                const bx = 14 + i * (boxW + gap);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.3);
                doc.rect(bx, y, boxW, boxH);
                doc.setFontSize(7);
                doc.setTextColor(130, 130, 130);
                doc.text(label, bx + boxW / 2, y + boxH + 4, { align: 'center' });
            });

            pdfFooter(doc);
            doc.save('Materials_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        // ==================== PDF 3: WORK ORDER (Crew) ====================
        function generateWorkOrderPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const c = calc;
            const pageW = 210, pageH = 297;
            const mx = 14, mr = 196; // margins
            const cw = mr - mx; // content width

            // ── Helpers ──
            const mm = v => Math.round(v) + 'mm';
            const styleLabel = c.roofStyle === 'hip' ? 'HIP' : (c.isGable ? 'GABLE' : 'SKILLION');
            const connLabel = connectionLabel(c.connection).toUpperCase();
            const roofLabel = roofingLabel(c.roofing);
            const sheetClr = sheetColor.name;
            const steelClr = steelColor.name;
            const Lmm = c.lenInput, Wmm = c.projInput;
            const Lm = Lmm / 1000, Wm = Wmm / 1000;
            const postHmm = c.postH;
            const riseMm = Math.round(c.rise);
            const ridgeH = Math.round(c.frontBeamY + c.rise);
            const backBeamH = Math.round(c.backBeamY);
            const frontBeamH = Math.round(c.frontBeamY);
            const nPosts = c.nPosts;
            const nTruss = c.nTruss;
            const postFix = (document.getElementById('inPostFix')?.value || 'concrete');
            const isConc = postFix === 'concrete';
            const postCut = isConc ? postHmm + 300 : postHmm;
            const postSpacing = Math.round(Lmm / (nPosts - 1));
            const trussSpacing = c.nTruss > 1 ? Math.round(Lmm / (c.nTruss - 1)) : Lmm;
            const diagonal = Math.round(Math.sqrt(Lmm * Lmm + Wmm * Wmm));
            const cosP = Math.cos(c.pitchRad);
            const sheetLen = c.isGable ? Math.round((Wmm / 2) / cosP + 50) : Math.round(Wmm / cosP + 50);
            const infill = c.infill || 'none';
            const downlights = parseInt(document.getElementById('extraDownlights')?.value) || 0;
            const hasElectrical = document.getElementById('extraElectrical')?.value === 'yes';
            const steelName = (STEEL[c.trussSteel] || STEEL['76x38']).name;
            const totalPosts = c.isGable ? nPosts * 2 : nPosts;
            const sheetsPerSide = Math.ceil(Lmm / (c.sheetCoverage || 762));
            const totalSheets = c.isGable ? sheetsPerSide * 2 : sheetsPerSide;
            const purlinSpacing = isInsulated(c.roofing) ? 0 : 1000;
            const nPurlins = purlinSpacing > 0 ? Math.max(2, Math.ceil((Wmm / 2) / purlinSpacing)) : 0;
            const accessNotes = [
                (document.getElementById('jobNotes')?.value || '').trim(),
                (document.getElementById('siteNotes')?.value || '').trim()
            ].filter(Boolean).join('. ') || 'None noted';

            function woSectionTitle(title, yp) {
                doc.setFillColor(245, 245, 247);
                doc.rect(mx, yp, cw, 7, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(10);
                doc.setTextColor(...SW_DARK);
                doc.text(title, mx + 3, yp + 5);
                return yp + 9;
            }
            function woKeyVal(label, val, yp, xOff) {
                xOff = xOff || mx;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(120, 120, 120);
                doc.text(label, xOff, yp);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text(String(val), xOff, yp + 4);
                return yp;
            }
            function woCheckRow(text, yp) {
                doc.setDrawColor(180, 180, 180);
                doc.rect(mx + 1, yp - 2.5, 3, 3);
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(60, 60, 60);
                doc.text(text, mx + 7, yp);
                return yp + 5;
            }

            // ═══════════════════════════════════════
            // PAGE 1: JOB SUMMARY + VISUALS
            // ═══════════════════════════════════════
            let y = pdfHeader(doc, 'WORK ORDER', jobRef);

            // Client block with install date + crew blanks
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(60, 60, 60);
            var cName = getClientName(), cAddr = getSiteAddress(), cPhone = getClientPhone();
            doc.text('Client: ' + cName, mx, y);
            doc.text('Phone: ' + cPhone, 130, y);
            y += 5;
            if (cAddr) { doc.text('Address: ' + cAddr, mx, y); y += 5; }
            doc.text('Install Date: _______________', mx, y);
            doc.text('Crew: _______________', 130, y);
            y += 5;
            doc.setFontSize(8);
            doc.setTextColor(100, 100, 100);
            doc.text('ACCESS: ' + accessNotes, mx, y);
            y += 7;

            // THE BUILD box
            y = woSectionTitle('THE BUILD', y);
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(11);
            doc.setTextColor(...SW_ORANGE);
            doc.text(styleLabel + ' PATIO \u2014 ' + connLabel + ' Attachment', mx + 3, y + 1);
            y += 6;
            // Key-value grid
            var kvY = y;
            woKeyVal('Width', mm(Lmm), kvY, mx + 3);
            woKeyVal('Projection', mm(Wmm), kvY, mx + 42);
            woKeyVal('Pitch', c.pitch.toFixed(1) + '\u00B0', kvY, mx + 82);
            woKeyVal('Post Height', mm(postHmm) + ' above FFL', kvY, mx + 112);
            y = kvY + 10;
            woKeyVal('Roofing', roofLabel + ' \u2014 ' + sheetClr, y, mx + 3);
            woKeyVal('Frame', steelClr, y, mx + 82);
            woKeyVal('Post Fixing', isConc ? 'Concrete footings' : 'Baseplate', y, mx + 112);
            y += 10;
            if (c.isGable && infill !== 'none') {
                woKeyVal('Gable Infill', infill.charAt(0).toUpperCase() + infill.slice(1), y, mx + 3);
                y += 10;
            } else { y += 2; }

            // ── PLAN VIEW DIAGRAM ──
            y = woSectionTitle('PLAN VIEW', y);
            var planH = 56, planY = y + 2;
            var planMx = mx + 10, planMr = mr - 40;
            var planW = planMr - planMx;
            var planDepth = planH - 16;
            // Scale
            var scX = planW / Lmm, scY = planDepth / Wmm;
            var sc = Math.min(scX, scY) * 0.85;
            var drawW = Lmm * sc, drawD = Wmm * sc;
            var ox = planMx + (planW - drawW) / 2;
            var oy = planY + (planDepth - drawD) / 2 + 3;

            doc.setDrawColor(180, 180, 180);
            doc.setLineWidth(0.2);
            // House wall
            doc.setFillColor(220, 210, 195);
            doc.rect(ox - 2, oy - 5, drawW + 4, 4, 'F');
            doc.setFontSize(6);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(120, 120, 120);
            if (c.isAttached) doc.text('HOUSE', ox + drawW / 2, oy - 2, { align: 'center' });

            // Patio outline
            doc.setDrawColor(...SW_DARK);
            doc.setLineWidth(0.4);
            doc.rect(ox, oy, drawW, drawD);

            // Ridge line for gable
            if (c.isGable) {
                doc.setDrawColor(...SW_ORANGE);
                doc.setLineWidth(0.2);
                // Dashed ridge line
                var rdY = oy + drawD / 2;
                for (var dx = ox; dx < ox + drawW; dx += 3) {
                    doc.line(dx, rdY, Math.min(dx + 1.5, ox + drawW), rdY);
                }
                doc.setFontSize(5);
                doc.setTextColor(...SW_ORANGE);
                doc.text('RIDGE', ox + drawW + 2, oy + drawD / 2 + 1);
            }

            // Posts
            doc.setFillColor(...SW_DARK);
            var postR = 1.2;
            for (var pi = 0; pi < nPosts; pi++) {
                var px = ox + (pi / (nPosts - 1)) * drawW;
                // Back row
                doc.circle(px, oy, postR, 'F');
                // Front row (or same row for skillion)
                if (c.isGable) {
                    doc.circle(px, oy + drawD, postR, 'F');
                } else {
                    doc.circle(px, oy + drawD, postR, 'F');
                }
            }

            // Dimension labels
            doc.setFontSize(6);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(80, 80, 80);
            // Width
            doc.text(mm(Lmm), ox + drawW / 2, oy + drawD + 6, { align: 'center' });
            // Depth
            doc.text(mm(Wmm), ox - 5, oy + drawD / 2 + 1, { align: 'center', angle: 90 });
            // Post spacing
            if (nPosts > 1) {
                doc.setFontSize(5);
                doc.text(mm(postSpacing) + ' ctrs', ox + drawW / (nPosts - 1) / 2, oy + drawD + 10, { align: 'center' });
            }
            // Annotation
            doc.setFontSize(6);
            doc.setTextColor(120, 120, 120);
            doc.text('BACK BEAM ' + mm(Lmm) + ' (house side)', planMr + 5, oy + 2);
            doc.text('FRONT BEAM ' + mm(Lmm) + ' (post side)', planMr + 5, oy + drawD);
            doc.text(totalPosts + ' posts total', planMr + 5, oy + drawD / 2);
            y = planY + planH + 2;

            // ── CROSS SECTION DIAGRAM ──
            y = woSectionTitle('CROSS SECTION (looking along ridge)', y);
            var csH = 56, csY = y + 2;
            var csMx = mx + 25, csMr = mr - 25;
            var csW = csMr - csMx;
            // Scaled drawing area
            var maxH = Math.max(ridgeH, backBeamH, frontBeamH + (c.isGable ? c.rise : 0));
            var csScX = csW / Wmm;
            var csScY = (csH - 14) / maxH;
            var cssc = Math.min(csScX, csScY) * 0.8;
            var csOx = csMx + (csW - Wmm * cssc) / 2;
            var csGround = csY + csH - 6;

            doc.setDrawColor(160, 160, 160);
            doc.setLineWidth(0.3);
            // Ground line
            doc.setLineWidth(0.6);
            doc.line(csOx - 10, csGround, csOx + Wmm * cssc + 10, csGround);
            doc.setFontSize(5);
            doc.setTextColor(120, 120, 120);
            doc.text('FFL', csOx + Wmm * cssc + 12, csGround + 1);
            doc.setLineWidth(0.3);

            if (c.isGable) {
                // Left post
                var lpx = csOx;
                var lpy = csGround - frontBeamH * cssc;
                doc.setDrawColor(...SW_DARK);
                doc.line(lpx, csGround, lpx, lpy);
                // Right post
                var rpx = csOx + Wmm * cssc;
                doc.line(rpx, csGround, rpx, lpy);
                // Beams
                doc.setLineWidth(0.5);
                doc.line(lpx - 3, lpy, rpx + 3, lpy);
                // Ridge
                var ridgeX = csOx + (Wmm / 2) * cssc;
                var ridgeY = csGround - ridgeH * cssc;
                // Roof slopes
                doc.setDrawColor(...SW_ORANGE);
                doc.setLineWidth(0.4);
                doc.line(lpx, lpy, ridgeX, ridgeY);
                doc.line(rpx, lpy, ridgeX, ridgeY);
                // Ridge cap dot
                doc.setFillColor(...SW_ORANGE);
                doc.circle(ridgeX, ridgeY, 0.8, 'F');
                // Labels
                doc.setFontSize(5);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(80, 80, 80);
                doc.text(mm(postHmm), lpx - 5, csGround - postHmm * cssc / 2, { align: 'center', angle: 90 });
                doc.text(mm(Wmm), csOx + Wmm * cssc / 2, csGround + 4, { align: 'center' });
                doc.text(c.pitch.toFixed(1) + '\u00B0', ridgeX + 8, ridgeY + 6);
                doc.setTextColor(...SW_ORANGE);
                doc.text('RIDGE ' + mm(ridgeH), ridgeX, ridgeY - 2, { align: 'center' });
                doc.text(roofLabel, csOx + Wmm * cssc / 4, lpy - 3, { align: 'center' });
            } else {
                // Skillion
                var lpx2 = csOx;
                var rpx2 = csOx + Wmm * cssc;
                var frontY = csGround - frontBeamH * cssc;
                var backY = csGround - backBeamH * cssc;
                doc.setDrawColor(...SW_DARK);
                // Posts
                doc.line(rpx2, csGround, rpx2, frontY);
                doc.line(lpx2, csGround, lpx2, backY);
                // Beams
                doc.setLineWidth(0.5);
                doc.line(lpx2 - 3, backY, lpx2 + 3, backY);
                doc.line(rpx2 - 3, frontY, rpx2 + 3, frontY);
                // Roof
                doc.setDrawColor(...SW_ORANGE);
                doc.setLineWidth(0.4);
                doc.line(lpx2, backY, rpx2, frontY);
                // Labels
                doc.setFontSize(5);
                doc.setTextColor(80, 80, 80);
                doc.text(mm(postHmm), rpx2 + 4, csGround - postHmm * cssc / 2);
                doc.text(mm(Wmm), csOx + Wmm * cssc / 2, csGround + 4, { align: 'center' });
                doc.text(c.pitch.toFixed(1) + '\u00B0', csOx + Wmm * cssc / 2, Math.min(backY, frontY) - 2, { align: 'center' });
                doc.setTextColor(...SW_ORANGE);
                doc.text(roofLabel, csOx + Wmm * cssc / 2, (backY + frontY) / 2 - 2, { align: 'center' });
                doc.text('BACK ' + mm(backBeamH), lpx2 - 5, backY, { align: 'right' });
                doc.text('FRONT ' + mm(frontBeamH), rpx2 + 5, frontY);
            }

            pdfFooter(doc);

            // ═══════════════════════════════════════
            // PAGE 2: MATERIALS + CRITICAL DIMENSIONS
            // ═══════════════════════════════════════
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Materials & Dimensions', jobRef);

            // Materials checklist
            y = woSectionTitle('MATERIALS CHECKLIST \u2014 Check off when loaded', y);

            const mats = getMaterialRows();
            // Group materials by category
            var matGroups = { 'STRUCTURE': [], 'ROOFING': [], 'DRAINAGE': [], 'FINISHING': [], 'FIXINGS': [] };
            mats.forEach(m => {
                var d = m.desc.toLowerCase();
                if (d.includes('post') || d.includes('beam') || d.includes('truss') || d.includes('purlin') || d.includes('rafter') || d.includes('riser') || d.includes('bracket'))
                    matGroups['STRUCTURE'].push(m);
                else if (d.includes('sheet') || d.includes('ridge') || d.includes('solarspan') || d.includes('spanplus') || d.includes('trimdek') || d.includes('corrugat'))
                    matGroups['ROOFING'].push(m);
                else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow') || d.includes('dp '))
                    matGroups['DRAINAGE'].push(m);
                else
                    matGroups['FINISHING'].push(m);
            });
            // Always add fixings
            matGroups['FIXINGS'].push({ desc: 'Tek screws, rivets, clips, brackets', qty: 1, length: 0 });
            matGroups['FIXINGS'].push({ desc: 'Silicone (clear + colour match)', qty: 1, length: 0 });
            if (hasElectrical && downlights > 0)
                matGroups['FINISHING'].push({ desc: 'LED Downlights', qty: downlights, length: 0 });

            Object.entries(matGroups).forEach(function(entry) {
                var cat = entry[0], items = entry[1];
                if (!items.length) return;
                if (y + 8 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(7);
                doc.setTextColor(...SW_ORANGE);
                doc.text(cat, mx + 6, y);
                y += 4;
                items.forEach(function(m) {
                    if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                    var lenStr = m.length >= 0.1 ? Math.round(m.length * 1000) + 'mm' : '';
                    y = woCheckRow(m.qty + '\u00D7  ' + m.desc + (lenStr ? '    ' + lenStr : ''), y);
                });
                y += 2;
            });
            y += 4;

            // Critical dimensions
            if (y + 60 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
            y = woSectionTitle('CRITICAL DIMENSIONS (pre-calculated)', y);
            doc.setFont('courier', 'normal');
            doc.setFontSize(8);
            doc.setTextColor(...SW_DARK);
            var dimRows = [
                ['Post Cut Length', mm(postCut) + (isConc ? ' (' + mm(postHmm) + ' above FFL + 300 in ground)' : ' (above FFL)')],
                ['Front Beam Height', mm(frontBeamH) + ' above FFL'],
                ['Back Beam Height', mm(backBeamH) + ' above FFL']
            ];
            if (c.isGable) {
                dimRows.push(['Ridge Height', mm(ridgeH) + ' above FFL']);
                dimRows.push(['Rise', mm(riseMm) + ' (' + mm(Wmm) + ' \u00D7 tan ' + c.pitch.toFixed(1) + '\u00B0 \u00F7 2)']);
            } else {
                dimRows.push(['Rise (total)', mm(riseMm)]);
            }
            dimRows.push(['Sheet Length', mm(sheetLen)]);
            dimRows.push(['Post Spacing', mm(postSpacing) + ' centres']);
            if (c.isGable) dimRows.push(['Truss Spacing', mm(trussSpacing) + ' centres']);
            if (nPurlins > 0) dimRows.push(['Purlin Spacing', mm(purlinSpacing) + ' centres']);
            if (isConc) dimRows.push(['Footing Size', '450\u00D7450\u00D7600mm deep']);
            dimRows.push(['Diagonal Check', mm(diagonal) + ' (for square)']);

            dimRows.forEach(function(r) {
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(8);
                doc.setTextColor(100, 100, 100);
                doc.text(r[0] + ':', mx + 3, y);
                doc.setFont('courier', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text(r[1], mx + 55, y);
                y += 5;
            });

            pdfFooter(doc);

            // ═══════════════════════════════════════
            // PAGE 3: BUILD SEQUENCE
            // ═══════════════════════════════════════
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Build Sequence', jobRef);

            var steps = [];

            // 1. Set out
            steps.push({
                title: 'SET OUT',
                items: [
                    'Mark post positions from house wall',
                    'Front row: ' + mm(Wmm) + ' out from house',
                    'Spacing: ' + (function() { var s = []; for (var i = 0; i < nPosts; i++) s.push(mm(Math.round(i * postSpacing))); return s.join(', '); })() + ' from left',
                    'Check square: diagonal = ' + mm(diagonal)
                ]
            });

            // 2. Footings / baseplates
            if (isConc) {
                steps.push({
                    title: 'FOOTINGS',
                    items: [
                        'Dig ' + totalPosts + '\u00D7 holes: 450\u00D7450\u00D7600mm',
                        'Check depths, clear loose soil',
                        'Mix: 1 bag per hole'
                    ]
                });
            } else {
                steps.push({
                    title: 'BASEPLATES',
                    items: [
                        'Mark and drill ' + totalPosts + '\u00D7 baseplate positions',
                        'Fix with dynabolts to slab',
                        'Check alignment before tightening'
                    ]
                });
            }

            // 3. Posts
            steps.push({
                title: 'POSTS',
                items: isConc ? [
                    'Set ' + totalPosts + '\u00D7 posts in wet concrete',
                    'Plumb in both directions',
                    'Top of post: ' + mm(postHmm) + ' above FFL (measure twice)',
                    'Brace and allow to set'
                ] : [
                    'Fix ' + totalPosts + '\u00D7 posts to baseplates',
                    'Plumb in both directions',
                    'Top of post: ' + mm(postHmm) + ' above FFL'
                ]
            });

            // 4. Back beam
            if (c.isAttached) {
                var backDesc = c.connection === 'riser' ? 'Fix riser brackets at ' + mm(backBeamH) + ' above FFL' :
                               c.connection === 'flyover' ? 'Fix beam above house roof at ' + mm(backBeamH) + ' above FFL' :
                               'Fix to house at ' + mm(backBeamH) + ' above FFL';
                steps.push({
                    title: 'BACK BEAM (house connection)',
                    items: [
                        backDesc,
                        'Beam: ' + steelName + ' RHS \u00D7 ' + mm(Lmm),
                        'Check level across full length'
                    ]
                });
            }

            // 5. Front beam
            steps.push({
                title: 'FRONT BEAM',
                items: [
                    'Beam: ' + steelName + ' RHS \u00D7 ' + mm(Lmm),
                    'Fix to top of posts',
                    'Height: ' + mm(frontBeamH) + ' above FFL',
                    'Check level' + (c.isAttached ? ', check fall matches back beam' : '')
                ]
            });

            // 6. Trusses (gable/hip) or skip
            if (c.isGable) {
                steps.push({
                    title: 'TRUSSES',
                    items: [
                        nTruss + '\u00D7 trusses at ' + mm(trussSpacing) + ' centres',
                        'Fix to top of beams',
                        'Check plumb, apex aligned',
                        'Ridge height: ' + mm(ridgeH) + ' above FFL'
                    ]
                });
            }

            // 7. Purlins (if needed)
            if (nPurlins > 0) {
                steps.push({
                    title: 'PURLINS',
                    items: [
                        nPurlins + '\u00D7 purlins per ' + (c.isGable ? 'side' : 'slope') + ' at ' + mm(purlinSpacing) + ' centres',
                        'Run parallel to beams, across ' + (c.isGable ? 'trusses' : 'rafters'),
                        'Fix with tek screws'
                    ]
                });
            }

            // 8. Sheets
            steps.push({
                title: 'ROOFING SHEETS',
                items: [
                    totalSheets + '\u00D7 sheets @ ' + mm(sheetLen) + ' long',
                    'Start from left, work right',
                    '50mm overhang into gutter',
                    c.isGable ? '15mm gap at ridge for cap' : 'Fix with appropriate fasteners',
                    isInsulated(c.roofing) ? 'Fix with SolarSpan clips' : 'Fix with tek screws to purlins'
                ]
            });

            // 9. Ridge cap (gable only)
            if (c.isGable) {
                steps.push({
                    title: 'RIDGE CAP',
                    items: [
                        mm(Lmm + 100) + ' ridge cap',
                        'Seal both ends',
                        'Fix through to purlins/trusses'
                    ]
                });
            }

            // 10. Gable infill
            if (c.isGable && infill !== 'none') {
                steps.push({
                    title: 'GABLE INFILL',
                    items: [
                        infill.charAt(0).toUpperCase() + infill.slice(1) + ' infill',
                        'Cut to match pitch',
                        'Fix to end trusses',
                        'Seal edges with silicone'
                    ]
                });
            }

            // 11. Gutters
            steps.push({
                title: 'GUTTERS & DOWNPIPES',
                items: [
                    'Gutter: ' + mm(Lmm + 200) + ' with fall',
                    'Downpipe at end',
                    'Check water flows to DP'
                ]
            });

            // 12. Flashings
            steps.push({
                title: 'FLASHINGS',
                items: c.isGable ? [
                    'Barge rolls both ends',
                    'Apron at house wall',
                    'Seal all junctions'
                ] : [
                    'Back flashing at house wall',
                    'Barge rolls both ends',
                    'Seal all junctions'
                ]
            });

            // 13. Electrical (if applicable)
            if (hasElectrical && downlights > 0) {
                steps.push({
                    title: 'ELECTRICAL',
                    items: [
                        downlights + '\u00D7 downlights as marked',
                        'Electrician to connect'
                    ]
                });
            }

            // 14. Final
            steps.push({
                title: 'FINAL',
                items: [
                    'Check all fixings tight',
                    'Clean up site',
                    'Take completion photos',
                    'Customer walkthrough'
                ]
            });

            // Render steps
            steps.forEach(function(step, si) {
                var needed = 8 + step.items.length * 4.5;
                if (y + needed > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }

                // Step number + title
                doc.setFillColor(245, 245, 247);
                doc.rect(mx, y, cw, 6, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(8);
                doc.setTextColor(...SW_DARK);
                doc.text((si + 1) + '. ' + step.title, mx + 3, y + 4);
                // Done checkbox on right
                doc.setDrawColor(180, 180, 180);
                doc.rect(mr - 15, y + 1, 3, 3);
                doc.setFontSize(6);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(150, 150, 150);
                doc.text('Done', mr - 11, y + 3.5);
                y += 8;

                // Items
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(60, 60, 60);
                step.items.forEach(function(item) {
                    doc.text('\u2022 ' + item, mx + 5, y);
                    y += 4.5;
                });
                y += 2;
            });

            pdfFooter(doc);

            // ═══════════════════════════════════════
            // PAGE 4: SIGN-OFF
            // ═══════════════════════════════════════
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Sign-Off', jobRef);

            // Completion checklist
            y = woSectionTitle('COMPLETION CHECKLIST', y);
            var checks = [
                'Structure plumb and level',
                'All fixings secure',
                'Roof sheets correctly lapped',
                c.isGable ? 'Ridge cap sealed' : 'Roof sealed at house junction',
                'Gutters fall to downpipe',
                'No visible gaps or defects',
                'Flashings sealed',
                'Site clean, rubbish removed',
                'Before photos taken',
                'After photos taken',
                'Customer walkthrough completed'
            ];
            checks.forEach(function(item) { y = woCheckRow(item, y); });
            y += 6;

            // Notes / Issues
            y = woSectionTitle('NOTES / ISSUES', y);
            doc.setDrawColor(200, 200, 200);
            for (var li = 0; li < 6; li++) {
                doc.line(mx + 3, y + 1, mr - 3, y + 1);
                y += 7;
            }
            y += 4;

            // Sign-off
            y = woSectionTitle('SIGN-OFF', y);
            y += 4;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(80, 80, 80);
            doc.text('Installer: ___________________________   Sign: _______________   Date: __________', mx + 3, y);
            y += 12;
            doc.text('Customer: ___________________________   Sign: _______________   Date: __________', mx + 3, y);
            y += 8;
            doc.setFontSize(8);
            doc.setTextColor(120, 120, 120);
            doc.setFont('helvetica', 'italic');
            doc.text('"I confirm the work has been completed to my satisfaction"', mx + 3, y);

            pdfFooter(doc);
            doc.save('WorkOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        // ==================== PDF: TRUSS ORDER ====================
        function exportTrussPDF() {
            if (!calc.isGable || !calc.trussData) {
                alert('Truss data only available for Gable roofs. Switch to Gable first.');
                return;
            }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const td = calc.trussData;
            let y = pdfHeader(doc, 'Truss Fabrication Order', jobRef);
            y = pdfClientBlock(doc, y);

            // Truss image capture
            const img = captureTrussImage();
            if (img) {
                try {
                    doc.addImage(img, 'PNG', 14, y, 110, 55);
                    y += 58;
                } catch(e) { /* skip */ }
            }

            const lx = 14;
            const rw = 178;
            const lh = 5.5;

            function fabSection(title) {
                doc.setFillColor(...SW_ORANGE);
                doc.rect(lx, y, rw, 6, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                doc.setTextColor(255, 255, 255);
                doc.text('  ' + title, lx + 2, y + 4.5);
                y += 7;
            }
            function fabRow(label, value, bold) {
                doc.setFont('helvetica', bold ? 'bold' : 'normal');
                doc.setFontSize(10);
                doc.setTextColor(...SW_DARK);
                doc.text(label, lx + 4, y);
                doc.text(String(value), lx + rw - 4, y, { align: 'right' });
                y += lh;
            }

            fabSection('STEEL');
            fabRow('Profile', td.steelName + ' RHS');
            fabRow('Colour', td.clr);
            fabRow('BMT', td.bmt + 'mm');
            fabRow('Quantity', td.nTruss + ' trusses');
            y += 2;

            fabSection('DIMENSIONS');
            fabRow('SP (Span)', td.trussSpan + 'mm');
            fabRow('HT (Height)', td.rise + 'mm');
            fabRow('Pitch', td.pitch.toFixed(1) + '\u00B0');
            if (td.overhang > 0) fabRow('Overhang', td.overhang + 'mm');
            if (td.riser && td.riser.enabled) {
                fabRow('RX', td.riser.rx + 'mm');
                fabRow('RY', td.riser.ry + 'mm');
            }
            if (td.dogleg && td.dogleg.enabled) {
                fabRow('LX', td.dogleg.lx + 'mm');
                fabRow('LY', td.dogleg.ly + 'mm');
            }
            if (td.extender && td.extender.enabled) {
                fabRow('Extender', td.extender.length + 'mm');
            }
            y += 2;

            fabSection('CUT LIST (per truss)');
            fabRow('Bottom Chord', '1 \u00D7 ' + td.chordCut + 'mm', true);
            fabRow('Rafters', '2 \u00D7 ' + td.rafterCut + 'mm', true);
            if (td.trussStyle === 'kingpost') {
                fabRow('King Post', '1 \u00D7 ' + td.kingPostH + 'mm');
            }
            y += 2;

            fabSection('CUT ANGLES');
            fabRow('Apex Mitre', td.apexAngle.toFixed(1) + '\u00B0 (both rafters)');
            fabRow('Heel Mitre', td.heelAngle.toFixed(1) + '\u00B0 (rafter to chord)');
            y += 2;

            fabSection('MATERIAL REQUIRED');
            fabRow('Per truss', td.totalLM.toFixed(3) + ' LM');
            fabRow('All ' + td.nTruss + ' trusses', td.totalAllLM.toFixed(2) + ' LM', true);
            fabRow('Order length', td.totalSticks + ' \u00D7 6m sticks', true);

            pdfFooter(doc);
            doc.save('TrussOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        function captureTrussImage() {
            try {
                if (trussRend && trussScene && trussCam) {
                    trussRend.render(trussScene, trussCam);
                    return trussRend.domElement.toDataURL('image/png');
                }
            } catch(e) {}
            return null;
        }

        function initPricing() {
            loadRates();
            renderRatesPanel();
            buildJobRows();
            // Set default labour day rate from stored rates
            const drEl = document.getElementById('labDayRate');
            if (drEl && storedRates['Skilled Trade']) drEl.value = storedRates['Skilled Trade'];
            updatePricing();
        }

        function rebuildAll() {
            getInputs();
            draw2DPlan();
            buildTruss3D();
            buildAsm3D();
            buildJobRows();
            updatePricing();
            updateEstimate();
            updateRightPanelSummary();
        }

        function exportOrder() {
            const c = calc;
            alert('Export order for SW1772 - ' + c.roofStyle.toUpperCase() + ' PATIO\n' +
                  'Size: ' + c.lenInput + 'mm × ' + c.projInput + 'mm\n' +
                  'Orientation: ' + c.orientation + '\n' +
                  'Roofing: ' + c.roofing + '\n' +
                  'Connection: ' + c.connection);
        }

        // ==================== INIT ====================
        function resizeAsm() {
            const ac = document.getElementById('asmViewport');
            if (asmCam && asmRend && ac && !ac.classList.contains('fullscreen')) {
                var w = ac.clientWidth, h = ac.clientHeight;
                if (w > 0 && h > 0) {
                    asmCam.aspect = w / h;
                    asmCam.updateProjectionMatrix();
                    asmRend.setSize(w, h);
                }
            }
        }
        function resizeTruss() {
            const tc = document.getElementById('trussViewport');
            if (trussCam && trussRend && tc) {
                var w = tc.clientWidth, h = tc.clientHeight;
                if (w > 0 && h > 0) {
                    trussCam.aspect = w / h;
                    trussCam.updateProjectionMatrix();
                    trussRend.setSize(w, h);
                }
            }
        }
        window.addEventListener('resize', () => {
            resizeTruss();
            resizeAsm();
            draw2DPlan();
        });
        // ResizeObserver for container-specific resize (layout changes, panel toggle)
        if (typeof ResizeObserver !== 'undefined') {
            var ro = new ResizeObserver(function() {
                resizeAsm();
                resizeTruss();
                draw2DPlan();
            });
            var asmEl = document.getElementById('asmViewport');
            var trussEl = document.getElementById('trussViewport');
            var rpEl = document.getElementById('panelRight');
            if (asmEl) ro.observe(asmEl);
            if (trussEl) ro.observe(trussEl);
            if (rpEl) ro.observe(rpEl);
        }

        // ==================== LAYOUT TOGGLE ====================
        function toggleLayout() {
            var main = document.getElementById('mainLayout');
            var btn = document.getElementById('layoutToggle');
            var isFullWidth = main.classList.toggle('full-width');
            btn.innerHTML = isFullWidth ? '&#9704; Show Preview' : '&#9703; Full Width';
            localStorage.setItem('patioLayout', isFullWidth ? 'full' : 'split');
            // Resize canvases after layout change — multiple delays for CSS transition
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 50);
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 200);
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 500);
        }

        function initLayout() {
            var pref = localStorage.getItem('patioLayout');
            if (pref === 'full') {
                document.getElementById('mainLayout').classList.add('full-width');
                document.getElementById('layoutToggle').innerHTML = '&#9704; Show Preview';
            }
        }

        // initRightPanel3D removed — single renderer now in right panel via initAsm3D

        function updateRightPanelSummary() {
            var c = calc;
            if (!c || !c.L) return;
            var rpDims = document.getElementById('rpDims');
            var rpRoof = document.getElementById('rpRoofType');
            var rpMat = document.getElementById('rpMaterial');
            var rpClr = document.getElementById('rpColour');
            if (rpDims) rpDims.textContent = (c.lenInput / 1000).toFixed(1) + 'm × ' + (c.projInput / 1000).toFixed(1) + 'm';
            if (rpRoof) rpRoof.textContent = c.roofStyle === 'hip' ? 'Hip' : (c.isGable ? 'Gable' : 'Skillion');
            if (rpMat) rpMat.textContent = (ROOFING_TYPES[c.roofing] || ROOFING_TYPES.corrugated).name;
            if (rpClr) rpClr.textContent = sheetColor.name;

            // Estimate now writes directly to rpEstSqm/rpEstRange via updateEstimate()
        }

        // Initialize
        initLayout();
        initCollapseSections();
        initJobDetails();
        updateUI();
        initTruss3D();
        initAsm3D();
        initPricing();
        rebuildAll();
        // Deferred resize to ensure renderers sync after DOM settles
        function deferredResize() {
            resizeAsm(); resizeTruss(); draw2DPlan();
        }
        requestAnimationFrame(deferredResize);
        setTimeout(deferredResize, 200);
        setTimeout(deferredResize, 500);
    </script>
</body>
</html>
