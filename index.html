
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureWorks WA - Patio Designer Pro V18</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js"></script>
    <style>
        :root {
            --sw-orange: #F15A29;
            --sw-blue-dark: #293C46;
            --sw-white: #FFFFFF;
            --sw-bg: #F5F5F7;
            --sw-border: #E5E5E5;
            --sw-text: #1D1D1F;
            --sw-text-sec: #86868B;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: var(--sw-bg);
            color: var(--sw-text);
        }
        .header {
            background: var(--sw-white);
            border-bottom: 1px solid var(--sw-border);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo { display: flex; align-items: center; gap: 8px; }
        .logo-icon {
            width: 32px; height: 32px;
            background: var(--sw-orange);
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
        }
        .logo-icon svg { width: 18px; height: 18px; fill: white; }
        .logo-text { font-size: 16px; font-weight: 600; }
        .logo-text span { color: var(--sw-orange); }
        .job-badge { background: var(--sw-bg); padding: 6px 14px; border-radius: 16px; font-size: 13px; }
        .job-badge strong { color: var(--sw-orange); }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }
        .btn-primary { background: var(--sw-orange); color: white; }
        .btn-secondary { background: var(--sw-bg); color: var(--sw-text); border: 1px solid var(--sw-border); }
        .main { max-width: 1400px; margin: 0 auto; padding: 24px; }
        .section {
            background: var(--sw-white);
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 1px 8px rgba(0,0,0,0.04);
            overflow: hidden;
        }
        .section-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--sw-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .section-title { font-size: 16px; font-weight: 600; }
        .section-subtitle { font-size: 12px; color: var(--sw-text-sec); }
        .section-body { padding: 20px; }

        .setup-grid { display: grid; grid-template-columns: 320px 1fr 280px; gap: 20px; }
        .options-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 16px; }
        .setup-card { background: var(--sw-bg); border-radius: 10px; padding: 14px; }
        .setup-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 10px; }
        .field { margin-bottom: 10px; }
        .field-label { display: flex; justify-content: space-between; font-size: 12px; font-weight: 500; margin-bottom: 3px; }
        .field-unit { font-size: 10px; color: var(--sw-text-sec); }
        .field-input { width: 100%; padding: 7px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; }
        .field-input:focus { outline: none; border-color: var(--sw-orange); }
        .field-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .plan-2d { background: #EEF1F4; border-radius: 8px; height: 220px; }
        .plan-2d canvas { width: 100%; height: 100%; }
        .color-chips { display: flex; flex-wrap: wrap; gap: 5px; }
        .color-chip { width: 24px; height: 24px; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
        .color-chip.active { border-color: var(--sw-text); }
        .color-label { font-size: 11px; color: var(--sw-text-sec); margin-top: 6px; }
        .calc-display { background: var(--sw-blue-dark); border-radius: 8px; padding: 10px; margin-top: 10px; color: white; }
        .calc-row { display: flex; justify-content: space-between; font-size: 11px; padding: 3px 0; }
        .calc-label { opacity: 0.7; }
        .calc-value { font-weight: 600; font-family: 'SF Mono', monospace; color: var(--sw-orange); }

        .truss-grid { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .truss-viewport { background: linear-gradient(180deg, #E0E4E8 0%, #CED4DA 100%); border-radius: 10px; height: 420px; position: relative; }
        .truss-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .truss-viewport canvas:active { cursor: grabbing; }
        .truss-view-btns { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.9); padding: 3px; border-radius: 6px; }
        .truss-view-btn { padding: 5px 10px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .truss-view-btn.active { background: var(--sw-blue-dark); color: white; }
        .truss-panel { display: flex; flex-direction: column; gap: 12px; }
        .truss-card { background: var(--sw-bg); border-radius: 10px; padding: 12px; }
        .truss-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .spec-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .spec-item { background: white; border-radius: 6px; padding: 8px; text-align: center; }
        .spec-label { font-size: 9px; color: var(--sw-text-sec); }
        .spec-value { font-size: 15px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .spec-value.hl { color: var(--sw-orange); }
        .fab-box { background: var(--sw-blue-dark); border-radius: 10px; padding: 12px; color: white; }
        .fab-box h4 { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; margin-bottom: 8px; }
        .fab-line { font-family: 'SF Mono', monospace; font-size: 11px; padding: 4px 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-bottom: 2px; }

        .asm-viewport { height: 520px; background: linear-gradient(180deg, #D4D9E0 0%, #BCC4CC 100%); border-radius: 10px; position: relative; }
        .asm-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .asm-viewport canvas:active { cursor: grabbing; }
        .asm-viewport.fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100vw; height: 100vh; z-index: 1000; border-radius: 0; }
        .layer-panel { position: absolute; top: 12px; left: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; min-width: 140px; }
        .layer-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .layer-item { display: flex; align-items: center; gap: 6px; padding: 4px 0; cursor: pointer; font-size: 11px; }
        .layer-check { width: 14px; height: 14px; border: 2px solid var(--sw-border); border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 9px; color: white; }
        .layer-item.active .layer-check { background: var(--sw-orange); border-color: var(--sw-orange); }
        .layer-item.active .layer-check::after { content: '✓'; }
        .mat-panel { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; width: 200px; }
        .mat-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .mat-row { display: flex; justify-content: space-between; font-size: 10px; padding: 3px 0; border-bottom: 1px solid var(--sw-border); }
        .mat-row:last-child { border-bottom: none; }
        .mat-qty { font-weight: 600; color: var(--sw-orange); }
        .view-panel { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.95); padding: 3px; border-radius: 6px; }
        .view-btn { padding: 5px 12px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .view-btn.active { background: var(--sw-blue-dark); color: white; }
        .fullscreen-btn { position: absolute; top: 12px; right: 230px; background: rgba(255,255,255,0.95); border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; font-size: 11px; }
        .tooltip { position: absolute; background: rgba(41,60,70,0.95); color: white; padding: 10px 14px; border-radius: 8px; font-size: 11px; pointer-events: none; opacity: 0; transition: opacity 0.15s; z-index: 50; max-width: 240px; }
        .tooltip.visible { opacity: 1; }
        .tooltip-title { font-weight: 600; font-size: 12px; color: var(--sw-orange); margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .tooltip-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .tooltip-label { opacity: 0.7; }
        .tooltip-value { font-weight: 500; font-family: 'SF Mono', monospace; }

        /* Pricing Section */
        .pricing-card { background: var(--sw-bg); border-radius: 10px; padding: 16px; margin-bottom: 12px; }
        .pricing-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 10px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .pricing-card h4::after { content: '▾'; font-size: 10px; transition: transform 0.2s; }
        .pricing-card h4.collapsed::after { transform: rotate(-90deg); }
        .pricing-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .pricing-table th { text-align: left; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 6px 6px; border-bottom: 2px solid var(--sw-border); white-space: nowrap; }
        .pricing-table td { padding: 4px 6px; border-bottom: 1px solid var(--sw-border); font-size: 12px; }
        .pricing-table tr:last-child td { border-bottom: none; }
        .pricing-table .subtotal-row td { font-weight: 700; border-top: 2px solid var(--sw-text); border-bottom: none; padding-top: 8px; }
        .pricing-table .section-label td { font-weight: 600; font-size: 10px; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding-top: 12px; border-bottom: 1px solid var(--sw-border); }
        .pricing-table .mono { font-family: 'SF Mono', monospace; font-size: 11px; }
        .pricing-table th.r, .pricing-table td.r { text-align: right; }
        .pricing-table td.margin-pos { color: #34C759; font-weight: 600; }
        .pricing-table td.margin-neg { color: #FF3B30; font-weight: 600; }
        .cell-input { width: 72px; padding: 3px 5px; border: 1px solid transparent; border-radius: 3px; font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; background: transparent; }
        .cell-input:hover { border-color: var(--sw-border); background: white; }
        .cell-input:focus { outline: none; border-color: var(--sw-orange); background: white; }
        .cell-input.wide { width: 100%; text-align: left; font-family: inherit; }
        .rate-input { width: 70px; padding: 3px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; }
        .rate-input:focus { outline: none; border-color: var(--sw-orange); }
        .addon-bar { display: flex; flex-wrap: wrap; gap: 6px; margin: 10px 0; }
        .addon-btn { background: white; border: 1px solid var(--sw-border); border-radius: 6px; padding: 5px 10px; font-size: 11px; cursor: pointer; color: var(--sw-text); }
        .addon-btn:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        .add-line-btn { background: none; border: 1px dashed var(--sw-border); border-radius: 6px; padding: 6px 12px; font-size: 11px; color: var(--sw-text-sec); cursor: pointer; width: 100%; margin-top: 4px; }
        .add-line-btn:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        .remove-btn { background: none; border: none; color: var(--sw-text-sec); cursor: pointer; font-size: 13px; padding: 0 2px; line-height: 1; }
        .remove-btn:hover { color: #FF3B30; }
        .pricing-summary { background: var(--sw-blue-dark); border-radius: 10px; padding: 16px; color: white; }
        .pricing-summary h4 { font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; margin-bottom: 10px; }
        .summary-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 13px; }
        .summary-row.total { font-size: 16px; font-weight: 700; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 10px; margin-top: 6px; }
        .summary-value { font-family: 'SF Mono', monospace; color: var(--sw-orange); font-weight: 600; }
        .summary-value.green { color: #4CD964; }
        .totals-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-top: 16px; }
        .labour-roles { display: flex; flex-wrap: wrap; gap: 6px; margin: 8px 0 4px; }
        .role-btn { background: white; border: 1px solid var(--sw-border); border-radius: 6px; padding: 5px 10px; font-size: 11px; cursor: pointer; color: var(--sw-text); }
        .role-btn:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        .client-info-card .client-fields { display: grid; grid-template-columns: 1fr 2fr 1fr 1fr; gap: 10px; }
        .client-info-card label { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 3px; display: block; }
        .client-field .field-input { font-size: 12px; padding: 6px 8px; }
        .labour-totals { display: flex; justify-content: flex-end; gap: 20px; padding: 8px 6px 2px; font-size: 11px; color: var(--sw-text-sec); border-top: 2px solid var(--sw-border); margin-top: 8px; }
        .labour-totals strong { color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .complexity-card { margin-top: 8px; }
        .complexity-table { width: 100%; border-collapse: collapse; font-size: 11px; margin-bottom: 10px; }
        .complexity-table th { text-align: left; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 5px 6px; border-bottom: 2px solid var(--sw-border); }
        .complexity-table td { padding: 5px 6px; border-bottom: 1px solid var(--sw-border); font-size: 11px; }
        .complexity-table td.hint { color: var(--sw-text-sec); font-size: 10px; }
        .complexity-table tr:last-child td { border-bottom: none; }
        .complexity-input { width: 42px; padding: 3px 4px; border: 1px solid var(--sw-border); border-radius: 3px; font-size: 11px; font-family: 'SF Mono', monospace; text-align: center; }
        .complexity-input:focus { outline: none; border-color: var(--sw-orange); }
        .complexity-result { padding: 10px 12px; background: var(--sw-bg); border-radius: 8px; border: 1px solid var(--sw-border); }
        .complexity-display { font-size: 13px; font-weight: 500; color: var(--sw-text); }
        .complexity-score { font-size: 18px; font-weight: 700; font-family: 'SF Mono', monospace; color: var(--sw-orange); }
        .complexity-suggestion { font-size: 14px; font-weight: 700; color: var(--sw-text); }
        .complexity-note { font-size: 10px; color: var(--sw-text-sec); margin-top: 6px; font-style: italic; }
        .complexity-band { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: 600; margin-left: 6px; }
        .complexity-band.easy { background: #D1F2EB; color: #1E8449; }
        .complexity-band.medium { background: #FEF9E7; color: #B7950B; }
        .complexity-band.hard { background: #FADBD8; color: #C0392B; }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon"><svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg></div>
            <div class="logo-text">Secure<span>Works</span> WA</div>
        </div>
        <div class="job-badge"><strong>SW1772</strong> &nbsp;Stefan Botha • Rockingham</div>
        <button class="btn btn-primary" onclick="exportOrder()">Export Order</button>
    </header>

    <main class="main">
        <!-- SECTION 1: JOB SETUP -->
        <div class="section">
            <div class="section-header">
                <div><div class="section-title">Job Setup</div><div class="section-subtitle">Configure patio dimensions</div></div>
            </div>
            <div class="section-body">
                <div class="setup-grid">
                    <div class="setup-card">
                        <h4>Patio Type</h4>
                        <div class="field">
                            <label class="field-label">Roof Style</label>
                            <select class="field-input" id="inRoofStyle" onchange="updateUI(); rebuildAll()">
                                <option value="gable">Gable</option>
                                <option value="skillion">Skillion</option>
                            </select>
                        </div>
                        <div class="field" id="orientationField">
                            <label class="field-label">Ridge Direction</label>
                            <select class="field-input" id="inOrientation" onchange="rebuildAll()">
                                <option value="lengthways">Along House (Ridge || House)</option>
                                <option value="perpendicular">Away from House (Ridge ⊥ House)</option>
                            </select>
                        </div>
                        <h4 style="margin-top:10px">Dimensions</h4>
                        <div class="field-row">
                            <div class="field">
                                <label class="field-label">Projection<span class="field-unit">mm</span></label>
                                <input type="number" class="field-input" id="inWidth" value="3000" oninput="rebuildAll()">
                            </div>
                            <div class="field">
                                <label class="field-label">Length<span class="field-unit">mm</span></label>
                                <input type="number" class="field-input" id="inLength" value="6000" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field" id="pitchField">
                                <label class="field-label">Pitch<span class="field-unit">°</span></label>
                                <input type="number" class="field-input" id="inPitch" value="10" step="0.5" oninput="rebuildAll()">
                            </div>
                            <div class="field">
                                <label class="field-label">Post Height<span class="field-unit">mm</span></label>
                                <input type="number" class="field-input" id="inPostHeight" value="2400" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field">
                                <label class="field-label">Posts (per side)</label>
                                <input type="number" class="field-input" id="inPosts" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="field" id="trussField">
                                <label class="field-label">Trusses</label>
                                <input type="number" class="field-input" id="inTrusses" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="field" id="rafterField" style="display:none">
                                <label class="field-label">Rafters</label>
                                <input type="number" class="field-input" id="inRafters" value="5" min="2" oninput="rebuildAll()">
                            </div>
                        </div>
                        <!-- Calculated values display -->
                        <div class="calc-display" id="calcDisplay">
                            <div class="calc-row"><span class="calc-label">Rise:</span><span class="calc-value" id="calcRise">--</span></div>
                            <div class="calc-row"><span class="calc-label">Rafter TRUE:</span><span class="calc-value" id="calcRafter">--</span></div>
                            <div class="calc-row" id="calcPitchRow" style="display:none"><span class="calc-label">Actual Pitch:</span><span class="calc-value" id="calcPitch">--</span></div>
                        </div>
                    </div>
                    <div class="setup-card">
                        <h4>2D Site Plan</h4>
                        <div class="plan-2d"><canvas id="plan2d"></canvas></div>
                    </div>
                    <div class="setup-card">
                        <h4>Materials</h4>
                        <div class="field">
                            <label class="field-label">Roof Sheeting</label>
                            <select class="field-input" id="inRoofing" onchange="updateUI(); rebuildAll()">
                                <option value="corrugated">Corrugated</option>
                                <option value="trimdek">Trimdek</option>
                                <option value="insulated">Insulated Panel (Bondor)</option>
                            </select>
                        </div>
                        <div class="field" id="gableInfillField">
                            <label class="field-label">Gable Infill</label>
                            <select class="field-input" id="inInfill" onchange="rebuildAll()">
                                <option value="colorbond">Colorbond</option>
                                <option value="twinwall">10mm Twinwall</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                        <div class="field">
                            <label class="field-label">Steel Size</label>
                            <select class="field-input" id="inTrussSteel" onchange="rebuildAll()">
                                <option value="76x38">76 × 38 × 1.6mm RHS</option>
                                <option value="100x50">100 × 50 × 2mm RHS</option>
                            </select>
                        </div>
                        <h4 style="margin-top:12px">Colours</h4>
                        <div style="font-size:11px; color: var(--sw-text-sec); margin-bottom:4px;">Sheets</div>
                        <div class="color-chips" id="sheetChips"></div>
                        <div class="color-label" id="sheetLabel">Monument</div>
                        <div style="font-size:11px; color: var(--sw-text-sec); margin-top:8px; margin-bottom:4px;">Steel</div>
                        <div class="color-chips" id="steelChips"></div>
                        <div class="color-label" id="steelLabel">Monument</div>
                    </div>
                </div>
                <div class="options-grid">
                    <div class="setup-card">
                        <h4>House Connection</h4>
                        <div class="field">
                            <label class="field-label">Type</label>
                            <select class="field-input" id="inConnection" onchange="updateUI(); rebuildAll()">
                                <option value="freestanding">Freestanding</option>
                                <option value="fascia">Receiving Channel (Fascia)</option>
                                <option value="wall">Receiving Channel (Wall)</option>
                                <option value="fasciabeam" disabled>Fascia Beam</option>
                                <option value="riser">Riser Beam</option>
                                <option value="flyover">Flyover</option>
                            </select>
                        </div>
                        <div class="field" id="fasciaHeightField" style="display:none">
                            <label class="field-label">House Fascia Height<span class="field-unit">mm</span></label>
                            <input type="number" class="field-input" id="inFasciaHeight" value="2700" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="riserHeightField" style="display:none">
                            <label class="field-label">Riser Height<span class="field-unit">mm</span></label>
                            <input type="number" class="field-input" id="inRiserHeight" value="400" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="riserOffsetField" style="display:none">
                            <label class="field-label">Riser Offset<span class="field-unit">mm</span></label>
                            <input type="number" class="field-input" id="inRiserOffset" value="150" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="riserQtyField" style="display:none">
                            <label class="field-label">Riser Brackets</label>
                            <input type="number" class="field-input" id="inRiserQty" value="" min="2" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="houseGutterField" style="display:none">
                            <label class="field-label">House Gutter</label>
                            <select class="field-input" id="inHouseGutter" onchange="rebuildAll()">
                                <option value="quad">Existing Quad Gutter</option>
                                <option value="box">Replace with Box Gutter</option>
                            </select>
                        </div>
                        <div class="field" id="riserGutterField" style="display:none">
                            <label class="field-label">Riser Gutter</label>
                            <select class="field-input" id="inRiserGutter" onchange="rebuildAll()">
                                <option value="none">None</option>
                                <option value="quad">Quad Gutter on Riser Beam</option>
                            </select>
                        </div>
                    </div>
                    <div class="setup-card">
                        <h4>Construction</h4>
                        <div class="field">
                            <label class="field-label">Post Fixing</label>
                            <select class="field-input" id="inPostFix">
                                <option value="concrete">Concrete Footing (600mm)</option>
                                <option value="baseplate">Base Plate + Dynabolts</option>
                            </select>
                        </div>
                        <div class="field" id="trussStyleField">
                            <label class="field-label">Truss Style</label>
                            <select class="field-input" id="inTrussStyle" onchange="rebuildAll()">
                                <option value="open">Open (no web)</option>
                                <option value="king">King Post</option>
                                <option value="queen">Queen Post</option>
                            </select>
                        </div>
                    </div>
                    <div class="setup-card">
                        <h4>Notes</h4>
                        <textarea class="field-input" id="jobNotes" rows="4" placeholder="Job notes..."></textarea>
                    </div>
                </div>
            </div>
        </div>

        <!-- SECTION 2: TRUSS CALCULATOR (GABLE ONLY) -->
        <div class="section" id="section2">
            <div class="section-header">
                <div><div class="section-title">Gable Truss Calculator</div><div class="section-subtitle">Interactive 3D truss with fabrication specs</div></div>
            </div>
            <div class="section-body">
                <div class="truss-grid">
                    <div class="truss-viewport" id="trussViewport">
                        <canvas id="trussCanvas"></canvas>
                        <div class="truss-view-btns">
                            <button class="truss-view-btn active" onclick="setTrussView('3d',this)">3D</button>
                            <button class="truss-view-btn" onclick="setTrussView('front',this)">Front</button>
                            <button class="truss-view-btn" onclick="setTrussView('side',this)">Side</button>
                        </div>
                    </div>
                    <div class="truss-panel">
                        <div class="truss-card">
                            <h4>Truss Dimensions</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">A: Span (out-out)</div><div class="spec-value" id="specA">3000</div></div>
                                <div class="spec-item"><div class="spec-label">B: Rise</div><div class="spec-value" id="specB">264</div></div>
                                <div class="spec-item"><div class="spec-label">C: Rafter TRUE</div><div class="spec-value hl" id="specC">1523</div></div>
                                <div class="spec-item"><div class="spec-label">D: Pitch</div><div class="spec-value" id="specD">10°</div></div>
                            </div>
                        </div>
                        <div class="truss-card">
                            <h4>Cut Angles</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">Apex Cut</div><div class="spec-value" id="angleApex">80°</div></div>
                                <div class="spec-item"><div class="spec-label">Heel Cut</div><div class="spec-value" id="angleBase">10°</div></div>
                                <div class="spec-item"><div class="spec-label">Plumb Cut</div><div class="spec-value" id="anglePlumb">80°</div></div>
                                <div class="spec-item"><div class="spec-label">Level Cut</div><div class="spec-value" id="angleLevel">10°</div></div>
                            </div>
                        </div>
                        <div class="truss-card" id="webCard" style="display:none">
                            <h4>Web Members</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">King Post</div><div class="spec-value" id="webKing">--</div></div>
                                <div class="spec-item"><div class="spec-label">Queen Posts</div><div class="spec-value" id="webQueen">--</div></div>
                            </div>
                        </div>
                        <div class="fab-box">
                            <h4>✓ FABRICATOR CUT LIST</h4>
                            <div class="fab-line" id="fabSteel">Steel: 76×38×1.6 RHS</div>
                            <div class="fab-line" id="fabThick">Wall: 1.6mm BMT</div>
                            <div class="fab-line" style="margin-top:6px; border-top:1px solid rgba(255,255,255,0.2); padding-top:6px" id="fabChord">Bottom Chord: 3000mm</div>
                            <div class="fab-line" id="fabRafterOut">Rafter (out): 1523mm</div>
                            <div class="fab-line" id="fabRafterIn">Rafter (in): 1447mm</div>
                            <div class="fab-line" id="fabApexCut">Apex Mitre: 80°</div>
                            <div class="fab-line" id="fabHeelCut">Heel Mitre: 10°</div>
                            <div class="fab-line" id="fabWeb" style="display:none">Web: --</div>
                            <div class="fab-line" style="margin-top:6px; border-top:1px solid rgba(255,255,255,0.2); padding-top:6px" id="fabQty">Qty: 3 trusses</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SECTION 3: FULL ASSEMBLY -->
        <div class="section">
            <div class="section-header">
                <div><div class="section-title">Full Patio Assembly</div><div class="section-subtitle">Hover for dimensions • Toggle layers</div></div>
            </div>
            <div class="section-body" style="padding:0">
                <div class="asm-viewport" id="asmViewport">
                    <canvas id="asmCanvas"></canvas>
                    <button class="fullscreen-btn" onclick="toggleFullscreen()">⛶ Fullscreen</button>
                    <div class="layer-panel">
                        <div class="layer-title">Layers</div>
                        <div class="layer-item active" data-layer="steel" onclick="toggleLayer('steel',this)"><span class="layer-check"></span>Steel</div>
                        <div class="layer-item active" data-layer="roof" onclick="toggleLayer('roof',this)"><span class="layer-check"></span>Roofing</div>
                        <div class="layer-item active" data-layer="acc" onclick="toggleLayer('acc',this)"><span class="layer-check"></span>Gutters/DP</div>
                        <div class="layer-item active" data-layer="house" onclick="toggleLayer('house',this)"><span class="layer-check"></span>House</div>
                    </div>
                    <div class="mat-panel">
                        <div class="mat-title">Materials</div>
                        <div id="matList"></div>
                    </div>
                    <div class="tooltip" id="tooltip"><div class="tooltip-title" id="ttTitle"></div><div id="ttContent"></div></div>
                    <div class="view-panel">
                        <button class="view-btn active" onclick="setAsmView('3d',this)">3D</button>
                        <button class="view-btn" onclick="setAsmView('front',this)">Front</button>
                        <button class="view-btn" onclick="setAsmView('side',this)">Side</button>
                        <button class="view-btn" onclick="setAsmView('top',this)">Top</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- PRICING & OUTPUTS SECTION -->
        <div class="section" id="pricingSection">
            <div class="section-header">
                <div><div class="section-title">Pricing &amp; Outputs</div><div class="section-subtitle">Three outputs: Quote (client) • Materials Order (supplier) • Work Order (crew)</div></div>
                <div style="display:flex;gap:8px">
                    <button class="btn btn-primary" onclick="generateQuotePDF()">Generate Quote PDF</button>
                    <button class="btn btn-secondary" onclick="generateMaterialsOrderPDF()">Materials Order PDF</button>
                    <button class="btn btn-secondary" onclick="generateWorkOrderPDF()">Work Order PDF</button>
                </div>
            </div>
            <div class="section-body">
                <!-- Client / Job Info -->
                <div class="pricing-card client-info-card">
                    <h4 onclick="toggleClientInfo(this)">Client &amp; Job Details</h4>
                    <div id="clientInfoPanel">
                        <div class="client-fields">
                            <div class="client-field">
                                <label>Client Name</label>
                                <input type="text" class="field-input" id="clientName" placeholder="e.g. Stefan Botha">
                            </div>
                            <div class="client-field">
                                <label>Site Address</label>
                                <input type="text" class="field-input" id="siteAddress" placeholder="e.g. 14 Smith St, Rockingham WA 6168">
                            </div>
                            <div class="client-field">
                                <label>Contact Phone</label>
                                <input type="text" class="field-input" id="clientPhone" placeholder="e.g. 0412 345 678">
                            </div>
                            <div class="client-field">
                                <label>Job Reference</label>
                                <input type="text" class="field-input" id="jobRef" placeholder="Auto: SW1772" style="font-family:'SF Mono',monospace">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Stored Rates (collapsible) -->
                <div class="pricing-card" id="ratesCard">
                    <h4 onclick="toggleRatesPanel(this)" class="collapsed">Stored Rates ($/LM)</h4>
                    <div id="ratesPanel" style="display:none">
                        <table class="pricing-table">
                            <thead><tr><th>Material</th><th class="r">Rate $/LM</th></tr></thead>
                            <tbody id="ratesBody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Job Pricing Table -->
                <div class="pricing-card">
                    <h4 style="cursor:default">Job Pricing</h4>
                    <table class="pricing-table" id="jobTable">
                        <thead>
                            <tr>
                                <th style="width:30%">Item</th>
                                <th class="r" style="width:50px">Qty</th>
                                <th class="r" style="width:70px">Length</th>
                                <th class="r" style="width:80px">Unit Cost</th>
                                <th class="r" style="width:80px">Unit Sell</th>
                                <th class="r" style="width:90px">Line Cost</th>
                                <th class="r" style="width:90px">Line Sell</th>
                                <th class="r" style="width:65px">Margin</th>
                                <th style="width:24px"></th>
                            </tr>
                        </thead>
                        <tbody id="jobBody"></tbody>
                    </table>

                    <!-- Add-on buttons -->
                    <div class="addon-bar">
                        <button class="addon-btn" onclick="addAddon('Concrete Footings')">+ Concrete Footings</button>
                        <button class="addon-btn" onclick="addAddon('Electrical')">+ Electrical</button>
                        <button class="addon-btn" onclick="addAddon('Demo / Removal')">+ Demo / Removal</button>
                        <button class="addon-btn" onclick="addAddon('Fan Install')">+ Fan Install</button>
                        <button class="addon-btn" onclick="addAddon('Downlights')">+ Downlights</button>
                        <button class="addon-btn" onclick="addAddon('')">+ Custom Item</button>
                    </div>
                </div>

                <!-- Labour Calculator -->
                <div class="pricing-card" id="labourCard">
                    <h4 onclick="toggleLabourPanel(this)">Labour Calculator</h4>
                    <div id="labourPanel">
                    <table class="pricing-table" id="labourTable">
                        <thead>
                            <tr>
                                <th style="width:25%">Role</th>
                                <th class="r" style="width:55px">Trades</th>
                                <th class="r" style="width:55px">Days</th>
                                <th class="r" style="width:80px">Day Rate</th>
                                <th class="r" style="width:90px">Cost</th>
                                <th class="r" style="width:90px">Sell</th>
                                <th class="r" style="width:65px">Margin</th>
                                <th style="width:24px"></th>
                            </tr>
                        </thead>
                        <tbody id="labourBody"></tbody>
                    </table>
                    <div class="labour-roles">
                        <button class="role-btn" onclick="addLabourRole('Skilled (Patio Install)')">+ Skilled Trade</button>
                        <button class="role-btn" onclick="addLabourRole('Labourer')">+ Labourer</button>
                        <button class="role-btn" onclick="addLabourRole('Electrician')">+ Electrician</button>
                        <button class="role-btn" onclick="addLabourRole('')">+ Custom Role</button>
                    </div>
                    <div class="labour-totals">
                        <span>Total Labour Cost: <strong id="labourTotalCost">$0.00</strong></span>
                        <span>Total Labour Sell: <strong id="labourTotalSell">$0.00</strong></span>
                    </div>
                    </div>
                </div>

                <!-- Job Complexity Guide -->
                <div class="pricing-card complexity-card">
                    <h4 onclick="toggleComplexity(this)" class="collapsed">Job Complexity Guide</h4>
                    <div id="complexityPanel" style="display:none">
                        <table class="complexity-table">
                            <thead>
                                <tr>
                                    <th style="width:25%">Factor</th>
                                    <th class="hint">Easy (1-3)</th>
                                    <th class="hint">Medium (4-6)</th>
                                    <th class="hint">Hard (7-10)</th>
                                    <th class="r" style="width:50px">Score</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Build Difficulty</td>
                                    <td class="hint">Simple skillion</td>
                                    <td class="hint">Standard gable</td>
                                    <td class="hint">Complex hip/multi</td>
                                    <td class="r"><input type="number" class="complexity-input" id="cxBuild" value="3" min="1" max="10" oninput="updateComplexity()"></td>
                                </tr>
                                <tr>
                                    <td>Site Access</td>
                                    <td class="hint">Easy drive-in</td>
                                    <td class="hint">Side access</td>
                                    <td class="hint">Rear / crane needed</td>
                                    <td class="r"><input type="number" class="complexity-input" id="cxAccess" value="3" min="1" max="10" oninput="updateComplexity()"></td>
                                </tr>
                                <tr>
                                    <td>Distance from Base</td>
                                    <td class="hint">&lt;20km</td>
                                    <td class="hint">20-50km</td>
                                    <td class="hint">&gt;50km</td>
                                    <td class="r"><input type="number" class="complexity-input" id="cxDistance" value="2" min="1" max="10" oninput="updateComplexity()"></td>
                                </tr>
                                <tr>
                                    <td>Footing Type</td>
                                    <td class="hint">Surface mount</td>
                                    <td class="hint">Concrete 600mm</td>
                                    <td class="hint">Deep / rock / pier</td>
                                    <td class="r"><input type="number" class="complexity-input" id="cxFooting" value="3" min="1" max="10" oninput="updateComplexity()"></td>
                                </tr>
                                <tr>
                                    <td>Height / Safety</td>
                                    <td class="hint">Standard 2.4m</td>
                                    <td class="hint">High 3m+</td>
                                    <td class="hint">Multi-storey</td>
                                    <td class="r"><input type="number" class="complexity-input" id="cxHeight" value="2" min="1" max="10" oninput="updateComplexity()"></td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="complexity-result">
                            <div class="complexity-display" id="cxDisplay">Complexity Score: <span class="complexity-score" id="cxScore">2.6</span>/10 &rarr; Suggested Margin: <span class="complexity-suggestion" id="cxSuggestion">25-30%</span> <span class="complexity-band easy" id="cxBand">Standard</span></div>
                            <div class="complexity-note">GUIDE only &mdash; does not auto-fill pricing. Use to help decide margin.</div>
                        </div>
                    </div>
                </div>

                <!-- Delivery -->
                <div class="pricing-card">
                    <h4 style="cursor:default">Delivery</h4>
                    <table class="pricing-table">
                        <thead>
                            <tr>
                                <th style="width:30%">Description</th>
                                <th class="r" style="width:90px">Cost</th>
                                <th class="r" style="width:90px">Sell</th>
                                <th class="r" style="width:65px">Margin</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Delivery</td>
                                <td class="r"><input type="number" class="cell-input" id="deliveryCost" value="0" min="0" step="10" oninput="updatePricing()"></td>
                                <td class="r"><input type="number" class="cell-input" id="deliverySell" value="0" min="0" step="10" oninput="updatePricing()"></td>
                                <td class="r mono" id="deliveryMargin">—</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Totals -->
                <div class="totals-grid">
                    <div class="pricing-summary">
                        <h4>Cost Breakdown</h4>
                        <div class="summary-row"><span>Materials</span><span class="summary-value" id="sumMatCost">$0.00</span></div>
                        <div class="summary-row"><span>Add-ons</span><span class="summary-value" id="sumAddonCost">$0.00</span></div>
                        <div class="summary-row"><span>Labour</span><span class="summary-value" id="sumLabourCost">$0.00</span></div>
                        <div class="summary-row"><span>Delivery</span><span class="summary-value" id="sumDeliveryCost">$0.00</span></div>
                        <div class="summary-row total"><span>TOTAL COST</span><span class="summary-value" id="sumTotalCost">$0.00</span></div>
                    </div>
                    <div class="pricing-summary">
                        <h4>Quote Breakdown</h4>
                        <div class="summary-row"><span>Materials</span><span class="summary-value" id="sumMatSell">$0.00</span></div>
                        <div class="summary-row"><span>Installation</span><span class="summary-value" id="sumLabourSell">$0.00</span></div>
                        <div class="summary-row"><span>Delivery</span><span class="summary-value" id="sumDeliverySell">$0.00</span></div>
                        <div class="summary-row"><span>Extras</span><span class="summary-value" id="sumExtrasSell">$0.00</span></div>
                        <div class="summary-row total"><span>Subtotal (ex GST)</span><span class="summary-value" id="sumSubtotal">$0.00</span></div>
                        <div class="summary-row total"><span>GST (10%)</span><span class="summary-value" id="sumGST">$0.00</span></div>
                        <div class="summary-row total" style="font-size:18px"><span>TOTAL (inc GST)</span><span class="summary-value" id="sumTotalIncGST">$0.00</span></div>
                    </div>
                    <div class="pricing-summary">
                        <h4>Margin</h4>
                        <div class="summary-row"><span>Total Cost</span><span class="summary-value" id="sumTotalCostM">$0.00</span></div>
                        <div class="summary-row"><span>Total Sell (ex GST)</span><span class="summary-value" id="sumTotalSellM">$0.00</span></div>
                        <div class="summary-row total"><span>Margin</span><span class="summary-value green" id="sumMargin">$0.00 (0%)</span></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        /*
         * V18 FIXES:
         * 1. Downpipes - now extend from ground to actual gutter height (not postH)
         * 2. Gable sheets perpendicular - complete rotation rewrite for proper roof alignment
         * 3. Carry beam condition - removed for gable+fascia (trusses sit on fascia beam directly)
         * 4. Gable+riser beam stacking - riser beam now sits ON TOP of risers correctly
         */

        // ==================== CONFIG ====================
        const COLORS = [
            {name:'Monument',hex:'#2D3436'},{name:'Woodland Grey',hex:'#4B5D52'},{name:'Paperbark',hex:'#C4BAA2'},
            {name:'Surfmist',hex:'#E8E6E0'},{name:'Basalt',hex:'#5C5C5C'},{name:'Manor Red',hex:'#6B2D2D'},
            {name:'Deep Ocean',hex:'#1E3A4C'},{name:'Windspray',hex:'#7D8B8A'}
        ];
        const STEEL = {'76x38':{w:0.076,h:0.038,name:'76×38×1.6'},'100x50':{w:0.1,h:0.05,name:'100×50×2'}};

        const SHEET_COVERAGE = {
            corrugated: 762,
            trimdek: 762,
            spandek: 762,
            insulated: 1000
        };

        const SPAN_TABLES = {
            corrugated: { maxSpan: 1100, endSpan: 900, needsPurlins: true },
            trimdek: { maxSpan: 2100, endSpan: 1500, needsPurlins: true },
            spandek: { maxSpan: 2400, endSpan: 1800, needsPurlins: true },
            insulated: { maxSpan: 6000, endSpan: 6000, needsPurlins: false }
        };

        let sheetColor = COLORS[0];
        let steelColor = COLORS[0];
        let calc = {};

        // ==================== COLOR CHIPS ====================
        function initColorChips(containerId, labelId, setFn) {
            const container = document.getElementById(containerId);
            COLORS.forEach((c,i) => {
                const el = document.createElement('div');
                el.className = 'color-chip' + (i===0?' active':'');
                el.style.background = c.hex;
                el.title = c.name;
                el.onclick = () => {
                    setFn(c);
                    container.querySelectorAll('.color-chip').forEach(x=>x.classList.remove('active'));
                    el.classList.add('active');
                    document.getElementById(labelId).textContent = c.name;
                    rebuildAll();
                };
                container.appendChild(el);
            });
        }
        initColorChips('sheetChips', 'sheetLabel', c => sheetColor = c);
        initColorChips('steelChips', 'steelLabel', c => steelColor = c);

        // ==================== UI UPDATES ====================
        function updateUI() {
            const roofSelect = document.getElementById('inRoofStyle');
            const connSelect = document.getElementById('inConnection');
            const roofingSelect = document.getElementById('inRoofing');
            let conn = connSelect.value;
            const roofing = roofingSelect.value;
            // === RESTRICTION: Receiving channel (wall) only works with skillion ===
            // Gable + fascia is allowed (truss attaches to side of fascia beam)
            const gableOption = roofSelect.querySelector('option[value="gable"]');
            if (conn === 'wall') {
                if (roofSelect.value === 'gable') roofSelect.value = 'skillion';
                gableOption.disabled = true;
            } else {
                gableOption.disabled = false;
            }

            // === RESTRICTION: Gable doesn't work with receiving channels ===
            const fasciaOption = connSelect.querySelector('option[value="fascia"]');
            const wallOption = connSelect.querySelector('option[value="wall"]');
            const fasciaBeamOption = connSelect.querySelector('option[value="fasciabeam"]');
            const style = roofSelect.value;
            const isGable = style === 'gable';
            if (isGable) {
                // Gable can ONLY use: Freestanding, Fascia Beam, or Riser
                if (conn === 'fascia' || conn === 'wall') { connSelect.value = 'fasciabeam'; conn = 'fasciabeam'; }
                fasciaOption.disabled = true;
                wallOption.disabled = true;
                fasciaBeamOption.disabled = false;
            } else {
                // Skillion: no fascia beam option
                if (conn === 'fasciabeam') { connSelect.value = 'fascia'; conn = 'fascia'; }
                fasciaOption.disabled = false;
                wallOption.disabled = false;
                fasciaBeamOption.disabled = true;
            }

            // === RESTRICTION: Flyover only works with insulated panels + skillion ===
            const flyoverOption = connSelect.querySelector('option[value="flyover"]');
            if (roofing !== 'insulated' || isGable) {
                if (conn === 'flyover') {
                    connSelect.value = isGable ? 'riser' : 'riser';
                    conn = 'riser';
                }
                flyoverOption.disabled = true;
            } else {
                flyoverOption.disabled = false;
            }

            const isAttached = conn !== 'freestanding';

            document.getElementById('section2').style.display = isGable ? 'block' : 'none';
            document.getElementById('orientationField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussField').style.display = isGable ? 'block' : 'none';
            document.getElementById('rafterField').style.display = isGable ? 'none' : 'block';
            document.getElementById('gableInfillField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussStyleField').style.display = isGable ? 'block' : 'none';

            const showPitchInput = isGable || !isAttached;
            document.getElementById('pitchField').style.display = showPitchInput ? 'block' : 'none';
            document.getElementById('calcPitchRow').style.display = (!isGable && isAttached) ? 'flex' : 'none';

            // Fascia height needed for all attached types (sets connection height)
            document.getElementById('fasciaHeightField').style.display = isAttached ? 'block' : 'none';
            const showRiserOptions = conn === 'riser';
            document.getElementById('riserHeightField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserOffsetField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserQtyField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('houseGutterField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserGutterField').style.display = (showRiserOptions && isGable) ? 'block' : 'none';
        }

        // ==================== GET INPUTS & CALCULATE ====================
        function getInputs() {
            const roofStyle = document.getElementById('inRoofStyle').value;
            const orientation = document.getElementById('inOrientation').value;
            const projInput = parseFloat(document.getElementById('inWidth').value) || 3000;
            const lenInput = parseFloat(document.getElementById('inLength').value) || 6000;
            const userPitch = parseFloat(document.getElementById('inPitch').value) || 10;
            const postH = parseFloat(document.getElementById('inPostHeight').value) || 2400;
            const nPosts = parseInt(document.getElementById('inPosts').value) || 3;
            const nTruss = parseInt(document.getElementById('inTrusses').value) || 3;
            const nRafters = parseInt(document.getElementById('inRafters').value) || 5;
            const trussStyle = document.getElementById('inTrussStyle').value;
            const trussSteel = document.getElementById('inTrussSteel').value;
            const roofing = document.getElementById('inRoofing').value;
            const infill = document.getElementById('inInfill').value;
            const connection = document.getElementById('inConnection').value;
            const fasciaH = parseFloat(document.getElementById('inFasciaHeight').value) || 2700;
            const riserH = parseFloat(document.getElementById('inRiserHeight').value) || 400;
            const riserOffset = parseFloat(document.getElementById('inRiserOffset').value) || 150;
            const riserQtyInput = parseInt(document.getElementById('inRiserQty').value);
            const houseGutter = document.getElementById('inHouseGutter').value;
            const riserGutter = document.getElementById('inRiserGutter').value;

            const isGable = roofStyle === 'gable';
            const isAttached = connection !== 'freestanding';
            const hasFascia = (connection === 'fascia' || connection === 'fasciabeam' || connection === 'riser' || connection === 'flyover');
            const isRecvChan = (connection === 'fascia' || connection === 'wall');

            let W, L;
            if (isGable && orientation === 'perpendicular') {
                W = lenInput;
                L = projInput;
            } else {
                W = projInput;
                L = lenInput;
            }

            // ========== V18 FIX: BEAM HEIGHTS - Proper stacking for gable+riser ==========
            let frontBeamY = postH;
            const beamH = 50;  // 50mm beam height
            const riserMemberSize = 75;  // 75mm SHS riser members
            // Patio attaches at rafter level (fasciaH = wall top / rafter base)
            // This is ABOVE the fascia board and gutter which hang below

            let backBeamY, fasciaBeamY;
            if (isGable) {
                if (connection === 'riser') {
                    // Gable + Riser: fascia beam sits below house gutter, against lower house fascia
                    // Gutter front face 76mm + 5mm gap ≈ beam top 50mm below fascia top
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    const elevatedBeamY = fasciaH + beamH + riserMemberSize + riserH;
                    frontBeamY = elevatedBeamY;
                    backBeamY = elevatedBeamY;
                } else if (connection === 'fascia' || connection === 'fasciabeam' || connection === 'wall') {
                    // Gable + Fascia/Wall/FasciaBeam: both beams lowered for sheet clearance
                    fasciaBeamY = (connection === 'fascia' || connection === 'fasciabeam') ? (fasciaH) : null;
                    frontBeamY = fasciaH;
                    backBeamY = fasciaH;
                } else if (connection === 'flyover') {
                    // Gable + Flyover: beams above existing house roof
                    fasciaBeamY = fasciaH;
                    // Calculate actual house roof rise: 1.5m depth at 15° pitch
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150; // 150mm clearance above roof ridge
                    const flyoverBeamY = fasciaH + houseRoofRise + flyoverClearance;
                    frontBeamY = flyoverBeamY;
                    backBeamY = flyoverBeamY;
                } else {
                    // Freestanding - back beam at post height
                    backBeamY = postH;
                    fasciaBeamY = null;
                }
            } else {
                // SKILLION
                if (connection === 'freestanding') {
                    const rise = W * Math.tan(userPitch * Math.PI / 180);
                    backBeamY = postH + rise;
                    fasciaBeamY = null;
                } else if (connection === 'riser') {
                    // Fascia beam sits below house gutter, against lower house fascia
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    backBeamY = fasciaH + beamH + riserMemberSize + riserH;
                } else if (connection === 'flyover') {
                    fasciaBeamY = fasciaH;
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150;
                    backBeamY = fasciaH + houseRoofRise + flyoverClearance;
                } else {
                    // fascia or wall
                    fasciaBeamY = (connection === 'fascia' || connection === 'fasciabeam') ? (fasciaH) : null;
                    backBeamY = fasciaH;
                }
            }

            // ========== PITCH & RISE CALCULATION ==========
            let pitch, pitchRad, rise, rafter, trussSpan;

            if (isGable) {
                pitch = userPitch;
                pitchRad = pitch * Math.PI / 180;
                trussSpan = W;
                rise = (W / 2) * Math.tan(pitchRad);
                rafter = Math.sqrt((W / 2) ** 2 + rise ** 2);
            } else {
                rise = backBeamY - frontBeamY;
                pitch = Math.atan(rise / W) * 180 / Math.PI;
                pitchRad = pitch * Math.PI / 180;
                rafter = Math.sqrt(W ** 2 + rise ** 2);
                trussSpan = W;
            }

            calc = {
                roofStyle, orientation, W, L, projInput, lenInput, userPitch, pitch, pitchRad,
                postH, nPosts, nTruss, nRafters, trussStyle, trussSteel, trussSpan,
                roofing, infill, connection, fasciaH, riserH, riserOffset, houseGutter, riserGutter,
                riserQty: riserQtyInput || Math.max(2, Math.ceil(L / 1200)),
                rise, rafter, isGable, isAttached, hasFascia, isRecvChan,
                frontBeamY, backBeamY, fasciaBeamY,
                steel: STEEL[trussSteel],
                sheetCoverage: SHEET_COVERAGE[roofing]
            };

            document.getElementById('calcRise').textContent = Math.round(rise) + 'mm';
            document.getElementById('calcRafter').textContent = Math.round(rafter) + 'mm';
            document.getElementById('calcPitch').textContent = pitch.toFixed(1) + '°';
            // Set riser qty placeholder to show calculated default
            document.getElementById('inRiserQty').placeholder = Math.max(2, Math.ceil(L / 1200));

            if (isGable) {
                const steelW = STEEL[trussSteel].w * 1000;
                const steelH = STEEL[trussSteel].h * 1000;
                const rafterInside = rafter - steelH;
                const apexAngle = 90 - pitch;
                const heelAngle = pitch;
                const kingPostH = rise - steelH;
                const queenPostH = rise * 0.6;
                const queenSpacing = trussSpan * 0.2;

                document.getElementById('specA').textContent = Math.round(trussSpan);
                document.getElementById('specB').textContent = Math.round(rise);
                document.getElementById('specC').textContent = Math.round(rafter);
                document.getElementById('specD').textContent = pitch + '°';

                document.getElementById('angleApex').textContent = apexAngle.toFixed(1) + '°';
                document.getElementById('angleBase').textContent = heelAngle.toFixed(1) + '°';
                document.getElementById('anglePlumb').textContent = (90 - pitch).toFixed(1) + '°';
                document.getElementById('angleLevel').textContent = pitch.toFixed(1) + '°';

                const showWeb = trussStyle === 'king' || trussStyle === 'queen';
                document.getElementById('webCard').style.display = showWeb ? 'block' : 'none';
                document.getElementById('fabWeb').style.display = showWeb ? 'block' : 'none';

                if (trussStyle === 'king') {
                    document.getElementById('webKing').textContent = Math.round(kingPostH) + 'mm';
                    document.getElementById('webQueen').textContent = '--';
                    document.getElementById('fabWeb').textContent = 'King Post: ' + Math.round(kingPostH) + 'mm';
                } else if (trussStyle === 'queen') {
                    document.getElementById('webKing').textContent = '--';
                    document.getElementById('webQueen').textContent = Math.round(queenPostH) + 'mm × 2';
                    document.getElementById('fabWeb').textContent = 'Queen Posts: ' + Math.round(queenPostH) + 'mm × 2 @ ±' + Math.round(queenSpacing) + 'mm';
                }

                document.getElementById('fabSteel').textContent = 'Steel: ' + STEEL[trussSteel].name + ' RHS';
                document.getElementById('fabThick').textContent = 'Wall: ' + (trussSteel === '76x38' ? '1.6' : '2.0') + 'mm BMT';
                document.getElementById('fabChord').textContent = 'Bottom Chord: ' + Math.round(trussSpan) + 'mm (out-out)';
                document.getElementById('fabRafterOut').textContent = 'Rafter (out): ' + Math.round(rafter) + 'mm TRUE';
                document.getElementById('fabRafterIn').textContent = 'Rafter (in): ' + Math.round(rafterInside) + 'mm';
                document.getElementById('fabApexCut').textContent = 'Apex Mitre: ' + apexAngle.toFixed(1) + '°';
                document.getElementById('fabHeelCut').textContent = 'Heel Mitre: ' + heelAngle.toFixed(1) + '°';
                document.getElementById('fabQty').textContent = 'Qty: ' + nTruss + ' trusses';
            }

            return calc;
        }

        // ==================== 2D PLAN ====================
        function draw2DPlan() {
            const canvas = document.getElementById('plan2d');
            const p = canvas.parentElement;
            canvas.width = p.clientWidth; canvas.height = p.clientHeight;
            const ctx = canvas.getContext('2d');
            const c = calc;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            const planL = c.lenInput;
            const planW = c.projInput;

            const scale = Math.min((canvas.width-60)/planL, (canvas.height-60)/planW) * 0.85;
            const ox = (canvas.width - planL*scale)/2;
            const oy = (canvas.height - planW*scale)/2 + 10;

            if (c.connection !== 'freestanding') {
                ctx.fillStyle = '#D4C4B0';
                ctx.fillRect(ox-5, oy-20, planL*scale+10, 18);
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('HOUSE', ox+planL*scale/2, oy-6);
            }

            ctx.strokeStyle = steelColor.hex;
            ctx.lineWidth = 2;
            ctx.strokeRect(ox, oy, planL*scale, planW*scale);

            ctx.strokeStyle = '#F15A29';
            ctx.lineWidth = 2;
            if (c.isGable) {
                if (c.orientation === 'lengthways') {
                    ctx.beginPath();
                    ctx.moveTo(ox, oy + planW*scale/2);
                    ctx.lineTo(ox + planL*scale, oy + planW*scale/2);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.fillText('RIDGE', ox + planL*scale/2, oy + planW*scale/2 - 5);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(ox + planL*scale/2, oy);
                    ctx.lineTo(ox + planL*scale/2, oy + planW*scale);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.save();
                    ctx.translate(ox + planL*scale/2 + 12, oy + planW*scale/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.fillText('RIDGE', 0, 0);
                    ctx.restore();
                }
            } else {
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2, oy + 15);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2 - 6, oy + planW*scale - 25);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.lineTo(ox + planL*scale/2 + 6, oy + planW*scale - 25);
                ctx.stroke();
                ctx.fillStyle = '#F15A29';
                ctx.font = '9px sans-serif';
                ctx.fillText('FALL ' + calc.pitch.toFixed(1) + '°', ox + planL*scale/2 + 30, oy + planW*scale/2);
            }

            ctx.fillStyle = steelColor.hex;
            for (let i = 0; i < c.nPosts; i++) {
                const x = ox + (planL*scale/(c.nPosts-1)) * i;
                ctx.fillRect(x-4, oy + planW*scale - 4, 8, 8);
            }

            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = ox + (planL*scale/(c.nPosts-1)) * i;
                    ctx.fillRect(x-4, oy - 4, 8, 8);
                }
            }

            if (c.isAttached) {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.lineTo(ox + planL*scale, oy);
                ctx.stroke();
                ctx.fillStyle = '#666';
                ctx.font = '8px sans-serif';
                ctx.fillText('FASCIA', ox + planL*scale/2, oy + 10);
            }

            ctx.fillStyle = '#333';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(planL + 'mm', ox + planL*scale/2, oy + planW*scale + 20);
            ctx.save();
            ctx.translate(ox - 15, oy + planW*scale/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText(planW + 'mm', 0, 0);
            ctx.restore();
        }

        // ==================== TRUSS 3D (Section 2) ====================
        let trussScene, trussCam, trussRend, trussGroup;
        let tCamT = 0.4, tCamP = 0.3, tCamD = 3;
        let tDrag = false, tLast = {x:0,y:0};

        function initTruss3D() {
            const container = document.getElementById('trussViewport');
            const canvas = document.getElementById('trussCanvas');
            trussScene = new THREE.Scene();
            trussScene.background = new THREE.Color(0xD8DCE0);
            trussCam = new THREE.PerspectiveCamera(40, container.clientWidth/container.clientHeight, 0.01, 50);
            updateTrussCam();
            trussRend = new THREE.WebGLRenderer({canvas, antialias: true});
            trussRend.setSize(container.clientWidth, container.clientHeight);
            trussRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            trussScene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(2, 4, 3);
            trussScene.add(light);

            trussGroup = new THREE.Group();
            trussScene.add(trussGroup);

            canvas.addEventListener('mousedown', e => { tDrag = true; tLast = {x:e.clientX,y:e.clientY}; });
            canvas.addEventListener('mousemove', e => {
                if (!tDrag) return;
                tCamT -= (e.clientX - tLast.x) * 0.01;
                tCamP = Math.max(0.1, Math.min(1.4, tCamP - (e.clientY - tLast.y) * 0.008));
                updateTrussCam();
                tLast = {x:e.clientX, y:e.clientY};
            });
            canvas.addEventListener('mouseup', () => tDrag = false);
            canvas.addEventListener('mouseleave', () => tDrag = false);
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                tCamD = Math.max(1, Math.min(8, tCamD + e.deltaY * 0.003));
                updateTrussCam();
            }, {passive: false});

            buildTruss3D();
            animateTruss();
        }

        function updateTrussCam() {
            trussCam.position.set(
                tCamD * Math.sin(tCamT) * Math.cos(tCamP),
                tCamD * Math.sin(tCamP),
                tCamD * Math.cos(tCamT) * Math.cos(tCamP)
            );
            trussCam.lookAt(0, 0.2, 0);
        }

        function buildTruss3D() {
            while (trussGroup.children.length) trussGroup.remove(trussGroup.children[0]);
            if (!calc.isGable) return;

            const c = calc;
            const span = c.trussSpan / 1000;
            tCamD = Math.max(3, span * 0.7);
            updateTrussCam();
            const rise = c.rise / 1000;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;
            const th = c.steel.h;
            const mat = new THREE.MeshStandardMaterial({color: new THREE.Color(steelColor.hex), metalness: 0.8, roughness: 0.3});

            const chord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, span), mat.clone());
            chord.position.set(0, th/2, 0);
            trussGroup.add(chord);

            const leftGeo = new THREE.BoxGeometry(tw, th, rafter);
            leftGeo.translate(0, 0, rafter/2);
            const leftRafter = new THREE.Mesh(leftGeo, mat.clone());
            leftRafter.position.set(0, th, -span/2);
            leftRafter.rotation.x = -c.pitchRad;
            trussGroup.add(leftRafter);

            const rightGeo = new THREE.BoxGeometry(tw, th, rafter);
            rightGeo.translate(0, 0, -rafter/2);
            const rightRafter = new THREE.Mesh(rightGeo, mat.clone());
            rightRafter.position.set(0, th, span/2);
            rightRafter.rotation.x = c.pitchRad;
            trussGroup.add(rightRafter);

            if (c.trussStyle === 'king') {
                const kingH = rise - th;
                if (kingH > 0) {
                    const king = new THREE.Mesh(new THREE.BoxGeometry(tw, kingH, th), mat.clone());
                    king.position.set(0, th + kingH/2, 0);
                    trussGroup.add(king);
                }
            } else if (c.trussStyle === 'queen') {
                const qH = rise * 0.6;
                const qZ = span * 0.2;
                [-1, 1].forEach(s => {
                    const q = new THREE.Mesh(new THREE.BoxGeometry(tw, qH, th), mat.clone());
                    q.position.set(0, th + qH/2, s * qZ);
                    trussGroup.add(q);
                });
                const topChord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, span * 0.4), mat.clone());
                topChord.position.set(0, th + qH, 0);
                trussGroup.add(topChord);
            }

            const dimMat = new THREE.LineBasicMaterial({color: 0xF15A29, linewidth: 2});
            const spanLineY = -0.08;
            addDimensionLine(-span/2, spanLineY, 0, span/2, spanLineY, 0, dimMat);
            addTrussLabel('A: ' + Math.round(c.trussSpan) + 'mm', 0, spanLineY - 0.06, 0);

            const riseX = span/2 + 0.12;
            addDimensionLine(riseX, th, 0, riseX, th + rise, 0, dimMat);
            addTrussLabel('B: ' + Math.round(c.rise) + 'mm', riseX + 0.1, th + rise/2, 0);

            addTrussLabel('C: ' + Math.round(c.rafter) + 'mm TRUE', -0.08, th + rise*0.5, -span*0.25);

            addAngleArc(span/2, th, 0, 0.15, c.pitchRad, dimMat);
            addTrussLabel('D: ' + c.pitch.toFixed(1) + '°', span/2 + 0.05, th + 0.06, 0);

            addCutMarker(0, th + rise, 0, (90 - c.pitch), 'APEX');
            addCutMarker(-span/2, th, 0, c.pitch, 'HEEL');
            addCutMarker(span/2, th, 0, c.pitch, 'HEEL');

            const rafterIn = c.rafter - (c.steel.h / Math.cos(c.pitchRad) * 1000);
            addSmallLabel('In: ' + Math.round(rafterIn) + 'mm', 0.08, th + rise*0.35, -span*0.15);
        }

        function addDimensionLine(x1, y1, z1, x2, y2, z2, mat) {
            const points = [new THREE.Vector3(x1, y1, z1), new THREE.Vector3(x2, y2, z2)];
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeo, mat);
            trussGroup.add(line);

            const tickSize = 0.03;
            const isVertical = Math.abs(y2 - y1) > Math.abs(x2 - x1);
            if (isVertical) {
                addTick(x1, y1, z1, tickSize, 0, mat);
                addTick(x2, y2, z2, tickSize, 0, mat);
            } else {
                addTick(x1, y1, z1, 0, tickSize, mat);
                addTick(x2, y2, z2, 0, tickSize, mat);
            }
        }

        function addTick(x, y, z, dx, dy, mat) {
            const pts = [new THREE.Vector3(x-dx, y-dy, z), new THREE.Vector3(x+dx, y+dy, z)];
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            trussGroup.add(new THREE.Line(geo, mat));
        }

        function addAngleArc(x, y, z, radius, angle, mat) {
            const segments = 16;
            const pts = [];
            for (let i = 0; i <= segments; i++) {
                const a = (i / segments) * angle;
                pts.push(new THREE.Vector3(x - radius * Math.cos(a), y + radius * Math.sin(a), z));
            }
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            trussGroup.add(new THREE.Line(geo, mat));
        }

        function addCutMarker(x, y, z, angle, label) {
            const markerMat = new THREE.MeshBasicMaterial({color: 0xFF6B35, transparent: true, opacity: 0.7});
            const markerGeo = new THREE.CircleGeometry(0.025, 8);
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.set(x, y, z + 0.01);
            trussGroup.add(marker);
        }

        function addSmallLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            canvas.width = 120; canvas.height = 24;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(102, 102, 102, 0.9)';
            ctx.beginPath();
            ctx.roundRect(0, 2, 120, 20, 3);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(text, 60, 16);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
            sprite.scale.set(0.18, 0.04, 1);
            sprite.position.set(x, y, z);
            trussGroup.add(sprite);
        }

        function addTrussLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            canvas.width = 200; canvas.height = 40;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#F15A29';
            ctx.beginPath();
            ctx.roundRect(0, 5, 200, 30, 4);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 13px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(text, 100, 26);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
            sprite.scale.set(0.32, 0.08, 1);
            sprite.position.set(x, y, z);
            trussGroup.add(sprite);
        }

        function setTrussView(v, btn) {
            document.querySelectorAll('.truss-view-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const span = calc.trussSpan / 1000;
            const baseDist = Math.max(3, span * 0.7);
            if (v === '3d') { tCamT = 0.4; tCamP = 0.3; tCamD = baseDist; }
            else if (v === 'front') { tCamT = 0; tCamP = 0.05; tCamD = baseDist * 0.9; }
            else if (v === 'side') { tCamT = Math.PI/2; tCamP = 0.1; tCamD = baseDist * 0.8; }
            updateTrussCam();
        }

        function animateTruss() {
            requestAnimationFrame(animateTruss);
            if (trussRend && trussScene && trussCam) {
                trussRend.render(trussScene, trussCam);
            }
        }

        // ==================== ASSEMBLY 3D (Section 3) ====================
        let asmScene, asmCam, asmRend, asmRay, asmMouse;
        let steelGrp, roofGrp, accGrp, houseGrp;
        let compData = new Map();
        let hovered = null;
        let aCamT = 0.5, aCamP = 0.4, aCamD = 12;
        let aCamTarget = new THREE.Vector3(0, 1.5, 0); // updated dynamically after build
        let aDrag = false, aLast = {x:0,y:0};

        function initAsm3D() {
            const container = document.getElementById('asmViewport');
            const canvas = document.getElementById('asmCanvas');
            asmScene = new THREE.Scene();
            asmScene.background = new THREE.Color(0xC4CCD4);
            asmCam = new THREE.PerspectiveCamera(35, container.clientWidth/container.clientHeight, 0.1, 100);
            updateAsmCam();
            asmRend = new THREE.WebGLRenderer({canvas, antialias: true});
            asmRend.setSize(container.clientWidth, container.clientHeight);
            asmRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            asmRend.shadowMap.enabled = true;

            asmRay = new THREE.Raycaster();
            asmMouse = new THREE.Vector2();

            asmScene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(5, 10, 7);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            asmScene.add(sun);

            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshStandardMaterial({color: 0xA8A090, roughness: 0.9})
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            asmScene.add(ground);

            steelGrp = new THREE.Group();
            roofGrp = new THREE.Group();
            accGrp = new THREE.Group();
            houseGrp = new THREE.Group();
            asmScene.add(steelGrp);
            asmScene.add(roofGrp);
            asmScene.add(accGrp);
            asmScene.add(houseGrp);

            canvas.addEventListener('mousedown', e => { aDrag = true; aLast = {x:e.clientX,y:e.clientY}; });
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                asmMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                asmMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                checkHover(e.clientX - rect.left, e.clientY - rect.top);
                if (aDrag) {
                    aCamT -= (e.clientX - aLast.x) * 0.008;
                    aCamP = Math.max(0.1, Math.min(1.4, aCamP - (e.clientY - aLast.y) * 0.006));
                    updateAsmCam();
                    aLast = {x:e.clientX, y:e.clientY};
                }
            });
            canvas.addEventListener('mouseup', () => { aDrag = false; });
            canvas.addEventListener('mouseleave', () => { aDrag = false; clearHover(); });
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                aCamD = Math.max(4, Math.min(30, aCamD + e.deltaY * 0.01));
                updateAsmCam();
            }, {passive: false});

            buildAsm3D();
            animateAsm();
        }

        function updateAsmCam() {
            asmCam.position.set(
                aCamTarget.x + aCamD * Math.sin(aCamT) * Math.cos(aCamP),
                aCamTarget.y + aCamD * Math.sin(aCamP),
                aCamTarget.z + aCamD * Math.cos(aCamT) * Math.cos(aCamP)
            );
            asmCam.lookAt(aCamTarget);
        }

        function createCorrugatedGeometry(width, length, segments = 20) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const waveHeight = 0.012;
            const waveFreq = 15;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                pos.setZ(i, Math.sin(x * waveFreq * Math.PI) * waveHeight);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createTrimdekGeometry(width, length, segments = 30) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const ribHeight = 0.025;
            const ribWidth = 0.04;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const phase = ((x / ribWidth) % 1 + 1) % 1;
                let z = 0;
                if (phase < 0.3) z = ribHeight * (phase / 0.3);
                else if (phase < 0.7) z = ribHeight;
                else z = ribHeight * (1 - (phase - 0.7) / 0.3);
                pos.setZ(i, z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createInsulatedGeometry(width, length) {
            return new THREE.BoxGeometry(width, length, 0.05);
        }

        function buildAsm3D() {
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => { while(g.children.length) g.remove(g.children[0]); });
            compData.clear();

            const c = calc;
            const W = c.W / 1000;
            const L = c.L / 1000;
            const postH = c.postH / 1000;
            const rise = c.rise / 1000;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;
            const th = c.steel.h;
            const frontBeamY = c.frontBeamY / 1000;
            const backBeamY = c.backBeamY / 1000;
            const fasciaBeamY = c.fasciaBeamY ? c.fasciaBeamY / 1000 : null;

            const steelCol = new THREE.Color(steelColor.hex);
            const sheetCol = new THREE.Color(sheetColor.hex);
            const sMat = () => new THREE.MeshStandardMaterial({color: steelCol, metalness: 0.8, roughness: 0.3});
            const rMat = () => new THREE.MeshStandardMaterial({color: sheetCol, metalness: 0.5, roughness: 0.4, side: THREE.DoubleSide});

            const fasciaCol = new THREE.Color(steelColor.hex).offsetHSL(0, -0.1, 0.15);
            const fasciaMat = () => new THREE.MeshStandardMaterial({color: fasciaCol, metalness: 0.7, roughness: 0.4});

            const riserCol = new THREE.Color(0x8B4513);
            const riserMat = () => new THREE.MeshStandardMaterial({color: riserCol, metalness: 0.6, roughness: 0.5});

            const beamW = 0.1, beamH = 0.05, postW = 0.09;

            const isPerpendicular = c.isGable && c.orientation === 'perpendicular';

            // ===== FRONT POSTS (Gutter side) =====
            const fpostH = frontBeamY;  // May be elevated for gable+riser
            for (let i = 0; i < c.nPosts; i++) {
                const x = -L/2 + (L / (c.nPosts - 1)) * i;
                const post = new THREE.Mesh(new THREE.BoxGeometry(postW, fpostH, postW), sMat());
                if (isPerpendicular) {
                    post.position.set(W/2, fpostH/2, x);
                } else {
                    post.position.set(x, fpostH/2, W/2);
                }
                post.castShadow = true;
                steelGrp.add(post);
                regComp(post, 'Front Post ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(fpostH*1000) + 'mm'});
            }

            // ===== BACK POSTS (freestanding only) =====
            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = -L/2 + (L / (c.nPosts - 1)) * i;
                    const bpostH = backBeamY;
                    const post = new THREE.Mesh(new THREE.BoxGeometry(postW, bpostH, postW), sMat());
                    if (isPerpendicular) {
                        post.position.set(-W/2, bpostH/2, x);
                    } else {
                        post.position.set(x, bpostH/2, -W/2);
                    }
                    post.castShadow = true;
                    steelGrp.add(post);
                    regComp(post, 'Back Post ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(bpostH*1000) + 'mm'});
                }
            }

            // ===== GUTTER BEAM (Front beam on posts) =====
            const gutterBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamH, beamW), sMat());
            if (isPerpendicular) {
                gutterBeam.rotation.y = Math.PI / 2;
                gutterBeam.position.set(W/2, frontBeamY + beamH/2, 0);
            } else {
                gutterBeam.position.set(0, frontBeamY + beamH/2, W/2);
            }
            gutterBeam.castShadow = true;
            steelGrp.add(gutterBeam);
            regComp(gutterBeam, 'Gutter Beam', {'Size': '100×50×2 RHS', 'Length': c.L + 'mm'});

            // ===== FASCIA BEAM (on house - for attached only) =====
            // Against house fascia board face, below gutter in exposed fascia zone
            if (c.isAttached && fasciaBeamY !== null) {
                const fasciaBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamW * 1.1, beamH * 1.2), fasciaMat());
                // Z: against house fascia face (wall face + fascia board thickness offset)
                const fbmZ = -W/2 - 0.02;
                if (isPerpendicular) {
                    fasciaBeam.rotation.y = Math.PI / 2;
                    fasciaBeam.position.set(fbmZ, fasciaBeamY + beamW/2, 0);
                } else {
                    fasciaBeam.position.set(0, fasciaBeamY + beamW/2, fbmZ);
                }
                fasciaBeam.castShadow = true;
                steelGrp.add(fasciaBeam);
                regComp(fasciaBeam, 'Fascia Beam', {'Size': '100×50×2 RHS', 'Length': c.L + 'mm', 'Height': c.fasciaH + 'mm', 'Note': 'House connection'});
            }

            // ===== RAFTER BRACKETS (for fascia connections only) =====
            if (c.connection === 'fascia' || c.connection === 'fasciabeam') {
                const bracketLen = 0.5;
                const bracketH = 0.006;
                const bracketW = 0.05;
                const bracketCount = Math.max(3, Math.ceil(L / 1.0));
                for (let i = 0; i < bracketCount; i++) {
                    const x = -L/2 + (L / (bracketCount - 1)) * i;
                    const bracket = new THREE.Mesh(
                        new THREE.BoxGeometry(bracketW, bracketH, bracketLen),
                        sMat()
                    );
                    if (isPerpendicular) {
                        bracket.rotation.y = Math.PI / 2;
                        bracket.position.set(-W/2 - bracketLen/2 - 0.08, fasciaBeamY + beamH + 0.1, x);
                    } else {
                        bracket.position.set(x, fasciaBeamY + beamH + 0.1, -W/2 - bracketLen/2 - 0.08);
                    }
                    steelGrp.add(bracket);
                }
            }

            // ===== V18 FIX: RISERS with correct stacking =====
            if (c.connection === 'riser') {
                // V18: Riser beam sits ON TOP of risers
                const riserOff = c.riserOffset / 1000;
                const riserSize = 0.075;
                const count = c.riserQty;

                // Calculate actual vertical rise of risers
                // Span from fascia beam top (horiz piece) up to riser beam bottom (backBeamY)
                const actualRiserH = backBeamY - (fasciaBeamY + beamH + riserSize);

                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;

                    // HORIZONTAL piece (comes out from fascia beam)
                    const horizPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, riserSize, riserOff),
                        riserMat()
                    );

                    // VERTICAL piece (rises up)
                    const vertPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, actualRiserH, riserSize),
                        riserMat()
                    );

                    if (isPerpendicular) {
                        horizPiece.rotation.y = Math.PI / 2;
                        horizPiece.position.set(-W/2 + riserOff/2, fasciaBeamY + beamH + riserSize/2, x);
                        vertPiece.position.set(-W/2 + riserOff, fasciaBeamY + beamH + riserSize + actualRiserH/2, x);
                    } else {
                        horizPiece.position.set(x, fasciaBeamY + beamH + riserSize/2, -W/2 + riserOff/2);
                        vertPiece.position.set(x, fasciaBeamY + beamH + riserSize + actualRiserH/2, -W/2 + riserOff);
                    }

                    horizPiece.castShadow = true;
                    vertPiece.castShadow = true;
                    steelGrp.add(horizPiece);
                    steelGrp.add(vertPiece);
                    regComp(vertPiece, 'Riser Elbow ' + (i+1), {
                        'Size': '75×75×2 SHS',
                        'Offset': c.riserOffset + 'mm',
                        'Rise': Math.round(actualRiserH * 1000) + 'mm',
                        'Note': '90° elbow clears house gutter'
                    });
                }

                // Riser brackets – threaded rod through house fascia, clamps fascia beam tight
                // Strip lays along rafter top, threaded rod pokes through fascia board
                const galvMat = () => new THREE.MeshStandardMaterial({color: 0xC0C0C0, metalness: 0.7, roughness: 0.4});
                const fasciaHmR = c.fasciaH / 1000; // rafter base Y (independent of fascia beam)
                const fasciaBdH = 0.15; // house fascia board height
                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;
                    const stripLen = 0.45;   // 450mm long
                    const stripW = 0.03;     // 30mm wide
                    const stripT = 0.006;    // 6mm thick galv plate
                    // Y: vertically centred on house fascia board
                    const bkY = fasciaHmR - fasciaBdH / 2;
                    // House fascia front face is 50mm behind patio edge
                    // Fascia beam front face is 10mm past patio edge
                    const fasciaFaceOff = -0.05; // house fascia front face relative to -W/2
                    const fbmFrontOff = 0.01;    // fascia beam front face relative to -W/2
                    // Threaded rod: from fascia face through to fascia beam front face
                    const rodLen = fbmFrontOff - fasciaFaceOff; // 60mm
                    const rodD = 0.012; // M12 threaded rod
                    // Strip: mostly behind wall, tip at house fascia face
                    const strip = new THREE.Mesh(
                        new THREE.BoxGeometry(stripW, stripT, stripLen),
                        galvMat()
                    );
                    // Threaded rod: pokes through fascia, does NOT protrude past fascia beam
                    const bolt = new THREE.Mesh(
                        new THREE.BoxGeometry(rodD, rodD, rodLen),
                        galvMat()
                    );
                    if (isPerpendicular) {
                        strip.rotation.y = Math.PI / 2;
                        strip.position.set(-W/2 + fasciaFaceOff - stripLen/2, bkY, x);
                        bolt.rotation.y = Math.PI / 2;
                        bolt.position.set(-W/2 + fasciaFaceOff + rodLen/2, bkY, x);
                    } else {
                        strip.position.set(x, bkY, -W/2 + fasciaFaceOff - stripLen/2);
                        bolt.position.set(x, bkY, -W/2 + fasciaFaceOff + rodLen/2);
                    }
                    steelGrp.add(strip);
                    steelGrp.add(bolt);
                    regComp(strip, 'Riser Bracket ' + (i+1), {'Size': '450×30×6mm Galv Flat Bar', 'Rod': 'M12 threaded rod', 'Note': 'Threaded rod through fascia, clamps fascia beam tight'});
                }

                // Box gutter (if selected) - sits in gap between house wall and riser beam
                if (c.houseGutter === 'box') {
                    // Width sized to fit the gap between house fascia and riser beam
                    const boxGutterW = riserOff;
                    const boxGutterD = 0.1;       // inner wall height (house side)
                    const boxGutterOuter = 0.12;  // outer wall height (riser side, taller to catch water)
                    const wallT = 0.01;

                    // U-shaped cross-section: X=0 is house side, X=boxGutterW is riser side
                    const gutterShape = new THREE.Shape();
                    gutterShape.moveTo(0, 0);
                    gutterShape.lineTo(boxGutterW, 0);
                    gutterShape.lineTo(boxGutterW, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, wallT);
                    gutterShape.lineTo(wallT, wallT);
                    gutterShape.lineTo(wallT, boxGutterD);
                    gutterShape.lineTo(0, boxGutterD);
                    gutterShape.closePath();

                    const extrudeSettings = { depth: L, bevelEnabled: false };
                    const gutterGeo = new THREE.ExtrudeGeometry(gutterShape, extrudeSettings);
                    const boxGutter = new THREE.Mesh(gutterGeo, sMat());

                    // Y: gutter bottom sits ON TOP of the riser elbow horizontal pieces
                    // horiz piece top = fasciaBeamY + beamH + riserSize
                    const boxGutterY = fasciaBeamY + beamH + riserSize;

                    if (isPerpendicular) {
                        // House wall at X = -W/2, riser beam at X = -W/2 + riserOff
                        // rotation.y = π: local X → world -X, local +Z → world -Z
                        // Shape X=0 (house side) → world X = position.x (riser beam)
                        // Shape X=gutterW (riser side) → world X = position.x - gutterW = -W/2 (house)
                        // So we need to flip: position at -W/2, no extra rotation for X direction
                        // Use rotation.y = 0: local X → world +X, local Z → world +Z
                        // Shape X=0 (house side) at world X = -W/2, X=gutterW at -W/2 + riserOff
                        boxGutter.rotation.y = 0;
                        boxGutter.position.set(-W/2, boxGutterY, -L/2);
                    } else {
                        // House wall at Z = -W/2, riser beam at Z = -W/2 + riserOff
                        // rotation.y = -π/2: local X → world +Z, local +Z → world -X
                        // Shape X=0 (house side) at world Z = -W/2
                        // Shape X=gutterW (riser side) at world Z = -W/2 + riserOff
                        // Extrusion goes -X, so position at X = +L/2
                        boxGutter.rotation.y = -Math.PI / 2;
                        boxGutter.position.set(L/2, boxGutterY, -W/2);
                    }
                    accGrp.add(boxGutter);
                    regComp(boxGutter, 'Box Gutter', {'Width': Math.round(riserOff*1000)+'mm', 'Inner Depth': '100mm', 'Outer Depth': '120mm'});
                }

                // Patio gutter on riser beam (gable only) - catches back slope water
                if (c.isGable && c.riserGutter === 'quad') {
                    const rgW = 0.115;     // 115mm quad gutter
                    const rgFront = 0.076; // 76mm front face
                    const rgBack = 0.045;  // 45mm back face
                    const rgT = 0.001;     // 1mm sheet steel
                    const rgs = new THREE.Shape();
                    rgs.moveTo(0, 0);
                    rgs.lineTo(rgW, 0);
                    rgs.lineTo(rgW, rgFront);
                    rgs.lineTo(rgW - rgT, rgFront);
                    rgs.lineTo(rgW - rgT, rgT);
                    rgs.lineTo(rgT, rgT);
                    rgs.lineTo(rgT, rgBack);
                    rgs.lineTo(0, rgBack);
                    rgs.closePath();
                    const rgGeo = new THREE.ExtrudeGeometry(rgs, { depth: L, bevelEnabled: false });
                    const riserGutterMesh = new THREE.Mesh(rgGeo, sMat());
                    // Sits on top of riser beam
                    const riserBeamTop = backBeamY + 0.1; // riser beam height = 0.1
                    if (isPerpendicular) {
                        riserGutterMesh.position.set(-W/2 + riserOff - rgW/2, riserBeamTop, -L/2);
                    } else {
                        riserGutterMesh.rotation.y = -Math.PI / 2;
                        riserGutterMesh.position.set(L/2, riserBeamTop, -W/2 + riserOff - rgW/2);
                    }
                    accGrp.add(riserGutterMesh);
                    regComp(riserGutterMesh, 'Riser Beam Gutter', {'Type': '115mm Quad', 'Length': c.L + 'mm', 'Note': 'Catches gable back slope water'});
                }
            }

            // ===== CARRY / BACK BEAM - NOT for receiving channel (fascia/wall use channel instead) =====
            if (c.connection !== 'fascia' && c.connection !== 'fasciabeam' && c.connection !== 'wall') {
                const isRiser = c.connection === 'riser';
                const isFlyover = c.connection === 'flyover';
                const beamHeight = isRiser ? 0.1 : (isFlyover ? 0.05 : beamH);
                const beamWidth = isRiser ? 0.05 : (isFlyover ? 0.15 : beamW);
                const riserOff = isRiser ? c.riserOffset/1000 : 0;

                const carryBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamHeight, beamWidth), sMat());
                if (isPerpendicular) {
                    carryBeam.rotation.y = Math.PI / 2;
                    carryBeam.position.set(-W/2 + riserOff, backBeamY + beamHeight/2, 0);
                } else {
                    carryBeam.position.set(0, backBeamY + beamHeight/2, -W/2 + riserOff);
                }
                carryBeam.castShadow = true;
                steelGrp.add(carryBeam);
                const beamName = isRiser ? 'Riser Beam' : (isFlyover ? 'Flyover Beam' : 'Back Beam');
                const beamSpec = isRiser ? '100×50×2 RHS (on edge)' : (isFlyover ? '150×50×2 RHS' : '100×50×2 RHS');
                regComp(carryBeam, beamName, {'Size': beamSpec, 'Length': c.L + 'mm', 'Height': Math.round(backBeamY*1000) + 'mm'});
            }

            // ===== FLYOVER VERTICAL STRUTS - sit ON TOP of house roof =====
            // Struts penetrate through roof sheets and bolt to house rafters
            if (c.connection === 'flyover') {
                const fasciaHm = c.fasciaH / 1000;
                const hRafterH = 0.09; // house rafter height
                // Struts positioned on house roof near the eave, directly under the flyover beam
                // Roof surface at the eave = rafter top = fasciaHm + hRafterH
                const roofSurfaceY = fasciaHm + hRafterH;
                const strutSize = 0.09; // 90x90 SHS
                const strutH = Math.max(0.15, backBeamY - roofSurfaceY);
                const strutCount = Math.max(2, Math.ceil(L / 1.2));
                // Struts are at same Z as the flyover beam (at patio back edge)
                // They go through the roof/fascia and bolt to the house rafters below

                for (let i = 0; i < strutCount; i++) {
                    const x = -L/2 + (L / (strutCount - 1)) * i;
                    const strut = new THREE.Mesh(
                        new THREE.BoxGeometry(strutSize, strutH, strutSize),
                        sMat()
                    );
                    if (isPerpendicular) {
                        strut.position.set(-W/2, roofSurfaceY + strutH/2, x);
                    } else {
                        strut.position.set(x, roofSurfaceY + strutH/2, -W/2);
                    }
                    strut.castShadow = true;
                    steelGrp.add(strut);
                    regComp(strut, 'Flyover Strut ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(strutH*1000) + 'mm'});
                }
            }

            // ===== ROOF STRUCTURE =====
            const frontTop = frontBeamY + beamH;
            const backTop = backBeamY + beamH;
            const sheetW = c.sheetCoverage / 1000;

            // V18: Calculate actual gutter height for downpipes
            let gutterY;

            if (c.isGable) {
                // ========== GABLE ROOF ==========
                const trussBaseY = (frontTop + backTop) / 2;
                const tiltAngle = Math.atan2(backTop - frontTop, W);
                gutterY = frontTop - 0.04;

                // Trusses (peak from internal geometry; tilt spans between beams when heights differ)
                for (let i = 0; i < c.nTruss; i++) {
                    const x = -L/2 + (L / (c.nTruss - 1)) * i;
                    const truss = createTrussUnit(W, rise, rafter, tw, th, sMat(), c.trussStyle, c.pitchRad);
                    if (isPerpendicular) {
                        truss.rotation.order = 'ZYX';
                        truss.rotation.y = Math.PI / 2;
                        truss.rotation.z = -tiltAngle;
                        truss.position.set(0, trussBaseY, x);
                    } else {
                        truss.rotation.x = tiltAngle;
                        truss.position.set(x, trussBaseY, 0);
                    }
                    steelGrp.add(truss);
                    regComp(truss, 'Truss ' + (i+1), {'Span': Math.round(c.trussSpan) + 'mm', 'Rise': Math.round(c.rise) + 'mm'});

                    // Gable infill
                    if ((i === 0 || i === c.nTruss - 1) && c.infill !== 'none') {
                        const shape = new THREE.Shape();
                        shape.moveTo(-W/2, th);
                        shape.lineTo(0, rise + th);
                        shape.lineTo(W/2, th);
                        shape.closePath();
                        const infillMat = new THREE.MeshStandardMaterial({
                            color: c.infill === 'twinwall' ? 0xDDEEEE : sheetCol,
                            transparent: c.infill === 'twinwall',
                            opacity: c.infill === 'twinwall' ? 0.6 : 1,
                            side: THREE.DoubleSide
                        });
                        const infillMesh = new THREE.Mesh(new THREE.ShapeGeometry(shape), infillMat);

                        if (isPerpendicular) {
                            infillMesh.rotation.y = x > 0 ? Math.PI : 0;
                            infillMesh.position.set(0, trussBaseY, x);
                        } else {
                            infillMesh.rotation.y = Math.PI / 2;
                            infillMesh.position.set(x, trussBaseY, 0);
                        }
                        roofGrp.add(infillMesh);
                        regComp(infillMesh, 'Gable Infill', {'Material': c.infill === 'twinwall' ? '10mm Twinwall' : 'Colorbond'});
                    }
                }

                // Purlins
                const purlinCount = Math.max(2, Math.ceil(rafter / 0.8));
                for (let side = -1; side <= 1; side += 2) {
                    for (let p = 1; p <= purlinCount; p++) {
                        const frac = p / (purlinCount + 1);
                        const zPos = (W/2) * frac * side;
                        const yPos = trussBaseY + th + rise * (1 - frac);
                        const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                        if (isPerpendicular) {
                            purlin.rotation.y = Math.PI / 2;
                            purlin.position.set(zPos, yPos, 0);
                        } else {
                            purlin.position.set(0, yPos, zPos);
                        }
                        steelGrp.add(purlin);
                    }
                }

                // V18 FIX: Roof sheets - corrected rotation for perpendicular mode
                const numSheets = Math.ceil(L / sheetW);
                for (let side = -1; side <= 1; side += 2) {
                    for (let s = 0; s < numSheets; s++) {
                        const sheetPos = -L/2 + sheetW/2 + s * sheetW;
                        let sheetGeo;
                        if (c.roofing === 'corrugated') {
                            sheetGeo = createCorrugatedGeometry(sheetW, rafter + 0.05);
                        } else if (c.roofing === 'trimdek') {
                            sheetGeo = createTrimdekGeometry(sheetW, rafter + 0.05);
                        } else {
                            sheetGeo = createInsulatedGeometry(sheetW, rafter + 0.05);
                        }

                        const sheet = new THREE.Mesh(sheetGeo, rMat());

                        if (isPerpendicular) {
                            // Perpendicular: same X rotation as lengthways, then Y=π/2 to turn 90°
                            // YXZ order: Rx applied to point first (slope tilt), then Ry (90° turn)
                            sheet.rotation.order = 'YXZ';
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                            sheet.rotation.y = Math.PI / 2;

                            const midHeight = trussBaseY + th + rise/2;
                            sheet.position.set(side * W/4, midHeight + 0.02, sheetPos);
                        } else {
                            // Lengthways - ridge along X, slopes in Z direction
                            sheet.position.set(sheetPos, trussBaseY + th + rise/2 + 0.01, side * W/4);
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                        }
                        sheet.castShadow = true;
                        roofGrp.add(sheet);
                        const sideLabel = side === -1 ? 'A' : 'B';
                        regComp(sheet, 'Roof Sheet ' + sideLabel + (s+1), {'Profile': c.roofing, 'Length': Math.round((rafter + 0.05)*1000) + 'mm', 'Side': side === -1 ? 'Left slope' : 'Right slope'});
                    }
                }

                // Ridge capping
                const ridge = new THREE.Mesh(new THREE.BoxGeometry(L, 0.04, 0.3), rMat());
                if (isPerpendicular) {
                    ridge.rotation.y = Math.PI / 2;
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                } else {
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                }
                accGrp.add(ridge);
                regComp(ridge, 'Ridge Cap', {'Length': c.L + 'mm'});

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                if (isPerpendicular) {
                    gutter.rotation.y = Math.PI / 2;
                    gutter.position.set(W/2 + 0.07, gutterY, 0);
                } else {
                    gutter.position.set(0, gutterY, W/2 + 0.07);
                }
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.L + 'mm'});

                // Gable barges
                const bargeThick = 0.003;
                const bargeWidth = 0.15;
                const bargeLen = rafter + 0.05;

                if (isPerpendicular) {
                    [-L/2, L/2].forEach((zEnd) => {
                        const bargeL = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeL.position.set(-W/4, trussBaseY + th + rise/2, zEnd);
                        bargeL.rotation.z = c.pitchRad;
                        accGrp.add(bargeL);

                        const bargeR = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeR.position.set(W/4, trussBaseY + th + rise/2, zEnd);
                        bargeR.rotation.z = -c.pitchRad;
                        accGrp.add(bargeR);
                    });
                } else {
                    [-L/2, L/2].forEach((xEnd) => {
                        const bargeHouse = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeHouse.position.set(xEnd, trussBaseY + th + rise/2, -W/4);
                        bargeHouse.rotation.x = -c.pitchRad;
                        accGrp.add(bargeHouse);

                        const bargeGutter = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeGutter.position.set(xEnd, trussBaseY + th + rise/2, W/4);
                        bargeGutter.rotation.x = c.pitchRad;
                        accGrp.add(bargeGutter);
                    });
                }

            } else {
                // ========== SKILLION ROOF ==========
                gutterY = frontTop - 0.04;  // V18: Store gutter Y for downpipes

                const riserOff = c.connection === 'riser' ? c.riserOffset / 1000 : 0;
                const backEdgeZ = -W/2 + riserOff;

                // Rafters
                for (let i = 0; i < c.nRafters; i++) {
                    const x = -L/2 + (L / (c.nRafters - 1)) * i;
                    const rafterGeo = new THREE.BoxGeometry(tw, th, rafter);
                    rafterGeo.translate(0, 0, rafter/2);
                    const raft = new THREE.Mesh(rafterGeo, sMat());
                    raft.position.set(x, backTop + th/2, backEdgeZ);
                    raft.rotation.x = c.pitchRad;
                    steelGrp.add(raft);
                    regComp(raft, 'Rafter ' + (i+1), {'Size': c.steel.name, 'Length': Math.round(c.rafter) + 'mm'});
                }

                // Purlins
                const effectiveW = W - riserOff;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9));
                for (let p = 0; p <= purlinCount; p++) {
                    const frac = p / purlinCount;
                    const zPos = backEdgeZ + effectiveW * frac;
                    const yPos = backTop + th - (backTop - frontTop) * frac;
                    const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                    purlin.position.set(0, yPos, zPos);
                    steelGrp.add(purlin);
                }

                // Roof sheets
                const sheetInset = c.isRecvChan ? 0.03 : 0; // 30mm into channel
                const numSheets = Math.ceil(L / sheetW);
                for (let s = 0; s < numSheets; s++) {
                    const xPos = -L/2 + sheetW/2 + s * sheetW;
                    let sheetGeo;
                    if (c.roofing === 'corrugated') {
                        sheetGeo = createCorrugatedGeometry(sheetW, rafter);
                    } else if (c.roofing === 'trimdek') {
                        sheetGeo = createTrimdekGeometry(sheetW, rafter);
                    } else {
                        sheetGeo = createInsulatedGeometry(sheetW, rafter);
                    }
                    sheetGeo.translate(0, rafter/2, 0);

                    const sheet = new THREE.Mesh(sheetGeo, rMat());
                    sheet.position.set(xPos, backTop + th + 0.01, backEdgeZ - sheetInset);
                    sheet.rotation.x = Math.PI/2 + c.pitchRad;
                    sheet.castShadow = true;
                    roofGrp.add(sheet);
                    regComp(sheet, 'Roof Sheet ' + (s+1), {'Profile': c.roofing, 'Length': Math.round(rafter*1000) + 'mm'});
                }

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                gutter.position.set(0, gutterY, W/2 + 0.07);
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.lenInput + 'mm'});

                // Back flashing - skip for riser+box gutter AND receiving channel (channel acts as flashing)
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    const flash = new THREE.Mesh(new THREE.BoxGeometry(L, 0.15, 0.003), sMat());
                    flash.position.set(0, backTop + 0.08, backEdgeZ - 0.05);
                    flash.rotation.x = -0.3;
                    accGrp.add(flash);
                    regComp(flash, 'Back Flashing', {'Length': c.lenInput + 'mm'});
                }

                // Barge flashings
                [-L/2, L/2].forEach((xPos, idx) => {
                    const barge = new THREE.Mesh(new THREE.BoxGeometry(0.1, rafter, 0.003), sMat());
                    barge.position.set(xPos, (backTop + frontTop)/2 + th, 0);
                    barge.rotation.x = -(Math.PI/2 - c.pitchRad);
                    accGrp.add(barge);
                });
            }

            // ===== V18 FIX: DOWNPIPES - Use actual gutter height =====
            let dpPositions;
            if (isPerpendicular) {
                dpPositions = [[W/2 + 0.1, -L/2 + 0.1], [W/2 + 0.1, L/2 - 0.1]];
            } else {
                dpPositions = [[-L/2 + 0.1, W/2 + 0.1], [L/2 - 0.1, W/2 + 0.1]];
            }
            dpPositions.forEach((pos, idx) => {
                // V18 FIX: Downpipe height = from ground to gutter, not postH
                const dpHeight = gutterY + 0.04;  // Gutter bottom + 40mm into gutter
                const dp = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, dpHeight, 12), sMat());
                dp.position.set(pos[0], dpHeight/2, pos[1]);
                accGrp.add(dp);
                regComp(dp, 'Downpipe ' + (idx+1), {'Size': '90mm Round', 'Height': Math.round(dpHeight*1000) + 'mm'});
            });

            // ===== HOUSE / WALL REPRESENTATION =====
            // riser, fascia, flyover: house with wall + fascia board + Colorbond roof
            // wall: flat wall only (receiving channel bolts to wall surface)
            // freestanding: no wall
            if (c.isAttached) {
                const fasciaHm = c.fasciaH / 1000;
                const wallThick = 0.15;
                const wallLen = L + 0.2;
                const wallMat = new THREE.MeshStandardMaterial({color: 0xD4C4B0, roughness: 0.9});
                const fasciaTimberMat = new THREE.MeshStandardMaterial({color: 0x8B7355, roughness: 0.8});
                // Monument colour (#3C3C3C) for existing house Colorbond roof
                const roofColorbondMat = new THREE.MeshStandardMaterial({color: 0x3C3C3C, roughness: 0.5, metalness: 0.4});

                if (c.connection === 'wall') {
                    // === WALL MODE: just a flat brick/render wall ===
                    const wallH = Math.max(backBeamY + 0.5, fasciaHm + 0.5);
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                } else {
                    // === HOUSE MODE (riser, fascia, flyover): wall + fascia + roof ===
                    // Wall: only up to fascia height (roof sits above)
                    const wallH = fasciaHm;
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                    // Fascia board (timber) covers the full rafter end face
                    if (fasciaHm > 0) {
                        const fasciaBoardH = 0.15;   // 150mm tall
                        const fasciaBoardT = 0.025;  // 25mm thick
                        const fasciaBoard = new THREE.Mesh(
                            new THREE.BoxGeometry(wallLen, fasciaBoardH, fasciaBoardT),
                            fasciaTimberMat
                        );
                        // Fascia board top aligns with rafter bottom (fasciaHm)
                        // Gutter sits against fascia front face at the top half
                        const fbZ = -W/2 - wallThick/2 + fasciaBoardT/2;
                        const fbY = fasciaHm - fasciaBoardH/2; // center of board, top at rafter bottom
                        if (isPerpendicular) {
                            fasciaBoard.rotation.y = Math.PI / 2;
                            fasciaBoard.position.set(fbZ, fbY, 0);
                        } else {
                            fasciaBoard.position.set(0, fbY, fbZ);
                        }
                        fasciaBoard.castShadow = true;
                        houseGrp.add(fasciaBoard);
                        regComp(fasciaBoard, 'House Fascia Board', {'Size': '150×25mm Timber', 'Height': c.fasciaH + 'mm'});
                    }

                    // House roof: timber rafters + individual Colorbond sheets
                    const roofDepth = 1.5;       // 1.5m visible depth
                    const roofPitch = 15 * Math.PI / 180;
                    const roofRise = roofDepth * Math.tan(roofPitch);
                    const roofBaseY = fasciaHm;  // rafters sit on wall top plate
                    const roofCenterY = roofBaseY + roofRise / 2;
                    const roofZCenter = -W/2 - wallThick/2 - roofDepth/2;

                    // Timber rafters (45×90mm) at 600mm spacing
                    const rafterW = 0.045, rafterH = 0.09, rafterSpacing = 0.6;
                    const rafterCount = Math.max(2, Math.ceil(wallLen / rafterSpacing) + 1);
                    for (let i = 0; i < rafterCount; i++) {
                        const pos = -wallLen/2 + (wallLen / (rafterCount - 1)) * i;
                        const rafter = new THREE.Mesh(
                            new THREE.BoxGeometry(rafterW, rafterH, roofDepth),
                            fasciaTimberMat
                        );
                        if (isPerpendicular) {
                            rafter.rotation.order = 'YXZ';
                            rafter.rotation.y = Math.PI / 2;
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(roofZCenter, roofCenterY, pos);
                        } else {
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(pos, roofCenterY, roofZCenter);
                        }
                        rafter.castShadow = true;
                        houseGrp.add(rafter);
                    }
                    // Register first rafter for tooltip
                    if (houseGrp.children.length > 0) {
                        const lastRafter = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastRafter, 'House Rafter', {'Size': '45×90mm Timber', 'Spacing': '600mm', 'Qty': rafterCount});
                    }

                    // Individual Colorbond roof sheets on top of rafters
                    // Sheets overhang 50mm past fascia into gutter
                    const hSheetW = 0.762;  // corrugated sheet cover width
                    const hSheetT = 0.001;  // ~1mm Colorbond
                    const hOverhang = 0.05; // 50mm overhang past fascia
                    const hSheetDepth = roofDepth + hOverhang;
                    const hSheetZCenter = roofZCenter + hOverhang/2; // shift toward fascia
                    const hSheetCount = Math.max(1, Math.ceil(wallLen / hSheetW));
                    const hSheetCenterY = roofCenterY + rafterH/2 + hSheetT/2;
                    for (let i = 0; i < hSheetCount; i++) {
                        const sw = (i === hSheetCount - 1) ? (wallLen - hSheetW * i) : hSheetW;
                        const pos = -wallLen/2 + hSheetW * i + sw/2;
                        const hSheet = new THREE.Mesh(
                            new THREE.BoxGeometry(sw, hSheetT, hSheetDepth),
                            roofColorbondMat.clone()
                        );
                        if (isPerpendicular) {
                            hSheet.rotation.order = 'YXZ';
                            hSheet.rotation.y = Math.PI / 2;
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(hSheetZCenter, hSheetCenterY, pos);
                        } else {
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(pos, hSheetCenterY, hSheetZCenter);
                        }
                        hSheet.castShadow = true;
                        hSheet.receiveShadow = true;
                        houseGrp.add(hSheet);
                    }
                    const roofLabel = c.connection === 'flyover' ? 'Existing House Roof (Flyover)' : 'Existing House Roof';
                    if (houseGrp.children.length > 0) {
                        const lastSheet = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastSheet, roofLabel, {'Pitch': '15°', 'Material': 'Colorbond', 'Sheets': hSheetCount});
                    }

                    // House quad gutter – sits against front face of fascia, at the top half
                    // Hidden when box gutter is selected (box gutter replaces it)
                    const showHouseGutter = !(c.connection === 'riser' && c.houseGutter === 'box');
                    if (showHouseGutter) {
                    const hGutterW = 0.115;    // 115mm wide
                    const hGutterFront = 0.076; // 76mm front face
                    const hGutterBack = 0.045;  // 45mm back face
                    const hGutterT = 0.001;     // 1mm sheet steel
                    const hgs = new THREE.Shape();
                    hgs.moveTo(0, 0);
                    hgs.lineTo(hGutterW, 0);
                    hgs.lineTo(hGutterW, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterBack);
                    hgs.lineTo(0, hGutterBack);
                    hgs.closePath();
                    const hGutterGeo = new THREE.ExtrudeGeometry(hgs, { depth: L, bevelEnabled: false });
                    const hGutter = new THREE.Mesh(hGutterGeo, roofColorbondMat.clone());
                    // Back lip top at fasciaHm – gutter against top half of fascia face
                    const hGutterY = fasciaHm - hGutterBack;
                    const hGutterZ = -W/2 - wallThick/2 + 0.025; // at fascia board front face
                    if (isPerpendicular) {
                        // extrude along +Z; rotation.y=0 keeps local Z=world Z
                        hGutter.position.set(hGutterZ, hGutterY, -L/2);
                    } else {
                        // rotation.y=-π/2: local +Z → world -X, shape X → world +Z
                        hGutter.rotation.y = -Math.PI / 2;
                        hGutter.position.set(L/2, hGutterY, hGutterZ);
                    }
                    houseGrp.add(hGutter);
                    regComp(hGutter, 'House Quad Gutter', {'Size': '115mm Quad', 'Front': '76mm', 'Back': '45mm'});
                    } // end showHouseGutter
                }

                // C-Channel - for receiving channel modes (fascia and wall only, not fasciabeam)
                if (c.isRecvChan) {
                    const chanW = 0.075;  // 75mm wide – captures sheet edges
                    const chanH = 0.03;   // 30mm tall
                    const chanT = 0.003;  // 3mm steel thickness
                    // C-channel profile (U-shape opening toward patio)
                    const chanShape = new THREE.Shape();
                    chanShape.moveTo(0, 0);
                    chanShape.lineTo(chanW, 0);
                    chanShape.lineTo(chanW, chanT);
                    chanShape.lineTo(chanT, chanT);
                    chanShape.lineTo(chanT, chanH - chanT);
                    chanShape.lineTo(chanW, chanH - chanT);
                    chanShape.lineTo(chanW, chanH);
                    chanShape.lineTo(0, chanH);
                    chanShape.closePath();

                    const chanGeo = new THREE.ExtrudeGeometry(chanShape, { depth: L, bevelEnabled: false });
                    const channel = new THREE.Mesh(chanGeo, sMat());

                    if (c.connection === 'fascia') {
                        // On fascia board face, at fascia beam height
                        const chanY = fasciaHm + beamH/2 - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    } else {
                        // Wall mode: on wall surface at connection height
                        const chanY = fasciaHm - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    }
                    steelGrp.add(channel);
                    regComp(channel, 'Receiving Channel', {'Size': '75×30mm C-Channel', 'Length': c.L + 'mm', 'Type': c.connection === 'fascia' ? 'Fascia mount' : 'Wall mount'});
                }
            }

            updateMatList();

            // Update camera orbit target to center of combined patio + house
            const bbox = new THREE.Box3();
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => {
                if (g.children.length > 0) bbox.expandByObject(g);
            });
            if (!bbox.isEmpty()) {
                bbox.getCenter(aCamTarget);
            }
            updateAsmCam();
        }

        function createTrussUnit(W, rise, rafter, tw, th, mat, style, pitchRad) {
            const g = new THREE.Group();

            const chord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, W), mat.clone());
            chord.position.set(0, th/2, 0);
            g.add(chord);

            const leftGeo = new THREE.BoxGeometry(tw, th, rafter);
            leftGeo.translate(0, 0, rafter/2);
            const leftR = new THREE.Mesh(leftGeo, mat.clone());
            leftR.position.set(0, th, -W/2);
            leftR.rotation.x = -pitchRad;
            g.add(leftR);

            const rightGeo = new THREE.BoxGeometry(tw, th, rafter);
            rightGeo.translate(0, 0, -rafter/2);
            const rightR = new THREE.Mesh(rightGeo, mat.clone());
            rightR.position.set(0, th, W/2);
            rightR.rotation.x = pitchRad;
            g.add(rightR);

            if (style === 'king') {
                const kingH = rise - th;
                if (kingH > 0) {
                    const king = new THREE.Mesh(new THREE.BoxGeometry(tw, kingH, th), mat.clone());
                    king.position.set(0, th + kingH/2, 0);
                    g.add(king);
                }
            } else if (style === 'queen') {
                const qH = rise * 0.6;
                const qZ = W * 0.2;
                [-1, 1].forEach(s => {
                    const q = new THREE.Mesh(new THREE.BoxGeometry(tw, qH, th), mat.clone());
                    q.position.set(0, th + qH/2, s * qZ);
                    g.add(q);
                });
                const topChord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, W * 0.4), mat.clone());
                topChord.position.set(0, th + qH, 0);
                g.add(topChord);
            }

            return g;
        }

        function regComp(mesh, name, specs) {
            compData.set(mesh.uuid, {name, specs});
        }

        function checkHover(mx, my) {
            asmRay.setFromCamera(asmMouse, asmCam);
            const all = [];
            if (steelGrp.visible) all.push(...steelGrp.children);
            if (roofGrp.visible) all.push(...roofGrp.children);
            if (accGrp.visible) all.push(...accGrp.children);
            if (houseGrp.visible) all.push(...houseGrp.children);
            const hits = asmRay.intersectObjects(all, true);
            if (hits.length > 0) {
                let obj = hits[0].object;
                while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;
                if (compData.has(obj.uuid)) {
                    if (hovered !== obj) { clearHover(); hovered = obj; highlight(obj); }
                    showTooltip(mx, my, compData.get(obj.uuid));
                    return;
                }
            }
            clearHover();
        }

        function highlight(mesh) {
            const hl = new THREE.Color(0xF15A29);
            if (mesh.material) { mesh.material.emissive = hl; mesh.material.emissiveIntensity = 0.3; }
            mesh.traverse(c => { if (c.material) { c.material.emissive = hl; c.material.emissiveIntensity = 0.3; }});
        }

        function clearHover() {
            if (hovered) {
                if (hovered.material) { hovered.material.emissive = new THREE.Color(0); hovered.material.emissiveIntensity = 0; }
                hovered.traverse(c => { if (c.material) { c.material.emissive = new THREE.Color(0); c.material.emissiveIntensity = 0; }});
                hovered = null;
            }
            hideTooltip();
        }

        function showTooltip(x, y, data) {
            const tt = document.getElementById('tooltip');
            document.getElementById('ttTitle').textContent = data.name;
            document.getElementById('ttContent').innerHTML = Object.entries(data.specs)
                .map(([k,v]) => `<div class="tooltip-row"><span class="tooltip-label">${k}</span><span class="tooltip-value">${v}</span></div>`).join('');
            tt.style.left = (x + 15) + 'px';
            tt.style.top = (y + 15) + 'px';
            tt.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function toggleLayer(layer, el) {
            el.classList.toggle('active');
            const vis = el.classList.contains('active');
            if (layer === 'steel') steelGrp.visible = vis;
            if (layer === 'roof') roofGrp.visible = vis;
            if (layer === 'acc') accGrp.visible = vis;
            if (layer === 'house') houseGrp.visible = vis;
        }

        function setAsmView(v, btn) {
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            if (v === '3d') { aCamT = 0.5; aCamP = 0.4; aCamD = 12; }
            else if (v === 'front') { aCamT = 0; aCamP = 0.25; aCamD = 10; }
            else if (v === 'side') { aCamT = Math.PI/2; aCamP = 0.3; aCamD = 12; }
            else if (v === 'top') { aCamT = 0; aCamP = 1.4; aCamD = 15; }
            updateAsmCam();
        }

        function toggleFullscreen() {
            const el = document.getElementById('asmViewport');
            el.classList.toggle('fullscreen');
            setTimeout(() => {
                asmCam.aspect = el.clientWidth / el.clientHeight;
                asmCam.updateProjectionMatrix();
                asmRend.setSize(el.clientWidth, el.clientHeight);
            }, 100);
        }

        function updateMatList() {
            const c = calc;
            let mats = [];
            const sheetCover = c.sheetCoverage;

            if (c.isGable) {
                const numSheets = Math.ceil(c.L / sheetCover) * 2;
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                const riserCount = c.riserQty;
                // Beam count depends on connection type
                let beamCount;
                if (c.connection === 'freestanding') {
                    beamCount = 2;  // Gutter beam + back beam
                } else if (c.connection === 'riser') {
                    beamCount = 3;  // Gutter beam + fascia beam + riser beam
                } else {
                    beamCount = 2;  // Gutter beam + fascia/back beam
                }
                const purlinCount = Math.max(2, Math.ceil(c.rafter / 1000 / 0.8)) * 2;
                mats = [
                    {d: 'Posts 90×90×2', q: postCount},
                    {d: 'Beams 100×50×2', q: beamCount},
                    {d: 'Trusses ' + c.steel.name, q: c.nTruss},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    {d: c.roofing + ' Sheets', q: numSheets},
                    {d: 'Ridge Cap', q: 1},
                    {d: 'Gable Barges', q: 4},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                if (c.infill !== 'none') mats.push({d: 'Gable Infill', q: 2});
                if (c.connection === 'riser') {
                    mats.push({d: 'Riser Elbows 75×75', q: riserCount});
                    mats.push({d: 'Riser Beam 100×50', q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                    if (c.riserGutter === 'quad') {
                        mats.push({d: 'Riser Beam Gutter 115mm Quad', q: 1});
                    }
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            } else {
                const numSheets = Math.ceil(c.L / sheetCover);
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                let beamCount;
                if (c.connection === 'riser') {
                    beamCount = 3;  // gutter + fascia + riser beam
                } else if (c.isRecvChan) {
                    beamCount = 1;  // gutter beam only (channel replaces back beam)
                } else {
                    beamCount = 2;  // gutter + back/flyover beam
                }
                const riserCount = c.riserQty;
                const effectiveW = (c.W - (c.connection === 'riser' ? c.riserOffset : 0)) / 1000;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9)) + 1;
                mats = [
                    {d: 'Posts 90×90×2', q: postCount},
                    {d: 'Beams 100×50×2', q: beamCount},
                    {d: 'Rafters ' + c.steel.name, q: c.nRafters},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    {d: c.roofing + ' Sheets', q: numSheets},
                    {d: 'Barge Flashings', q: 2},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                // Back flashing - skip for riser+box gutter AND receiving channel
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    mats.splice(5, 0, {d: 'Back Flashing', q: 1});
                }
                if (c.connection === 'riser') {
                    mats.splice(2, 0, {d: 'Riser Elbows 75×75', q: riserCount});
                    mats.splice(3, 0, {d: 'Riser Beam 100×50', q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                }
                if (c.connection === 'flyover') {
                    const strutCount = Math.max(2, Math.ceil(c.L / 1200));
                    mats.push({d: 'Flyover Struts 90×90', q: strutCount});
                    mats.push({d: 'Flyover Beam 150×50', q: 1});
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                    mats.push({d: 'Foam Backfill Strips (' + c.roofing + ')', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            }

            document.getElementById('matList').innerHTML = mats
                .map(m => `<div class="mat-row"><span>${m.d}</span><span class="mat-qty">${m.q}×</span></div>`).join('');
        }

        function animateAsm() {
            requestAnimationFrame(animateAsm);
            if (asmRend && asmScene && asmCam) {
                asmRend.render(asmScene, asmCam);
            }
        }

        // ==================== PRICING ====================
        const DEFAULT_RATES = {
            '90×90×2 RHS':     35.50,
            '76×38×1.6 RHS':   15.50,
            '75×50×2 RHS':     26.00,
            '100×50×2 RHS':    30.00,
            '150×50×2 RHS':    39.05,
            'Solarspan 75mm':  110.00,
            'Corrugated Colorbond': 12.04,
            'Quad Gutter 115mm': 18.00,
            'Box Gutter':      45.00,
            'Downpipe 90mm':   12.00,
            'Skilled Trade':   400.00,
            'Labourer':        250.00,
            'Electrician':     450.00
        };

        const DEFAULT_SELL_MARKUP = 1.35; // 35% default markup on cost for sell price
        let storedRates = {};
        let jobRows = [];      // {desc, qty, length, unitCost, unitSell, isAddon}
        let labourRows = [];   // {desc, trades, days, dayRate, sell}

        function loadRates() {
            try {
                const saved = localStorage.getItem('patioRates');
                storedRates = saved ? JSON.parse(saved) : { ...DEFAULT_RATES };
            } catch (e) {
                storedRates = { ...DEFAULT_RATES };
            }
        }

        function saveRates() {
            localStorage.setItem('patioRates', JSON.stringify(storedRates));
        }

        function renderRatesPanel() {
            const body = document.getElementById('ratesBody');
            body.innerHTML = Object.entries(storedRates).map(([k, v]) =>
                `<tr><td>${k}</td><td><input type="number" class="rate-input" step="0.01" value="${v.toFixed(2)}" onchange="updateRate('${k}', this.value)"></td></tr>`
            ).join('');
        }

        function updateRate(key, val) {
            storedRates[key] = parseFloat(val) || 0;
            saveRates();
            buildJobRows();
            renderJobTable();
            // Update labour day rates if a day rate changed
            if (['Skilled Trade', 'Labourer', 'Electrician'].includes(key)) {
                labourRows.forEach(r => {
                    if (matchDayRate(r.role) === storedRates[key]) {
                        r.dayRate = storedRates[key];
                    }
                });
                renderLabourTable();
            }
            updatePricing();
        }

        function toggleRatesPanel(el) {
            el.classList.toggle('collapsed');
            const panel = document.getElementById('ratesPanel');
            panel.style.display = el.classList.contains('collapsed') ? 'none' : '';
        }

        function matchRate(desc) {
            const d = desc.toLowerCase();
            if (d.includes('90×90') || d.includes('90x90')) return storedRates['90×90×2 RHS'] || 0;
            if (d.includes('76×38') || d.includes('76x38')) return storedRates['76×38×1.6 RHS'] || 0;
            if (d.includes('75×50') || d.includes('75x50') || d.includes('75×75') || d.includes('75x75')) return storedRates['75×50×2 RHS'] || 0;
            if (d.includes('150×50') || d.includes('150x50')) return storedRates['150×50×2 RHS'] || 0;
            if (d.includes('100×50') || d.includes('100x50')) return storedRates['100×50×2 RHS'] || 0;
            if (d.includes('solarspan')) return storedRates['Solarspan 75mm'] || 0;
            if (d.includes('sheet') && !d.includes('solarspan')) return storedRates['Corrugated Colorbond'] || 0;
            if (d.includes('box gutter')) return storedRates['Box Gutter'] || 0;
            if (d.includes('gutter') && !d.includes('box') && !d.includes('downpipe')) return storedRates['Quad Gutter 115mm'] || 0;
            if (d.includes('downpipe')) return storedRates['Downpipe 90mm'] || 0;
            return 0;
        }

        function getItemLength(desc) {
            const c = calc;
            const d = desc.toLowerCase();
            const Lm = c.L / 1000;
            const Wm = c.W / 1000;
            if (d.includes('post')) return c.postH / 1000;
            if (d.includes('beam') || d.includes('ridge') || d.includes('barge') || d.includes('flashing') || d.includes('channel') || d.includes('gutter') || d.includes('fascia board')) return Lm;
            if (d.includes('truss') || d.includes('rafter')) return c.rafter / 1000;
            if (d.includes('purlin')) return Lm;
            if (d.includes('sheet') && d.includes('solarspan')) return Wm;
            if (d.includes('sheet')) return c.rafter / 1000;
            if (d.includes('downpipe')) return c.postH / 1000;
            if (d.includes('strut')) return 0.5;
            if (d.includes('riser elbow')) return 0.5;
            if (d.includes('infill')) return c.rafter / 1000;
            if (d.includes('foam')) return Lm;
            return 1;
        }

        // Build jobRows from the materials list (called after rebuildAll)
        function buildJobRows() {
            const matRowEls = document.querySelectorAll('#matList .mat-row');
            // Preserve existing addon rows
            const addons = jobRows.filter(r => r.isAddon);
            jobRows = [];
            matRowEls.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length < 2) return;
                const desc = spans[0].textContent.trim();
                const qty = parseInt(spans[1].textContent.trim().replace('×', '')) || 1;
                const length = getItemLength(desc);
                const unitCost = matchRate(desc);
                const unitSell = +(unitCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc, qty, length, unitCost, unitSell, isAddon: false });
            });
            // Re-append addons
            addons.forEach(a => jobRows.push(a));
        }

        function renderJobTable() {
            const body = document.getElementById('jobBody');
            body.innerHTML = jobRows.map((r, i) => {
                const lineCost = r.qty * r.length * r.unitCost;
                const lineSell = r.qty * r.length * r.unitSell;
                const marginPct = lineSell > 0 ? ((lineSell - lineCost) / lineSell * 100) : 0;
                const marginCls = marginPct >= 0 ? 'margin-pos' : 'margin-neg';
                const removeBtn = r.isAddon ? `<button class="remove-btn" onclick="removeJobRow(${i})">×</button>` : '';
                return `<tr>
                    <td>${r.isAddon ? `<input type="text" class="cell-input wide" value="${r.desc}" onchange="jobRows[${i}].desc=this.value">` : r.desc}</td>
                    <td class="r"><input type="number" class="cell-input" value="${r.qty}" min="0" step="1" onchange="jobRows[${i}].qty=parseFloat(this.value)||0;renderJobTable();updatePricing()"></td>
                    <td class="r"><input type="number" class="cell-input" value="${r.length.toFixed(2)}" min="0" step="0.1" onchange="jobRows[${i}].length=parseFloat(this.value)||0;renderJobTable();updatePricing()"></td>
                    <td class="r"><input type="number" class="cell-input" value="${r.unitCost.toFixed(2)}" min="0" step="0.01" onchange="jobRows[${i}].unitCost=parseFloat(this.value)||0;renderJobTable();updatePricing()"></td>
                    <td class="r"><input type="number" class="cell-input" value="${r.unitSell.toFixed(2)}" min="0" step="0.01" onchange="jobRows[${i}].unitSell=parseFloat(this.value)||0;renderJobTable();updatePricing()"></td>
                    <td class="r mono">$${lineCost.toFixed(2)}</td>
                    <td class="r mono">$${lineSell.toFixed(2)}</td>
                    <td class="r ${marginCls}">${marginPct.toFixed(0)}%</td>
                    <td>${removeBtn}</td>
                </tr>`;
            }).join('');
        }

        function addAddon(desc) {
            jobRows.push({ desc: desc || '', qty: 1, length: 1, unitCost: 0, unitSell: 0, isAddon: true });
            renderJobTable();
            updatePricing();
        }

        function removeJobRow(idx) {
            jobRows.splice(idx, 1);
            renderJobTable();
            updatePricing();
        }

        // Labour rows: {role, trades, days, dayRate, sell}
        function matchDayRate(role) {
            const r = role.toLowerCase();
            if (r.includes('electrician')) return storedRates['Electrician'] || 450;
            if (r.includes('labourer')) return storedRates['Labourer'] || 250;
            return storedRates['Skilled Trade'] || 400;
        }

        function addLabourRole(role) {
            const dayRate = role ? matchDayRate(role) : (storedRates['Skilled Trade'] || 400);
            const trades = role.toLowerCase().includes('labourer') ? 1 : 2;
            const days = role.toLowerCase().includes('labourer') ? 1 : 1.5;
            labourRows.push({ role: role, trades: trades, days: days, dayRate: dayRate, sell: 0 });
            renderLabourTable();
            updatePricing();
        }

        function addLabourLine() {
            addLabourRole('Skilled (Patio Install)');
        }

        function removeLabourRow(idx) {
            labourRows.splice(idx, 1);
            renderLabourTable();
            updatePricing();
        }

        function renderLabourTable() {
            const body = document.getElementById('labourBody');
            let totalCost = 0, totalSell = 0;
            body.innerHTML = labourRows.map((r, i) => {
                const cost = r.trades * r.days * r.dayRate;
                const sell = r.sell || 0;
                totalCost += cost;
                totalSell += sell;
                const marginPct = sell > 0 ? ((sell - cost) / sell * 100) : 0;
                const marginCls = marginPct >= 0 ? 'margin-pos' : 'margin-neg';
                return `<tr>
                    <td><input type="text" class="cell-input wide" value="${r.role}" onchange="labourRows[${i}].role=this.value"></td>
                    <td class="r"><input type="number" class="cell-input" value="${r.trades}" min="1" step="1" onchange="labourRows[${i}].trades=parseFloat(this.value)||0;renderLabourTable();updatePricing()"></td>
                    <td class="r"><input type="number" class="cell-input" value="${r.days}" min="0.5" step="0.5" onchange="labourRows[${i}].days=parseFloat(this.value)||0;renderLabourTable();updatePricing()"></td>
                    <td class="r"><input type="number" class="cell-input" value="${r.dayRate.toFixed(2)}" min="0" step="10" onchange="labourRows[${i}].dayRate=parseFloat(this.value)||0;renderLabourTable();updatePricing()"></td>
                    <td class="r mono">$${cost.toFixed(2)}</td>
                    <td class="r"><input type="number" class="cell-input" value="${sell.toFixed(2)}" min="0" step="10" onchange="labourRows[${i}].sell=parseFloat(this.value)||0;renderLabourTable();updatePricing()"></td>
                    <td class="r ${marginCls}">${marginPct.toFixed(0)}%</td>
                    <td><button class="remove-btn" onclick="removeLabourRow(${i})">×</button></td>
                </tr>`;
            }).join('');
            const fmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            document.getElementById('labourTotalCost').textContent = fmt(totalCost);
            document.getElementById('labourTotalSell').textContent = fmt(totalSell);
        }

        function toggleLabourPanel(el) {
            el.classList.toggle('collapsed');
            const panel = document.getElementById('labourPanel');
            panel.style.display = el.classList.contains('collapsed') ? 'none' : '';
        }

        // ==================== COMPLEXITY GUIDE ====================
        function toggleComplexity(el) {
            el.classList.toggle('collapsed');
            const panel = document.getElementById('complexityPanel');
            panel.style.display = el.classList.contains('collapsed') ? 'none' : '';
        }

        function updateComplexity() {
            const ids = ['cxBuild', 'cxAccess', 'cxDistance', 'cxFooting', 'cxHeight'];
            let total = 0;
            ids.forEach(id => {
                let v = parseInt(document.getElementById(id).value) || 1;
                if (v < 1) v = 1; if (v > 10) v = 10;
                total += v;
            });
            const avg = total / ids.length;
            document.getElementById('cxScore').textContent = avg.toFixed(1);

            let suggestion, band, bandClass;
            if (avg <= 3) {
                suggestion = '25-30%'; band = 'Standard'; bandClass = 'easy';
            } else if (avg <= 6) {
                suggestion = '30-40%'; band = 'Moderate'; bandClass = 'medium';
            } else {
                suggestion = '40-50%'; band = 'Difficult'; bandClass = 'hard';
            }
            document.getElementById('cxSuggestion').textContent = suggestion;
            const bandEl = document.getElementById('cxBand');
            bandEl.textContent = band;
            bandEl.className = 'complexity-band ' + bandClass;
        }

        function updatePricing() {
            // Materials (non-addon job rows)
            let matCost = 0, matSell = 0;
            // Add-ons
            let addonCost = 0, addonSell = 0;

            jobRows.forEach(r => {
                const lc = r.qty * r.length * r.unitCost;
                const ls = r.qty * r.length * r.unitSell;
                if (r.isAddon) {
                    addonCost += lc;
                    addonSell += ls;
                } else {
                    matCost += lc;
                    matSell += ls;
                }
            });

            // Labour
            let labCost = 0, labSell = 0;
            labourRows.forEach(r => {
                labCost += r.trades * r.days * r.dayRate;
                labSell += r.sell || 0;
            });

            // Delivery
            const delCost = parseFloat(document.getElementById('deliveryCost').value) || 0;
            const delSell = parseFloat(document.getElementById('deliverySell').value) || 0;
            const delMarginPct = delSell > 0 ? ((delSell - delCost) / delSell * 100) : 0;
            const delMarginEl = document.getElementById('deliveryMargin');
            if (delCost > 0 || delSell > 0) {
                delMarginEl.textContent = delMarginPct.toFixed(0) + '%';
                delMarginEl.className = 'r mono ' + (delMarginPct >= 0 ? 'margin-pos' : 'margin-neg');
            } else {
                delMarginEl.textContent = '—';
                delMarginEl.className = 'r mono';
            }

            // Totals
            const totalCost = matCost + addonCost + labCost + delCost;
            const totalSell = matSell + addonSell + labSell + delSell;
            const gst = totalSell * 0.10;
            const totalIncGST = totalSell + gst;
            const margin = totalSell - totalCost;
            const marginPct = totalSell > 0 ? (margin / totalSell * 100) : 0;

            const fmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');

            // Cost Breakdown panel
            document.getElementById('sumMatCost').textContent = fmt(matCost);
            document.getElementById('sumAddonCost').textContent = fmt(addonCost);
            document.getElementById('sumLabourCost').textContent = fmt(labCost);
            document.getElementById('sumDeliveryCost').textContent = fmt(delCost);
            document.getElementById('sumTotalCost').textContent = fmt(totalCost);

            // Quote Breakdown panel
            document.getElementById('sumMatSell').textContent = fmt(matSell);
            document.getElementById('sumLabourSell').textContent = fmt(labSell);
            document.getElementById('sumDeliverySell').textContent = fmt(delSell);
            document.getElementById('sumExtrasSell').textContent = fmt(addonSell);
            document.getElementById('sumSubtotal').textContent = fmt(totalSell);
            document.getElementById('sumGST').textContent = fmt(gst);
            document.getElementById('sumTotalIncGST').textContent = fmt(totalIncGST);

            // Margin panel
            document.getElementById('sumTotalCostM').textContent = fmt(totalCost);
            document.getElementById('sumTotalSellM').textContent = fmt(totalSell);
            document.getElementById('sumMargin').textContent = fmt(margin) + ' (' + marginPct.toFixed(1) + '%)';
        }

        // ==================== PDF SHARED HELPERS ====================
        function getJobRef() {
            const el = document.getElementById('jobRef');
            return (el && el.value.trim()) || 'SW' + Date.now().toString().slice(-4);
        }
        function getClientName() { return (document.getElementById('clientName')?.value || '').trim() || 'Client'; }
        function getSiteAddress() { return (document.getElementById('siteAddress')?.value || '').trim(); }
        function getClientPhone() { return (document.getElementById('clientPhone')?.value || '').trim(); }
        function safeName(s) { return s.replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_'); }
        function todayStr() {
            const d = new Date();
            return d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();
        }
        function fmtDollars(v) { return '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ','); }

        function connectionLabel(conn) {
            const map = {freestanding:'Freestanding',fascia:'Fascia Channel',wall:'Wall Channel',fasciabeam:'Fascia Beam',riser:'Riser Beam',flyover:'Flyover'};
            return map[conn] || conn;
        }
        function roofingLabel(r) {
            const map = {corrugated:'Corrugated Colorbond',trimdek:'Trimdek',spandek:'Spandek',insulated:'Insulated Panel (Solarspan)'};
            return map[r] || r;
        }

        function buildScopeText() {
            const c = calc;
            const style = c.isGable ? 'Gable' : 'Skillion';
            const Lm = (c.lenInput / 1000).toFixed(1);
            const Wm = (c.projInput / 1000).toFixed(1);
            const conn = connectionLabel(c.connection);
            const roof = roofingLabel(c.roofing);
            return 'Supply and install a ' + style + ' patio, ' + Lm + 'm x ' + Wm + 'm, attached via ' + conn + '. ' +
                   'Roof: ' + roof + ' (' + sheetColor.name + '). Steel: ' + steelColor.name + '. Including gutters, downpipes and flashings.';
        }

        function capture3DImage() {
            try {
                if (asmRend && asmScene && asmCam) {
                    asmRend.render(asmScene, asmCam);
                    return asmRend.domElement.toDataURL('image/png');
                }
            } catch(e) { /* cross-origin or not ready */ }
            return null;
        }

        function getMaterialRows() {
            const rows = [];
            const els = document.querySelectorAll('#matList .mat-row');
            els.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length >= 2) {
                    const desc = spans[0].textContent.trim();
                    const qty = parseInt(spans[1].textContent.trim().replace('×', '')) || 1;
                    const length = getItemLength(desc);
                    rows.push({ desc, qty, length });
                }
            });
            return rows;
        }

        // SW Orange accent
        const SW_ORANGE = [242, 101, 34];  // #F26522
        const SW_DARK = [41, 60, 70];      // #293C46

        function pdfHeader(doc, title, jobRef) {
            // Orange header bar
            doc.setFillColor(...SW_ORANGE);
            doc.rect(0, 0, 210, 28, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(18);
            doc.setTextColor(255, 255, 255);
            doc.text('SecureWorks WA', 14, 13);
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.text('Patios  •  Carports  •  Pergolas', 14, 20);
            // Job ref right side
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text(jobRef, 196, 13, { align: 'right' });
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.text(todayStr(), 196, 20, { align: 'right' });
            // Title below header
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text(title, 14, 38);
            return 46;
        }

        function pdfFooter(doc) {
            const pageH = doc.internal.pageSize.getHeight();
            doc.setDrawColor(200, 200, 200);
            doc.line(14, pageH - 16, 196, pageH - 16);
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(130, 130, 130);
            doc.text('SecureWorks WA  |  ABN: XX XXX XXX XXX  |  Phone: (08) XXXX XXXX  |  info@secureworkswa.com.au', 105, pageH - 10, { align: 'center' });
        }

        function pdfClientBlock(doc, y) {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(80, 80, 80);
            const name = getClientName();
            const addr = getSiteAddress();
            const phone = getClientPhone();
            if (name) { doc.text('Client: ' + name, 14, y); y += 5; }
            if (addr) { doc.text('Site: ' + addr, 14, y); y += 5; }
            if (phone) { doc.text('Phone: ' + phone, 14, y); y += 5; }
            return y + 3;
        }

        // Simple table helper
        function pdfTable(doc, y, headers, rows, colWidths, opts) {
            opts = opts || {};
            const startX = opts.startX || 14;
            const rowH = opts.rowH || 6;
            const fontSize = opts.fontSize || 9;
            const headerBg = opts.headerBg || SW_DARK;
            const altBg = opts.altBg || [245, 245, 247];
            const totalW = colWidths.reduce((a, b) => a + b, 0);

            // Header row
            doc.setFillColor(...headerBg);
            doc.rect(startX, y, totalW, rowH + 1, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(fontSize - 1);
            doc.setTextColor(255, 255, 255);
            let cx = startX;
            headers.forEach((h, i) => {
                const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                doc.text(h, tx, y + rowH - 1, { align });
                cx += colWidths[i];
            });
            y += rowH + 1;

            // Data rows
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(fontSize);
            rows.forEach((row, ri) => {
                // Check page break
                if (y + rowH > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                if (ri % 2 === 1) {
                    doc.setFillColor(...altBg);
                    doc.rect(startX, y, totalW, rowH, 'F');
                }
                const isBold = row._bold;
                doc.setFont('helvetica', isBold ? 'bold' : 'normal');
                doc.setTextColor(...(isBold ? SW_DARK : [60, 60, 60]));
                cx = startX;
                row.forEach((cell, i) => {
                    const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                    const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                    doc.text(String(cell), tx, y + rowH - 1.5, { align });
                    cx += colWidths[i];
                });
                y += rowH;
            });
            return y + 2;
        }

        function toggleClientInfo(el) {
            el.classList.toggle('collapsed');
            const panel = document.getElementById('clientInfoPanel');
            panel.style.display = el.classList.contains('collapsed') ? 'none' : '';
        }

        // ==================== PDF 1: QUOTE (Client) ====================
        function generateQuotePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Quote', jobRef);
            y = pdfClientBlock(doc, y);

            // Date & validity
            doc.setFontSize(9);
            doc.setTextColor(100, 100, 100);
            doc.text('Date: ' + todayStr() + '    |    Quote valid for 30 days', 14, y);
            y += 8;

            // 3D render image
            const img = capture3DImage();
            if (img) {
                try {
                    doc.addImage(img, 'PNG', 14, y, 120, 68);
                    y += 72;
                } catch(e) { /* skip image */ }
            }

            // Scope description
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Scope of Works', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const scopeLines = doc.splitTextToSize(buildScopeText(), 178);
            doc.text(scopeLines, 14, y);
            y += scopeLines.length * 4.5 + 6;

            // Pricing table (sell only)
            const matSell = document.getElementById('sumMatSell').textContent;
            const labSell = document.getElementById('sumLabourSell').textContent;
            const delSell = document.getElementById('sumDeliverySell').textContent;
            const extrasSell = document.getElementById('sumExtrasSell').textContent;
            const subtotal = document.getElementById('sumSubtotal').textContent;
            const gst = document.getElementById('sumGST').textContent;
            const totalInc = document.getElementById('sumTotalIncGST').textContent;

            const priceRows = [];
            priceRows.push(['Materials', matSell]);
            priceRows.push(['Installation', labSell]);
            if (parseFloat(delSell.replace(/[$,]/g, '')) > 0) priceRows.push(['Delivery', delSell]);
            if (parseFloat(extrasSell.replace(/[$,]/g, '')) > 0) priceRows.push(['Extras', extrasSell]);

            // Separator rows
            const subRow = ['Subtotal (ex GST)', subtotal]; subRow._bold = true;
            priceRows.push(subRow);
            const gstRow = ['GST (10%)', gst]; gstRow._bold = true;
            priceRows.push(gstRow);
            const totalRow = ['TOTAL (inc GST)', totalInc]; totalRow._bold = true;
            priceRows.push(totalRow);

            y = pdfTable(doc, y, ['Description', 'Amount'], priceRows, [120, 62]);

            // Terms & conditions
            y += 4;
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Terms & Conditions', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(8);
            doc.setTextColor(80, 80, 80);
            const terms = [
                '• 50% deposit required to confirm booking. Balance due on completion.',
                '• Quote valid for 30 days from date of issue.',
                '• Council permits not included unless specified.',
                '• Price excludes any electrical, plumbing or council works unless listed above.',
                '• All work completed to Australian Standards and BCA requirements.'
            ];
            terms.forEach(t => {
                doc.text(t, 14, y);
                y += 4;
            });

            pdfFooter(doc);
            doc.save('Quote_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        // ==================== PDF 2: MATERIALS ORDER (Supplier) ====================
        function generateMaterialsOrderPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Materials Order', jobRef);

            // Delivery info
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(60, 60, 60);
            const addr = getSiteAddress();
            if (addr) { doc.text('Deliver to: ' + addr, 14, y); y += 5; }
            doc.text('Required by: ______________________', 14, y);
            y += 5;
            doc.text('Contact: ' + getClientName() + (getClientPhone() ? '  |  ' + getClientPhone() : ''), 14, y);
            y += 8;

            // Build materials grouped by category
            const mats = getMaterialRows();
            const c = calc;
            const steelName = c.steel ? c.steel.name : '76×38×1.6';
            const colour = steelColor.name;
            const sheetColour = sheetColor.name;

            // Categorise materials
            const categories = {
                'Steel': [],
                'Roofing': [],
                'Flashings & Trim': [],
                'Gutters & Drainage': [],
                'Fixings & Other': []
            };

            mats.forEach(m => {
                const d = m.desc.toLowerCase();
                const lengthM = (m.length).toFixed(2) + 'm';
                const col = d.includes('sheet') || d.includes('gutter') || d.includes('downpipe') || d.includes('flashing') || d.includes('barge') || d.includes('ridge') ? sheetColour : colour;
                const row = [m.desc, steelName, lengthM, String(m.qty), col, ''];

                if (d.includes('post') || d.includes('beam') || d.includes('rafter') || d.includes('truss') || d.includes('purlin') || d.includes('strut') || d.includes('riser')) {
                    row[1] = steelName;
                    categories['Steel'].push(row);
                } else if (d.includes('sheet')) {
                    row[1] = roofingLabel(c.roofing);
                    categories['Roofing'].push(row);
                } else if (d.includes('flashing') || d.includes('barge') || d.includes('ridge') || d.includes('channel') || d.includes('foam') || d.includes('infill')) {
                    row[1] = '';
                    categories['Flashings & Trim'].push(row);
                } else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow')) {
                    row[1] = '';
                    categories['Gutters & Drainage'].push(row);
                } else {
                    row[1] = '';
                    categories['Fixings & Other'].push(row);
                }
            });

            const colWidths = [50, 36, 22, 16, 30, 28];
            const tableHeaders = ['Item', 'Size', 'Length', 'Qty', 'Colour', 'Notes'];

            Object.entries(categories).forEach(([cat, rows]) => {
                if (rows.length === 0) return;
                // Check page break for category header + at least 2 rows
                if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_ORANGE);
                doc.text(cat, 14, y);
                y += 4;
                y = pdfTable(doc, y, tableHeaders, rows, colWidths, { leftAlignAll: true });
                y += 2;
            });

            // Flashing sketch section
            if (y + 55 > doc.internal.pageSize.getHeight() - 25) {
                pdfFooter(doc);
                doc.addPage();
                y = 20;
            }
            y += 4;
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_ORANGE);
            doc.text('Flashing Sketches', 14, y);
            y += 5;
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(130, 130, 130);
            doc.text('Sketch flashing profiles below — hand draw dimensions and bends', 14, y);
            y += 5;

            const boxW = 42;
            const boxH = 32;
            const gap = 4;
            const labels = ['Back Flashing', 'Barge Flashing L', 'Barge Flashing R', 'Other'];
            labels.forEach((label, i) => {
                const bx = 14 + i * (boxW + gap);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.3);
                doc.rect(bx, y, boxW, boxH);
                doc.setFontSize(7);
                doc.setTextColor(130, 130, 130);
                doc.text(label, bx + boxW / 2, y + boxH + 4, { align: 'center' });
            });

            pdfFooter(doc);
            doc.save('Materials_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        // ==================== PDF 3: WORK ORDER (Crew) ====================
        function generateWorkOrderPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Work Order', jobRef);
            y = pdfClientBlock(doc, y);

            const c = calc;
            // Scope
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Scope of Works', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const scopeLines = doc.splitTextToSize(buildScopeText(), 178);
            doc.text(scopeLines, 14, y);
            y += scopeLines.length * 4.5 + 4;

            // Key dimensions
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(9);
            doc.setTextColor(...SW_DARK);
            doc.text('Key Dimensions', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(60, 60, 60);
            const dims = (c.lenInput / 1000).toFixed(1) + 'm x ' + (c.projInput / 1000).toFixed(1) + 'm  |  Post Height: ' + (c.postH / 1000).toFixed(1) + 'm  |  Pitch: ' + c.pitch.toFixed(1) + '\u00B0  |  ' + (c.isGable ? 'Gable' : 'Skillion');
            doc.text(dims, 14, y);
            y += 8;

            // Labour allocation
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(10);
            doc.setTextColor(...SW_ORANGE);
            doc.text('Labour Allocation', 14, y);
            y += 5;

            const labRows = [];
            let labTotal = 0;
            labourRows.forEach(r => {
                const cost = r.trades * r.days * r.dayRate;
                labTotal += cost;
                labRows.push([r.role, String(r.trades), String(r.days), fmtDollars(r.dayRate), fmtDollars(cost)]);
            });
            const totalLabRow = ['TOTAL LABOUR', '', '', '', fmtDollars(labTotal)];
            totalLabRow._bold = true;
            labRows.push(totalLabRow);

            y = pdfTable(doc, y, ['Task', 'Trades', 'Days', 'Rate', 'Amount'], labRows, [56, 22, 22, 36, 46]);
            y += 2;

            // Materials checklist — TO BE DELIVERED
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(10);
            doc.setTextColor(...SW_ORANGE);
            doc.text('Materials \u2014 To Be Delivered (we order)', 14, y);
            y += 5;

            const mats = getMaterialRows();
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            mats.forEach(m => {
                if (y + 5 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                const lengthStr = m.length >= 1 ? m.length.toFixed(1) + 'm' : '';
                doc.rect(14, y - 2.5, 3, 3);  // checkbox
                doc.text(m.desc + '  \u00D7 ' + m.qty + (lengthStr ? '  @ ' + lengthStr : ''), 19, y);
                y += 5;
            });
            y += 4;

            // Materials — FROM STOCK
            if (y + 30 > doc.internal.pageSize.getHeight() - 25) {
                pdfFooter(doc);
                doc.addPage();
                y = 20;
            }
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(10);
            doc.setTextColor(...SW_ORANGE);
            doc.text('Materials \u2014 From Stock (crew brings)', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const stockItems = ['Tek screws (various)', 'Timber screws', 'Concrete anchors / Dynabolts', 'Silicone (clear + colour match)', 'Rivets', 'Touch-up paint'];
            stockItems.forEach(item => {
                doc.rect(14, y - 2.5, 3, 3);
                doc.text(item, 19, y);
                y += 5;
            });
            y += 4;

            // Equipment needed
            if (y + 30 > doc.internal.pageSize.getHeight() - 25) {
                pdfFooter(doc);
                doc.addPage();
                y = 20;
            }
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(10);
            doc.setTextColor(...SW_ORANGE);
            doc.text('Equipment Needed', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const equipItems = ['Ladder', 'Scaffold (if height >3m)', 'Post hole digger / auger'];
            equipItems.forEach(item => {
                doc.rect(14, y - 2.5, 3, 3);
                doc.text(item, 19, y);
                y += 5;
            });
            // Blank lines for extra notes
            for (let bl = 0; bl < 3; bl++) {
                doc.rect(14, y - 2.5, 3, 3);
                doc.setDrawColor(200, 200, 200);
                doc.line(19, y, 120, y);
                y += 5;
            }
            y += 4;

            // Install notes
            const notes = (document.getElementById('jobNotes')?.value || '').trim();
            if (notes) {
                if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(10);
                doc.setTextColor(...SW_ORANGE);
                doc.text('Install Notes', 14, y);
                y += 5;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(9);
                doc.setTextColor(60, 60, 60);
                const noteLines = doc.splitTextToSize(notes, 178);
                doc.text(noteLines, 14, y);
            }

            pdfFooter(doc);
            doc.save('WorkOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        function initPricing() {
            loadRates();
            renderRatesPanel();
            buildJobRows();
            renderJobTable();
            // Add default labour lines
            if (labourRows.length === 0) {
                labourRows.push({ role: 'Skilled (Patio Install)', trades: 2, days: 1.5, dayRate: storedRates['Skilled Trade'] || 400, sell: 0 });
                labourRows.push({ role: 'Labourer', trades: 1, days: 1, dayRate: storedRates['Labourer'] || 250, sell: 0 });
            }
            renderLabourTable();
            updateComplexity();
            updatePricing();
        }

        function rebuildAll() {
            getInputs();
            draw2DPlan();
            buildTruss3D();
            buildAsm3D();
            buildJobRows();
            renderJobTable();
            updatePricing();
        }

        function exportOrder() {
            const c = calc;
            alert('Export order for SW1772 - ' + c.roofStyle.toUpperCase() + ' PATIO\n' +
                  'Size: ' + c.lenInput + 'mm × ' + c.projInput + 'mm\n' +
                  'Orientation: ' + c.orientation + '\n' +
                  'Roofing: ' + c.roofing + '\n' +
                  'Connection: ' + c.connection);
        }

        // ==================== INIT ====================
        window.addEventListener('resize', () => {
            const tc = document.getElementById('trussViewport');
            if (trussCam) {
                trussCam.aspect = tc.clientWidth / tc.clientHeight;
                trussCam.updateProjectionMatrix();
                trussRend.setSize(tc.clientWidth, tc.clientHeight);
            }

            const ac = document.getElementById('asmViewport');
            if (asmCam && !ac.classList.contains('fullscreen')) {
                asmCam.aspect = ac.clientWidth / ac.clientHeight;
                asmCam.updateProjectionMatrix();
                asmRend.setSize(ac.clientWidth, ac.clientHeight);
            }
            draw2DPlan();
        });

        // Initialize
        updateUI();
        getInputs();
        draw2DPlan();
        initTruss3D();
        initAsm3D();
        initPricing();
    </script>
</body>
</html>
