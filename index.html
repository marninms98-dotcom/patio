
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureWorks WA - Patio Designer Pro V18</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/3.0.3/jspdf.umd.min.js"></script>
    <style>
        :root {
            --sw-orange: #F15A29;
            --sw-blue-dark: #293C46;
            --sw-white: #FFFFFF;
            --sw-bg: #F5F5F7;
            --sw-border: #E5E5E5;
            --sw-text: #1D1D1F;
            --sw-text-sec: #86868B;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: var(--sw-bg);
            color: var(--sw-text);
        }
        .header {
            background: var(--sw-white);
            border-bottom: 1px solid var(--sw-border);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo { display: flex; align-items: center; gap: 10px; }
        .header-logo { height: 32px; width: auto; }
        .job-badge { background: var(--sw-bg); padding: 6px 14px; border-radius: 16px; font-size: 13px; }
        .job-badge strong { color: var(--sw-orange); }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }
        .btn-primary { background: var(--sw-orange); color: white; }
        .btn-secondary { background: var(--sw-bg); color: var(--sw-text); border: 1px solid var(--sw-border); }
        .main { max-width: 1400px; margin: 0 auto; padding: 24px; display: flex; gap: 24px; align-items: flex-start; }
        .panel-left { flex: 0 0 45%; min-width: 0; overflow-y: auto; max-height: calc(100vh - 80px); }
        .panel-right { flex: 0 0 calc(55% - 24px); position: sticky; top: 80px; max-height: calc(100vh - 100px); overflow-y: auto; height: fit-content; }
        .main.full-width .panel-left { flex: 0 0 100%; max-height: none; }
        .main.full-width .panel-right { display: none; }
        /* Right panel cards */
        .rp-card { background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); overflow: hidden; margin-bottom: 16px; }
        .rp-card-hdr { padding: 12px 16px; border-bottom: 1px solid var(--sw-border); font-size: 14px; font-weight: 600; }
        .rp-card-body { padding: 16px; }
        .rp-summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .rp-summary-item { background: var(--sw-bg); border-radius: 8px; padding: 8px 10px; }
        .rp-summary-label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); }
        .rp-summary-value { font-size: 14px; font-weight: 600; font-family: 'SF Mono', monospace; }
        .rp-est-range { font-size: 20px; font-weight: 700; font-family: 'SF Mono', monospace; text-align: center; padding: 8px 0; }
        .rp-est-label { font-size: 11px; color: var(--sw-text-sec); text-align: center; }
        .rp-est-btn { margin-top: 12px; }
        .rp-est-btn .btn { width: 100%; text-align: center; }
        .section {
            background: #fff;
            border-radius: 0;
            margin-bottom: 0;
            overflow: hidden;
        }
        .section-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--sw-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .section-title { font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; color: #333; }
        .section-subtitle { display: none; }
        .section-body { padding: 16px 20px; }

        /* Basics layout helpers */
        .basics-group { margin-bottom: 0; }
        .basics-group-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .basics-divider { height: 1px; background: var(--sw-border); margin: 14px 0; }
        .basics-grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        .basics-grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .basics-grid-4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 8px; }
        .basics-field label { font-size: 11px; font-weight: 500; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .basics-field input, .basics-field select, .basics-field textarea { width: 100%; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 12px; }
        .basics-field input:focus, .basics-field select:focus { outline: none; border-color: var(--sw-orange); }
        .basics-colours { display: flex; gap: 24px; align-items: flex-start; }
        .basics-colour-block { flex: 1; }
        .basics-colour-label { font-size: 10px; color: var(--sw-text-sec); margin-bottom: 4px; }
        .extras-cost { margin-top: 6px; }
        .extras-cost label { font-size: 10px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .extras-cost input { width: 100%; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 12px; }
        .readonly-field { background: #f5f5f5 !important; color: #666 !important; cursor: not-allowed; }
        .helper-text { font-size: 11px; color: var(--sw-text-sec); margin-top: 5px; }

        .setup-grid { display: grid; grid-template-columns: 320px 1fr 280px; gap: 20px; }
        .options-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 16px; }
        .setup-card { background: var(--sw-bg); border-radius: 10px; padding: 14px; }
        .setup-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 10px; }
        .field { margin-bottom: 10px; }
        .field-label { display: flex; justify-content: space-between; font-size: 12px; font-weight: 500; margin-bottom: 3px; }
        .field-unit { font-size: 10px; color: var(--sw-text-sec); }
        .field-input { width: 100%; padding: 7px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; }
        .field-input:focus { outline: none; border-color: var(--sw-orange); }
        .field-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .plan-2d { background: #EEF1F4; border-radius: 8px; height: 220px; }
        .plan-2d canvas { width: 100%; height: 100%; }
        .color-chips { display: flex; flex-wrap: wrap; gap: 5px; }
        .color-chip { width: 24px; height: 24px; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
        .color-chip.active { border-color: var(--sw-text); }
        .color-label { font-size: 11px; color: var(--sw-text-sec); margin-top: 6px; }
        .calc-display { background: var(--sw-blue-dark); border-radius: 8px; padding: 10px; margin-top: 10px; color: white; }
        .calc-row { display: flex; justify-content: space-between; font-size: 11px; padding: 3px 0; }
        .calc-label { opacity: 0.7; }
        .calc-value { font-weight: 600; font-family: 'SF Mono', monospace; color: var(--sw-orange); }

        /* Structural Sizing Component */
        .struct-sizing { border: 1px solid var(--sw-border); border-radius: 8px; overflow: hidden; }
        .struct-row { display: grid; grid-template-columns: 100px 1fr 1fr; align-items: center; gap: 8px; padding: 7px 12px; border-bottom: 1px solid var(--sw-border); }
        .struct-row:last-child { border-bottom: none; }
        .struct-label { font-size: 11px; font-weight: 600; color: var(--sw-text); white-space: nowrap; }
        .struct-qty { display: flex; align-items: center; gap: 0; }
        .struct-qty button { width: 26px; height: 26px; border: 1px solid var(--sw-border); background: #fff; cursor: pointer; font-size: 14px; line-height: 1; color: var(--sw-text); }
        .struct-qty button:first-child { border-radius: 4px 0 0 4px; }
        .struct-qty button:last-child { border-radius: 0 4px 4px 0; }
        .struct-qty button:hover { background: var(--sw-bg); }
        .struct-qty input, .struct-qty span { width: 40px; height: 26px; border: 1px solid var(--sw-border); border-left: none; border-right: none; text-align: center; font-size: 12px; font-weight: 600; font-family: 'SF Mono', monospace; background: #fff; line-height: 26px; }
        .struct-qty input { padding: 0; }
        .struct-size select { width: 100%; padding: 4px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 11px; background: #fff; }
        .struct-size select:focus { outline: none; border-color: var(--sw-orange); }
        .struct-configure-btn { padding: 4px 12px; border: 1px solid var(--sw-accent); border-radius: 4px; background: #fff; color: var(--sw-accent); font-size: 11px; font-weight: 600; cursor: pointer; }
        .struct-configure-btn:hover { background: var(--sw-accent); color: #fff; }
        .struct-row.warn { background: #FEF9E7; }
        .struct-row.warn .struct-label { color: #7D6608; }
        .struct-warn-tip { grid-column: 1 / -1; font-size: 10px; color: #7D6608; padding: 0 0 2px 0; }

        .truss-viewport { background: linear-gradient(180deg, #E8ECF0 0%, #D5DAE0 100%); border-radius: 10px; min-height: 500px; height: 60vh; max-height: 800px; position: relative; overflow: hidden; }
        .truss-viewport:fullscreen { max-height: none; height: 100vh; border-radius: 0; }
        .truss-viewport:fullscreen canvas { border-radius: 0; }
        .truss-fullscreen-btn { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); border: none; border-radius: 6px; padding: 5px 10px; font-size: 13px; cursor: pointer; z-index: 50; color: var(--sw-text-sec); }
        .truss-fullscreen-btn:hover { background: white; color: var(--sw-text); }
        .truss-dim-toggle { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); border-radius: 6px; padding: 5px 10px; font-size: 11px; z-index: 50; display: flex; align-items: center; gap: 4px; cursor: pointer; color: var(--sw-text-sec); user-select: none; }
        .truss-dim-toggle input { accent-color: var(--sw-orange); }
        .truss-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .truss-viewport canvas:active { cursor: grabbing; }
        .truss-view-btns { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.9); padding: 3px; border-radius: 6px; }
        .truss-view-btn { padding: 5px 10px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .truss-view-btn.active { background: var(--sw-blue-dark); color: white; }
        .truss-panel-vertical { display: flex; flex-direction: column; gap: 12px; margin-top: 12px; }
        .truss-cards-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        .truss-card { background: var(--sw-bg); border-radius: 10px; padding: 12px; }
        .truss-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .spec-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .spec-item { background: white; border-radius: 6px; padding: 8px; text-align: center; }
        .spec-label { font-size: 9px; color: var(--sw-text-sec); }
        .spec-value { font-size: 15px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .spec-value.hl { color: var(--sw-orange); }
        .fab-box { background: var(--sw-blue-dark); border-radius: 10px; padding: 12px; color: white; }
        .fab-box h4 { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; margin-bottom: 8px; }
        .fab-line { font-family: 'SF Mono', monospace; font-size: 11px; padding: 4px 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-bottom: 2px; }
        .truss-config { display: flex; gap: 12px; padding: 8px 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; }
        .truss-config-item { display: flex; align-items: center; gap: 6px; }
        .truss-config-item > label { font-size: 11px; font-weight: 600; color: var(--sw-text); display: flex; align-items: center; gap: 4px; cursor: pointer; white-space: nowrap; }
        .truss-config-item input[type="checkbox"] { accent-color: var(--sw-orange); }
        .truss-opt-fields { display: flex; gap: 6px; align-items: center; }
        .truss-opt-fields label { font-size: 10px; color: var(--sw-text-sec); display: flex; align-items: center; gap: 3px; white-space: nowrap; }
        .truss-opt-fields input[type="number"] { width: 52px; font-size: 11px; padding: 2px 4px; border: 1px solid var(--sw-border); border-radius: 4px; }
        .truss-opt-fields span { font-size: 9px; color: var(--sw-text-sec); }

        .gutter-inputs { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        .gutter-inputs label { font-size: 10px; color: var(--sw-text-sec); display: flex; flex-direction: column; gap: 2px; }
        .gutter-inputs input, .gutter-inputs select { font-size: 11px; padding: 4px 6px; border: 1px solid var(--sw-border); border-radius: 4px; }
        .gutter-inputs small { font-size: 8px; color: #aaa; }
        .gutter-results { margin-top: 10px; }
        .gutter-results h5 { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin: 10px 0 6px; }
        .gutter-result-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; }
        .gutter-result-item { background: white; border-radius: 6px; padding: 6px 8px; text-align: center; }
        .gutter-result-item .r-label { font-size: 8px; color: var(--sw-text-sec); text-transform: uppercase; }
        .gutter-result-item .r-value { font-size: 14px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .gutter-status { margin: 8px 0; }
        .gutter-badge { display: inline-block; padding: 3px 10px; border-radius: 4px; font-size: 11px; font-weight: 700; }
        .gutter-badge.ok { background: #e8f5e9; color: #2e7d32; }
        .gutter-badge.warn { background: #fff3e0; color: #ef6c00; }
        .gutter-badge.fail { background: #ffebee; color: #c62828; }
        .gutter-issues { font-size: 10px; color: #c62828; margin-top: 4px; }

        .gutter-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .gutter-modal { background: white; border-radius: 12px; max-width: 1000px; width: 95%; max-height: 90vh; box-shadow: 0 20px 60px rgba(0,0,0,0.3); display: flex; flex-direction: column; overflow: hidden; }
        .gutter-modal-header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--sw-border); }
        .gutter-modal-header h3 { font-size: 16px; font-weight: 600; margin: 0; }
        .gutter-modal-header .close-btn { width: 28px; height: 28px; border: none; background: none; font-size: 18px; cursor: pointer; border-radius: 6px; color: var(--sw-text-sec); }
        .gutter-modal-header .close-btn:hover { background: #f0f0f0; }
        .gutter-modal-body { display: grid; grid-template-columns: 1fr 1fr; gap: 0; flex: 1; overflow: hidden; min-height: 0; }
        .gutter-modal-left { padding: 16px 20px; overflow-y: auto; border-right: 1px solid var(--sw-border); }
        .gutter-modal-right { position: relative; background: #f8f9fa; min-height: 400px; }
        .gutter-modal-right canvas { width: 100%; height: 100%; }
        .gutter-modal-footer { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; border-top: 1px solid var(--sw-border); }
        .gutter-modal-footer .btn-save { padding: 8px 20px; border-radius: 6px; border: none; background: var(--sw-orange); color: white; font-size: 13px; font-weight: 500; cursor: pointer; }
        .gutter-modal-footer .btn-save:hover { background: #e05a1a; }
        .gutter-modal-footer .btn-remove { padding: 8px 16px; border-radius: 6px; border: 1px solid var(--sw-border); background: none; font-size: 12px; color: var(--sw-text-sec); cursor: pointer; }
        .gutter-modal-footer .btn-remove:hover { border-color: #c62828; color: #c62828; }
        .truss-box-gutter-btn { padding: 4px 12px; border: 1px solid var(--sw-border); border-radius: 4px; background: white; font-size: 10px; cursor: pointer; font-weight: 600; }
        .truss-box-gutter-btn.active { background: var(--sw-orange); color: white; border-color: var(--sw-orange); }

        .asm-viewport { height: 520px; background: linear-gradient(180deg, #D4D9E0 0%, #BCC4CC 100%); border-radius: 10px; position: relative; }
        .asm-viewport canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        .asm-viewport canvas:active { cursor: grabbing; }
        .asm-viewport.fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100vw; height: 100vh; z-index: 1000; border-radius: 0; }
        .asm-viewport.fullscreen-mode { width: 100vw !important; height: 100vh !important; border-radius: 0; background: #1a1a1a; }
        .asm-viewport.fullscreen-mode:fullscreen { width: 100vw; height: 100vh; }
        .layer-panel { position: absolute; top: 12px; left: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; min-width: 140px; }
        .layer-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .layer-item { display: flex; align-items: center; gap: 6px; padding: 4px 0; cursor: pointer; font-size: 11px; }
        .layer-check { width: 14px; height: 14px; border: 2px solid var(--sw-border); border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 9px; color: white; }
        .layer-item.active .layer-check { background: var(--sw-orange); border-color: var(--sw-orange); }
        .layer-item.active .layer-check::after { content: 'âœ“'; }
        .mat-panel { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; width: 200px; }
        .mat-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .mat-row { display: flex; justify-content: space-between; font-size: 10px; padding: 3px 0; border-bottom: 1px solid var(--sw-border); }
        .mat-row:last-child { border-bottom: none; }
        .mat-qty { font-weight: 600; color: var(--sw-orange); }
        .view-panel { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.95); padding: 3px; border-radius: 6px; }
        .view-btn { padding: 5px 12px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .view-btn.active { background: var(--sw-blue-dark); color: white; }
        .fullscreen-btn { position: absolute; top: 12px; right: 230px; background: rgba(255,255,255,0.95); border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; font-size: 11px; }
        .fullscreen-btn:hover { background:#e0e0e0; }
        /* Toolbar strip at top of viewport */
        .asm-toolbar { position:absolute; top:12px; right:12px; display:flex; gap:6px; align-items:center; z-index:40; }
        .asm-tool-btn { padding:5px 10px; border:1px solid rgba(0,0,0,0.15); background:rgba(255,255,255,0.95); border-radius:5px; cursor:pointer; font-size:11px; color:var(--sw-text-sec); transition:all 0.15s; white-space:nowrap; }
        .asm-tool-btn:hover { background:#e0e0e0; border-color:rgba(0,0,0,0.25); }
        .asm-tool-btn.active { background:var(--sw-blue-dark); color:white; border-color:var(--sw-blue-dark); }
        .asm-tool-btn.primary { background:var(--sw-orange); color:white; border-color:var(--sw-orange); }
        .asm-tool-btn.primary:hover { background:#d14d12; }
        .asm-tool-sep { width:1px; height:20px; background:rgba(0,0,0,0.12); }
        #asmSectionSelect { padding:4px 8px; border:1px solid rgba(0,0,0,0.15); border-radius:5px; font-size:11px; background:rgba(255,255,255,0.95); cursor:pointer; }
        /* Dimension label overlay (CSS2DRenderer-style, but using sprites for export) */
        .dim-label-overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; overflow:hidden; }
        .tooltip { position: absolute; background: rgba(41,60,70,0.95); color: white; padding: 10px 14px; border-radius: 8px; font-size: 11px; pointer-events: none; opacity: 0; transition: opacity 0.15s; z-index: 50; max-width: 240px; }
        .tooltip.visible { opacity: 1; }
        .tooltip-title { font-weight: 600; font-size: 12px; color: var(--sw-orange); margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .tooltip-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .tooltip-label { opacity: 0.7; }
        .tooltip-value { font-weight: 500; font-family: 'SF Mono', monospace; }

        /* Polycarb preview blocks */
        .pc-block { width: 16px; height: 20px; border-radius: 2px; border: 1px solid #ccc; }
        .pc-block.steel { background: #6B7B8D; border-color: #5A6A7C; }
        .pc-block.polycarb { border-color: #8ECAE6; }

        /* Pricing Section - Card Layout */
        .pricing-cards-container { display: flex; flex-direction: column; gap: 24px; }
        .q-card { background: #fff; border-radius: 8px; padding: 20px 24px; box-shadow: 0 1px 4px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04); }
        .q-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .q-card-title { font-size: 15px; font-weight: 600; color: var(--sw-text); display: flex; align-items: center; gap: 8px; }
        .q-card-title .status-ok { color: #34C759; }
        .q-card-title .status-warn { color: #FF9500; }
        .q-card-amount { font-size: 22px; font-weight: 700; font-family: 'SF Mono', monospace; color: var(--sw-text); }
        .q-card-sub { font-size: 13px; color: var(--sw-text-sec); margin-bottom: 0; }
        .q-card-edit { font-size: 13px; color: var(--sw-orange); cursor: pointer; font-weight: 500; background: none; border: none; padding: 0; }
        .q-card-edit:hover { text-decoration: underline; }
        /* Labour inline */
        .labour-inline { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
        .labour-inline .li-input { width: 60px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: center; }
        .labour-inline .li-input:focus { outline: none; border-color: var(--sw-orange); }
        .labour-inline .li-input.wide { width: 80px; }
        .labour-inline .li-label { font-size: 13px; color: var(--sw-text-sec); }
        .labour-inline .li-equals { font-size: 14px; font-weight: 600; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .labour-sell-row { display: flex; align-items: center; gap: 10px; margin-top: 10px; padding-top: 10px; border-top: 1px solid #f0f0f0; }
        .labour-sell-row label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .labour-sell-row input { width: 120px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: right; }
        .labour-sell-row input:focus { outline: none; border-color: var(--sw-orange); }
        /* Extras pills & rows */
        .extras-pills { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
        .extras-pill { padding: 7px 14px; border-radius: 20px; border: 1px solid var(--sw-border); background: #fff; font-size: 13px; cursor: pointer; color: var(--sw-text); transition: all 0.15s; }
        .extras-pill:hover { border-color: var(--sw-orange); color: var(--sw-orange); background: #FFF5F0; }
        .extras-rows { margin-top: 16px; display: flex; flex-direction: column; gap: 8px; }
        .extras-row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #f9f9f9; border-radius: 6px; border: 1px solid #f0f0f0; }
        .extras-row .ex-desc { flex: 1; font-size: 13px; font-weight: 500; color: var(--sw-text); }
        .extras-row .ex-field { display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--sw-text-sec); }
        .extras-row .ex-input { width: 80px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: right; }
        .extras-row .ex-input:focus { outline: none; border-color: var(--sw-orange); }
        .extras-row .ex-input.desc-input { width: 160px; text-align: left; font-family: inherit; }
        .extras-row .ex-remove { background: none; border: none; color: #ccc; cursor: pointer; font-size: 18px; padding: 0 4px; line-height: 1; transition: color 0.15s; }
        .extras-row .ex-remove:hover { color: #FF3B30; }
        /* Pricing sub-sections */
        .pricing-subsection { background: #fff; border-radius: 8px; margin-bottom: 12px; box-shadow: 0 1px 4px rgba(0,0,0,0.06); overflow: hidden; }
        .pricing-sub-hdr { padding: 10px 16px; font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; border-left: 4px solid transparent; background: var(--sw-bg); display: flex; justify-content: space-between; align-items: center; }
        .pricing-sub-body { padding: 12px 16px; }
        .pricing-subtotal { display: flex; align-items: center; gap: 8px; padding: 10px 0 2px; border-top: 2px solid var(--sw-border); margin-top: 8px; font-size: 13px; font-weight: 600; }
        .pricing-subtotal span:nth-child(2) { font-family: 'SF Mono', monospace; }
        /* Patio materials table */
        .pm-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .pm-table th { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 4px 6px; border-bottom: 1px solid var(--sw-border); text-align: left; white-space: nowrap; }
        .pm-table th.r { text-align: right; }
        .pm-table td { padding: 5px 6px; border-bottom: 1px solid #f0f0f0; vertical-align: middle; }
        .pm-table td.r { text-align: right; font-family: 'SF Mono', monospace; font-size: 10px; }
        .pm-table td.cost-cell { color: var(--sw-text-sec); }
        .pm-table td .pm-sell-input { width: 70px; padding: 2px 4px; border: none; border-bottom: 1px dashed var(--sw-border); font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; background: transparent; }
        .pm-table td .pm-sell-input:focus { outline: none; border-bottom-color: var(--sw-orange); background: #FFF5F0; }
        .pm-table .pm-cat-hdr td { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding-top: 10px; border-bottom: 1px solid var(--sw-border); background: var(--sw-bg); }
        .pm-table .markup-badge { display: inline-block; font-size: 9px; padding: 1px 5px; border-radius: 8px; background: #f0f0f0; color: var(--sw-text-sec); font-weight: 600; }
        .pm-table .markup-badge.high { background: #E8F5E9; color: #2E7D32; }
        .pm-table .markup-badge.low { background: #FFF3E0; color: #E65100; }
        .pm-table .pm-dupe-btn { background: none; border: 1px solid transparent; color: #ccc; cursor: pointer; font-size: 14px; padding: 0 2px; line-height: 1; transition: all 0.15s; border-radius: 3px; }
        .pm-table tr:hover .pm-dupe-btn { color: var(--sw-orange); border-color: var(--sw-border); }
        .pm-table .pm-dupe-btn:hover { color: #fff; background: var(--sw-orange); border-color: var(--sw-orange); }
        /* Additional materials table */
        .am-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .am-table th { font-size: 10px; font-weight: 600; text-transform: uppercase; color: var(--sw-text-sec); padding: 4px 6px; border-bottom: 1px solid var(--sw-border); text-align: left; }
        .am-table th.r { text-align: right; }
        .am-table td { padding: 4px 6px; border-bottom: 1px solid #f0f0f0; }
        .am-table input[type="text"] { width: 100%; padding: 3px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 11px; }
        .am-table input[type="number"] { width: 65px; padding: 3px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; }
        .am-table .am-del { background: none; border: none; color: transparent; cursor: pointer; font-size: 14px; padding: 0 4px; transition: color 0.15s; }
        .am-table tr:hover .am-del { color: #ccc; }
        .am-table .am-del:hover { color: #FF3B30; }
        .am-quick-add { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; margin-top: 10px; padding-top: 8px; border-top: 1px dashed #e8e8e8; }
        .am-table .am-empty-row td { opacity: 0.5; }
        .am-table .am-empty-row:focus-within td { opacity: 1; }
        .am-table input:focus { outline: none; border-color: var(--sw-orange) !important; }
        /* Hidden compat elements */
        .hidden-compat { display: none; }
        /* Total card */
        .total-card { background: #fff; border-radius: 8px 8px 0 0; padding: 16px 20px; box-shadow: 0 -2px 8px rgba(0,0,0,0.08); text-align: center; position: sticky; bottom: 0; z-index: 10; border-top: 2px solid var(--sw-border); }
        .total-breakdown { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; margin-top: 6px; font-size: 11px; color: var(--sw-text-sec); font-family: 'SF Mono', monospace; }
        .total-breakdown span { white-space: nowrap; }
        .total-breakdown .bd-label { color: #999; }
        .total-breakdown .bd-val { font-weight: 600; color: var(--sw-text); }
        .total-amount { font-size: 32px; font-weight: 800; font-family: 'SF Mono', monospace; color: var(--sw-text); letter-spacing: -0.5px; }
        .total-label { font-size: 13px; color: var(--sw-text-sec); margin-top: 2px; }
        .total-margin { font-size: 14px; font-weight: 600; margin-top: 10px; font-family: 'SF Mono', monospace; }
        .total-margin.margin-green { color: #34C759; }
        .total-margin.margin-orange { color: #FF9500; }
        .total-margin.margin-red { color: #FF3B30; }
        /* Notes fields */
        .notes-field { margin-bottom: 10px; }
        .notes-field:last-child { margin-bottom: 0; }
        .notes-label { display: block; font-size: 11px; font-weight: 600; margin-bottom: 4px; color: var(--sw-text); }
        .notes-field textarea { width: 100%; font-size: 11px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 6px; resize: vertical; font-family: inherit; }
        .notes-field textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Totals table */
        .totals-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .totals-table th { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 4px 8px; border-bottom: 1px solid var(--sw-border); text-align: left; }
        .totals-table th.r { text-align: right; }
        .totals-table td { padding: 6px 8px; border-bottom: 1px solid #f0f0f0; }
        .totals-table td.r { text-align: right; }
        .totals-table td.mono { font-family: 'SF Mono', monospace; font-size: 11px; }
        .totals-table .tt-subtotal td { border-top: 2px solid var(--sw-border); font-weight: 600; padding-top: 8px; }
        .totals-table .tt-gst td { color: var(--sw-text-sec); font-size: 11px; }
        .totals-table .tt-total td { font-weight: 800; font-size: 14px; background: var(--sw-bg); border-top: 2px solid var(--sw-text); }
        .totals-table .tt-margin td { font-weight: 600; font-family: 'SF Mono', monospace; font-size: 11px; border-bottom: none; }
        .btn-generate-quote { display: block; width: 100%; padding: 14px; border: none; border-radius: 8px; background: #F26522; color: white; font-size: 15px; font-weight: 600; cursor: pointer; margin-top: 20px; letter-spacing: 0.3px; transition: background 0.15s; }
        .btn-generate-quote:hover { background: #e05a1a; }
        .total-links { display: flex; justify-content: center; gap: 24px; margin-top: 14px; }
        .total-links a { font-size: 13px; color: var(--sw-text-sec); cursor: pointer; text-decoration: none; }
        .total-links a:hover { color: var(--sw-orange); }
        /* Settings gear */
        .settings-gear { background: none; border: none; cursor: pointer; font-size: 16px; color: var(--sw-text-sec); padding: 4px; transition: color 0.15s; }
        .settings-gear:hover { color: var(--sw-orange); }
        /* Materials modal */
        .mat-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .mat-modal { background: white; border-radius: 12px; padding: 24px; max-width: 800px; width: 95%; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .mat-modal h3 { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
        .mat-modal-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; }
        .mat-modal-controls label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .mat-modal-controls input { width: 60px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: center; }
        .mat-modal-controls input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-controls .btn-apply { padding: 6px 14px; border-radius: 6px; border: 1px solid var(--sw-orange); background: #FFF5F0; color: var(--sw-orange); font-size: 12px; font-weight: 500; cursor: pointer; }
        .mat-modal-controls .btn-apply:hover { background: var(--sw-orange); color: white; }
        .mat-modal-controls .toggle-wrap { display: flex; align-items: center; gap: 6px; margin-left: auto; }
        .mat-modal-controls .toggle-wrap input[type="checkbox"] { accent-color: var(--sw-orange); }
        .mat-modal-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .mat-modal-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 8px 8px; border-bottom: 2px solid var(--sw-border); }
        .mat-modal-table th.r { text-align: right; }
        .mat-modal-table td { padding: 6px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; vertical-align: middle; }
        .mat-modal-table td.r { text-align: right; }
        .mat-modal-table td.mono { font-family: 'SF Mono', monospace; font-size: 12px; }
        .mat-modal-table tr:last-child td { border-bottom: none; }
        .mat-modal-table input { width: 80px; padding: 5px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .mat-modal-table input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-table .markup-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 500; background: #E8F5E9; color: #2E7D32; }
        .mat-modal-table .markup-badge.custom { background: #FFF3E0; color: #E65100; }
        .mat-modal-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--sw-border); }
        .mat-modal-footer .mat-total { font-size: 16px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .mat-modal-footer .btn-done { padding: 10px 28px; border-radius: 6px; border: none; background: var(--sw-orange); color: white; font-size: 14px; font-weight: 500; cursor: pointer; }
        .mat-modal-footer .btn-done:hover { background: #e05a1a; }
        .mat-modal-footer .btn-add-custom { padding: 8px 16px; border-radius: 6px; border: 1px dashed var(--sw-border); background: none; font-size: 12px; color: var(--sw-text-sec); cursor: pointer; }
        .mat-modal-footer .btn-add-custom:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        /* Rates modal */
        .rates-modal { background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .rates-modal h3 { font-size: 16px; font-weight: 600; margin-bottom: 16px; }
        .rate-input { width: 80px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .rate-input:focus { outline: none; border-color: var(--sw-orange); }
        .pricing-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .pricing-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 6px 8px; border-bottom: 2px solid var(--sw-border); }
        .pricing-table td { padding: 5px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; }
        .pricing-table th.r, .pricing-table td.r { text-align: right; }
        .pricing-table tr:last-child td { border-bottom: none; }
        /* Hidden elements for PDF compatibility */
        .pdf-data { display: none; }
        /* Collapsible sections */
        .collapse-header {
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background 0.15s ease;
        }
        .collapse-header:hover { background: #fafafa; }
        .collapse-header .section-title { font-size: 13px; font-weight: 600; }
        .collapse-arrow {
            font-size: 12px;
            color: #999;
            transition: transform 0.2s ease;
            flex-shrink: 0;
            margin-left: 12px;
        }
        .collapse-header:not(.collapsed) .collapse-arrow { transform: rotate(90deg); }
        .collapse-header.collapsed { border-bottom: none; }
        .collapse-body { overflow: hidden; transition: max-height 0.3s ease, opacity 0.2s ease; max-height: 2000px; opacity: 1; }
        .collapse-body.shut { max-height: 0; opacity: 0; }
        /* Warning dot indicator on section header */
        .section-warn-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: #FF9500; display: none; flex-shrink: 0; margin-left: 8px;
        }
        .section-warn-dot.active { display: inline-block; }

        /* Section Groups */
        .section-group {
            margin-bottom: 12px;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            overflow: hidden;
            background: #fff;
        }
        .section-group .section {
            margin-bottom: 0;
            border-radius: 0;
            border: none;
            border-bottom: 1px solid #f0f0f0;
        }
        .section-group .section:last-child { border-bottom: none; }
        .section-group-header {
            padding: 10px 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #F97316;
            border-left: 4px solid #F97316;
            background: rgba(249,115,22,0.04);
            border-bottom: 1px solid #f0f0f0;
        }
        #group-build > .section-group-header {
            color: #3B82F6;
            border-left-color: #3B82F6;
            background: rgba(59,130,246,0.04);
        }
        #group-sale > .section-group-header {
            color: #22C55E;
            border-left-color: #22C55E;
            background: rgba(34,197,94,0.04);
        }
        /* Sticky Price Card (right panel) */
        .rp-price-card {
            background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            overflow: hidden; margin-bottom: 16px;
            border-left: 4px solid #28A745;
        }
        .rp-price-card .rp-price-body { padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; gap: 12px; }
        .rp-price-total { font-size: 20px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .rp-price-sqm { font-size: 11px; color: var(--sw-text-sec); }
        .rp-price-link { font-size: 11px; color: #2980B9; cursor: pointer; text-decoration: underline; }
        .rp-price-margin { font-size: 11px; font-weight: 600; font-family: 'SF Mono', monospace; margin-top: 2px; }
        .rp-breakdown { padding: 0 16px 6px; border-top: 1px solid #f0f0f0; }
        .rp-bd-row { display: flex; justify-content: space-between; font-size: 11px; color: var(--sw-text-sec); padding: 2px 0; }
        .rp-bd-row span:last-child { font-family: 'SF Mono', monospace; font-size: 10px; }
        .rp-bd-total { font-weight: 600; color: var(--sw-text); border-top: 1px solid var(--sw-border); padding-top: 4px; margin-top: 2px; }
        /* Import/Export modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .modal-box { background: white; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .modal-box h3 { font-size: 16px; margin-bottom: 12px; }
        .modal-box textarea { width: 100%; height: 200px; font-family: 'SF Mono', monospace; font-size: 11px; border: 1px solid var(--sw-border); border-radius: 6px; padding: 10px; resize: vertical; }
        .modal-box textarea:focus { outline: none; border-color: var(--sw-orange); }
        .modal-btns { display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end; }
        .modal-status { font-size: 12px; color: #34C759; margin-top: 8px; min-height: 18px; }
        .job-details-grid { display: grid; grid-template-columns: 140px 1fr 1fr 150px 150px 140px; gap: 10px; align-items: end; }
        .job-details-grid label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .job-details-grid input, .job-details-grid select { width: 100%; font-size: 12px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-family: inherit; }
        .job-details-grid input:focus, .job-details-grid select:focus { outline: none; border-color: var(--sw-orange); }
        .job-ref-input { font-family: 'SF Mono', monospace !important; font-weight: 600; color: var(--sw-orange); }
        /* Notes card */
        .notes-inline { margin-top: 12px; }
        .notes-inline textarea { width: 100%; padding: 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; min-height: 60px; }
        .notes-inline textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Customer details section */
        .customer-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
        .customer-grid label { font-size: 12px; font-weight: 500; margin-bottom: 4px; display: block; }
        .customer-grid input { width: 100%; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; }
        .customer-grid input:focus { outline: none; border-color: var(--sw-orange); }
        /* Site details subsection */
        .site-details { background: var(--sw-bg); border-radius: 10px; padding: 16px 20px; margin-top: 16px; }
        .site-details-label { font-size: 13px; font-weight: 600; margin-bottom: 4px; }
        .site-details-hint { font-size: 11px; color: var(--sw-text-sec); margin-bottom: 14px; }
        .site-details-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 14px; }
        .radio-group-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .radio-options { display: flex; flex-wrap: wrap; gap: 4px; }
        .radio-pill input[type="radio"] { display: none; }
        .radio-pill span { display: inline-block; padding: 4px 10px; font-size: 12px; border: 1px solid var(--sw-border); border-radius: 16px; cursor: pointer; background: var(--sw-white); transition: all 0.15s; }
        .radio-pill input[type="radio"]:checked + span { background: var(--sw-orange); color: white; border-color: var(--sw-orange); }
        .site-notes-wrap { grid-column: 1 / -1; }
        .site-notes-wrap textarea { width: 100%; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; }
        .site-notes-wrap textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Estimate Options section */
        .estimate-cards { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .est-card { border-radius: 10px; padding: 20px; display: flex; flex-direction: column; }
        .est-card--quick { background: var(--sw-bg); }
        .est-card--full { background: var(--sw-white); border: 1px solid var(--sw-border); }
        .est-card-icon { font-size: 20px; margin-bottom: 4px; }
        .est-card-title { font-size: 15px; font-weight: 700; margin-bottom: 2px; }
        .est-card-desc { font-size: 12px; color: var(--sw-text-sec); line-height: 1.4; }
        .est-card-divider { border: none; border-top: 1px solid var(--sw-border); margin: 14px 0; }
        .est-card-stat { font-size: 13px; color: var(--sw-text-sec); margin-bottom: 2px; }
        .est-card-range { font-size: 22px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .est-card-gst { font-size: 11px; color: var(--sw-text-sec); }
        .est-card-btn { margin-top: auto; padding-top: 16px; }
        .est-card-btn .btn { width: 100%; text-align: center; }
        .est-hint { font-size: 12px; color: var(--sw-text-sec); margin-top: 16px; }
        /* Detailed Configuration groups */
        .cfg-group { border: 1px solid var(--sw-border); border-radius: 8px; margin-bottom: 8px; overflow: hidden; }
        .cfg-group:last-child { margin-bottom: 0; }
        .cfg-group-hdr { display: flex; align-items: center; gap: 8px; padding: 10px 14px; cursor: pointer; user-select: none; background: var(--sw-bg); font-size: 13px; font-weight: 600; }
        .cfg-group-hdr:hover { background: #ECECEE; }
        .cfg-group-arrow { font-size: 10px; color: var(--sw-text-sec); transition: transform 0.2s; }
        .cfg-group-arrow.open { transform: rotate(90deg); }
        .cfg-group-num { color: var(--sw-text-sec); font-size: 11px; font-weight: 500; }
        .cfg-group-body { display: none; }
        .cfg-group-body.open { display: block; }
        .cfg-group-body .mat-hdr { display: grid; grid-template-columns: 1fr 50px 130px 60px 120px; gap: 4px; padding: 5px 14px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); border-bottom: 1px solid var(--sw-border); }
        .cfg-group-body .mat-row { display: grid; grid-template-columns: 1fr 50px 130px 60px 120px; gap: 4px; font-size: 12px; padding: 6px 14px; border-bottom: 1px solid #f0f0f0; align-items: baseline; }
        .cfg-group-body .mat-row:last-child { border-bottom: none; }
        .cfg-group-body .mat-qty { font-weight: 600; color: var(--sw-orange); font-family: 'SF Mono', monospace; font-size: 11px; text-align: right; }
        .cfg-group-body .mat-size { font-size: 11px; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .cfg-group-body .mat-len { font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; }
        .cfg-group-body .mat-clr { font-size: 11px; color: var(--sw-text-sec); }
        .cfg-group-empty { padding: 10px 14px; font-size: 12px; color: var(--sw-text-sec); font-style: italic; }
        /* Pre-order checks */
        .preorder-box { display: none; }
        .preorder-title { display: none; }
        .preorder-item { display: none; }
        .preorder-ok { color: #2e7d32; }
        .preorder-warn { color: #e65100; }

        /* ==================== FLASHING EDITOR ==================== */
        /* Fullscreen modal */
        .flash-modal-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:9999; }
        .flash-modal-overlay.open { display:flex; }
        .flash-modal { display:flex; flex-direction:column; width:100%; height:100%; background:#fff; }
        .flash-modal-header { display:flex; align-items:center; justify-content:space-between; padding:10px 16px; border-bottom:2px solid var(--sw-border); background:var(--sw-bg); flex-shrink:0; }
        .flash-modal-header h2 { margin:0; font-size:15px; font-weight:700; letter-spacing:0.5px; color:var(--sw-text); }
        .flash-modal-close { background:none; border:none; font-size:22px; cursor:pointer; color:var(--sw-text-sec); padding:4px 8px; border-radius:4px; line-height:1; }
        .flash-modal-close:hover { background:#eee; color:#333; }
        .flash-modal-body { display:flex; flex:1; overflow:hidden; }
        /* Left sidebar - templates */
        .flash-sidebar { width:260px; min-width:220px; border-right:1px solid var(--sw-border); display:flex; flex-direction:column; overflow:hidden; flex-shrink:0; background:#FAFBFC; }
        .flash-sidebar-title { padding:10px 12px 6px; font-size:11px; font-weight:700; text-transform:uppercase; letter-spacing:0.4px; color:var(--sw-text-sec); flex-shrink:0; }
        .flash-sidebar-scroll { flex:1; overflow-y:auto; padding:0 8px 8px; }
        /* Right - canvas area */
        .flash-canvas-area { flex:1; display:flex; flex-direction:column; overflow:hidden; }
        .flash-viewport { background:#fff; position:relative; overflow:hidden; flex:1; }
        .flash-viewport canvas { display:block; width:100%; height:100%; cursor:grab; }
        .flash-viewport canvas.mode-drawing { cursor:crosshair; }
        .flash-toolbar { display:flex; gap:4px; padding:8px 12px; border-top:1px solid var(--sw-border); flex-wrap:wrap; align-items:center; flex-shrink:0; }
        .flash-tool-btn { padding:5px 10px; border:1px solid var(--sw-border); background:var(--sw-white); border-radius:4px; font-size:11px; cursor:pointer; color:var(--sw-text-sec); transition:all 0.15s; }
        .flash-tool-btn:hover { border-color:var(--sw-orange); color:var(--sw-orange); }
        .flash-tool-btn.active { background:var(--sw-blue-dark); color:white; border-color:var(--sw-blue-dark); }
        .flash-tool-sep { width:1px; height:20px; background:var(--sw-border); margin:0 4px; }
        .flash-info { display:flex; gap:16px; padding:4px 12px; border-top:1px solid var(--sw-border); font-size:10px; color:var(--sw-text-sec); align-items:center; flex-shrink:0; background:#FAFBFC; }
        .flash-info-val { font-weight:600; color:var(--sw-text); font-family:'SF Mono',monospace; }
        .flash-zoom-ctrl { display:flex; align-items:center; gap:4px; }
        .flash-zoom-btn { width:22px; height:22px; border:1px solid var(--sw-border); border-radius:4px; background:#fff; cursor:pointer; font-size:14px; line-height:1; display:flex; align-items:center; justify-content:center; color:var(--sw-text); padding:0; }
        .flash-zoom-btn:hover { background:var(--sw-blue-dark); color:#fff; border-color:var(--sw-blue-dark); }
        .flash-status-bar { display:flex; gap:8px; padding:6px 12px; border-top:1px solid var(--sw-border); font-size:11px; color:var(--sw-text-sec); align-items:center; flex-shrink:0; background:#f0f2f5; }
        .flash-status-mode { font-weight:700; font-size:10px; text-transform:uppercase; letter-spacing:0.5px; padding:2px 8px; border-radius:3px; background:#293C46; color:#fff; }
        .flash-status-mode.extending { background:#2563eb; }
        .flash-status-mode.selected { background:#F15A29; }
        .flash-status-sep { width:1px; height:14px; background:var(--sw-border); }
        .flash-status-btn { padding:3px 12px; border:1px solid var(--sw-border); border-radius:4px; background:#fff; font-size:11px; cursor:pointer; color:var(--sw-text-sec); }
        .flash-status-btn:hover { border-color:#e74c3c; color:#e74c3c; }
        .flash-inspector { position:absolute; top:12px; right:12px; width:200px; background:#fff; border:1px solid var(--sw-border); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:20; font-size:11px; }
        .flash-inspector-header { display:flex; justify-content:space-between; align-items:center; padding:8px 10px; border-bottom:1px solid var(--sw-border); font-weight:700; font-size:12px; color:var(--sw-text); }
        .flash-inspector-close { border:none; background:none; font-size:16px; cursor:pointer; color:var(--sw-text-sec); padding:0 2px; line-height:1; }
        .flash-inspector-close:hover { color:#e74c3c; }
        .flash-inspector-body { padding:10px; }
        .flash-insp-row { display:flex; align-items:center; gap:6px; margin-bottom:8px; }
        .flash-insp-row label { font-size:10px; color:var(--sw-text-sec); min-width:24px; font-weight:600; }
        .flash-insp-row input { flex:1; padding:3px 6px; border:1px solid var(--sw-border); border-radius:4px; font-size:11px; font-family:'SF Mono',monospace; }
        .flash-insp-row input:focus { outline:none; border-color:var(--sw-orange); }
        .flash-insp-unit { font-size:10px; color:var(--sw-text-sec); }
        .flash-insp-info { font-size:10px; color:var(--sw-text-sec); margin-bottom:8px; padding:4px 0; border-top:1px solid var(--sw-border); }
        .flash-insp-btn { width:100%; padding:5px; border:1px solid var(--sw-border); border-radius:4px; background:#fff; font-size:10px; cursor:pointer; color:var(--sw-text-sec); margin-top:4px; }
        .flash-insp-btn:hover { border-color:#e74c3c; color:#e74c3c; }
        .flash-insp-btn.danger:hover { background:#FDEDEC; }
        .flash-modal-tabs { display:flex; gap:2px; }
        .flash-tab { padding:6px 16px; border:none; background:transparent; font-size:12px; font-weight:600; cursor:pointer; color:var(--sw-text-sec); border-bottom:2px solid transparent; }
        .flash-tab.active { color:var(--sw-orange); border-bottom-color:var(--sw-orange); }
        .flash-tab:hover { color:var(--sw-text); }
        /* Add to job bar */
        .flash-add-bar { display:grid; grid-template-columns:1fr 120px 80px 80px 60px auto; gap:8px; padding:10px 14px; border-top:2px solid var(--sw-border); align-items:end; flex-shrink:0; background:var(--sw-bg); }
        .flash-add-bar label { font-size:10px; font-weight:600; text-transform:uppercase; letter-spacing:0.3px; color:var(--sw-text-sec); margin-bottom:2px; display:block; }
        .flash-add-bar input, .flash-add-bar select { width:100%; font-size:12px; padding:5px 8px; border:1px solid var(--sw-border); border-radius:4px; font-family:inherit; }
        .flash-add-bar input:focus, .flash-add-bar select:focus { outline:none; border-color:var(--sw-orange); }
        /* Template items and folders */
        .flash-tpl { min-width:70px; padding:6px; border:1px solid var(--sw-border); border-radius:6px; cursor:pointer; text-align:center; transition:all 0.15s; flex-shrink:0; }
        .flash-tpl:hover { border-color:var(--sw-orange); }
        .flash-tpl.active { border-color:var(--sw-orange); background:#FFF5F0; }
        .flash-tpl canvas { display:block; margin:0 auto 4px; width:56px; height:34px; }
        .flash-tpl-name { font-size:9px; color:var(--sw-text-sec); white-space:nowrap; }
        .template-folder { margin-bottom:4px; border:1px solid var(--sw-border); border-radius:6px; overflow:hidden; }
        .folder-header { display:flex; align-items:center; gap:6px; padding:6px 10px; cursor:pointer; user-select:none; font-size:11px; font-weight:600; color:var(--sw-text); background:var(--sw-bg); transition:background 0.15s; }
        .folder-header:hover { background:#E8EAED; }
        .folder-icon { font-size:13px; }
        .folder-contents { display:flex; flex-wrap:wrap; gap:6px; padding:8px 10px; }
        .folder-contents.collapsed { display:none; }
        /* Colour side & treatment controls */
        .flash-colour-side { display:flex; gap:4px; align-items:center; }
        .flash-cs-btn { padding:3px 8px; border:1px solid var(--sw-border); background:var(--sw-white); border-radius:3px; font-size:10px; cursor:pointer; }
        .flash-cs-btn.active { background:var(--sw-orange); color:white; border-color:var(--sw-orange); }
        /* Job flashings table (inline section) */
        .flash-table { width:100%; border-collapse:collapse; font-size:12px; }
        .flash-table th { text-align:left; font-size:10px; font-weight:600; text-transform:uppercase; letter-spacing:0.3px; color:var(--sw-text-sec); padding:6px 10px; border-bottom:2px solid var(--sw-border); }
        .flash-table th.r { text-align:right; }
        .flash-table td { padding:6px 10px; border-bottom:1px solid #f0f0f0; vertical-align:middle; }
        .flash-table td.r { text-align:right; }
        .flash-table td.mono { font-family:'SF Mono',monospace; font-size:11px; }
        .flash-table tr:last-child td { border-bottom:none; }
        .flash-table tr:hover { background:#FAFAFA; }
        .flash-table tr.selected { background:#FFF5F0; }
        .flash-table .flash-row-actions { display:flex; gap:4px; }
        .flash-table .flash-row-btn { background:none; border:none; cursor:pointer; font-size:14px; color:#ccc; padding:0 4px; transition:color 0.15s; }
        .flash-table .flash-row-btn:hover { color:var(--sw-orange); }
        .flash-table .flash-row-btn.del:hover { color:#FF3B30; }
        .flash-total-row { display:flex; justify-content:flex-end; padding:8px 12px; font-size:12px; font-weight:600; color:var(--sw-text); border-top:1px solid var(--sw-border); }
        .flash-total-row span { font-family:'SF Mono',monospace; margin-left:8px; color:var(--sw-orange); }
        .flash-header-row { display:flex; justify-content:space-between; align-items:center; padding:0 0 8px 0; }
        /* Summary line in collapsed section */
        .flash-summary { display:flex; align-items:center; gap:12px; padding:10px 14px; }
        .flash-summary-text { font-size:12px; color:var(--sw-text-sec); }
        .flash-summary-count { font-weight:700; color:var(--sw-text); font-family:'SF Mono',monospace; }

        /* Properties Panel (3D selection) */
        .properties-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 0;
            min-width: 200px;
            max-width: 280px;
            color: #fff;
            font-size: 13px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .props-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #2a2a2a;
            border-bottom: 1px solid #444;
            font-weight: bold;
            border-radius: 6px 6px 0 0;
        }
        .props-header button {
            background: none;
            border: none;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            padding: 0 4px;
        }
        .props-header button:hover { color: #fff; }
        .props-content { padding: 10px 12px; }
        .props-content div { margin-bottom: 6px; }
        .props-content div:last-child { margin-bottom: 0; }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: #fff;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 10000;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        .toast-success { background: #2e7d32; }
        .toast-error { background: #c62828; }

        /* Output Buttons */
        .output-buttons { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
        .output-buttons .btn { flex: 1; min-width: 120px; text-align: center; padding: 10px 14px; font-size: 13px; }
        .material-order-options { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 10px; align-items: center; }
        .material-order-options .btn-small { padding: 5px 10px; border-radius: 4px; font-size: 11px; cursor: pointer; border: 1px solid var(--sw-border); background: var(--sw-bg); color: var(--sw-text); }
        .material-order-options .btn-small:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        .load-section { margin-top: 12px; text-align: center; }
        .load-section .btn-secondary { display: inline-block; }
        .button-group { display: flex; gap: 4px; flex-wrap: wrap; }
        .toggle-btn-group { display: flex; gap: 4px; flex-wrap: wrap; }
        .toggle-btn { padding: 6px 12px; border: 1px solid var(--sw-border); background: #fff; border-radius: 4px; cursor: pointer; font-size: 13px; transition: all 0.15s; }
        .toggle-btn:hover { border-color: #999; }
        .toggle-btn.active { background: var(--sw-blue-dark); color: #fff; border-color: var(--sw-blue-dark); }
        .toggle-btn.disabled { opacity: 0.35; pointer-events: none; cursor: not-allowed; }

        /* Customer Preview Generator */
        #aiPreviewSection button {
            background: #4285f4;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            font-size: 13px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        #aiPreviewSection button:hover {
            background: #3367d6;
        }
        #generatePromptBtn {
            background: linear-gradient(135deg, #4285f4, #34a853) !important;
        }

        /* Fabrication Cut List Panel */
        .cut-list-panel {
            background: #fff;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
            font-size: 13px;
        }
        .cut-list-panel .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #333;
        }
        .cut-list-panel h4 {
            margin: 0;
            flex: 1;
            font-size: 16px;
            letter-spacing: 1px;
        }
        .cut-list-panel .btn-small {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            border: 1px solid var(--sw-border);
            background: var(--sw-bg);
            color: var(--sw-text);
        }
        .cut-list-panel .btn-small:hover {
            border-color: var(--sw-orange);
            color: var(--sw-orange);
        }
        .tubing-summary {
            margin-bottom: 12px;
            font-size: 12px;
        }
        .tubing-summary .label {
            color: #666;
            text-transform: uppercase;
            font-size: 10px;
            margin-right: 6px;
        }
        .tubing-summary .value {
            font-weight: 700;
        }
        .cut-list-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'SF Mono', 'Courier New', monospace;
        }
        .cut-list-table th {
            background: #333;
            color: #fff;
            padding: 8px 12px;
            text-align: left;
            font-size: 11px;
            text-transform: uppercase;
        }
        .cut-list-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
            vertical-align: top;
        }
        .cut-list-table tr:hover {
            background: #f5f5f5;
        }
        .cut-list-table .cut-length {
            font-size: 18px;
            font-weight: bold;
            color: #d32f2f;
        }
        .cut-list-table .angle-info {
            font-size: 11px;
            color: #666;
            display: block;
        }
        .cut-list-table .mitre {
            color: #1976d2;
            font-weight: 600;
        }
        .cut-list-table .square {
            color: #388e3c;
        }
        .cut-list-totals {
            display: flex;
            gap: 24px;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 2px solid #333;
            flex-wrap: wrap;
        }
        .total-item {
            display: flex;
            flex-direction: column;
        }
        .total-item span:first-child {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
        }
        .total-item span:last-child {
            font-size: 20px;
            font-weight: bold;
        }
        @media print {
            .cut-list-panel .btn-small { display: none; }
            .cut-list-panel { border-color: #000; break-inside: avoid; }
            .cut-list-table th { background: #000; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <svg class="header-logo" viewBox="0 0 220 40" xmlns="http://www.w3.org/2000/svg">
                <!-- House icon -->
                <path d="M20 8 L10 18 L12 18 L12 28 L18 28 L18 22 L22 22 L22 28 L28 28 L28 18 L30 18 Z" fill="#3a3f47"/>
                <path d="M17 28 L17 23 L23 23 L23 28" fill="#e85a1c"/>
                <!-- Orange accent bar under house -->
                <rect x="10" y="30" width="20" height="3" rx="1.5" fill="#e85a1c"/>
                <!-- SecureWorks text -->
                <text x="40" y="23" font-family="-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif" font-size="18" font-weight="700" fill="#2d3340">Secure<tspan fill="#e85a1c">Works</tspan></text>
                <!-- WA text -->
                <text x="164" y="23" font-family="-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif" font-size="18" font-weight="400" fill="#8a8f98">WA</text>
            </svg>
        </div>
        <div class="job-badge" id="headerBadge"><strong>SWâ€”</strong></div>
        <div style="display:flex;gap:8px">
            <button class="btn btn-secondary" id="layoutToggle" onclick="toggleLayout()">&#9703; Full Width</button>
            <button class="btn btn-secondary" onclick="showLoadJobModal()">Load Job</button>
            <button class="btn btn-primary" onclick="exportAllOutputs()">Export All</button>
        </div>
    </header>

    <main class="main" id="mainLayout">
        <div class="panel-left">

        <!-- ======== GROUP: JOB ======== -->
        <div class="section-group" id="group-job">
        <div class="section-group-header">Job</div>

        <!-- ============ SECTION: JOB DETAILS ============ -->
        <div class="section" id="sec-job">
            <div class="collapse-header" onclick="toggleSection('sec-job')">
                <div>
                    <div class="section-title">Job Details</div>
                </div>
                <div style="display:flex;align-items:center;gap:6px">
                    <button class="btn btn-secondary" style="font-size:10px;padding:3px 8px" onclick="event.stopPropagation();exportJobData()">Export</button>
                    <button class="btn btn-secondary" style="font-size:10px;padding:3px 8px" onclick="event.stopPropagation();showImportModal()">Import</button>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body">
                <div class="section-body">
                <div class="basics-group">
                    <div class="basics-grid-3">
                        <div class="basics-field">
                            <label>Job Ref</label>
                            <input type="text" id="jobRef" placeholder="SW250208-01">
                        </div>
                        <div class="basics-field">
                            <label>Salesperson</label>
                            <select id="salesperson">
                                <option value="Nithin">Nithin</option>
                                <option value="Marnin">Marnin</option>
                                <option value="Other">Other</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Email</label>
                            <input type="text" id="clientEmail" placeholder="client@email.com">
                        </div>
                    </div>
                    <div class="basics-grid-4" style="margin-top:6px">
                        <div class="basics-field">
                            <label>Customer Name</label>
                            <input type="text" id="customerName" placeholder="Full name" oninput="updateCustomer()">
                        </div>
                        <div class="basics-field" style="grid-column:span 2">
                            <label>Address</label>
                            <input type="text" id="customerAddress" placeholder="Street, suburb, postcode" oninput="updateCustomer()">
                        </div>
                        <div class="basics-field">
                            <label>Phone</label>
                            <input type="text" id="customerPhone" placeholder="0412 345 678" oninput="updateCustomer()">
                        </div>
                    </div>
                </div>
                </div>
            </div>
        </div>

        </div><!-- end group-job -->

        <!-- ======== GROUP: BUILD ======== -->
        <div class="section-group" id="group-build">
        <div class="section-group-header">Build</div>

        <!-- ============ SECTION: DESIGN ============ -->
        <div class="section" id="sec-design">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-design')">
                <div><div class="section-title">Design</div></div>
                <div style="display:flex;align-items:center;gap:4px">
                    <span class="section-warn-dot" id="buildWarnDot"></span>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">
                <div class="basics-group">
                    <!-- Roof Style toggle buttons -->
                    <div class="basics-field" style="margin-bottom:10px">
                        <label>Roof Style</label>
                        <input type="hidden" id="inRoofStyle" value="skillion">
                        <div class="toggle-btn-group" id="roofStyleGroup">
                            <button type="button" class="toggle-btn" data-value="gable" onclick="setDesignToggle('inRoofStyle','gable',this)">Gable</button>
                            <button type="button" class="toggle-btn active" data-value="skillion" onclick="setDesignToggle('inRoofStyle','skillion',this)">Skillion</button>
                        </div>
                    </div>
                    <!-- Attachment toggle buttons -->
                    <div class="basics-field" style="margin-bottom:10px">
                        <label>Attachment</label>
                        <input type="hidden" id="inConnection" value="riser">
                        <div class="toggle-btn-group" id="connectionGroup">
                            <button type="button" class="toggle-btn active" data-value="riser" onclick="setDesignToggle('inConnection','riser',this)">Riser</button>
                            <button type="button" class="toggle-btn" data-value="flyover" onclick="setDesignToggle('inConnection','flyover',this)">Flyover</button>
                            <button type="button" class="toggle-btn" data-value="fascia" onclick="setDesignToggle('inConnection','fascia',this)">Fascia</button>
                            <button type="button" class="toggle-btn" data-value="wall" onclick="setDesignToggle('inConnection','wall',this)">Wall</button>
                            <button type="button" class="toggle-btn" data-value="freestanding" onclick="setDesignToggle('inConnection','freestanding',this)">Free</button>
                        </div>
                    </div>
                    <div class="basics-grid-3">
                        <div class="basics-field">
                            <label>Material</label>
                            <select id="inRoofing" onchange="updateUI(); rebuildAll()">
                                <option value="solarspan75">SolarSpan 75mm</option>
                                <option value="solarspan100">SolarSpan 100mm</option>
                                <option value="trimdek">Trimdek</option>
                                <option value="spanplus330">SpanPlus 330</option>
                                <option value="corrugated">Corrugated</option>
                                <option value="spandek">Spandek</option>
                            </select>
                        </div>
                        <div class="basics-field" id="pitchField">
                            <label>Pitch <span style="color:var(--sw-text-sec);font-size:9px">&deg;</span></label>
                            <input type="number" id="inPitch" value="10" step="0.5" oninput="rebuildAll()">
                        </div>
                    </div>
                </div>
                <div class="basics-divider"></div>
                <!-- Colours -->
                <div class="basics-group">
                    <div class="basics-group-title">Colours</div>
                    <div class="basics-colours">
                        <div class="basics-colour-block">
                            <div class="basics-colour-label">Sheets</div>
                            <div class="color-chips" id="sheetChips"></div>
                            <div class="color-label" id="sheetLabel">Monument</div>
                        </div>
                        <div class="basics-colour-block">
                            <div class="basics-colour-label">Steel</div>
                            <div class="color-chips" id="steelChips"></div>
                            <div class="color-label" id="steelLabel">Monument</div>
                        </div>
                    </div>
                </div>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: STRUCTURE ============ -->
        <div class="section" id="sec-structure">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-structure')">
                <div><div class="section-title">Structure</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">

                    <!-- 1. DIMENSIONS subsection -->
                    <div class="basics-group">
                        <div class="basics-group-title">Dimensions</div>
                        <div class="basics-grid-3">
                            <div class="basics-field">
                                <label>Length <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                                <input type="number" id="inLength" value="6" step="0.1" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field">
                                <label>Projection <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                                <input type="number" id="inWidth" value="3" step="0.1" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field">
                                <label>Post Height <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                                <input type="number" id="inPostHeight" value="2.4" step="0.1" oninput="rebuildAll()">
                            </div>
                        </div>
                    </div>

                    <!-- 2. Purlin validation display (inline) -->
                    <div id="purlinValidation" style="margin:8px 0 4px;padding:8px 10px;border-radius:6px;font-size:11px;background:var(--sw-bg)">
                        <div id="purlinValidationText" style="color:var(--sw-text-sec)">--</div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 3. CONNECTION subsection -->
                    <div class="basics-group">
                        <div class="basics-group-title">Connection</div>
                        <div class="basics-grid-3">
                            <div class="basics-field" id="fasciaHeightField" style="display:none">
                                <label>Fascia Height <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inFasciaHeight" value="2700" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="fasciaBracketQtyField" style="display:none">
                                <label>Fascia Brackets</label>
                                <input type="number" id="inFasciaBracketQty" value="4" min="2" step="1" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="basics-grid-4" style="margin-top:6px">
                            <div class="basics-field" id="riserHeightField" style="display:none">
                                <label>Riser Height <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inRiserHeight" value="400" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserOffsetField" style="display:none">
                                <label>Riser Offset <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inRiserOffset" value="150" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserQtyField" style="display:none">
                                <label>Riser Brackets</label>
                                <input type="number" id="inRiserQty" value="" min="2" oninput="rebuildAll()">
                            </div>
                        </div>
                        <!-- House Gutter Impact (show if Attachment = Riser) -->
                        <div id="houseGutterImpactField" style="display:none;margin-top:8px">
                            <label style="font-size:11px;color:var(--sw-text-sec);margin-bottom:4px;display:block">House Gutter Impact</label>
                            <input type="hidden" id="inHouseGutter" value="quad">
                            <div class="toggle-btn-group">
                                <button type="button" class="toggle-btn active" data-value="quad" onclick="setDesignToggle('inHouseGutter','quad',this)">No change</button>
                                <button type="button" class="toggle-btn" data-value="box" onclick="setDesignToggle('inHouseGutter','box',this)">Box Gutter</button>
                            </div>
                            <div id="boxGutterConfig" style="display:none;margin-top:8px;padding:10px;background:var(--sw-bg);border-radius:8px">
                                <div class="basics-field" style="margin-bottom:6px">
                                    <label>House roof catchment (m&sup2;)</label>
                                    <input type="number" id="inBoxGutterCatchment" value="85" min="10" max="500" step="5" oninput="updateBoxGutterSummary()">
                                </div>
                                <div id="boxGutterSummary" style="font-size:11px;color:var(--sw-text-sec);margin-bottom:6px">
                                    <div id="boxGutterWidthRec">Recommended width: 300mm</div>
                                    <div id="boxGutterProfileRec" style="font-size:10px;margin-top:2px">Profile: 100mm deep &times; 70mm back &times; 130mm front</div>
                                </div>
                                <div id="boxGutterWarn" style="display:none;font-size:10px;color:#7D6608;background:#FEF9E7;border:1px solid #F39C12;border-radius:4px;padding:4px 8px;margin-bottom:6px"></div>
                                <button type="button" class="flash-tool-btn" style="font-size:10px;padding:4px 10px" onclick="openFlashModalBoxGutter()">Edit in Flashing Creator</button>
                            </div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 4. STRUCTURAL SIZING -->
                    <div class="basics-group">
                        <div class="basics-group-title">Structural Sizing</div>
                        <div class="struct-sizing" id="structSizing">
                            <!-- Posts -->
                            <div class="struct-row" id="structRowPosts">
                                <span class="struct-label">Posts</span>
                                <div class="struct-qty">
                                    <button onclick="adjustPostQty(-1)">&#8722;</button>
                                    <input type="number" id="inPostQty" value="" min="2" max="20" step="1" placeholder="auto" oninput="onPostQtyChange()">
                                    <button onclick="adjustPostQty(1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <select id="inPostSize" onchange="rebuildAll()">
                                        <option value="65x65">65&times;65 SHS</option>
                                        <option value="75x75">75&times;75 SHS</option>
                                        <option value="90x90" selected>90&times;90 SHS</option>
                                        <option value="100x100">100&times;100 SHS</option>
                                        <option value="125x125">125&times;125 SHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Purlins -->
                            <div class="struct-row" id="structRowPurlins">
                                <span class="struct-label">Purlins</span>
                                <div class="struct-qty">
                                    <button onclick="adjustStructPurlinQty(-1)">&#8722;</button>
                                    <span id="structPurlinQty">--</span>
                                    <button onclick="adjustStructPurlinQty(1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <select id="inPurlinSize" onchange="rebuildAll()">
                                        <option value="C75">C75</option>
                                        <option value="C100" selected>C100</option>
                                        <option value="C150">C150</option>
                                        <option value="C200">C200</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Fascia Beam -->
                            <div class="struct-row" id="structRowFasciaBeam">
                                <span class="struct-label">Fascia Beam</span>
                                <div class="struct-qty">
                                    <button onclick="adjustStructBeamQty('fascia',-1)">&#8722;</button>
                                    <span id="structFasciaBeamQty">1</span>
                                    <button onclick="adjustStructBeamQty('fascia',1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <select id="inBeamSize" onchange="rebuildAll()">
                                        <option value="75x50">75&times;50 RHS</option>
                                        <option value="100x50" selected>100&times;50 RHS</option>
                                        <option value="125x50">125&times;50 RHS</option>
                                        <option value="150x50">150&times;50 RHS</option>
                                        <option value="200x50">200&times;50 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Gutter Beam -->
                            <div class="struct-row" id="structRowGutterBeam">
                                <span class="struct-label">Gutter Beam</span>
                                <div class="struct-qty">
                                    <button onclick="adjustStructBeamQty('gutter',-1)">&#8722;</button>
                                    <span id="structGutterBeamQty">1</span>
                                    <button onclick="adjustStructBeamQty('gutter',1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <select id="inGutterBeamSize" onchange="rebuildAll()">
                                        <option value="75x50">75&times;50 RHS</option>
                                        <option value="100x50" selected>100&times;50 RHS</option>
                                        <option value="125x50">125&times;50 RHS</option>
                                        <option value="150x50">150&times;50 RHS</option>
                                        <option value="200x50">200&times;50 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Riser Beam (skillion + riser only) -->
                            <div class="struct-row" id="structRowRiserBeam" style="display:none">
                                <span class="struct-label">Riser Beam</span>
                                <div class="struct-qty">
                                    <button onclick="adjustStructBeamQty('riser',-1)">&#8722;</button>
                                    <span id="structRiserBeamQty">1</span>
                                    <button onclick="adjustStructBeamQty('riser',1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <select id="inRiserBeamSize" onchange="rebuildAll()">
                                        <option value="75x50">75&times;50 RHS</option>
                                        <option value="100x50" selected>100&times;50 RHS</option>
                                        <option value="125x50">125&times;50 RHS</option>
                                        <option value="150x50">150&times;50 RHS</option>
                                        <option value="200x50">200&times;50 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Rafters (skillion only) -->
                            <div class="struct-row" id="structRowRafters">
                                <span class="struct-label">Rafters</span>
                                <div class="struct-qty">
                                    <button onclick="adjustRafterQty(-1)">&#8722;</button>
                                    <input type="number" id="inRafterQtyOverride" value="" min="2" max="30" step="1" placeholder="auto" oninput="onRafterQtyChange()">
                                    <button onclick="adjustRafterQty(1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <select id="inRafterSize" onchange="rebuildAll()">
                                        <option value="50x25">50&times;25 RHS</option>
                                        <option value="65x35">65&times;35 RHS</option>
                                        <option value="75x35" selected>75&times;35 RHS</option>
                                        <option value="100x50">100&times;50 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Trusses (gable only) -->
                            <div class="struct-row" id="structRowTrusses" style="display:none">
                                <span class="struct-label">Trusses</span>
                                <div class="struct-qty">
                                    <button onclick="adjustStructTrussQty(-1)">&#8722;</button>
                                    <input type="number" id="inTrussesOverride" value="" min="2" max="20" step="1" placeholder="auto" oninput="onTrussQtyOverride()">
                                    <button onclick="adjustStructTrussQty(1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <button class="struct-configure-btn" onclick="scrollToTrussSection()">Configure</button>
                                </div>
                            </div>
                        </div>
                        <div id="structSizingWarnings" style="margin-top:6px"></div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 5. POST OPTIONS -->
                    <div class="basics-group">
                        <div class="basics-group-title">Post Options</div>
                        <div class="basics-field" style="margin-bottom:10px">
                            <label>Ground Surface</label>
                            <div class="toggle-btn-group" id="groundSurfaceGroup">
                                <button type="button" class="toggle-btn" data-value="slab" onclick="setToggle('groundSurface', 'slab', this); smartPostFixDefault()">Slab</button>
                                <button type="button" class="toggle-btn" data-value="paving" onclick="setToggle('groundSurface', 'paving', this); smartPostFixDefault()">Paving</button>
                                <button type="button" class="toggle-btn active" data-value="grass" onclick="setToggle('groundSurface', 'grass', this); smartPostFixDefault()">Grass</button>
                                <button type="button" class="toggle-btn" data-value="deck" onclick="setToggle('groundSurface', 'deck', this); smartPostFixDefault()">Deck</button>
                            </div>
                            <input type="hidden" id="groundSurface" value="grass">
                        </div>
                        <div class="basics-field">
                            <label>Post Fixing</label>
                            <input type="hidden" id="inPostFix" value="concrete">
                            <div class="toggle-btn-group" id="postFixGroup">
                                <button type="button" class="toggle-btn active" data-value="concrete" onclick="setDesignToggle('inPostFix','concrete',this)">In-ground</button>
                                <button type="button" class="toggle-btn" data-value="baseplate" onclick="setDesignToggle('inPostFix','baseplate',this)">Bolt-down</button>
                            </div>
                        </div>
                        <div id="postWarnings" style="display:none;margin-top:8px"></div>
                        <span id="postSizeDisplay" style="display:none">90Ã—90Ã—2 SHS</span>
                        <!-- Post calculation summary (hidden, populated for export) -->
                        <div id="postResult" style="display:none">
                            <div id="postResultTitle">--</div>
                            <div id="postResultSpacing">--</div>
                            <div id="postResultLineal">--</div>
                            <div id="postResultFootings">--</div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 6. SHEET BMT (single-skin only) -->
                    <div class="basics-group" id="bmtField" style="display:none">
                        <div class="basics-field">
                            <label>Sheet BMT</label>
                            <select id="inBMT" onchange="rebuildAll()">
                                <option value="042">0.42mm</option>
                                <option value="048">0.48mm</option>
                            </select>
                        </div>
                    </div>

                    <!-- Rise/Rafter calc display (hidden, moved to visualiser in Phase 11) -->
                    <div class="calc-display" id="calcDisplay" style="display:none">
                        <div class="calc-row"><span class="calc-label">Rise:</span><span class="calc-value" id="calcRise">--</span></div>
                        <div class="calc-row"><span class="calc-label">Rafter TRUE:</span><span class="calc-value" id="calcRafter">--</span></div>
                        <div class="calc-row" id="calcPitchRow" style="display:none"><span class="calc-label">Actual Pitch:</span><span class="calc-value" id="calcPitch">--</span></div>
                    </div>

                </div>
            </div>
        </div>


        <!-- ============ SECTION: GABLE TRUSS (conditional) ============ -->
        <div class="section" id="sec-truss" style="display:none">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-truss')">
                <div><div class="section-title">Gable Truss Calculator</div></div>
                <div style="display:flex;align-items:center;gap:8px">
                    <button class="btn btn-secondary" style="padding:3px 8px;font-size:10px" onclick="event.stopPropagation();exportTrussPDF()">PDF</button>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="padding:0">
                    <!-- Truss configuration inputs (moved from Site Details) -->
                    <div style="padding:12px 16px;border-bottom:1px solid var(--sw-border)">
                        <div class="basics-grid-4">
                            <div class="basics-field">
                                <label>Span <span style="color:var(--sw-text-sec);font-size:9px">from projection</span></label>
                                <input type="text" id="trussSpanDisplay" readonly class="readonly-field" value="3m">
                            </div>
                            <div class="basics-field">
                                <label>Pitch <span style="color:var(--sw-text-sec);font-size:9px">from roof pitch</span></label>
                                <input type="text" id="trussPitchDisplay" readonly class="readonly-field" value="10&deg;">
                            </div>
                            <div class="basics-field">
                                <label>Qty <span style="color:var(--sw-text-sec);font-size:9px">auto or override</span></label>
                                <input type="number" id="inTrusses" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="orientationField">
                                <label>Ridge Direction</label>
                                <select id="inOrientation" onchange="rebuildAll()">
                                    <option value="lengthways">Along House</option>
                                    <option value="perpendicular">Away from House</option>
                                </select>
                            </div>
                        </div>
                        <div class="basics-grid-4" style="margin-top:6px">
                            <div class="basics-field">
                                <label>Steel Size</label>
                                <select id="inTrussSteel" onchange="rebuildAll()">
                                    <option value="76x38">76 &times; 38 &times; 1.6mm RHS</option>
                                    <option value="75x50">75 &times; 50 &times; 2.0mm RHS</option>
                                    <option value="100x50">100 &times; 50 &times; 2.0mm RHS</option>
                                </select>
                            </div>
                            <div class="basics-field" id="trussBaseField">
                                <label>Web Style</label>
                                <select id="inTrussBase" onchange="rebuildAll()">
                                    <option value="kingpost" selected>King Post</option>
                                    <option value="kingverticals">King Post + Verticals</option>
                                    <option value="web">Web</option>
                                </select>
                            </div>
                            <div class="basics-field" id="trussChordField">
                                <label>Chord</label>
                                <select id="inTrussChord" onchange="rebuildAll()">
                                    <option value="bottom">Bottom</option>
                                    <option value="mid">Mid</option>
                                    <option value="none">None</option>
                                </select>
                            </div>
                            <div class="basics-field">
                                <label>Overhang <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inOverhang" value="0" min="0" step="10" oninput="rebuildAll()">
                            </div>
                        </div>
                        <!-- Auto-calculated posts (hidden, used by getInputs) -->
                        <input type="hidden" id="inPosts" value="3">
                        <!-- Rafters field for skillion (hidden here, used by getInputs) -->
                        <input type="hidden" id="inRafters" value="5">
                    </div>
                    <div class="truss-config">
                        <div class="truss-config-item">
                            <label><input type="checkbox" id="trussExtOn" onchange="toggleTrussOpt();rebuildAll()"> Extender</label>
                            <div class="truss-opt-fields" id="trussExtInputs" style="display:none">
                                <label>Length <input type="number" id="trussExtLen" value="300" min="0" step="10" oninput="rebuildAll()"><span>mm</span></label>
                            </div>
                        </div>
                        <div class="truss-config-item">
                            <label><input type="checkbox" id="trussRiserOn" onchange="toggleTrussOpt();rebuildAll()"> Risers</label>
                            <div class="truss-opt-fields" id="trussRiserInputs" style="display:none">
                                <label><input type="checkbox" id="trussRiserLock" checked onchange="syncRiserLock();rebuildAll()"> Lock L/R</label>
                                <input type="hidden" id="trussBoxGutterOn" value="0">
                                <button type="button" class="truss-box-gutter-btn" id="trussBoxGutterBtn" onclick="openGutterDesigner()">Box Gutter</button>
                            </div>
                            <div class="truss-opt-fields" id="trussRiserTypePanel" style="display:none;gap:6px;margin-top:2px">
                                <label style="font-weight:600;font-size:10px;color:var(--sw-text-sec)">Riser Type</label>
                                <label style="font-size:10px;cursor:pointer"><input type="radio" name="riserType" id="riserTypeWelded" value="welded" checked onchange="rebuildAll()"> Welded to Truss</label>
                                <label style="font-size:10px;cursor:pointer"><input type="radio" name="riserType" id="riserTypeSeparate" value="separate" onchange="rebuildAll()"> Separate Piece</label>
                            </div>
                        </div>
                        <div class="truss-config-item" id="trussRiserLPanel" style="display:none">
                            <span class="truss-opt-fields" style="display:flex">
                                <label style="font-weight:600;font-size:10px;color:var(--sw-text-sec)">Left Riser</label>
                                <label>Horiz <input type="number" id="riserLH" value="200" min="0" max="800" step="10" oninput="syncRiserInputs('L');if(document.getElementById('trussBoxGutterOn').value==='1')syncRiserToBoxGutter();rebuildAll()"><span>mm</span></label>
                                <label>Vert <input type="number" id="riserLV" value="150" min="0" max="600" step="10" oninput="syncRiserInputs('L');if(document.getElementById('trussBoxGutterOn').value==='1')syncRiserToBoxGutter();rebuildAll()"><span>mm</span></label>
                            </span>
                        </div>
                        <div class="truss-config-item" id="trussRiserRPanel" style="display:none">
                            <span class="truss-opt-fields" style="display:flex">
                                <label style="font-weight:600;font-size:10px;color:var(--sw-text-sec)">Right Riser</label>
                                <label>Horiz <input type="number" id="riserRH" value="200" min="0" max="800" step="10" oninput="syncRiserInputs('R');if(document.getElementById('trussBoxGutterOn').value==='1')syncRiserToBoxGutter();rebuildAll()"><span>mm</span></label>
                                <label>Vert <input type="number" id="riserRV" value="150" min="0" max="600" step="10" oninput="syncRiserInputs('R');if(document.getElementById('trussBoxGutterOn').value==='1')syncRiserToBoxGutter();rebuildAll()"><span>mm</span></label>
                            </span>
                        </div>
                    </div>
                    <div style="padding:12px">
                        <div class="truss-viewport" id="trussViewport">
                            <canvas id="trussCanvas"></canvas>
                            <div id="trussPropertiesPanel" class="properties-panel" style="display: none;"></div>
                            <button class="truss-fullscreen-btn" onclick="toggleTrussFullscreen()" title="Fullscreen">&#x26F6;</button>
                            <label class="truss-dim-toggle"><input type="checkbox" id="showTrussDims" checked onchange="toggleTrussDimensions()"> Dims</label>
                            <div class="truss-view-btns">
                                <button class="truss-view-btn" onclick="setTrussView('3d',this)">3D</button>
                                <button class="truss-view-btn active" onclick="setTrussView('front',this)">Front</button>
                                <button class="truss-view-btn" onclick="setTrussView('side',this)">Side</button>
                                <button class="truss-view-btn" onclick="setTrussView('top',this)">Top</button>
                                <button class="truss-view-btn" onclick="setTrussView('front',document.querySelector('.truss-view-btn:nth-child(2)'))" title="Reset view" style="font-size:13px;padding:3px 8px">&#x21BA;</button>
                            </div>
                        </div>
                        <div class="truss-panel-vertical">
                            <div class="truss-cards-row">
                                <div class="truss-card">
                                    <h4>Truss Dimensions</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">SP: Span</div><div class="spec-value" id="specA">3000</div></div>
                                        <div class="spec-item"><div class="spec-label">HT: Height</div><div class="spec-value" id="specB">264</div></div>
                                        <div class="spec-item"><div class="spec-label">Rafter</div><div class="spec-value hl" id="specC">1523</div></div>
                                        <div class="spec-item"><div class="spec-label">Pitch</div><div class="spec-value" id="specD">10&deg;</div></div>
                                        <div class="spec-item" id="specExtItem" style="display:none"><div class="spec-label">Extender</div><div class="spec-value" id="specExt">300</div></div>
                                        <div class="spec-item" id="specRiserLItem" style="display:none"><div class="spec-label">Riser L</div><div class="spec-value" id="specRiserL">200Ã—150</div></div>
                                        <div class="spec-item" id="specRiserRItem" style="display:none"><div class="spec-label">Riser R</div><div class="spec-value" id="specRiserR">200Ã—150</div></div>
                                    </div>
                                </div>
                                <div class="truss-card">
                                    <h4>Cut Lengths</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">Chord (cut)</div><div class="spec-value hl" id="specChordCut">--</div></div>
                                        <div class="spec-item"><div class="spec-label">Rafter (cut)</div><div class="spec-value hl" id="specRafterCut">--</div></div>
                                        <div class="spec-item" id="specRiserLMitem" style="display:none"><div class="spec-label">Riser steel (ea)</div><div class="spec-value" id="specRiserLM">--</div></div>
                                        <div class="spec-item"><div class="spec-label">LM / truss</div><div class="spec-value" id="specLMper">--</div></div>
                                        <div class="spec-item"><div class="spec-label">LM all</div><div class="spec-value" id="specLMall">--</div></div>
                                    </div>
                                </div>
                                <div class="truss-card">
                                    <h4>Cut Angles</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">Apex Mitre</div><div class="spec-value" id="angleApex">80&deg;</div></div>
                                        <div class="spec-item"><div class="spec-label">Heel Mitre</div><div class="spec-value" id="angleBase">10&deg;</div></div>
                                    </div>
                                </div>
                            </div>
                            <div class="truss-card" id="webCard" style="display:none">
                                <h4>Web Members</h4>
                                <div class="spec-grid">
                                    <div class="spec-item"><div class="spec-label">Style</div><div class="spec-value" id="webStyle">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Count</div><div class="spec-value" id="webCount">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Cut Lengths</div><div class="spec-value" id="webCuts">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Web LM</div><div class="spec-value" id="webLM">--</div></div>
                                </div>
                            </div>
                            <div class="fab-box" id="fabOrder" style="display:none;white-space:pre;font-family:'SF Mono',monospace;font-size:10px;line-height:1.5;padding:12px;overflow-x:auto"></div>
                            <!-- Fabrication Cut List Panel (hidden from scoper) -->
                            <div id="cutListPanel" class="cut-list-panel" style="display:none">
                                <div class="panel-header">
                                    <h4>FABRICATION CUT LIST</h4>
                                    <button onclick="printCutList()" class="btn-small">Print</button>
                                    <button onclick="copyCutList()" class="btn-small">Copy</button>
                                </div>
                                <div class="tubing-summary">
                                    <span class="label">Tubing:</span>
                                    <span class="value" id="cutListTubing">76x38 RHS</span>
                                </div>
                                <table class="cut-list-table">
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Part</th>
                                            <th>Qty</th>
                                            <th>Cut Length</th>
                                            <th>End 1</th>
                                            <th>End 2</th>
                                            <th>Notes</th>
                                        </tr>
                                    </thead>
                                    <tbody id="cutListBody"></tbody>
                                </table>
                                <div class="cut-list-totals">
                                    <div class="total-item">
                                        <span>Total Pieces:</span>
                                        <span id="totalPieces">-</span>
                                    </div>
                                    <div class="total-item">
                                        <span>Total Linear:</span>
                                        <span id="totalLinear">-</span>
                                    </div>
                                    <div class="total-item">
                                        <span>Stock Lengths (6.5m):</span>
                                        <span id="stockLengths">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============ SECTION: BATTEN / PURLIN CALCULATOR ============ -->
        <div class="section" id="sec-battens" style="display:none">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-battens')">
                <div><div class="section-title" id="battenSectionTitle">Purlin &amp; Batten Calculator</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="padding:14px 16px">

                    <!-- ===== RAFTERS SUBSECTION (skillion only â€” spacing detail) ===== -->
                    <div id="rafterSubsection" style="margin-bottom:16px">
                        <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px;border-bottom:1px solid var(--sw-border);padding-bottom:4px">Rafter Spacing</div>

                        <!-- Rafter spacing -->
                        <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">
                            <label style="font-size:11px;color:var(--sw-text-sec);white-space:nowrap;min-width:80px">Spacing (mm):</label>
                            <input type="number" id="inRafterSpacing" value="900" min="300" max="2400" step="50" oninput="onRafterSpacingChange()" style="font-size:11px;padding:4px 8px;border:1px solid var(--sw-border);border-radius:4px;width:80px">
                            <div style="display:flex;gap:4px">
                                <button onclick="setRafterSpacing(900)" style="font-size:10px;padding:2px 6px;border:1px solid var(--sw-border);border-radius:3px;background:#fff;cursor:pointer">900</button>
                                <button onclick="setRafterSpacing(1000)" style="font-size:10px;padding:2px 6px;border:1px solid var(--sw-border);border-radius:3px;background:#fff;cursor:pointer">1000</button>
                                <button onclick="setRafterSpacing(1200)" style="font-size:10px;padding:2px 6px;border:1px solid var(--sw-border);border-radius:3px;background:#fff;cursor:pointer">1200</button>
                            </div>
                        </div>

                        <!-- Rafter result -->
                        <div id="rafterResult" style="background:var(--sw-bg);border-radius:8px;padding:10px;margin-bottom:4px">
                            <div style="font-size:13px;font-weight:600;margin-bottom:4px" id="rafterResultTitle">--</div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="rafterResultSpacing">--</div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="rafterResultLineal">--</div>
                        </div>
                    </div>

                    <!-- ===== BATTENS SUBSECTION (skillion) ===== -->
                    <div id="skillionBattenSubsection">
                        <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px;border-bottom:1px solid var(--sw-border);padding-bottom:4px">Battens</div>

                        <!-- Validation warnings -->
                        <div id="battenWarnings" style="display:none;margin-bottom:10px"></div>

                        <!-- Summary row -->
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px">
                            <div style="font-size:11px;color:var(--sw-text-sec)">Sheet: <strong id="battenSheetLabel" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Max span: <strong id="battenMaxSpan" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Projection: <strong id="battenProjection" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Pitch: <strong id="battenPitch" style="color:var(--sw-text)">--</strong></div>
                        </div>

                        <!-- Result -->
                        <div id="battenResult" style="background:var(--sw-bg);border-radius:8px;padding:12px;margin-bottom:12px">
                            <div style="font-size:13px;font-weight:600;margin-bottom:6px" id="battenResultTitle">--</div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="battenResultSpacing"></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="battenResultPositions"></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="battenResultBrackets"></div>
                        </div>

                        <!-- Extra battens override -->
                        <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
                            <label style="font-size:11px;color:var(--sw-text-sec);white-space:nowrap">Extra battens for rigidity:</label>
                            <button onclick="adjustExtraBattens(-1)" style="width:24px;height:24px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer;font-size:14px;line-height:1">-</button>
                            <span id="extraBattensVal" style="font-size:13px;font-weight:600;min-width:16px;text-align:center">0</span>
                            <button onclick="adjustExtraBattens(1)" style="width:24px;height:24px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer;font-size:14px;line-height:1">+</button>
                        </div>

                        <!-- Bracket type -->
                        <div id="battenBracketType" style="display:none;margin-bottom:12px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:6px">Bracket Type</div>
                            <div style="display:flex;gap:12px">
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="bracketType" value="internal" checked onchange="rebuildAll()"> Internal (hidden, slower)
                                </label>
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="bracketType" value="external" onchange="rebuildAll()"> External (visible, faster)
                                </label>
                            </div>
                            <div id="battenPowdercoatWarn" style="display:none;font-size:10px;color:#E67E22;margin-top:4px">External brackets need powdercoating to match roof colour</div>
                        </div>

                        <!-- Side-view diagram -->
                        <div style="background:#f8f9fa;border:1px solid var(--sw-border);border-radius:6px;padding:10px;overflow-x:auto">
                            <div style="font-size:9px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:6px">Side View (battens run left-to-right across patio)</div>
                            <pre id="battenDiagram" style="font-family:'SF Mono',monospace;font-size:10px;line-height:1.4;color:var(--sw-text);margin:0;white-space:pre"></pre>
                        </div>
                    </div>

                    <!-- ===== GABLE PURLINS SUBSECTION ===== -->
                    <div id="gableBattenSubsection" style="display:none">
                        <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px;border-bottom:1px solid var(--sw-border);padding-bottom:4px">Gable Purlins</div>

                        <!-- Summary row -->
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px">
                            <div style="font-size:11px;color:var(--sw-text-sec)">Sheet: <strong id="gableBattenSheet" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Max span: <strong id="gableBattenMaxSpan" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Rafter length: <strong id="gableBattenRafter" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Pitch: <strong id="gableBattenPitch" style="color:var(--sw-text)">--</strong></div>
                        </div>

                        <!-- Extra purlins override -->
                        <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">
                            <label style="font-size:11px;color:var(--sw-text-sec);white-space:nowrap">Extra purlins per side:</label>
                            <button onclick="adjustGableExtraBattens(-1)" style="width:24px;height:24px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer;font-size:14px;line-height:1">-</button>
                            <span id="gableExtraBattensVal" style="font-size:13px;font-weight:600;min-width:16px;text-align:center">0</span>
                            <button onclick="adjustGableExtraBattens(1)" style="width:24px;height:24px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer;font-size:14px;line-height:1">+</button>
                        </div>

                        <!-- Result -->
                        <div id="gableBattenResult" style="background:var(--sw-bg);border-radius:8px;padding:12px;margin-bottom:12px">
                            <div style="font-size:13px;font-weight:600;margin-bottom:6px" id="gableBattenResultTitle">--</div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="gableBattenResultBreakdown"></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="gableBattenResultSpacing"></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="gableBattenResultLineal"></div>
                        </div>

                        <!-- Gable cross-section diagram -->
                        <div style="background:#f8f9fa;border:1px solid var(--sw-border);border-radius:6px;padding:10px;overflow-x:auto">
                            <div style="font-size:9px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:6px">Cross Section (purlins run along patio length)</div>
                            <pre id="gableBattenDiagram" style="font-family:'SF Mono',monospace;font-size:10px;line-height:1.4;color:var(--sw-text);margin:0;white-space:pre"></pre>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: FINISHING ============ -->
        <div class="section" id="sec-finishing">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-finishing')">
                <div><div class="section-title">Finishing</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">

                    <!-- Ceiling Finish (SolarSpan only) -->
                    <div class="basics-group" id="ceilingFinishField" style="display:none">
                        <div class="basics-field" style="margin-bottom:10px">
                            <label>Ceiling Finish</label>
                            <input type="hidden" id="inCeilingFinish" value="plain">
                            <div class="toggle-btn-group">
                                <button type="button" class="toggle-btn active" data-value="plain" onclick="setDesignToggle('inCeilingFinish','plain',this)">Plain</button>
                                <button type="button" class="toggle-btn" data-value="vj" onclick="setDesignToggle('inCeilingFinish','vj',this)">VJ Groove</button>
                            </div>
                        </div>
                        <div class="basics-divider"></div>
                    </div>

                    <!-- Gable Infill (gable only) -->
                    <div class="basics-group" id="gableInfillField" style="display:none">
                        <div class="basics-field" style="margin-bottom:10px">
                            <label>Gable Infill</label>
                            <select id="inInfill" onchange="rebuildAll()">
                                <option value="colorbond">Colorbond</option>
                                <option value="polycarbonate">Polycarbonate</option>
                                <option value="louvre">Louvre</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                        <div class="basics-divider"></div>
                    </div>

                    <!-- Polycarbonate -->
                    <div id="polycarbField" style="display:none">
                        <div class="basics-group">
                            <div class="basics-group-title">Polycarbonate</div>
                            <div style="display:flex;align-items:center;gap:12px;margin-bottom:6px">
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="no" checked onchange="updatePolycarbUI();rebuildAll()"> No
                                </label>
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="yes" onchange="updatePolycarbUI();rebuildAll()"> Yes
                                </label>
                            </div>
                            <div id="polycarbOptions" style="display:none">
                                <div class="basics-grid-3" style="gap:6px">
                                    <div class="basics-field">
                                        <label>Brand</label>
                                        <select id="inPolycarbBrand" onchange="updatePolycarbTints();rebuildAll()">
                                            <option value="ampelite">Ampelite Solasafe</option>
                                            <option value="laserlite">Laserlite 2000</option>
                                        </select>
                                    </div>
                                    <div class="basics-field">
                                        <label>Tint</label>
                                        <select id="inPolycarbTint" onchange="rebuildAll()"></select>
                                    </div>
                                    <div class="basics-field">
                                        <label>Pattern</label>
                                        <select id="inPolycarbPattern" onchange="updatePolycarbPreview();rebuildAll()">
                                            <option value="2">Every 2nd (1:1)</option>
                                            <option value="3" selected>Every 3rd (2:1)</option>
                                            <option value="4">Every 4th (3:1)</option>
                                            <option value="custom">Custom</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="basics-grid-3" style="gap:6px;margin-top:4px">
                                    <div class="basics-field">
                                        <label>Level</label>
                                        <select id="inPolycarbLevel" onchange="rebuildAll()">
                                            <option value="1">Level 1 - Max Light</option>
                                            <option value="2">Level 2 - Medium</option>
                                        </select>
                                    </div>
                                    <div class="basics-field" id="polycarbProfileNote" style="display:flex;align-items:flex-end">
                                        <span style="font-size:10px;color:var(--sw-text-sec)" id="polycarbProfileLabel"></span>
                                    </div>
                                </div>
                                <div id="polycarbCustomField" style="display:none;margin-top:4px">
                                    <div class="basics-field" style="max-width:140px">
                                        <label>Colorbond per 1 polycarb</label>
                                        <input type="number" id="inPolycarbCustom" value="3" min="1" max="20" step="1" oninput="updatePolycarbPreview();rebuildAll()">
                                    </div>
                                </div>
                                <div style="margin-top:6px">
                                    <div style="font-size:10px;color:var(--sw-text-sec);margin-bottom:3px">Preview</div>
                                    <div id="polycarbPreview" style="display:flex;gap:2px;flex-wrap:wrap"></div>
                                    <div style="font-size:9px;color:var(--sw-text-sec);margin-top:3px">&#9632;=steel &#9633;=polycarb</div>
                                </div>
                            </div>
                        </div>
                        <div class="basics-divider"></div>
                    </div>

                    <!-- Box Gutter Designer -->
                    <div class="basics-group">
                        <button type="button" class="btn btn-secondary" style="font-size:11px;padding:6px 12px" onclick="openGutterDesigner()">Open Box Gutter Designer</button>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- Flashings Editor (moved from standalone section) -->
                    <div class="basics-group">
                        <div class="basics-group-title">Flashings</div>
                        <div class="flash-summary" style="padding:0;border:none;margin-bottom:8px">
                            <span class="flash-summary-text"><span class="flash-summary-count" id="flashSummaryCount">0</span> flashings defined</span>
                            <button class="flash-tool-btn" style="background:var(--sw-orange);color:white;border-color:var(--sw-orange)" onclick="openFlashModal()">Open Editor</button>
                        </div>
                        <table class="flash-table" id="flashJobTable">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Name</th>
                                    <th class="r">Girth</th>
                                    <th class="r">Length</th>
                                    <th class="r">Qty</th>
                                    <th>Colour</th>
                                    <th>Gauge</th>
                                    <th>Side</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody id="flashJobBody"></tbody>
                        </table>
                        <div class="flash-total-row" id="flashTotalRow" style="display:none">
                            Total area: <span id="flashTotalArea">0</span> m&sup2;
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: EXTRAS ============ -->
        <div class="section" id="sec-extras">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-extras')">
                <div><div class="section-title">Extras</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">

                    <!-- 1. EXISTING STRUCTURE -->
                    <div class="basics-group">
                        <div class="basics-group-title">Existing Structure</div>
                        <div class="basics-field" style="margin-bottom:8px">
                            <label>What's There Now?</label>
                            <select id="existingSite" onchange="updateExistingSite()">
                                <option value="clear" selected>Clear site</option>
                                <option value="patio">Old patio</option>
                                <option value="pergola">Pergola</option>
                                <option value="shadesail">Shadesail</option>
                                <option value="deck">Deck</option>
                                <option value="other">Other</option>
                            </select>
                        </div>
                        <div class="basics-field" id="demoNotesField" style="display:none;margin-bottom:8px">
                            <label>Demo Notes</label>
                            <textarea id="demoNotes" rows="2" placeholder="Describe what needs removing and any special requirements..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                            <div style="font-size:10px;color:var(--sw-text-sec);margin-top:2px">Add demo pricing to Additional Items below</div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 2. SITE ACCESS -->
                    <div class="basics-group">
                        <div class="basics-field">
                            <label>Site Access</label>
                            <div class="toggle-btn-group" id="siteAccessGroup">
                                <button type="button" class="toggle-btn active" data-value="easy" onclick="setToggle('siteAccess', 'easy', this)">Easy</button>
                                <button type="button" class="toggle-btn" data-value="moderate" onclick="setToggle('siteAccess', 'moderate', this)">Moderate</button>
                                <button type="button" class="toggle-btn" data-value="difficult" onclick="setToggle('siteAccess', 'difficult', this)">Difficult</button>
                            </div>
                            <input type="hidden" id="siteAccess" value="easy">
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 3. ELECTRICAL -->
                    <div class="basics-group">
                        <div class="basics-group-title">Electrical</div>
                        <div style="display:flex;flex-wrap:wrap;gap:16px;margin-bottom:8px">
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="elecDownlights" onchange="syncElectricalCheckboxes()"> Downlights
                                <input type="number" id="elecDownlightsQty" value="4" min="1" max="20" style="width:45px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:4px;font-size:11px;text-align:center">
                            </label>
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="elecFan" onchange="syncElectricalCheckboxes()"> Ceiling Fan
                                <input type="number" id="elecFanQty" value="1" min="1" max="5" style="width:45px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:4px;font-size:11px;text-align:center">
                            </label>
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="elecGPO" onchange="syncElectricalCheckboxes()"> GPO
                                <input type="number" id="elecGPOQty" value="1" min="1" max="5" style="width:45px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:4px;font-size:11px;text-align:center">
                            </label>
                        </div>
                        <div id="elecSolarSpanNote" style="display:none;font-size:10px;color:#E67E22;margin-top:4px">Crew runs cable in panel chase. Electrician does final connections.</div>
                        <!-- Hidden dropdown for backward compatibility -->
                        <select id="electrical" style="display:none" onchange="updateUI()">
                            <option value="none" selected>None</option>
                            <option value="downlights">Downlights</option>
                            <option value="fan">Fan point</option>
                            <option value="both">Both</option>
                        </select>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 4. ADDITIONAL CHECKBOXES -->
                    <div class="basics-group">
                        <div style="display:flex;flex-wrap:wrap;gap:16px">
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="scopeSkip"> Skip bin
                            </label>
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="scopePermit"> Council permit required
                            </label>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 5. SITE REFERENCE (collapsible, for work order info) -->
                    <div class="basics-group">
                        <div class="basics-group-title" style="cursor:pointer" onclick="var b=this.nextElementSibling;b.style.display=b.style.display==='none'?'block':'none'">
                            Site Reference <span style="font-size:9px;color:var(--sw-text-sec)">(appears on work order) &#9656;</span>
                        </div>
                        <div id="siteReferenceBody" style="display:none">
                            <div class="basics-grid-3" style="gap:8px">
                                <div class="basics-field">
                                    <label>Existing Roof</label>
                                    <div class="toggle-btn-group" id="existingRoofGroup">
                                        <button type="button" class="toggle-btn active" data-value="tiles" onclick="setToggle('existingRoof', 'tiles', this)">Tiles</button>
                                        <button type="button" class="toggle-btn" data-value="colorbond" onclick="setToggle('existingRoof', 'colorbond', this)">Colorbond</button>
                                        <button type="button" class="toggle-btn" data-value="flat" onclick="setToggle('existingRoof', 'flat', this)">Flat</button>
                                    </div>
                                    <input type="hidden" id="existingRoof" value="tiles">
                                </div>
                                <div class="basics-field">
                                    <label>Fascia Material</label>
                                    <div class="toggle-btn-group" id="fasciaMaterialGroup">
                                        <button type="button" class="toggle-btn active" data-value="timber" onclick="setToggle('fasciaMaterial', 'timber', this)">Timber</button>
                                        <button type="button" class="toggle-btn" data-value="metal" onclick="setToggle('fasciaMaterial', 'metal', this)">Metal</button>
                                        <button type="button" class="toggle-btn" data-value="fc" onclick="setToggle('fasciaMaterial', 'fc', this)">Fibre Cement</button>
                                    </div>
                                    <input type="hidden" id="fasciaMaterial" value="timber">
                                </div>
                                <div class="basics-field">
                                    <label>Wall Type</label>
                                    <div class="toggle-btn-group" id="wallTypeGroup">
                                        <button type="button" class="toggle-btn active" data-value="doublebrick" onclick="setToggle('wallType', 'doublebrick', this)">Double Brick</button>
                                        <button type="button" class="toggle-btn" data-value="veneer" onclick="setToggle('wallType', 'veneer', this)">Brick Veneer</button>
                                        <button type="button" class="toggle-btn" data-value="rendered" onclick="setToggle('wallType', 'rendered', this)">Rendered</button>
                                    </div>
                                    <input type="hidden" id="wallType" value="doublebrick">
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- Fullscreen flashing editor modal (outside section flow) -->
        <div class="flash-modal-overlay" id="flashModalOverlay">
            <div class="flash-modal">
                <!-- Header with tabs -->
                <div class="flash-modal-header">
                    <div class="flash-modal-tabs">
                        <button class="flash-tab active" id="flashTabStandard" onclick="switchFlashTab('standard')">Standard Flashings</button>
                        <button class="flash-tab" id="flashTabBoxGutter" onclick="switchFlashTab('boxgutter')">Box Gutter</button>
                    </div>
                    <button class="flash-modal-close" onclick="closeFlashModal()" title="Close">&times;</button>
                </div>
                <!-- Standard flashing body: sidebar + canvas -->
                <div class="flash-modal-body" id="flashBodyStandard">
                    <!-- Left sidebar: templates -->
                    <div class="flash-sidebar">
                        <div class="flash-sidebar-title">Templates</div>
                        <div class="flash-sidebar-scroll" id="flashTemplates"></div>
                        <div style="padding:6px 8px;border-top:1px solid var(--sw-border)">
                            <div class="flash-tpl" style="border-style:dashed;cursor:pointer;display:inline-block" onclick="saveFlashTemplate()">
                                <div style="font-size:16px;color:var(--sw-text-sec)">+</div>
                                <div class="flash-tpl-name">Save Current</div>
                            </div>
                        </div>
                    </div>
                    <!-- Right: canvas area -->
                    <div class="flash-canvas-area">
                        <div class="flash-viewport" id="flashViewport">
                            <canvas id="flashCanvas"></canvas>
                            <!-- Inspector panel (floating) -->
                            <div class="flash-inspector" id="flashInspector" style="display:none">
                                <div class="flash-inspector-header">
                                    <span id="flashInspTitle">Point 1</span>
                                    <button class="flash-inspector-close" onclick="closeFlashInspector()">&times;</button>
                                </div>
                                <div class="flash-inspector-body" id="flashInspBody"></div>
                            </div>
                        </div>
                        <!-- Info bar -->
                        <div class="flash-info" id="flashInfoBar">
                            <span>Girth: <span class="flash-info-val" id="flashGirth">0</span> mm</span>
                            <span>Legs: <span class="flash-info-val" id="flashLegs">0</span></span>
                            <span style="margin-left:auto"></span>
                            <div class="flash-zoom-ctrl">
                                <button class="flash-zoom-btn" onclick="flashZoomIn()" title="Zoom in">+</button>
                                <span class="flash-info-val" id="flashZoom">10</span>
                                <span style="font-size:9px;color:var(--sw-text-sec)">mm/grid</span>
                                <button class="flash-zoom-btn" onclick="flashZoomOut()" title="Zoom out">&minus;</button>
                                <button class="flash-zoom-btn" onclick="flashZoomFit()" title="Fit profile to view" style="font-size:9px;width:auto;padding:0 6px">Fit</button>
                            </div>
                        </div>
                        <!-- Status bar (mode-aware) -->
                        <div class="flash-status-bar" id="flashStatusBar">
                            <span id="flashStatusMode" class="flash-status-mode">VIEWING</span>
                            <span class="flash-status-sep"></span>
                            <span id="flashStatusHints">Double-click to start drawing &bull; Click point to select &bull; Scroll to zoom</span>
                            <span style="flex:1"></span>
                            <button id="flashStatusBtn" class="flash-status-btn" style="display:none" onclick="flashStatusAction()">Cancel</button>
                        </div>
                        <!-- Toolbar -->
                        <div class="flash-toolbar">
                            <button class="flash-tool-btn" onclick="flashUndo()" title="Undo (Ctrl+Z)">Undo</button>
                            <button class="flash-tool-btn" onclick="flashRedo()" title="Redo (Ctrl+Y)">Redo</button>
                            <div class="flash-tool-sep"></div>
                            <button class="flash-tool-btn" onclick="flashClearConfirm()" title="Clear entire profile">Clear All</button>
                            <div class="flash-tool-sep"></div>
                            <button class="flash-tool-btn" id="flashSnapToggle" onclick="toggleFlashSnap()" title="Toggle 45Â° angle snapping">Snap: OFF</button>
                            <div class="flash-tool-sep"></div>
                            <button class="flash-tool-btn" onclick="flashFlipH()" title="Flip horizontal (H)">Flip H</button>
                            <button class="flash-tool-btn" onclick="flashFlipV()" title="Flip vertical (V)">Flip V</button>
                            <div class="flash-tool-sep"></div>
                            <div class="flash-colour-side">
                                <span style="font-size:10px;color:var(--sw-text-sec)">Colour face:</span>
                                <button class="flash-cs-btn active" data-cs="inside" onclick="setColourSide('inside',this)">Inside</button>
                                <button class="flash-cs-btn" data-cs="outside" onclick="setColourSide('outside',this)">Outside</button>
                            </div>
                            <div class="flash-tool-sep"></div>
                            <div style="display:flex;align-items:center;gap:4px">
                                <span style="font-size:10px;color:var(--sw-text-sec)">Start:</span>
                                <select id="flashStartTreat" onchange="updateFlashTreatment('start')" style="font-size:10px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:3px">
                                    <option value="none">None</option>
                                    <option value="miniBreak">Mini Break</option>
                                    <option value="hem">Hem</option>
                                </select>
                                <span style="font-size:10px;color:var(--sw-text-sec)">End:</span>
                                <select id="flashEndTreat" onchange="updateFlashTreatment('end')" style="font-size:10px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:3px">
                                    <option value="none">None</option>
                                    <option value="miniBreak">Mini Break</option>
                                    <option value="hem">Hem</option>
                                </select>
                            </div>
                            <div id="flashTreatOpts" style="display:none;align-items:center;gap:4px">
                                <span style="font-size:9px;color:var(--sw-text-sec)">Size:</span>
                                <input type="number" id="flashTreatSize" value="10" min="3" max="30" style="width:36px;font-size:10px;padding:1px 3px;border:1px solid var(--sw-border);border-radius:3px">
                                <span style="font-size:9px;color:var(--sw-text-sec)">Angle:</span>
                                <input type="number" id="flashTreatAngle" value="45" min="10" max="90" step="5" style="width:36px;font-size:10px;padding:1px 3px;border:1px solid var(--sw-border);border-radius:3px">
                                <button class="flash-cs-btn active" id="flashTreatDirOut" onclick="setTreatDir('out')" style="font-size:9px;padding:1px 5px">Out</button>
                                <button class="flash-cs-btn" id="flashTreatDirIn" onclick="setTreatDir('in')" style="font-size:9px;padding:1px 5px">In</button>
                            </div>
                            <div style="flex:1"></div>
                            <button class="flash-tool-btn" style="background:var(--sw-orange);color:white;border-color:var(--sw-orange)" onclick="flashAddToJob()">+ Add to Job</button>
                        </div>
                        <!-- Add to job fields -->
                        <div class="flash-add-bar">
                            <div><label>Name</label><input type="text" id="flashName" placeholder="Apron - Back Wall" value=""></div>
                            <div><label>Colour</label>
                                <select id="flashColour">
                                    <option>Monument</option><option>Woodland Grey</option><option>Paperbark</option><option>Surfmist</option>
                                    <option>Basalt</option><option>Manor Red</option><option selected>Deep Ocean</option><option>Windspray</option>
                                </select>
                            </div>
                            <div><label>Gauge</label>
                                <select id="flashGauge">
                                    <option value="0.42" selected>0.42</option><option value="0.48">0.48</option><option value="0.55">0.55</option>
                                </select>
                            </div>
                            <div><label>Length <span style="font-size:9px;color:var(--sw-text-sec)">mm</span></label><input type="number" id="flashLength" value="4500" step="100"></div>
                            <div><label>Qty</label><input type="number" id="flashQty" value="1" min="1" step="1"></div>
                        </div>
                    </div>
                </div>
                <!-- Box Gutter body -->
                <div class="flash-modal-body" id="flashBodyBoxGutter" style="display:none;flex-direction:column;padding:20px;overflow-y:auto">
                    <div style="max-width:600px;margin:0 auto;width:100%">
                        <h3 style="font-size:14px;font-weight:700;margin-bottom:16px;color:var(--sw-text)">BOX GUTTER DESIGNER</h3>
                        <!-- Catchment -->
                        <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Catchment &amp; Sizing</div>
                            <div class="basics-grid-2" style="gap:8px;margin-bottom:8px">
                                <div class="basics-field">
                                    <label>House roof catchment (m&sup2;)</label>
                                    <input type="number" id="bgCatchment" value="85" min="10" max="500" step="5" oninput="updateBGDesigner()">
                                </div>
                                <div class="basics-field">
                                    <label>Patio adds to catchment?</label>
                                    <div class="toggle-btn-group" id="bgPatioCatchGroup">
                                        <button type="button" class="toggle-btn" data-value="no" onclick="setToggle('bgPatioCatch','no',this);updateBGDesigner()">No</button>
                                        <button type="button" class="toggle-btn active" data-value="yes" onclick="setToggle('bgPatioCatch','yes',this);updateBGDesigner()">Yes</button>
                                    </div>
                                    <input type="hidden" id="bgPatioCatch" value="yes">
                                </div>
                            </div>
                            <div id="bgCatchSummary" style="font-size:11px;color:var(--sw-text-sec);margin-bottom:4px">Total catchment: -- m&sup2;</div>
                            <div id="bgWidthRec" style="font-size:12px;font-weight:600;color:var(--sw-text)">Minimum width required: --</div>
                            <div id="bgCatchWarn" style="display:none;font-size:10px;color:#7D6608;background:#FEF9E7;border:1px solid #F39C12;border-radius:4px;padding:4px 8px;margin-top:6px"></div>
                        </div>
                        <!-- Dimensions -->
                        <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Dimensions</div>
                            <div class="basics-grid-2" style="gap:8px">
                                <div class="basics-field"><label>Width (mm)</label><input type="number" id="bgWidth" value="300" min="200" max="600" step="10" oninput="updateBGDesigner()"></div>
                                <div class="basics-field"><label>Depth (mm)</label><input type="number" id="bgDepth" value="100" min="50" max="200" step="10" oninput="updateBGDesigner()"></div>
                                <div class="basics-field"><label>Back Height (mm)</label><input type="number" id="bgBackH" value="70" min="30" max="200" step="5" oninput="updateBGDesigner()"></div>
                                <div class="basics-field"><label>Front Height (mm)</label><input type="number" id="bgFrontH" value="130" min="50" max="300" step="5" oninput="updateBGDesigner()"></div>
                                <div class="basics-field"><label>Length (mm)</label><input type="number" id="bgLength" value="6200" min="1000" max="12000" step="100" oninput="updateBGDesigner()"></div>
                            </div>
                            <div id="bgDimWarn" style="display:none;font-size:10px;color:#7D6608;background:#FEF9E7;border:1px solid #F39C12;border-radius:4px;padding:4px 8px;margin-top:6px"></div>
                        </div>
                        <!-- Material -->
                        <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Material</div>
                            <div class="basics-grid-2" style="gap:8px">
                                <div class="basics-field">
                                    <label>Gauge</label>
                                    <select id="bgGauge" onchange="updateBGDesigner()"><option value="0.42">0.42 BMT</option><option value="0.48">0.48 BMT</option><option value="0.55" selected>0.55 BMT</option></select>
                                </div>
                                <div class="basics-field">
                                    <label>Colour</label>
                                    <select id="bgColour"><option>Monument</option><option>Woodland Grey</option><option>Paperbark</option><option>Surfmist</option><option>Basalt</option><option selected>Deep Ocean</option><option>Windspray</option></select>
                                </div>
                            </div>
                            <div style="margin-top:6px">
                                <label style="font-size:10px;color:var(--sw-text-sec)">Colour side:</label>
                                <span style="font-size:11px;font-weight:600"> Inside (channel)</span>
                            </div>
                        </div>
                        <!-- Outlet -->
                        <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Outlet</div>
                            <div class="basics-grid-2" style="gap:8px">
                                <div class="basics-field">
                                    <label>Position</label>
                                    <select id="bgOutletPos"><option value="left">Left end</option><option value="right" selected>Right end</option><option value="centre">Centre</option><option value="both">Both ends</option></select>
                                </div>
                                <div class="basics-field">
                                    <label>Size</label>
                                    <select id="bgOutletSize"><option value="90round">90mm round</option><option value="100round" selected>100mm round</option></select>
                                </div>
                            </div>
                        </div>
                        <!-- Profile Preview -->
                        <div style="margin-bottom:16px;padding:12px;background:#fff;border:1px solid var(--sw-border);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Profile Preview</div>
                            <canvas id="bgPreviewCanvas" width="560" height="200" style="width:100%;height:200px;border:1px solid #eee;border-radius:4px"></canvas>
                        </div>
                        <!-- Validation -->
                        <div id="bgValidation" style="margin-bottom:16px"></div>
                        <!-- Add button -->
                        <button class="flash-tool-btn" style="background:var(--sw-orange);color:white;border-color:var(--sw-orange);width:100%;padding:10px;font-size:13px" onclick="bgAddToJob()">+ Add Box Gutter to Job</button>
                    </div>
                </div>
            </div>
        </div>

        </div><!-- end group-build -->

        <!-- Hidden elements (JS targets, not visible) -->
        <div id="preOrderChecks" style="display:none"></div>
        <div style="display:none"><div id="matList"></div></div>

        <!-- ======== GROUP: SALE ======== -->
        <div class="section-group" id="group-sale">
        <div class="section-group-header">Sale</div>

        <!-- ============ SECTION: PRICING & COSTS ============ -->
        <div class="section" id="sec-pricing">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-pricing')">
                <div><div class="section-title">Pricing &amp; Costs</div></div>
                <div style="display:flex;align-items:center;gap:8px">
                    <button class="settings-gear" onclick="event.stopPropagation();openRatesModal()" title="Stored Rates">&#9881;</button>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="background:#f5f5f5;padding:16px">

                    <!-- ===== SUB-SECTION 1: PATIO MATERIALS ===== -->
                    <div class="pricing-subsection">
                        <div class="pricing-sub-hdr" style="border-left-color:#E8552A">
                            <span>Patio Materials</span>
                            <span style="font-size:10px;font-weight:400;color:var(--sw-text-sec)">Auto-calculated from design</span>
                        </div>
                        <div class="pricing-sub-body">
                            <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
                                <label style="font-size:11px;color:var(--sw-text-sec)">Markup:</label>
                                <input type="number" id="globalMarkupPct" value="35" min="0" max="200" step="1" style="width:55px;padding:3px 6px;border:1px solid var(--sw-border);border-radius:4px;font-size:11px;text-align:center" onchange="applyMarkupAll()">
                                <span style="font-size:11px;color:var(--sw-text-sec)">%</span>
                                <button style="font-size:10px;padding:3px 8px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer" onclick="applyMarkupAll()">Apply All</button>
                            </div>
                            <div id="patioMaterialsTable"></div>
                            <div class="pricing-subtotal" id="matSubtotal">
                                <span>Patio Materials Subtotal:</span>
                                <span id="matSellDisplay">$0</span>
                                <span style="font-size:10px;color:var(--sw-text-sec)">(cost: <span id="matCostDisplay">$0</span> | markup: <span id="matMarkupPct">0%</span>)</span>
                            </div>
                        </div>
                    </div>

                    <!-- ===== SUB-SECTION 2: ADDITIONAL MATERIALS ===== -->
                    <div class="pricing-subsection">
                        <div class="pricing-sub-hdr" style="border-left-color:#2980B9">
                            <span>Additional Materials</span>
                        </div>
                        <div class="pricing-sub-body">
                            <div id="additionalMaterialsTable"></div>
                            <div class="am-quick-add">
                                <span style="font-size:10px;color:var(--sw-text-sec);font-weight:600">Quick add:</span>
                                <button class="extras-pill" onclick="quickAddMaterial('electrical')">+ Electrical</button>
                                <button class="extras-pill" onclick="quickAddMaterial('post')">+ Extra Post</button>
                                <button class="extras-pill" onclick="quickAddMaterial('skip')">+ Skip Bin</button>
                                <button class="extras-pill" onclick="quickAddMaterial('permit')">+ Permit</button>
                                <button class="extras-pill" onclick="quickAddMaterial('other')">+ Other</button>
                            </div>
                            <div class="pricing-subtotal" id="addMatSubtotal" style="display:none">
                                <span>Additional Subtotal:</span>
                                <span style="font-size:10px;color:var(--sw-text-sec)">(cost: <span id="addMatCostDisplay">$0</span>)</span>
                                <span id="addMatSellDisplay">$0</span>
                            </div>
                        </div>
                    </div>

                    <!-- ===== SUB-SECTION 3: SCOPE ITEMS ===== -->
                    <div class="pricing-subsection">
                        <div class="pricing-sub-hdr" style="border-left-color:#8E44AD">
                            <span>Scope Items</span>
                        </div>
                        <div class="pricing-sub-body">
                            <div class="extras-pills">
                                <button class="extras-pill" onclick="addExtra('footings')">+ Footings</button>
                                <button class="extras-pill" onclick="addExtra('electrical')">+ Electrical</button>
                                <button class="extras-pill" onclick="addExtra('downlights')">+ Downlights</button>
                                <button class="extras-pill" onclick="addExtra('demo')">+ Demo</button>
                                <button class="extras-pill" onclick="addExtra('delivery')">+ Delivery</button>
                                <button class="extras-pill" onclick="addExtra('crane')">+ Crane Hire</button>
                                <button class="extras-pill" onclick="addExtra('permit')">+ Council/Permit</button>
                                <button class="extras-pill" onclick="addExtra('soakwell')">+ Soakwell</button>
                                <button class="extras-pill" onclick="addExtra('skip')">+ Skip Bin</button>
                                <button class="extras-pill" onclick="addExtra('other')">+ Custom</button>
                            </div>
                            <div class="extras-rows" id="extrasRowsContainer"></div>
                            <div class="pricing-subtotal" id="scopeSubtotal" style="display:none">
                                <span>Scope Subtotal:</span>
                                <span id="scopeSellDisplay">$0</span>
                            </div>
                        </div>
                    </div>

                    <!-- ===== SUB-SECTION 4: LABOUR ===== -->
                    <div class="pricing-subsection">
                        <div class="pricing-sub-hdr" style="border-left-color:#666">
                            <span>Labour</span>
                        </div>
                        <div class="pricing-sub-body">
                            <div class="labour-inline">
                                <input type="number" class="li-input" id="labTrades" value="2" min="0" step="1" oninput="updateLabour()">
                                <span class="li-label">trades</span>
                                <input type="number" class="li-input" id="labLabourers" value="0" min="0" step="1" oninput="updateLabour()">
                                <span class="li-label">labourers</span>
                                <span class="li-label">&times;</span>
                                <input type="number" class="li-input" id="labDays" value="1.5" min="0.5" step="0.5" oninput="updateLabour()">
                                <span class="li-label">days</span>
                            </div>
                            <div style="display:flex;gap:16px;margin-top:8px;font-size:12px">
                                <span>Cost: <strong id="labCostDisplay">$0</strong></span>
                                <span>Sell: <strong id="labSellDisplay">$0</strong></span>
                            </div>
                            <!-- Hidden fields for backward compat with export/import -->
                            <input type="hidden" id="labDayRate" value="400">
                            <input type="hidden" id="labSellInput" value="2000">
                        </div>
                    </div>

                    <!-- ===== TOTAL + OUTPUTS ===== -->
                    <!-- Output buttons (non-sticky, stay in flow) -->
                    <div style="background:#fff;border-radius:8px;padding:14px 16px;box-shadow:0 1px 4px rgba(0,0,0,0.06);text-align:center;margin-bottom:8px">
                        <!-- Primary exports -->
                        <div class="output-buttons" style="margin-bottom:8px">
                            <button class="btn btn-primary" onclick="generateQuotePDF()">Quote PDF</button>
                            <button class="btn btn-primary" onclick="generateWorkOrderPDF()">Work Order</button>
                            <button class="btn btn-primary" onclick="generateMaterialOrder()">Material Order</button>
                        </div>
                        <div id="materialOrderOptions" class="material-order-options" style="display: none;">
                            <span style="color: #888; font-size: 12px; margin-right: 6px;">Copy section:</span>
                            <button onclick="copySectionToClipboard('steel')" class="btn-small">Copy Steel</button>
                            <button onclick="copySectionToClipboard('sheets')" class="btn-small">Copy Sheets</button>
                            <button onclick="copySectionToClipboard('fab')" class="btn-small" id="copyFabBtn">Copy Fab</button>
                            <button onclick="downloadMaterialOrderPDF()" class="btn-small" style="border-color:var(--sw-orange);color:var(--sw-orange)">Download PDF</button>
                        </div>
                        <!-- Save/Load -->
                        <div style="display:flex;justify-content:center;gap:8px;margin-top:6px">
                            <button class="btn btn-secondary" onclick="exportRawData()">Save Job</button>
                            <label class="btn btn-secondary" style="cursor: pointer;">
                                Load Job
                                <input type="file" accept=".json" onchange="loadRawData(this.files[0])" style="display: none;">
                            </label>
                        </div>
                    </div>

                    <!-- Hidden field for backward compatibility -->
                    <textarea id="noteMaterialOrder" style="display:none"></textarea>

                    <!-- ===== TOTALS TABLE ===== -->
                    <div class="pricing-subsection">
                        <div class="pricing-sub-hdr" style="border-left-color:#293C46">
                            <span>Totals</span>
                        </div>
                        <div class="pricing-sub-body">
                            <table class="totals-table" id="totalsTable">
                                <thead><tr><th></th><th class="r">Cost</th><th class="r">Sell</th></tr></thead>
                                <tbody>
                                    <tr><td>Patio Materials</td><td class="r mono" id="ttMatCost">$0</td><td class="r mono" id="ttMatSell">$0</td></tr>
                                    <tr id="ttAddRow"><td>Additional Materials</td><td class="r mono" id="ttAddCost">$0</td><td class="r mono" id="ttAddSell">$0</td></tr>
                                    <tr id="ttScopeRow"><td>Scope Items</td><td class="r mono" id="ttScopeCost">$0</td><td class="r mono" id="ttScopeSell">$0</td></tr>
                                    <tr><td>Labour</td><td class="r mono" id="ttLabCost">$0</td><td class="r mono" id="ttLabSell">$0</td></tr>
                                </tbody>
                                <tfoot>
                                    <tr class="tt-subtotal"><td>Subtotal (ex GST)</td><td class="r mono" id="ttSubCost">$0</td><td class="r mono" id="ttSubSell">$0</td></tr>
                                    <tr class="tt-gst"><td>GST (10%)</td><td class="r mono"></td><td class="r mono" id="ttGst">$0</td></tr>
                                    <tr class="tt-total"><td>TOTAL (inc GST)</td><td class="r mono"></td><td class="r mono" id="ttTotal">$0</td></tr>
                                    <tr class="tt-margin"><td>Margin</td><td class="r mono" colspan="2" id="ttMargin">$0 (0%)</td></tr>
                                </tfoot>
                            </table>
                        </div>
                    </div>

                    <!-- Sticky total bar -->
                    <div class="total-card" id="totalCard">
                        <div class="total-amount" id="totalAmountDisplay" style="font-size:24px">TOTAL $0 inc GST</div>
                        <div class="total-breakdown" id="totalBreakdown">
                            <span><span class="bd-label">Materials:</span> <span class="bd-val" id="bdMatVal">$0</span></span>
                            <span><span class="bd-label">Additional:</span> <span class="bd-val" id="bdAddVal">$0</span></span>
                            <span><span class="bd-label">Scope:</span> <span class="bd-val" id="bdScopeVal">$0</span></span>
                            <span><span class="bd-label">Labour:</span> <span class="bd-val" id="bdLabVal">$0</span></span>
                        </div>
                        <div class="total-margin" id="totalMarginDisplay" style="font-size:12px;margin-top:4px">Margin: $0 (0%)</div>
                    </div>

                    <!-- Keep legacy textarea hidden for compat -->
                    <textarea id="pricingNotes" style="display:none"></textarea>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: NOTES ============ -->
        <div class="section" id="sec-notes">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-notes')">
                <div><div class="section-title">Notes</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">
                    <div class="basics-group">
                        <div class="basics-field" style="margin-bottom:12px">
                            <label style="font-weight:600;font-size:11px">Quote Note <span style="font-weight:400;color:var(--sw-text-sec)">(appears on customer quote)</span></label>
                            <textarea id="noteQuote" rows="2" placeholder="e.g. Price includes removal of existing pergola..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                        </div>
                        <div class="basics-field" style="margin-bottom:12px">
                            <label style="font-weight:600;font-size:11px">Work Order Note <span style="font-weight:400;color:var(--sw-text-sec)">(for install crew)</span></label>
                            <textarea id="noteWorkOrder" rows="2" placeholder="e.g. Access via side gate, dog on property..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                        </div>
                        <div class="basics-field">
                            <label style="font-weight:600;font-size:11px">Internal Note <span style="font-weight:400;color:var(--sw-text-sec)">(office only &mdash; doesn't print)</span></label>
                            <textarea id="noteInternal" rows="2" placeholder="e.g. Margin notes, follow-up reminders..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        </div><!-- end group-sale -->

        </div><!-- end panel-left -->

        <div class="panel-right" id="panelRight">

            <!-- Top row: Price Summary + Site Plan side-by-side -->
            <div style="display:flex;gap:12px;margin-bottom:16px;align-items:stretch">

                <!-- Price Summary (60%) -->
                <div class="rp-price-card" id="rpPriceCard" style="flex:3;margin-bottom:0">
                    <div class="rp-price-body">
                        <div>
                            <div class="rp-price-total" id="rpPriceTotal">$0 inc GST</div>
                            <div class="rp-price-margin" id="rpPriceMargin"></div>
                        </div>
                        <div style="text-align:right">
                            <div class="rp-price-sqm"><span id="rpDims">6.0m &times; 3.0m</span> &bull; <span id="rpRoofType">Skillion</span></div>
                            <div class="rp-price-sqm"><span id="rpMaterial">Corrugated</span> &bull; <span id="rpColour">Monument</span></div>
                            <div class="rp-price-sqm" style="font-size:10px;color:var(--sw-text-sec)">Rise: <span id="rpRise">--</span> &bull; Rafter: <span id="rpRafter">--</span></div>
                        </div>
                    </div>
                    <!-- Mini breakdown -->
                    <div class="rp-breakdown" id="rpBreakdown">
                        <div class="rp-bd-row"><span>Materials</span><span id="rpBdMat">$0</span></div>
                        <div class="rp-bd-row"><span>Labour</span><span id="rpBdLab">$0</span></div>
                        <div class="rp-bd-row" id="rpBdScopeRow" style="display:none"><span>Scope Items</span><span id="rpBdScope">$0</span></div>
                        <div class="rp-bd-row rp-bd-total"><span>Subtotal (ex GST)</span><span id="rpBdSubtotal">$0</span></div>
                        <div class="rp-bd-row"><span>GST 10%</span><span id="rpBdGst">$0</span></div>
                    </div>
                    <div style="display:flex;justify-content:center;padding:4px 16px 10px;gap:8px">
                        <div class="rp-est-range" id="rpEstRange" style="font-size:13px;padding:0">&mdash;</div>
                        <button class="btn btn-secondary" style="font-size:10px;padding:3px 8px" onclick="copyEstimate()">Copy</button>
                    </div>
                </div>

                <!-- Site Plan (40%) -->
                <div class="rp-card" style="flex:2;margin-bottom:0;display:flex;flex-direction:column">
                    <div class="rp-card-hdr" style="padding:8px 12px;font-size:12px">Site Plan</div>
                    <div class="rp-card-body" style="padding:6px;flex:1;display:flex">
                        <div class="plan-2d" style="flex:1;min-height:140px"><canvas id="plan2d"></canvas></div>
                    </div>
                </div>

            </div>

            <!-- 3D Assembly Preview -->
            <div class="rp-card">
                <div class="rp-card-hdr">3D Preview</div>
                <div class="asm-viewport" id="asmViewport" style="height:360px;border-radius:0">
                    <canvas id="asmCanvas"></canvas>
                    <!-- Top-right toolbar -->
                    <div class="asm-toolbar">
                        <button class="asm-tool-btn" id="dimToggleBtn" onclick="toggleAsmDimensions()">&#x1F4D0; Dimensions</button>
                        <div class="asm-tool-sep"></div>
                        <select id="asmSectionSelect" onchange="handleAsmSectionChange(this.value)">
                            <option value="">Section Views...</option>
                            <option value="riser">Riser Detail</option>
                            <option value="post">Post Detail</option>
                            <option value="gutter">Gutter Detail</option>
                            <option value="ridge">Ridge Detail</option>
                        </select>
                        <div class="asm-tool-sep"></div>
                        <button class="asm-tool-btn" onclick="toggleFullscreen()">&#x26F6; Fullscreen</button>
                        <button class="asm-tool-btn primary" onclick="exportWorkOrderViews()">&#x1F4F7; Export Views</button>
                    </div>
                    <div class="layer-panel">
                        <div class="layer-title">Layers</div>
                        <div class="layer-item active" data-layer="steel" onclick="toggleLayer('steel',this)"><span class="layer-check"></span>Steel</div>
                        <div class="layer-item active" data-layer="roof" onclick="toggleLayer('roof',this)"><span class="layer-check"></span>Roofing</div>
                        <div class="layer-item active" data-layer="acc" onclick="toggleLayer('acc',this)"><span class="layer-check"></span>Gutters/DP</div>
                        <div class="layer-item active" data-layer="house" onclick="toggleLayer('house',this)"><span class="layer-check"></span>House</div>
                    </div>
                    <div class="tooltip" id="tooltip"><div class="tooltip-title" id="ttTitle"></div><div id="ttContent"></div></div>
                    <div id="asmPropertiesPanel" class="properties-panel" style="display: none;"></div>
                    <div class="view-panel">
                        <button class="view-btn active" data-view="3d" onclick="setAsmView('3d',this)">3D</button>
                        <button class="view-btn" data-view="front" onclick="setAsmView('front',this)">Front</button>
                        <button class="view-btn" data-view="side" onclick="setAsmView('side',this)">Side</button>
                        <button class="view-btn" data-view="top" onclick="setAsmView('top',this)">Top</button>
                    </div>
                </div>
            </div>

            <!-- Customer Preview Generator (collapsible) -->
            <div class="rp-card" id="aiPreviewSection">
                <div class="rp-card-hdr" style="cursor:pointer" onclick="var t=document.getElementById('aiPreviewBody');t.style.display=t.style.display==='none'?'':'none'">Customer Preview Generator <span style="float:right;font-size:11px;color:var(--sw-text-sec)">&#9662;</span></div>
                <div id="aiPreviewBody" class="rp-card-body">
                    <p style="margin: 0 0 12px 0; font-size: 13px; color: #666;">
                        Generate a photorealistic image for your customer using AI.
                    </p>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button id="screenshot3DBtn" onclick="capture3DScreenshot()">
                            1. Screenshot 3D
                        </button>
                        <button id="generatePromptBtn" onclick="generateGeminiPrompt()">
                            2. Copy Prompt &amp; Open Gemini
                        </button>
                    </div>
                    <div id="screenshotPreview" style="display: none; margin-top: 12px;">
                        <p style="font-size: 12px; color: #666; margin-bottom: 8px;">3D Screenshot (right-click to save):</p>
                        <img id="screenshotImg" style="max-width: 300px; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    <div id="promptInstructions" style="display: none; margin-top: 12px; padding: 12px; background: #e8f5e9; border-radius: 4px;">
                        <p style="margin: 0; font-size: 13px; color: #2e7d32;">
                            Prompt copied! In Gemini:<br>
                            1. Upload the 3D screenshot<br>
                            2. Upload the site photo (if you have one)<br>
                            3. Paste the prompt (Ctrl+V)<br>
                            4. Generate!
                        </p>
                    </div>
                </div>
            </div>

            <!-- Hidden: rpEstSqm for updateEstimate() compatibility -->
            <div style="display:none"><span id="rpEstSqm"></span></div>

        </div><!-- end panel-right -->

        <!-- Hidden: Complexity scores preserved for export/import -->
        <div style="display:none">
            <input type="number" id="cxBuild" value="3"><input type="number" id="cxAccess" value="3">
            <input type="number" id="cxDistance" value="2"><input type="number" id="cxFooting" value="3"><input type="number" id="cxHeight" value="2">
        </div>

        <!-- Materials Edit Modal -->
        <div id="materialsModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)closeMaterialsModal()">
            <div class="mat-modal">
                <h3>Materials &amp; Pricing</h3>
                <div class="mat-modal-controls">
                    <label>Markup:</label>
                    <input type="number" id="modalMarkupPct" value="35" min="0" max="200" step="1">
                    <span style="font-size:13px;color:var(--sw-text-sec)">%</span>
                    <button class="btn-apply" onclick="applyMarkupAll(true)">Apply to All</button>
                    <div class="toggle-wrap">
                        <input type="checkbox" id="showCostToggle" onchange="renderMaterialsModal()">
                        <label for="showCostToggle" style="font-size:12px;color:var(--sw-text-sec);cursor:pointer">Show cost prices</label>
                    </div>
                </div>
                <table class="mat-modal-table">
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Qty</th>
                            <th class="r cost-col" style="display:none">Cost</th>
                            <th class="r">Sell Price</th>
                            <th class="r">Markup</th>
                            <th style="width:24px"></th>
                        </tr>
                    </thead>
                    <tbody id="matModalBody"></tbody>
                </table>
                <div class="mat-modal-footer">
                    <div>
                        <button class="btn-add-custom" onclick="addCustomMaterialRow()">+ Add Custom Item</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:16px">
                        <span>Total: <span class="mat-total" id="matModalTotal">$0.00</span></span>
                        <button class="btn-done" onclick="closeMaterialsModal()">Done</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Modal (expanded from Rates) -->
        <div id="ratesModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
            <div class="rates-modal" style="max-width:520px">
                <h3>Settings</h3>

                <!-- Defaults tab -->
                <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                    <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:8px">Defaults</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Default Markup %</label>
                            <input type="number" id="settingsDefaultMarkup" value="35" min="0" max="200" step="1" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                    </div>
                </div>

                <!-- Labour Rates -->
                <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                    <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:8px">Labour Rates</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Trade Cost $/hr</label>
                            <input type="number" id="settingsTradesCostHr" value="45" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Trade Sell $/hr</label>
                            <input type="number" id="settingsTradesSellHr" value="110" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Labourer Cost $/hr</label>
                            <input type="number" id="settingsLabourerCostHr" value="35" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Labourer Sell $/hr</label>
                            <input type="number" id="settingsLabourerSellHr" value="90" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Hours Per Day</label>
                            <input type="number" id="settingsHoursPerDay" value="8" min="1" max="12" step="1" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                    </div>
                </div>

                <!-- Scope item default costs -->
                <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                    <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:8px">Scope Item Defaults (cost per unit)</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Footings ($/each)</label>
                            <input type="number" id="settingsScopeFootings" value="85" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Demo (flat rate)</label>
                            <input type="number" id="settingsScopeDemo" value="500" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Crane Hire</label>
                            <input type="number" id="settingsScopeCrane" value="600" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Council/Permit</label>
                            <input type="number" id="settingsScopePermit" value="350" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Soakwell</label>
                            <input type="number" id="settingsScopeSoakwell" value="800" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Skip Bin</label>
                            <input type="number" id="settingsScopeSkip" value="350" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Delivery</label>
                            <input type="number" id="settingsScopeDelivery" value="200" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Electrical</label>
                            <input type="number" id="settingsScopeElectrical" value="0" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                    </div>
                </div>

                <!-- Work order options -->
                <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                    <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:8px">Output Options</div>
                    <label style="display:flex;align-items:center;gap:8px;font-size:12px;color:var(--sw-text);cursor:pointer">
                        <input type="checkbox" id="settingsShowWoCosts" onchange="saveSettingsDefaults()">
                        Show cost prices on Work Order
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;font-size:12px;color:var(--sw-text);cursor:pointer;margin-top:6px">
                        <input type="checkbox" id="settingsItemisedQuote" onchange="saveSettingsDefaults()">
                        Itemised quote (show individual scope items)
                    </label>
                </div>

                <!-- Material rates -->
                <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:6px">Material &amp; Labour Rates</div>
                <p style="font-size:11px;color:var(--sw-text-sec);margin-bottom:8px">$/LM, $/ea, $/day. Saved to browser.</p>
                <div style="max-height:300px;overflow-y:auto;border:1px solid var(--sw-border);border-radius:6px">
                <table class="pricing-table">
                    <thead><tr><th>Material / Role</th><th class="r">Rate $</th></tr></thead>
                    <tbody id="ratesBody"></tbody>
                </table>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:16px">
                    <button style="font-size:11px;padding:5px 12px;border:1px solid #ccc;border-radius:4px;background:#fff;cursor:pointer;color:#FF3B30" onclick="if(confirm('Reset all rates to defaults?')){storedRates={...DEFAULT_RATES};saveRates();renderRatesPanel();buildJobRows();updatePricing()}">Reset to Defaults</button>
                    <button class="btn-done" style="padding:8px 20px;border-radius:6px;border:none;background:var(--sw-orange);color:white;font-size:13px;cursor:pointer" onclick="document.getElementById('ratesModal').style.display='none'">Done</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Import Modal -->
    <div id="importModal" class="modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
        <div class="modal-box">
            <h3>Import Job Data</h3>
            <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:8px">Paste previously exported JSON data below, then click Load Job.</p>
            <textarea id="importTextarea" placeholder="Paste job JSON here..."></textarea>
            <div class="modal-status" id="importStatus"></div>
            <div class="modal-btns">
                <button class="btn btn-secondary" onclick="document.getElementById('importModal').style.display='none'">Cancel</button>
                <button class="btn btn-primary" onclick="importJobData()">Load Job</button>
            </div>
        </div>
    </div>

    <div id="loadJobModal" class="modal-overlay" style="display:none" onclick="if(event.target===this)closeLoadJobModal()">
        <div class="modal-box" style="max-width:500px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
                <h3 style="margin:0">Load Job</h3>
                <span style="cursor:pointer;font-size:18px;color:var(--sw-text-sec);padding:4px" onclick="closeLoadJobModal()">&times;</span>
            </div>
            <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:8px">Paste job data JSON:</p>
            <textarea id="loadJobTextarea" rows="6" placeholder="Paste job JSON here..." style="height:auto"></textarea>
            <div class="modal-status" id="loadJobStatus"></div>
            <div class="modal-btns">
                <button class="btn btn-secondary" onclick="closeLoadJobModal()">Cancel</button>
                <button class="btn btn-primary" onclick="loadJobData()">Load Job</button>
            </div>
        </div>
    </div>

    <!-- Box Gutter Designer Modal -->
    <div id="gutterDesignerModal" class="gutter-modal-overlay" style="display:none" onclick="if(event.target===this)closeGutterDesigner()">
        <div class="gutter-modal" onclick="event.stopPropagation()">
            <div class="gutter-modal-header">
                <h3>Box Gutter Designer</h3>
                <button class="close-btn" onclick="closeGutterDesigner()">&times;</button>
            </div>
            <div class="gutter-modal-body">
                <div class="gutter-modal-left">
                    <div class="gutter-inputs">
                        <label>House Catchment (m&sup2;)
                            <input type="number" id="bgHouseCatch" value="30" min="0" step="1" oninput="calcBoxGutter()">
                            <small>House roof area to gutter</small>
                        </label>
                        <label>Patio Catchment (m&sup2;)
                            <input type="number" id="bgPatioCatch" value="0" min="0" step="0.1" readonly>
                            <small>Auto from patio dims</small>
                        </label>
                        <label>Gutter Run (mm)
                            <input type="number" id="bgRunLength" value="6000" min="1000" max="15000" step="100" oninput="calcBoxGutter()">
                            <small>Length to nearest downpipe</small>
                        </label>
                    </div>
                    <div class="gutter-inputs" style="margin-top:8px">
                        <label>Available Width (mm)
                            <input type="number" id="bgAvailWidth" value="300" min="150" max="600" step="10" oninput="calcBoxGutter()">
                            <small>Riser gap</small>
                        </label>
                        <label>Available Depth (mm)
                            <input type="number" id="bgAvailDepth" value="150" min="75" max="300" step="10" oninput="calcBoxGutter()">
                            <small>Step-down house to patio</small>
                        </label>
                        <label>Fall Ratio
                            <select id="bgFallRatio" onchange="calcBoxGutter()">
                                <option value="100">1:100 (minimum)</option>
                                <option value="80">1:80 (standard)</option>
                                <option value="60" selected>1:60 (recommended)</option>
                                <option value="40">1:40 (steep)</option>
                            </select>
                        </label>
                    </div>
                    <div class="gutter-inputs" style="margin-top:8px">
                        <label>Downpipe Size
                            <select id="bgDownpipe" onchange="calcBoxGutter()">
                                <option value="100x75">100x75 rectangular</option>
                                <option value="100x100">100x100 square</option>
                                <option value="90round">90mm round</option>
                            </select>
                        </label>
                    </div>
                    <div class="gutter-results" id="bgResults" style="margin-top:12px">
                        <div class="gutter-status" id="bgStatus"></div>
                        <h5>Calculated Profile</h5>
                        <div class="gutter-result-grid">
                            <div class="gutter-result-item"><div class="r-label">Total Catchment</div><div class="r-value" id="bgResCatch">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Flow Rate</div><div class="r-value" id="bgResFlow">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Downpipes</div><div class="r-value" id="bgResDP">-</div></div>
                        </div>
                        <h5>Fabrication Dimensions</h5>
                        <div class="gutter-result-grid">
                            <div class="gutter-result-item"><div class="r-label">Back Upstand</div><div class="r-value" id="bgResBack">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Sole Width</div><div class="r-value" id="bgResSoleW">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Sole Depth</div><div class="r-value" id="bgResSoleD">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Front Upstand</div><div class="r-value" id="bgResFront">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Front Turn-in</div><div class="r-value" id="bgResTurnIn">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Total Girth</div><div class="r-value" id="bgResGirth">-</div></div>
                        </div>
                        <div class="gutter-result-grid" style="margin-top:6px">
                            <div class="gutter-result-item"><div class="r-label">Freeboard</div><div class="r-value" id="bgResFB">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Fall Total</div><div class="r-value" id="bgResFall">-</div></div>
                        </div>
                    </div>
                </div>
                <div class="gutter-modal-right" id="bgCrossSectionBox">
                    <canvas id="bgCanvas"></canvas>
                </div>
            </div>
            <div class="gutter-modal-footer">
                <button class="btn-remove" onclick="removeGutterFromTruss()">Remove Gutter</button>
                <button class="btn-save" onclick="saveGutterToTruss()">Save to Truss</button>
            </div>
        </div>
    </div>

    <script>
        /*
         * V18 FIXES:
         * 1. Downpipes - now extend from ground to actual gutter height (not postH)
         * 2. Gable sheets perpendicular - complete rotation rewrite for proper roof alignment
         * 3. Carry beam condition - removed for gable+fascia (trusses sit on fascia beam directly)
         * 4. Gable+riser beam stacking - riser beam now sits ON TOP of risers correctly
         */

        // ==================== CONFIG ====================
        // Official BlueScope Colorbond colour hex values
        const COLORBOND_COLOURS = {
            // Light tones
            'Surfmist':       '#E4E2D5',
            'Classic Cream':  '#E9DCB8',
            'Paperbark':      '#CABFA4',
            'Evening Haze':   '#C5C2AA',
            'Dune':           '#B1ADA3',
            // Mid tones
            'Shale Grey':     '#BDBFBA',
            'Windspray':      '#888B8A',
            'Pale Eucalypt':  '#7C846A',
            'Gully':          '#857E73',
            'Jasper':         '#6C6153',
            'Wallaby':        '#7F7C78',
            // Dark tones
            'Basalt':         '#6D6C6E',
            'Woodland Grey':  '#4B4C46',
            'Monument':       '#323233',
            'Ironstone':      '#3E434C',
            // Feature colours
            'Manor Red':      '#6B3D3A',
            'Cottage Green':  '#3D5246',
            'Deep Ocean':     '#2B3E4A',
            'Cove':           '#3F4C54',
            'Night Sky':      '#2D3033',
            // Special
            'Zincalume':      '#C0C0C0'
        };

        // CamelCase keyed Colorbond dictionary for AI prompt generation
        const COLORBOND_COLORS = {
            surfmist:       { hex: '#E4E2D5', name: 'Surfmist (off-white)' },
            classicCream:   { hex: '#E9DCB8', name: 'Classic Cream' },
            paperbark:      { hex: '#CABFA4', name: 'Paperbark (light tan)' },
            eveningHaze:    { hex: '#C5C2AA', name: 'Evening Haze' },
            dune:           { hex: '#B1ADA3', name: 'Dune (warm beige-grey)' },
            shaleGrey:      { hex: '#BDBFBA', name: 'Shale Grey (light grey)' },
            windspray:      { hex: '#888B8A', name: 'Windspray (mid grey)' },
            paleEucalypt:   { hex: '#7C846A', name: 'Pale Eucalypt (grey-green)' },
            gully:          { hex: '#857E73', name: 'Gully (brown-grey)' },
            jasper:         { hex: '#6C6153', name: 'Jasper (brown-grey)' },
            wallaby:        { hex: '#7F7C78', name: 'Wallaby (warm grey)' },
            basalt:         { hex: '#6D6C6E', name: 'Basalt (mid grey)' },
            woodlandGrey:   { hex: '#4B4C46', name: 'Woodland Grey (dark charcoal)' },
            monument:       { hex: '#323233', name: 'Monument (near black)' },
            ironstone:      { hex: '#3E434C', name: 'Ironstone (dark blue-grey)' },
            manorRed:       { hex: '#6B3D3A', name: 'Manor Red' },
            cottageGreen:   { hex: '#3D5246', name: 'Cottage Green' },
            deepOcean:      { hex: '#2B3E4A', name: 'Deep Ocean' }
        };

        function getColorbond(key) {
            return COLORBOND_COLORS[key] || COLORBOND_COLORS.surfmist;
        }

        // Common Perth patio Colorbond colours for picker (most popular first)
        const COLORS = [
            {name:'Surfmist',hex:'#E4E2D5'},{name:'Paperbark',hex:'#CABFA4'},{name:'Classic Cream',hex:'#E9DCB8'},
            {name:'Dune',hex:'#B1ADA3'},{name:'Shale Grey',hex:'#BDBFBA'},{name:'Evening Haze',hex:'#C5C2AA'},
            {name:'Windspray',hex:'#888B8A'},{name:'Pale Eucalypt',hex:'#7C846A'},
            {name:'Jasper',hex:'#6C6153'},{name:'Gully',hex:'#857E73'},{name:'Wallaby',hex:'#7F7C78'},
            {name:'Basalt',hex:'#6D6C6E'},{name:'Woodland Grey',hex:'#4B4C46'},{name:'Monument',hex:'#323233'},
            {name:'Ironstone',hex:'#3E434C'},{name:'Manor Red',hex:'#6B3D3A'},
            {name:'Cottage Green',hex:'#3D5246'},{name:'Deep Ocean',hex:'#2B3E4A'},
            {name:'Cove',hex:'#3F4C54'},{name:'Night Sky',hex:'#2D3033'}
        ];
        const STEEL = {'76x38':{w:0.076,h:0.038,name:'76Ã—38Ã—1.6',bmt:1.6},'75x50':{w:0.075,h:0.05,name:'75Ã—50Ã—2',bmt:2.0},'100x50':{w:0.1,h:0.05,name:'100Ã—50Ã—2',bmt:2.0}};
        const FRAME_POSTS = {
            '65x65': {w:0.065, name:'65Ã—65Ã—2 SHS', label:'65Ã—65Ã—2'},
            '75x75': {w:0.075, name:'75Ã—75Ã—2 SHS', label:'75Ã—75Ã—2'},
            '90x90': {w:0.09,  name:'90Ã—90Ã—2 SHS', label:'90Ã—90Ã—2'},
            '100x100':{w:0.1,  name:'100Ã—100Ã—2 SHS',label:'100Ã—100Ã—2'},
            '125x125':{w:0.125,name:'125Ã—125Ã—3 SHS',label:'125Ã—125Ã—3'},
            '150x150':{w:0.15, name:'150Ã—150Ã—3 SHS',label:'150Ã—150Ã—3'}
        };
        const FRAME_BEAMS = {
            '75x50':  {w:0.075, h:0.05, name:'75Ã—50Ã—2 RHS', label:'75Ã—50Ã—2'},
            '100x50': {w:0.1,   h:0.05, name:'100Ã—50Ã—2 RHS', label:'100Ã—50Ã—2'},
            '125x50': {w:0.125, h:0.05, name:'125Ã—50Ã—2 RHS', label:'125Ã—50Ã—2'},
            '150x50': {w:0.15,  h:0.05, name:'150Ã—50Ã—2 RHS', label:'150Ã—50Ã—2'},
            '200x50': {w:0.2,   h:0.05, name:'200Ã—50Ã—2 RHS', label:'200Ã—50Ã—2'}
        };

        const RAFTER_SIZES = {
            '50x25':  {w:0.05,  h:0.025, name:'50Ã—25Ã—1.6 RHS', label:'50Ã—25 RHS'},
            '65x35':  {w:0.065, h:0.035, name:'65Ã—35Ã—2 RHS',   label:'65Ã—35 RHS'},
            '75x35':  {w:0.075, h:0.035, name:'75Ã—35Ã—2 RHS',   label:'75Ã—35 RHS'},
            '75x50':  {w:0.075, h:0.05,  name:'75Ã—50Ã—2 RHS',   label:'75Ã—50 RHS'},
            '100x50': {w:0.1,   h:0.05,  name:'100Ã—50Ã—2 RHS',  label:'100Ã—50 RHS'},
            '125x50': {w:0.125, h:0.05,  name:'125Ã—50Ã—2 RHS',  label:'125Ã—50 RHS'},
            'C150':   {w:0.065, h:0.15,  name:'C150 Purlin',    label:'C150 Purlin'},
            'C200':   {w:0.065, h:0.20,  name:'C200 Purlin',    label:'C200 Purlin'}
        };

        const PURLIN_SIZES = {
            'C75':  {w:0.075, h:0.032, name:'C75 Purlin',  label:'C75'},
            'C100': {w:0.100, h:0.050, name:'C100 Purlin', label:'C100'},
            'C150': {w:0.150, h:0.064, name:'C150 Purlin', label:'C150'},
            'C200': {w:0.200, h:0.076, name:'C200 Purlin', label:'C200'}
        };

        const SHEET_COVERAGE = {
            corrugated: 762,
            trimdek: 762,
            spandek: 760,
            solarspan75: 1000,
            solarspan100: 1000,
            spanplus330: 330
        };

        // Detailed sheet profile data for steel and polycarbonate roofing
        const SHEET_PROFILES = {
            trimdek:    { name: 'Trimdek (5-rib)',         coverWidth: 762, overallWidth: 840, ribDepth: 29, minPitch: 2, material: 'colorbond', polycarbMatch: 'trimdek' },
            corrugated: { name: 'Custom Orb (Corrugated)', coverWidth: 762, overallWidth: 838, ribDepth: 16, minPitch: 5, material: 'colorbond', polycarbMatch: 'corrugated' },
            spandek:    { name: 'Spandek',                 coverWidth: 760, overallWidth: 835, ribDepth: 28, minPitch: 2, material: 'colorbond', polycarbMatch: null },
            solarspan75:  { name: 'SolarSpan 75mm',  coverWidth: 1000, material: 'insulated', polycarbMatch: null },
            solarspan100: { name: 'SolarSpan 100mm', coverWidth: 1000, material: 'insulated', polycarbMatch: null },
            spanplus330:  { name: 'SpanPlus 330',    coverWidth: 330,  material: 'colorbond',  polycarbMatch: null }
        };

        // Polycarbonate profile compatibility (which polycarb matches which steel profile)
        const POLYCARB_PROFILES = {
            trimdek:    { name: 'Solasafe 5-Rib',    coverWidth: 760, thickness: 0.8, maxLength: 8100, manufacturer: 'Ampelite', levels: [1, 2] },
            corrugated: { name: 'Solasafe Corrugated', coverWidth: 760, thickness: 0.8, maxLength: 8100, manufacturer: 'Ampelite', levels: [1, 2, 3] }
        };

        const SPAN_TABLES = {
            corrugated: { maxSpan: 1100, endSpan: 900, needsPurlins: true },
            trimdek: { maxSpan: 2100, endSpan: 1500, needsPurlins: true },
            spandek: { maxSpan: 2400, endSpan: 1800, needsPurlins: true },
            solarspan75: { maxSpan: 6000, endSpan: 6000, needsPurlins: false },
            solarspan100: { maxSpan: 6000, endSpan: 6000, needsPurlins: false },
            spanplus330: { maxSpan: 1800, endSpan: 1200, needsPurlins: true }
        };

        // Sheet span lookup for batten calculator (max spans in mm at standard load)
        const SHEET_SPANS = {
            solarspan75:       { maxSpan: 4500, minPitch: 2, battensRequired: false, label: 'SolarSpan 75mm' },
            solarspan100:      { maxSpan: 5500, minPitch: 2, battensRequired: false, label: 'SolarSpan 100mm' },
            trimdek_048:       { maxSpan: 2600, minPitch: 2, battensRequired: true,  label: 'Trimdek (0.48 BMT)' },
            trimdek_042:       { maxSpan: 1900, minPitch: 2, battensRequired: true,  label: 'Trimdek (0.42 BMT)' },
            corrugated_048:    { maxSpan: 1700, minPitch: 5, battensRequired: true,  label: 'Corrugated (0.48 BMT)' },
            corrugated_042:    { maxSpan: 1200, minPitch: 5, battensRequired: true,  label: 'Corrugated (0.42 BMT)' },
            spanplus330_042:   { maxSpan: 4500, minPitch: 1, battensRequired: true,  label: 'SpanPlus 330 (0.42 BMT)' }
        };

        // Map roofing dropdown value + BMT to SHEET_SPANS key
        function getSheetSpanKey(roofing, bmt) {
            if (roofing === 'solarspan75' || roofing === 'solarspan100') return roofing;
            if (roofing === 'trimdek') return 'trimdek_' + (bmt || '042');
            if (roofing === 'corrugated') return 'corrugated_' + (bmt || '042');
            if (roofing === 'spanplus330') return 'spanplus330_042';
            return null;
        }

        function calculateBattens(sheetSpanKey, projectionMm, patioLengthMm, extraBattens) {
            const sheet = SHEET_SPANS[sheetSpanKey];
            if (!sheet) return { battensNeeded: 0, spanDistance: projectionMm, battenPositions: [], battenLength: patioLengthMm, message: 'Unknown sheet type' };

            if (!sheet.battensRequired) {
                return {
                    battensNeeded: 0, spanDistance: projectionMm, battenPositions: [],
                    battenLength: patioLengthMm, maxSpan: sheet.maxSpan,
                    message: sheet.label + ' is self-spanning \u2014 no battens required'
                };
            }

            const spansNeeded = Math.ceil(projectionMm / sheet.maxSpan);
            const baseBattens = Math.max(0, spansNeeded - 1);
            const battensNeeded = baseBattens + (extraBattens || 0);

            if (battensNeeded === 0) {
                return {
                    battensNeeded: 0, spanDistance: projectionMm, battenPositions: [],
                    battenLength: patioLengthMm, maxSpan: sheet.maxSpan, baseBattens: 0,
                    message: sheet.label + ' can span ' + projectionMm + 'mm without battens'
                };
            }

            const totalSpans = battensNeeded + 1;
            const spanDistance = Math.round(projectionMm / totalSpans);
            const battenPositions = [];
            for (var i = 1; i <= battensNeeded; i++) battenPositions.push(spanDistance * i);

            return {
                battensNeeded, spanDistance, battenPositions, battenLength: patioLengthMm,
                maxSpan: sheet.maxSpan, baseBattens,
                message: battensNeeded + ' batten row' + (battensNeeded > 1 ? 's' : '') + ' at ' + spanDistance + 'mm centres'
            };
        }

        function calculateBrackets(battensNeeded, patioLengthMm) {
            if (battensNeeded === 0) return { bracketsNeeded: 0, perBatten: 0 };
            const perBatten = 2 + Math.floor(Math.max(0, patioLengthMm - 200) / 1200);
            return { bracketsNeeded: perBatten * battensNeeded, perBatten };
        }

        function validateBattenSetup(sheetSpanKey, projectionMm, pitchDeg) {
            const sheet = SHEET_SPANS[sheetSpanKey];
            if (!sheet) return { errors: [], warnings: [], isValid: true };
            var errors = [], warnings = [];
            if (pitchDeg < sheet.minPitch) {
                errors.push(sheet.label + ' requires min ' + sheet.minPitch + '\u00B0 pitch. Current: ' + pitchDeg.toFixed(1) + '\u00B0');
            }
            if (sheet.battensRequired) {
                var bn = Math.ceil(projectionMm / sheet.maxSpan) - 1;
                if (bn >= 3) warnings.push(bn + ' batten rows needed \u2014 consider a longer-spanning sheet');
            }
            if (projectionMm > 6000) warnings.push('Projection exceeds 6m \u2014 verify structural design');
            return { errors, warnings, isValid: errors.length === 0 };
        }

        function calculateRafters(spanMm, spacingMm, overrideQty) {
            if (overrideQty && overrideQty > 0) {
                var qty = overrideQty;
                var actualSpacing = qty > 1 ? Math.round(spanMm / (qty - 1)) : spanMm;
                return { rafterCount: qty, spacing: actualSpacing, isOverride: true };
            }
            var sp = Math.max(300, spacingMm || 900);
            var qty = Math.floor(spanMm / sp) + 1;
            if (qty < 2) qty = 2;
            var actualSpacing = qty > 1 ? Math.round(spanMm / (qty - 1)) : spanMm;
            return { rafterCount: qty, spacing: actualSpacing, isOverride: false };
        }

        function calculateGableBattens(roofing, rafterMm, patioLengthMm, extraBattens) {
            var spanTable = SPAN_TABLES[roofing];
            if (!spanTable || !spanTable.needsPurlins) {
                return {
                    totalBattens: 0, battensPerSide: 0, spacing: 0,
                    positionsPerSide: [], apexGap: 0,
                    battenLength: patioLengthMm,
                    message: (spanTable ? 'Self-spanning â€” no purlins required' : 'Unknown sheet type')
                };
            }
            var maxSpan = spanTable.maxSpan;
            var apexOffset = 75; // mm from ridge centre to each apex batten
            var effectiveLen = rafterMm - apexOffset;
            if (effectiveLen < 100) effectiveLen = rafterMm;
            var spansNeeded = Math.ceil(effectiveLen / maxSpan);
            if (spansNeeded < 1) spansNeeded = 1;
            var battensPerSide = spansNeeded + 1 + (extraBattens || 0);
            var spacing = Math.round(effectiveLen / (battensPerSide - 1));
            var positions = [];
            for (var i = 0; i < battensPerSide; i++) {
                positions.push(Math.round(spacing * i));
            }
            // Last position is at the apex batten
            positions[positions.length - 1] = Math.round(effectiveLen);
            var totalBattens = battensPerSide * 2;
            return {
                totalBattens: totalBattens,
                battensPerSide: battensPerSide,
                spacing: spacing,
                positionsPerSide: positions,
                apexGap: apexOffset * 2,
                battenLength: patioLengthMm,
                maxSpan: maxSpan,
                rafterLength: rafterMm,
                message: totalBattens + ' purlins total (' + battensPerSide + ' per side) at ' + spacing + 'mm centres'
            };
        }

        function isInsulated(roofing) {
            return roofing === 'solarspan75' || roofing === 'solarspan100';
        }

        const ROOFING_TYPES = {
            solarspan75:  { name: 'SolarSpan 75mm',  coverWidth: 1000, costPerLm: 110.00, sqmRate: 520 },
            solarspan100: { name: 'SolarSpan 100mm', coverWidth: 1000, costPerLm: 130.00, sqmRate: 560 },
            trimdek:      { name: 'Trimdek',         coverWidth: 762,  costPerLm: 15.00,  sqmRate: 420 },
            corrugated:   { name: 'Corrugated',      coverWidth: 762,  costPerLm: 12.04,  sqmRate: 380 },
            spandek:      { name: 'Spandek',         coverWidth: 760,  costPerLm: 14.50,  sqmRate: 420 },
            spanplus330:  { name: 'SpanPlus 330',    coverWidth: 330,  costPerLm: 12.04,  sqmRate: 400 }
        };

        const SPANPLUS_COLOURS = [
            'Basalt','Classic Cream','Cottage Green','Deep Ocean','Domain','Dune',
            'Evening Haze','Ironstone','Jasper','Manor Red','Monument',
            'Pale Eucalypt','Paperbark','Shale Grey','Surfmist','Woodland Grey'
        ];

        // Polycarbonate tint options per brand
        const POLYCARB_TINTS = {
            ampelite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Light Bronze',color:'rgba(180,150,100,0.4)'},
                {name:'Grey',       color:'rgba(160,160,165,0.45)'},
                {name:'Dark Tint',  color:'rgba(80,80,85,0.55)'},
                {name:'Smooth Cream',color:'rgba(245,235,210,0.5)'}
            ],
            laserlite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Cream',      color:'rgba(245,235,210,0.5)'},
                {name:'Bronze Tint',color:'rgba(170,140,90,0.45)'},
                {name:'Grey Tint',  color:'rgba(150,150,155,0.45)'}
            ]
        };

        // Three.js tint colours for polycarb 3D rendering
        const POLYCARB_3D_TINTS = {
            'Clear':        {color: 0x88CCEE, opacity: 0.5},
            'Opal':         {color: 0xE8E8F0, opacity: 0.6},
            'Light Bronze': {color: 0xB49664, opacity: 0.55},
            'Grey':         {color: 0x909098, opacity: 0.55},
            'Dark Tint':    {color: 0x505055, opacity: 0.65},
            'Smooth Cream': {color: 0xF0E4C8, opacity: 0.55},
            'Cream':        {color: 0xF0E4C8, opacity: 0.55},
            'Bronze Tint':  {color: 0xAA8C5A, opacity: 0.55},
            'Grey Tint':    {color: 0x868690, opacity: 0.55}
        };

        let sheetColor = COLORS[0]; // Surfmist default
        let steelColor = COLORS.find(c => c.name === 'Monument') || COLORS[9];
        let calc = {};

        // ==================== CUSTOMER STATE ====================
        let customer = { name: '', address: '', phone: '' };
        function updateCustomer() {
            customer = {
                name: document.getElementById('customerName').value,
                address: document.getElementById('customerAddress').value,
                phone: document.getElementById('customerPhone').value
            };
            // customer object updated from visible fields above
        }

        // ==================== SITE DETAILS STATE ====================
        let siteDetails = {
            existingSite: 'clear',
            demoNotes: '',
            electrical: 'none',
            siteAccess: 'easy',
            groundSurface: 'grass',
            fasciaMaterial: 'timber',
            wallType: 'doublebrick',
            existingRoof: 'tiles'
        };
        function updateSiteDetails() {
            siteDetails = {
                existingSite: document.getElementById('existingSite')?.value || 'clear',
                demoNotes: document.getElementById('demoNotes')?.value || '',
                electrical: document.getElementById('electrical')?.value || 'none',
                siteAccess: document.getElementById('siteAccess')?.value || 'easy',
                groundSurface: document.getElementById('groundSurface')?.value || 'grass',
                fasciaMaterial: document.getElementById('fasciaMaterial')?.value || 'timber',
                wallType: document.getElementById('wallType')?.value || 'doublebrick',
                existingRoof: document.getElementById('existingRoof')?.value || 'tiles'
            };
        }

        // ==================== EXISTING SITE ====================
        function updateExistingSite() {
            var existing = document.getElementById('existingSite').value;
            var demoNotesField = document.getElementById('demoNotesField');
            if (demoNotesField) {
                demoNotesField.style.display = (existing === 'clear') ? 'none' : 'block';
            }
            // Legacy compat: also update demoScopeGroup if it exists
            var demoGroup = document.getElementById('demoScopeGroup');
            if (demoGroup) {
                if (existing === 'clear') {
                    demoGroup.style.display = 'none';
                } else {
                    demoGroup.style.display = 'block';
                }
            }
            updateSiteDetails();
            updateUI();
        }

        function calculateDemoCost() {
            var existing = document.getElementById('existingSite')?.value || 'clear';
            if (existing === 'clear') return 0;
            // Demo cost now added via Additional Items â€” this returns 0
            // Old auto-cost removed; user adds demo pricing manually
            return 0;
        }

        // ==================== TOGGLE BUTTONS ====================
        function setToggle(fieldId, value, btn) {
            document.getElementById(fieldId).value = value;
            var group = btn.parentElement;
            group.querySelectorAll('.toggle-btn').forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            updateSiteDetails();
            updateUI();
        }

        function setDesignToggle(fieldId, value, btn) {
            document.getElementById(fieldId).value = value;
            var group = btn.parentElement;
            group.querySelectorAll('.toggle-btn').forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            updateUI();
            rebuildAll();
        }

        // Sync toggle button active states from hidden input values (used after import/load)
        function syncAllToggleButtons() {
            ['inRoofStyle', 'inConnection', 'inPostFix', 'inCeilingFinish', 'inHouseGutter'].forEach(function(id) {
                var el = document.getElementById(id);
                if (!el) return;
                var group = el.nextElementSibling;
                if (!group || !group.classList.contains('toggle-btn-group')) return;
                group.querySelectorAll('.toggle-btn').forEach(function(b) {
                    b.classList.toggle('active', b.dataset.value === el.value);
                });
            });
            // Also sync site toggle buttons
            ['siteAccess', 'groundSurface', 'existingSite', 'fasciaMaterial', 'wallType', 'existingRoof'].forEach(function(id) {
                var el = document.getElementById(id);
                if (!el) return;
                var group = el.closest('.basics-field')?.querySelector('.toggle-btn-group') || el.parentElement;
                if (!group) return;
                group.querySelectorAll('.toggle-btn').forEach(function(b) {
                    b.classList.toggle('active', b.dataset.value === el.value);
                });
            });
        }

        // Smart default: Slab/Paving â†’ Bolt-down, Grass/Deck â†’ In-ground
        function smartPostFixDefault() {
            var surface = document.getElementById('groundSurface').value;
            var fixEl = document.getElementById('inPostFix');
            if (surface === 'slab' || surface === 'paving') {
                fixEl.value = 'baseplate';
            } else {
                fixEl.value = 'concrete';
            }
            syncAllToggleButtons();
            rebuildAll();
        }

        // Purlin validation display (inline in Structure)
        function updatePurlinValidation() {
            var el = document.getElementById('purlinValidationText');
            if (!el) return;
            var roofing = document.getElementById('inRoofing').value;
            var pitch = parseFloat(document.getElementById('inPitch').value) || 10;
            var projMm = (parseFloat(document.getElementById('inWidth').value) || 3) * 1000;
            var profiles = {
                solarspan75: { label: 'SolarSpan 75mm', maxSpan: 4500 },
                solarspan100: { label: 'SolarSpan 100mm', maxSpan: 5500 },
                trimdek: { label: 'Trimdek', maxSpan: 2600 },
                corrugated: { label: 'Corrugated', maxSpan: 1700 },
                spandek: { label: 'Spandek', maxSpan: 2600 },
                spanplus330: { label: 'SpanPlus 330', maxSpan: 2600 }
            };
            var p = profiles[roofing] || profiles.trimdek;
            var isSelfSpanning = (roofing === 'solarspan75' || roofing === 'solarspan100');
            var parentDiv = document.getElementById('purlinValidation');
            if (isSelfSpanning && projMm <= p.maxSpan) {
                el.innerHTML = p.label + ' @ ' + pitch + '&deg; &mdash; Max span: ' + p.maxSpan + 'mm<br><span style="color:#22C55E">&check; Self-spanning &mdash; no purlins required</span>';
                parentDiv.style.borderLeft = '3px solid #22C55E';
            } else if (isSelfSpanning) {
                el.innerHTML = p.label + ' @ ' + pitch + '&deg; &mdash; Max span: ' + p.maxSpan + 'mm<br><span style="color:#EF4444">&cross; Projection exceeds max span &mdash; purlins required</span>';
                parentDiv.style.borderLeft = '3px solid #EF4444';
            } else {
                el.innerHTML = p.label + ' @ ' + pitch + '&deg; &mdash; Max span: ' + p.maxSpan + 'mm<br><span style="color:var(--sw-text-sec)">Purlins/battens required for single-skin sheets</span>';
                parentDiv.style.borderLeft = '3px solid var(--sw-border)';
            }
        }

        // ==================== ATTACHMENT VISIBILITY ====================
        function updateAttachmentVisibility() {
            // Site Reference visibility is optional â€” always show for now
        }


        // ==================== AUTO-CALCULATE POSTS & TRUSSES ====================
        function autoCalculatePostsAndTrusses() {
            var length = (parseFloat(document.getElementById('inLength').value) || 6) * 1000;
            var projection = (parseFloat(document.getElementById('inWidth').value) || 3) * 1000;
            var roofStyle = document.getElementById('inRoofStyle').value;
            var orientation = document.getElementById('inOrientation').value;
            var pitch = parseFloat(document.getElementById('inPitch').value) || 10;
            var isGable = roofStyle === 'gable' || roofStyle === 'hip';

            // For gable perpendicular (Away from House): posts/trusses distribute along projection, span = house length
            // For all other cases: posts/trusses distribute along house length, span = projection
            var distributeAlong = (isGable && orientation === 'perpendicular') ? projection : length;
            var trussSpanMm = (isGable && orientation === 'perpendicular') ? length : projection;

            // Posts: use user override if set, otherwise auto-calculate every 2400mm
            var postsField = document.getElementById('inPosts');
            var postQtyOverride = document.getElementById('inPostQty');
            if (postsField) {
                if (postQtyOverride && postQtyOverride.value && parseInt(postQtyOverride.value) >= 2) {
                    postsField.value = parseInt(postQtyOverride.value);
                } else {
                    var postsPerSide = Math.ceil(distributeAlong / 2400) + 1;
                    postsField.value = postsPerSide;
                }
            }

            // Trusses: auto-calculate for gable unless user has overridden
            var trussQtyField = document.getElementById('inTrusses');
            if (trussQtyField && !trussQtyField.dataset.userOverride) {
                if (isGable) {
                    var trussQty = Math.ceil(distributeAlong / 2000) + 1;
                    trussQtyField.value = trussQty;
                }
            }

            // Rafters: auto for skillion (use spacing input, respect qty override)
            var raftersField = document.getElementById('inRafters');
            var rafterQtyOverride = document.getElementById('inRafterQtyOverride');
            var rafterSpacingInput = parseInt(document.getElementById('inRafterSpacing')?.value) || 900;
            if (raftersField) {
                if (rafterQtyOverride && rafterQtyOverride.value && parseInt(rafterQtyOverride.value) >= 2) {
                    raftersField.value = parseInt(rafterQtyOverride.value);
                } else {
                    var rc = calculateRafters(distributeAlong, rafterSpacingInput, 0);
                    raftersField.value = rc.rafterCount;
                }
            }

            // Update readonly display fields in truss calculator
            var trussSpanDisplay = document.getElementById('trussSpanDisplay');
            if (trussSpanDisplay) {
                trussSpanDisplay.value = (trussSpanMm / 1000) + 'm';
            }
            var trussPitchDisplay = document.getElementById('trussPitchDisplay');
            if (trussPitchDisplay) {
                trussPitchDisplay.value = pitch + '\u00B0';
            }
        }

        // Mark truss qty as user-overridden when manually changed
        document.addEventListener('DOMContentLoaded', function() {
            var trussQtyField = document.getElementById('inTrusses');
            if (trussQtyField) {
                trussQtyField.addEventListener('input', function() {
                    this.dataset.userOverride = 'true';
                });
            }
            updateExistingSite();
            updateAttachmentVisibility();
            updateLabour();
        });

        function toggleTrussOpt() {
            var rOn = document.getElementById('trussRiserOn').checked;
            var eOn = document.getElementById('trussExtOn').checked;
            document.getElementById('trussRiserInputs').style.display = rOn ? 'flex' : 'none';
            document.getElementById('trussRiserLPanel').style.display = rOn ? '' : 'none';
            document.getElementById('trussRiserRPanel').style.display = rOn ? '' : 'none';
            document.getElementById('trussRiserTypePanel').style.display = rOn ? 'flex' : 'none';
            document.getElementById('trussExtInputs').style.display = eOn ? 'flex' : 'none';
            // Show/hide box gutter button based on riser state
            var bgBtn = document.getElementById('trussBoxGutterBtn');
            if (bgBtn) bgBtn.style.display = rOn ? '' : 'none';
            // Reset box gutter if risers disabled
            if (!rOn) {
                document.getElementById('trussBoxGutterOn').value = '0';
                if (bgBtn) bgBtn.classList.remove('active');
            }
        }

        // Sync truss riser dimensions to box gutter available space
        function syncRiserToBoxGutter() {
            var rLH = parseFloat(document.getElementById('riserLH').value) || 200;
            var rLV = parseFloat(document.getElementById('riserLV').value) || 150;
            var wEl = document.getElementById('bgAvailWidth');
            var dEl = document.getElementById('bgAvailDepth');
            if (wEl) wEl.value = rLH;
            if (dEl) dEl.value = rLV;
            calcBoxGutter();
        }

        // Sync left/right riser inputs when Lock L/R is on
        function syncRiserInputs(side) {
            var locked = document.getElementById('trussRiserLock').checked;
            if (!locked) return;
            if (side === 'L') {
                document.getElementById('riserRH').value = document.getElementById('riserLH').value;
                document.getElementById('riserRV').value = document.getElementById('riserLV').value;
            } else {
                document.getElementById('riserLH').value = document.getElementById('riserRH').value;
                document.getElementById('riserLV').value = document.getElementById('riserRV').value;
            }
            // Also sync to box gutter if enabled
            if (document.getElementById('trussBoxGutterOn')?.value === '1') syncRiserToBoxGutter();
        }

        // When lock is toggled on, sync right to match left
        function syncRiserLock() {
            if (document.getElementById('trussRiserLock').checked) {
                document.getElementById('riserRH').value = document.getElementById('riserLH').value;
                document.getElementById('riserRV').value = document.getElementById('riserLV').value;
            }
        }

        // ==================== QUICK SCOPE ESTIMATE ====================
        function updateEstimate() {
            const projM = parseFloat(document.getElementById('inWidth').value) || 3;
            const lenM = parseFloat(document.getElementById('inLength').value) || 6;
            const roofing = document.getElementById('inRoofing').value;
            const roofStyle = document.getElementById('inRoofStyle').value;
            const connection = document.getElementById('inConnection').value;
            const sqm = projM * lenM;

            const roofKey = roofing;
            const baseRate = (ROOFING_TYPES[roofKey] || ROOFING_TYPES.corrugated).sqmRate;

            let modifier = 1.0;
            if (roofStyle === 'gable') modifier *= 1.12;
            if (roofStyle === 'hip') modifier *= 1.15;
            if (connection === 'flyover') modifier *= 1.08;
            if (connection === 'freestanding') modifier *= 1.18;

            const base = sqm * baseRate * modifier;
            const low = Math.round((base * 0.95 * 1.1) / 500) * 500;
            const high = Math.round((base * 1.10 * 1.1) / 500) * 500;

            var rpSqm = document.getElementById('rpEstSqm');
            var rpRange = document.getElementById('rpEstRange');
            if (rpSqm) rpSqm.textContent = sqm.toFixed(0) + ' sqm';
            if (rpRange) rpRange.textContent = '~$' + low.toLocaleString() + ' \u2013 $' + high.toLocaleString() + ' (inc GST)';

            // Sticky price card sqm
            var rpPS = document.getElementById('rpPriceSqm');
            if (rpPS) rpPS.textContent = sqm.toFixed(0) + ' sqm \u2014 est. ' + '~$' + low.toLocaleString() + ' \u2013 $' + high.toLocaleString();
        }

        function copyEstimate() {
            const projM = parseFloat(document.getElementById('inWidth').value) || 3;
            const lenM = parseFloat(document.getElementById('inLength').value) || 6;
            const roofStyle = document.getElementById('inRoofStyle').value;
            const roofing = document.getElementById('inRoofing').value;
            const roofName = (ROOFING_TYPES[roofing] || ROOFING_TYPES.corrugated).name;
            const styleName = roofStyle.charAt(0).toUpperCase() + roofStyle.slice(1);

            const rangeEl = document.getElementById('rpEstRange');
            const rangeText = rangeEl ? rangeEl.textContent : '';
            const text = 'SecureWorks Patio Estimate\n' +
                lenM.toFixed(1) + 'm \u00D7 ' + projM.toFixed(1) + 'm ' + styleName + ' - ' + roofName + '\n' +
                'Approximately ' + rangeText.replace('~', '') + ' inc GST\n\n' +
                'This is a preliminary estimate only.\nFinal price confirmed after detailed scope.';

            navigator.clipboard.writeText(text).then(function() {
                var btn = document.querySelector('.rp-est-btn .btn') || document.querySelector('.rp-price-card .btn-secondary');
                if (!btn) return;
                var orig = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(function() { btn.textContent = orig; }, 1500);
            });
        }

        // ==================== COLOR CHIPS ====================
        function initColorChips(containerId, labelId, setFn, defaultColor) {
            const container = document.getElementById(containerId);
            const defName = defaultColor ? defaultColor.name : COLORS[0].name;
            COLORS.forEach((c,i) => {
                const el = document.createElement('div');
                el.className = 'color-chip' + (c.name === defName ? ' active' : '');
                el.style.background = c.hex;
                el.title = c.name;
                el.onclick = () => {
                    setFn(c);
                    container.querySelectorAll('.color-chip').forEach(x=>x.classList.remove('active'));
                    el.classList.add('active');
                    document.getElementById(labelId).textContent = c.name;
                    rebuildAll();
                };
                container.appendChild(el);
            });
            document.getElementById(labelId).textContent = defName;
        }
        initColorChips('sheetChips', 'sheetLabel', c => sheetColor = c, sheetColor);
        initColorChips('steelChips', 'steelLabel', c => steelColor = c, steelColor);

        // ==================== POLYCARBONATE ====================
        function hasPolycarbMatch(roofing) {
            var profile = SHEET_PROFILES[roofing];
            return profile && profile.polycarbMatch && POLYCARB_PROFILES[profile.polycarbMatch];
        }

        function isPolycarbEnabled() {
            return document.querySelector('input[name="polycarb"][value="yes"]')?.checked || false;
        }

        function getPolycarbConfig() {
            if (!isPolycarbEnabled()) return null;
            var roofing = document.getElementById('inRoofing').value;
            var matchKey = SHEET_PROFILES[roofing] && SHEET_PROFILES[roofing].polycarbMatch;
            if (!matchKey || !POLYCARB_PROFILES[matchKey]) return null;
            var pcProfile = POLYCARB_PROFILES[matchKey];
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintEl = document.getElementById('inPolycarbTint');
            const tint = tintEl.value || 'Clear';
            const level = parseInt(document.getElementById('inPolycarbLevel')?.value) || 1;
            const patternSel = document.getElementById('inPolycarbPattern').value;
            let steelPerPoly;
            if (patternSel === 'custom') {
                steelPerPoly = parseInt(document.getElementById('inPolycarbCustom').value) || 3;
            } else {
                steelPerPoly = parseInt(patternSel) - 1; // "Every 3rd" = 2 steel per 1 poly
            }
            return { brand, tint, level, steelPerPoly, patternN: steelPerPoly + 1, profile: pcProfile, profileName: pcProfile.name, matchKey: matchKey };
        }

        function getPolycarbSheetSplit(totalSheets) {
            const pc = getPolycarbConfig();
            if (!pc) return { colorbond: totalSheets, polycarb: 0 };
            const patternN = pc.patternN;
            const fullGroups = Math.floor(totalSheets / patternN);
            const remainder = totalSheets % patternN;
            const polycarb = fullGroups + (remainder >= patternN ? 1 : 0);
            const colorbond = totalSheets - polycarb;
            return { colorbond, polycarb };
        }

        function updatePolycarbUI() {
            const enabled = isPolycarbEnabled();
            document.getElementById('polycarbOptions').style.display = enabled ? 'block' : 'none';
            if (enabled) {
                updatePolycarbTints();
                updatePolycarbLevels();
                updatePolycarbPreview();
            }
        }

        function updatePolycarbTints() {
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintSelect = document.getElementById('inPolycarbTint');
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const currentVal = tintSelect.value;
            tintSelect.innerHTML = tints.map(t =>
                `<option value="${t.name}">${t.name}</option>`
            ).join('');
            // Restore previous selection if still valid
            if (tints.some(t => t.name === currentVal)) {
                tintSelect.value = currentVal;
            }
            updatePolycarbPreview();
        }

        function updatePolycarbPreview() {
            const container = document.getElementById('polycarbPreview');
            if (!container) return;
            const patternSel = document.getElementById('inPolycarbPattern').value;
            document.getElementById('polycarbCustomField').style.display = patternSel === 'custom' ? 'block' : 'none';
            const pc = getPolycarbConfig();
            if (!pc) { container.innerHTML = ''; return; }

            // Get tint colour for preview
            const brand = pc.brand;
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const tintObj = tints.find(t => t.name === pc.tint) || tints[0];
            const tintColor = tintObj.color;

            // Use actual sheet count if calc available, else show sample
            var roofing = document.getElementById('inRoofing').value;
            var lenMm = parseFloat(document.getElementById('inLength')?.value) || 6000;
            var sc = calculateSheets(Math.round(lenMm), roofing);
            var previewCount = Math.min(20, sc.totalSheets || Math.max(6, pc.patternN * 3));
            let html = '';
            for (let i = 0; i < previewCount; i++) {
                const isPoly = ((i + 1) % pc.patternN) === 0;
                var isPartial = sc.hasPartialSheet && i === previewCount - 1;
                var cls = isPoly ? 'pc-block polycarb' : 'pc-block steel';
                var style = isPoly ? 'background:' + tintColor : '';
                if (isPartial) {
                    var frac = Math.max(0.3, sc.partialSheetWidth / sc.coverWidth);
                    style += (style ? ';' : '') + 'width:' + Math.round(20 * frac) + 'px;border-style:dashed';
                }
                html += '<div class="' + cls + '" style="' + style + '" title="Sheet ' + (i + 1) + (isPartial ? ' (cut to ' + sc.partialSheetWidth + 'mm)' : '') + '"></div>';
            }
            // Summary line
            var split = getPolycarbSheetSplit(previewCount);
            html += '<div style="width:100%;font-size:9px;color:var(--sw-text-sec);margin-top:3px">';
            html += sc.totalSheets + ' sheets: ' + split.colorbond + ' steel, ' + split.polycarb + ' polycarb';
            if (sc.hasPartialSheet) html += ' \u2014 last cut to ' + sc.partialSheetWidth + 'mm';
            html += '</div>';
            container.innerHTML = html;
        }

        function calculateSheets(patioLengthMm, roofing) {
            var coverWidth = SHEET_COVERAGE[roofing] || 762;
            var fullSheets = Math.floor(patioLengthMm / coverWidth);
            var remainder = patioLengthMm % coverWidth;
            var totalSheets = remainder > 0 ? fullSheets + 1 : fullSheets;
            if (totalSheets < 1) totalSheets = 1;
            return {
                totalSheets: totalSheets,
                fullSheets: fullSheets,
                hasPartialSheet: remainder > 0,
                partialSheetWidth: remainder,
                coverWidth: coverWidth,
                orderQuantity: totalSheets,
                orderNote: remainder > 0 ? 'Last sheet cut to ' + remainder + 'mm' : 'All full width sheets'
            };
        }

        function updatePolycarbLevels() {
            var roofing = document.getElementById('inRoofing').value;
            var matchKey = SHEET_PROFILES[roofing] && SHEET_PROFILES[roofing].polycarbMatch;
            var pcProfile = matchKey ? POLYCARB_PROFILES[matchKey] : null;
            var levelSelect = document.getElementById('inPolycarbLevel');
            var profileLabel = document.getElementById('polycarbProfileLabel');
            if (!levelSelect) return;
            var levels = pcProfile ? pcProfile.levels : [1, 2];
            var currentVal = parseInt(levelSelect.value) || 1;
            levelSelect.innerHTML = levels.map(function(lv) {
                var label = lv === 1 ? 'Level 1 - Max Light' : lv === 2 ? 'Level 2 - Medium' : 'Level 3 - High Impact';
                return '<option value="' + lv + '"' + (lv === currentVal ? ' selected' : '') + '>' + label + '</option>';
            }).join('');
            if (!levels.includes(currentVal)) levelSelect.value = levels[0];
            if (profileLabel && pcProfile) {
                profileLabel.textContent = 'Profile: ' + pcProfile.name;
            }
        }

        // Init polycarb tints on load
        updatePolycarbTints();

        // Sync electrical checkboxes â†’ hidden dropdown for backward compatibility
        function syncElectricalCheckboxes() {
            var dl = document.getElementById('elecDownlights').checked;
            var fan = document.getElementById('elecFan').checked;
            var sel = document.getElementById('electrical');
            if (dl && fan) sel.value = 'both';
            else if (dl) sel.value = 'downlights';
            else if (fan) sel.value = 'fan';
            else sel.value = 'none';
            // Show SolarSpan note if relevant
            var roofing = (document.getElementById('inRoofing') || {}).value || '';
            var isSolar = roofing.indexOf('solarspan') === 0;
            var anyElec = dl || fan || document.getElementById('elecGPO').checked;
            var noteEl = document.getElementById('elecSolarSpanNote');
            if (noteEl) noteEl.style.display = (isSolar && anyElec) ? 'block' : 'none';
            updateUI();
        }

        // ==================== UI UPDATES ====================
        // Helper: enable/disable a toggle button by data-value within a group
        function setToggleBtnDisabled(groupId, value, disabled) {
            var group = document.getElementById(groupId);
            if (!group) return;
            var btn = group.querySelector('[data-value="' + value + '"]');
            if (btn) { btn.classList.toggle('disabled', disabled); }
        }

        function updateUI() {
            const roofEl = document.getElementById('inRoofStyle');
            const connEl = document.getElementById('inConnection');
            const roofingSelect = document.getElementById('inRoofing');
            let conn = connEl.value;
            const roofing = roofingSelect.value;
            const style = roofEl.value;
            const isGable = style === 'gable';
            const isHip = false; // hip removed

            // === RESTRICTION: Wall mount only works with skillion ===
            if (conn === 'wall') {
                if (isGable) { roofEl.value = 'skillion'; }
                setToggleBtnDisabled('roofStyleGroup', 'gable', true);
            } else {
                setToggleBtnDisabled('roofStyleGroup', 'gable', false);
            }

            // === RESTRICTION: Gable restricts wall connection ===
            if (isGable) {
                if (conn === 'wall') { connEl.value = 'riser'; conn = 'riser'; }
                setToggleBtnDisabled('connectionGroup', 'wall', true);
            } else {
                setToggleBtnDisabled('connectionGroup', 'wall', false);
            }

            // === RESTRICTION: Flyover only works with SolarSpan + skillion ===
            if (!isInsulated(roofing) || isGable) {
                if (conn === 'flyover') { connEl.value = 'riser'; conn = 'riser'; }
                setToggleBtnDisabled('connectionGroup', 'flyover', true);
            } else {
                setToggleBtnDisabled('connectionGroup', 'flyover', false);
            }

            // Sync toggle button active states after restriction changes
            syncAllToggleButtons();

            const isAttached = conn !== 'freestanding';

            // Truss calculator section (gable only, not hip)
            document.getElementById('sec-truss').style.display = (style === 'gable') ? 'block' : 'none';

            // Gable infill in BASICS (gable or hip)
            document.getElementById('gableInfillField').style.display = isGable ? 'block' : 'none';

            // Auto-calculate posts and trusses from dimensions
            autoCalculatePostsAndTrusses();

            // Ceiling finish (SolarSpan only)
            document.getElementById('ceilingFinishField').style.display = isInsulated(roofing) ? 'block' : 'none';

            // BMT dropdown (single-skin sheets only)
            const showBMT = (roofing === 'trimdek' || roofing === 'corrugated');
            document.getElementById('bmtField').style.display = showBMT ? 'block' : 'none';

            // Batten/Purlin calculator: show for all roof types
            document.getElementById('sec-battens').style.display = 'block';
            // Toggle subsections based on roof style
            document.getElementById('rafterSubsection').style.display = isGable ? 'none' : '';
            document.getElementById('skillionBattenSubsection').style.display = isGable ? 'none' : '';
            document.getElementById('gableBattenSubsection').style.display = isGable ? '' : 'none';
            // Update section title
            document.getElementById('battenSectionTitle').textContent = isGable ? 'Purlin Calculator' : 'Purlin & Batten Calculator';

            document.getElementById('pitchField').style.display = 'block';
            document.getElementById('calcPitchRow').style.display = 'none';

            // Connection sub-fields
            var showFasciaHeight = (conn === 'fascia' || conn === 'riser' || conn === 'flyover');
            document.getElementById('fasciaHeightField').style.display = showFasciaHeight ? 'block' : 'none';
            const showRiserOptions = conn === 'riser';
            document.getElementById('riserHeightField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserOffsetField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserQtyField').style.display = showRiserOptions ? 'block' : 'none';
            // House Gutter Impact (show for riser attachment)
            var hgField = document.getElementById('houseGutterImpactField');
            if (hgField) hgField.style.display = showRiserOptions ? 'block' : 'none';
            var bgConfig = document.getElementById('boxGutterConfig');
            if (bgConfig) {
                var isBox = document.getElementById('inHouseGutter').value === 'box';
                bgConfig.style.display = isBox ? 'block' : 'none';
                if (isBox) updateBoxGutterSummary();
            }

            // Fascia brackets (show for gable with fascia connection)
            var showFasciaBrackets = isGable && conn === 'fascia';
            document.getElementById('fasciaBracketQtyField').style.display = showFasciaBrackets ? 'block' : 'none';

            // Polycarbonate: for profiles with a matching polycarb sheet
            const showPolycarb = !!hasPolycarbMatch(roofing);
            document.getElementById('polycarbField').style.display = showPolycarb ? 'block' : 'none';
            if (!showPolycarb) {
                const noRadio = document.querySelector('input[name="polycarb"][value="no"]');
                if (noRadio) noRadio.checked = true;
                var pcOpts = document.getElementById('polycarbOptions');
                if (pcOpts) pcOpts.style.display = 'none';
            }
            // Update polycarb level options based on profile
            if (showPolycarb) updatePolycarbLevels();

            // House attachment subsection: hide for freestanding
            updateAttachmentVisibility();
        }

        // ==================== GET INPUTS & CALCULATE ====================
        function getInputs() {
            const roofStyle = document.getElementById('inRoofStyle').value;
            const orientation = document.getElementById('inOrientation').value;
            const projInput = (parseFloat(document.getElementById('inWidth').value) || 3) * 1000;
            const lenInput = (parseFloat(document.getElementById('inLength').value) || 6) * 1000;
            const userPitch = parseFloat(document.getElementById('inPitch').value) || 10;
            const postH = (parseFloat(document.getElementById('inPostHeight').value) || 2.4) * 1000;
            const nPosts = parseInt(document.getElementById('inPosts').value) || 3;
            const nTruss = parseInt(document.getElementById('inTrusses').value) || 3;
            const nRafters = parseInt(document.getElementById('inRafters').value) || 5;
            const rafterSizeKey = document.getElementById('inRafterSize')?.value || '75x35';
            const rafterSize = RAFTER_SIZES[rafterSizeKey] || RAFTER_SIZES['75x35'];
            const rafterSpacing = parseInt(document.getElementById('inRafterSpacing')?.value) || 900;
            const rafterQtyOverrideVal = parseInt(document.getElementById('inRafterQtyOverride')?.value);
            const rafterQtyOverride = (rafterQtyOverrideVal >= 2) ? rafterQtyOverrideVal : 0;
            const purlinSizeKey = document.getElementById('inPurlinSize')?.value || 'C100';
            const purlinSize = PURLIN_SIZES[purlinSizeKey] || PURLIN_SIZES['C100'];
            const postSizeKey = document.getElementById('inPostSize').value;
            const beamSizeKey = document.getElementById('inBeamSize').value;
            const framePost = FRAME_POSTS[postSizeKey] || FRAME_POSTS['90x90'];
            const frameBeam = FRAME_BEAMS[beamSizeKey] || FRAME_BEAMS['100x50'];
            const sheetBMT = document.getElementById('inBMT').value;
            const trussStyle = document.getElementById('inTrussBase').value;
            const trussChord = document.getElementById('inTrussChord').value;
            const trussSteel = document.getElementById('inTrussSteel').value;

            // Truss options: extender + separate risers (L/R)
            // Use helper to allow 0 as valid input (|| would treat 0 as falsy)
            function numVal(id, def) { const v = parseFloat(document.getElementById(id)?.value); return isNaN(v) ? def : v; }
            const trussExtOn = document.getElementById('trussExtOn')?.checked || false;
            const trussExtLen = trussExtOn ? numVal('trussExtLen', 300) : 0;
            const trussRiserOn = document.getElementById('trussRiserOn')?.checked || false;
            const trussRiserLocked = document.getElementById('trussRiserLock')?.checked || true;
            const trussRiserType = document.getElementById('riserTypeSeparate')?.checked ? 'separate' : 'welded';
            const riserLH = trussRiserOn ? numVal('riserLH', 200) : 0;
            const riserLV = trussRiserOn ? numVal('riserLV', 150) : 0;
            const riserRH = trussRiserOn ? numVal('riserRH', 200) : 0;
            const riserRV = trussRiserOn ? numVal('riserRV', 150) : 0;
            const roofing = document.getElementById('inRoofing').value;
            const infill = document.getElementById('inInfill').value;
            const connection = document.getElementById('inConnection').value;
            const fasciaH = parseFloat(document.getElementById('inFasciaHeight').value) || 2700;
            const riserH = parseFloat(document.getElementById('inRiserHeight').value) || 400;
            const riserOffset = parseFloat(document.getElementById('inRiserOffset').value) || 150;
            const riserQtyInput = parseInt(document.getElementById('inRiserQty').value);
            const houseGutter = document.getElementById('inHouseGutter').value;
            const riserGutter = document.getElementById('inRiserGutter')?.value || 'none';
            const fasciaBracketQty = parseInt(document.getElementById('inFasciaBracketQty').value) || 4;

            const isGable = roofStyle === 'gable' || roofStyle === 'hip';
            const isAttached = connection !== 'freestanding';
            const hasFascia = (connection === 'fascia' || connection === 'riser' || connection === 'flyover');
            const isRecvChan = (connection === 'fascia' || connection === 'wall');

            let W, L;
            if (isGable && orientation === 'perpendicular') {
                W = lenInput;
                L = projInput;
            } else {
                W = projInput;
                L = lenInput;
            }

            // ========== V18 FIX: BEAM HEIGHTS - Proper stacking for gable+riser ==========
            let frontBeamY = postH;
            const beamH = frameBeam.h * 1000;  // beam height in mm from selected beam size
            const riserMemberSize = framePost.w * 1000;  // riser elbow SHS from post size
            // Patio attaches at rafter level (fasciaH = wall top / rafter base)
            // This is ABOVE the fascia board and gutter which hang below

            let backBeamY, fasciaBeamY;
            if (isGable) {
                if (connection === 'riser') {
                    // Gable + Riser: fascia beam sits below house gutter, against lower house fascia
                    // Gutter front face 76mm + 5mm gap â‰ˆ beam top 50mm below fascia top
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    const elevatedBeamY = fasciaH + beamH + riserMemberSize + riserH;
                    frontBeamY = elevatedBeamY;
                    backBeamY = elevatedBeamY;
                } else if (connection === 'fascia' || connection === 'wall') {
                    // Gable + Fascia/Wall: both beams lowered for sheet clearance
                    fasciaBeamY = (connection === 'fascia') ? (fasciaH) : null;
                    frontBeamY = fasciaH;
                    backBeamY = fasciaH;
                } else if (connection === 'flyover') {
                    // Gable + Flyover: beams above existing house roof
                    fasciaBeamY = fasciaH;
                    // Calculate actual house roof rise: 1.5m depth at 15Â° pitch
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150; // 150mm clearance above roof ridge
                    const flyoverBeamY = fasciaH + houseRoofRise + flyoverClearance;
                    frontBeamY = flyoverBeamY;
                    backBeamY = flyoverBeamY;
                } else {
                    // Freestanding - back beam at post height
                    backBeamY = postH;
                    fasciaBeamY = null;
                }
            } else {
                // SKILLION â€” user always controls pitch
                const skillionRise = W * Math.tan(userPitch * Math.PI / 180);
                if (connection === 'freestanding') {
                    backBeamY = postH + skillionRise;
                    fasciaBeamY = null;
                } else if (connection === 'riser') {
                    // Fascia beam sits below house gutter, against lower house fascia
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    backBeamY = fasciaH + beamH + riserMemberSize + riserH;
                    frontBeamY = backBeamY - skillionRise;
                } else if (connection === 'flyover') {
                    fasciaBeamY = fasciaH;
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150;
                    backBeamY = fasciaH + houseRoofRise + flyoverClearance;
                    frontBeamY = backBeamY - skillionRise;
                } else {
                    // fascia or wall
                    fasciaBeamY = (connection === 'fascia') ? (fasciaH) : null;
                    backBeamY = fasciaH;
                    frontBeamY = backBeamY - skillionRise;
                }
            }

            // ========== PITCH & RISE CALCULATION ==========
            let pitch, pitchRad, rise, rafter, trussSpan;

            if (isGable) {
                pitch = userPitch;
                pitchRad = pitch * Math.PI / 180;
                trussSpan = W;
                rise = (W / 2) * Math.tan(pitchRad);
                rafter = Math.sqrt((W / 2) ** 2 + rise ** 2);
            } else {
                pitch = userPitch;
                pitchRad = pitch * Math.PI / 180;
                rise = backBeamY - frontBeamY;
                rafter = Math.sqrt(W ** 2 + rise ** 2);
                trussSpan = W;
            }

            // Batten calculation for skillion with single-skin sheets
            const sheetSpanKey = getSheetSpanKey(roofing, sheetBMT);
            const extraBattensCount = parseInt(document.getElementById('extraBattensVal')?.textContent) || 0;
            const battenCalc = calculateBattens(sheetSpanKey, W, L, extraBattensCount);
            const bracketType = document.querySelector('input[name="bracketType"]:checked')?.value || 'internal';
            const bracketCalc = calculateBrackets(battenCalc.battensNeeded, L);
            const battenValidation = validateBattenSetup(sheetSpanKey, W, pitch);

            // Gable batten/purlin calculation
            const gableExtraBattens = parseInt(document.getElementById('gableExtraBattensVal')?.textContent) || 0;
            const gableBattenCalc = isGable ? calculateGableBattens(roofing, Math.round(rafter), Math.round(L), gableExtraBattens) : null;

            // Rafter calculation
            const rafterCalc = calculateRafters(L, rafterSpacing, rafterQtyOverride);

            calc = {
                roofStyle, orientation, W, L, projInput, lenInput, userPitch, pitch, pitchRad,
                postH, nPosts, nTruss, nRafters, trussStyle, trussChord, trussSteel, trussSpan,
                roofing, sheetBMT, infill, connection, fasciaH, riserH, riserOffset, houseGutter, riserGutter,
                fasciaBracketQty,
                riserQty: riserQtyInput || Math.max(2, Math.ceil(L / 1200)),
                rise, rafter, isGable, isAttached, hasFascia, isRecvChan,
                frontBeamY, backBeamY, fasciaBeamY,
                steel: STEEL[trussSteel],
                framePost, frameBeam, rafterSize, purlinSize,
                sheetCoverage: SHEET_COVERAGE[roofing],
                sheetCalc: calculateSheets(Math.round(L), roofing),
                sheetSpanKey, battenCalc, bracketCalc, bracketType, battenValidation,
                gableBattenCalc,
                rafterCalc, rafterSpacing,
                postSpacing: nPosts > 1 ? Math.round(L / (nPosts - 1)) : L,
                postQtyOverride: !!(document.getElementById('inPostQty')?.value && parseInt(document.getElementById('inPostQty')?.value) >= 2),
                trussRiserLeft: { enabled: trussRiserOn, length: riserLH, height: riserLV },
                trussRiserRight: { enabled: trussRiserOn, length: riserRH, height: riserRV },
                trussRiserLocked: trussRiserLocked,
                riserType: trussRiserOn ? trussRiserType : null,
                trussExtender: { enabled: trussExtOn, length: trussExtLen }
            };

            document.getElementById('calcRise').textContent = Math.round(rise) + 'mm';
            document.getElementById('calcRafter').textContent = Math.round(rafter) + 'mm';
            document.getElementById('calcPitch').textContent = pitch.toFixed(1) + 'Â°';
            // Also update right panel
            var rpRiseEl = document.getElementById('rpRise');
            if (rpRiseEl) rpRiseEl.textContent = Math.round(rise) + 'mm';
            var rpRafterEl = document.getElementById('rpRafter');
            if (rpRafterEl) rpRafterEl.textContent = Math.round(rafter) + 'mm';
            // Set riser qty placeholder to show calculated default
            document.getElementById('inRiserQty').placeholder = Math.max(2, Math.ceil(L / 1200));

            if (isGable) {
                const steelW = STEEL[trussSteel].w * 1000;
                const steelH = STEEL[trussSteel].h * 1000;
                const bmt = STEEL[trussSteel].bmt;
                const overhang = parseFloat(document.getElementById('inOverhang')?.value) || 0;
                const apexAngle = 90 - pitch;
                const heelAngle = pitch;
                const cosP = Math.cos(pitchRad);
                const sinP = Math.sin(pitchRad);

                // Bottom chord: full span (truss is a standard gable shape)
                const chordCut = Math.round(trussSpan - 2 * steelH * cosP);

                // Rafter cut length: from heel face to apex face
                const apexDeduct = steelH / (2 * sinP);
                const heelAllowance = steelH * cosP;
                const rafterCut = Math.round(rafter - apexDeduct - heelAllowance + overhang);

                // Truss steel: chord + 2 rafters
                let trussLM = (chordCut + 2 * rafterCut) / 1000;
                const stickLength = 6000;

                // Extender: extends bottom chord at BOTH ends (gutter bracket mount point)
                let extLM = 0;
                if (trussExtOn) {
                    extLM = (2 * trussExtLen) / 1000;
                }
                trussLM += extLM;

                const kingPostH = rise - steelH;

                // Web member calculations
                let webLM = 0;
                let webText = '';
                let webMembers = []; // array of {type, count, length}
                const showWeb = trussStyle !== 'open';
                document.getElementById('webCard').style.display = showWeb ? 'block' : 'none';

                const halfSpanMM = trussSpan / 2;
                const chordYmm = (trussChord === 'mid') ? (steelH + rise / 3) : steelH;
                const kh = Math.round(kingPostH);

                // Helper: get rafter Y at a given X distance from center
                function rafterYatX(x) {
                    return steelH + rise * (1 - x / halfSpanMM);
                }

                // Helper: calculate diagonal length between two points
                function diagLength(x1, y1, x2, y2) {
                    return Math.round(Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)));
                }

                // Legacy style mapping
                var effectiveStyle = trussStyle;
                if (trussStyle === 'kingfan' || trussStyle === 'queenpost') effectiveStyle = 'kingverticals';
                if (trussStyle === 'kingstrut' || trussStyle === 'fink' || trussStyle === 'open') effectiveStyle = 'web';

                if (effectiveStyle === 'kingpost') {
                    // Single center vertical: bottom chord to ridge
                    webMembers.push({type: 'King Post', count: 1, length: kh});
                    webLM = kh / 1000;
                    webText = '  King Post:     1 \u00D7 ' + kh + 'mm';

                } else if (effectiveStyle === 'kingverticals') {
                    // King post + additional verticals at quarter-span points
                    webMembers.push({type: 'King Post', count: 1, length: kh});
                    webLM = kh / 1000;

                    var qpx = halfSpanMM / 2;
                    var qpChordTop = chordYmm + steelH / 2;
                    var qpRafterBottom = rafterYatX(qpx) - steelH / 2;
                    var qpH = Math.round(qpRafterBottom - qpChordTop);
                    if (qpH > steelH) {
                        webMembers.push({type: 'Vertical', count: 2, length: qpH});
                        webLM += (qpH / 1000) * 2;
                    }

                    webText = '  King Post:     1 \u00D7 ' + kh + 'mm';
                    if (qpH > steelH) {
                        webText += '\n  Verticals:     2 \u00D7 ' + qpH + 'mm';
                    }

                } else if (effectiveStyle === 'web') {
                    // Web: king post + diagonal struts from king post base to rafter quarter-points
                    webMembers.push({type: 'King Post', count: 1, length: kh});
                    webLM = kh / 1000;

                    var wChordTop = chordYmm + steelH / 2;
                    var wQpX = halfSpanMM / 2;
                    var wRafterQpY = rafterYatX(wQpX) - steelH / 2;
                    var wDx = wQpX;
                    var wDy = wRafterQpY - wChordTop;
                    var webDiagLen = Math.round(Math.sqrt(wDx * wDx + wDy * wDy));
                    if (webDiagLen > steelH) {
                        webMembers.push({type: 'Web Diagonal', count: 2, length: webDiagLen});
                        webLM += (webDiagLen / 1000) * 2;
                    }

                    webText = '  King Post:     1 \u00D7 ' + kh + 'mm';
                    if (webDiagLen > steelH) {
                        webText += '\n  Web Diags:     2 \u00D7 ' + webDiagLen + 'mm';
                    }
                }

                // Update web card display
                if (showWeb) {
                    var styleNames = {kingpost:'King Post', kingverticals:'King Post + Verticals', web:'Web'};
                    var styleName = styleNames[effectiveStyle] || effectiveStyle;
                    var totalPcs = 0;
                    var cutList = [];
                    for (var wi = 0; wi < webMembers.length; wi++) {
                        totalPcs += webMembers[wi].count;
                        cutList.push(webMembers[wi].count + '\u00D7' + webMembers[wi].length + 'mm');
                    }
                    document.getElementById('webStyle').textContent = styleName;
                    document.getElementById('webCount').textContent = totalPcs + ' pcs';
                    document.getElementById('webCuts').textContent = cutList.join(', ') || '--';
                    document.getElementById('webLM').textContent = webLM.toFixed(2) + ' LM';
                }

                const totalLM = trussLM + webLM;
                const totalAllLM = totalLM * nTruss;
                const totalSticks = Math.ceil((totalAllLM * 1000) / stickLength);

                // Riser steel: SEPARATE pieces bolted to truss ends (not part of truss)
                const riserLeftLM = trussRiserOn ? (riserLH + riserLV) / 1000 : 0;
                const riserRightLM = trussRiserOn ? (riserRH + riserRV) / 1000 : 0;
                const riserTotalLM = (riserLeftLM + riserRightLM) * nTruss;

                // Update spec cards
                document.getElementById('specA').textContent = Math.round(trussSpan) + 'mm';
                document.getElementById('specB').textContent = Math.round(rise) + 'mm';
                document.getElementById('specC').textContent = Math.round(rafter) + 'mm';
                document.getElementById('specD').textContent = pitch.toFixed(1) + '\u00B0';

                // Conditional dimension items
                document.getElementById('specExtItem').style.display = trussExtOn ? 'block' : 'none';
                document.getElementById('specRiserLItem').style.display = trussRiserOn ? 'block' : 'none';
                document.getElementById('specRiserRItem').style.display = trussRiserOn ? 'block' : 'none';
                document.getElementById('specRiserLMitem').style.display = trussRiserOn ? 'block' : 'none';
                if (trussExtOn) {
                    document.getElementById('specExt').textContent = Math.round(trussExtLen) + 'mm';
                }
                if (trussRiserOn) {
                    document.getElementById('specRiserL').textContent = Math.round(riserLH) + 'mm \u00D7 ' + Math.round(riserLV) + 'mm';
                    document.getElementById('specRiserR').textContent = Math.round(riserRH) + 'mm \u00D7 ' + Math.round(riserRV) + 'mm';
                    document.getElementById('specRiserLM').textContent = (riserLeftLM + riserRightLM).toFixed(2) + 'lm';
                }

                document.getElementById('specChordCut').textContent = chordCut + 'mm' + (trussExtOn ? ' (+' + Math.round(trussExtLen * 2) + 'mm ext)' : '');
                document.getElementById('specRafterCut').textContent = rafterCut + 'mm' + (overhang > 0 ? ' (+' + overhang + 'mm)' : '');
                document.getElementById('specLMper').textContent = totalLM.toFixed(2) + 'lm';
                document.getElementById('specLMall').textContent = totalAllLM.toFixed(1) + 'lm' + (riserTotalLM > 0 ? ' (+' + riserTotalLM.toFixed(1) + 'lm risers)' : '');

                document.getElementById('angleApex').textContent = apexAngle.toFixed(1) + '\u00B0';
                document.getElementById('angleBase').textContent = heelAngle.toFixed(1) + '\u00B0';

                // Build CMI format order text
                const steelName = STEEL[trussSteel].name;
                const clr = steelColor.name;

                const baseNames = {kingpost:'King Post', kingverticals:'King Post + Verticals', web:'Web', kingfan:'King Post + Verticals', queenpost:'King Post + Verticals', kingstrut:'Web', fink:'Web', open:'Web'};
                const baseName = baseNames[trussStyle] || 'King Post';
                const chordName = trussChord === 'bottom' ? 'Bottom Chord' : (trussChord === 'mid' ? 'Mid Chord' : 'No Chord');
                let extras = '';
                if (trussExtOn) extras += ' + Extender';
                if (trussRiserOn) extras += ' + Risers (separate)';
                const line1 = nTruss + '\u00D7 Gable Truss - ' + baseName + ', ' + chordName + extras;

                let dims = 'SP: ' + Math.round(trussSpan) + '  HT: ' + Math.round(rise);
                if (trussExtOn) dims += '  Ext: ' + Math.round(trussExtLen);

                const line3 = steelName + ' RHS - ' + clr;

                let fab = line1 + '\n ' + dims + '\n ' + line3;

                fab += '\n\n\u2500\u2500 Cut List (per truss) \u2500\u2500';
                fab += '\n Chord:        1 \u00D7 ' + chordCut + 'mm';
                if (trussExtOn) {
                    fab += '\n Extender:     2 \u00D7 ' + Math.round(trussExtLen) + 'mm';
                }
                fab += '\n Rafters:      2 \u00D7 ' + rafterCut + 'mm';
                for (var wi = 0; wi < webMembers.length; wi++) {
                    var wm = webMembers[wi];
                    var label = (wm.type + ':').padEnd(14, ' ');
                    fab += '\n ' + label + wm.count + ' \u00D7 ' + wm.length + 'mm';
                }
                fab += '\n Apex Mitre:   ' + apexAngle.toFixed(1) + '\u00B0';
                fab += '\n Heel Mitre:   ' + heelAngle.toFixed(1) + '\u00B0';

                if (trussRiserOn) {
                    fab += '\n\n\u2500\u2500 Risers (separate steel) \u2500\u2500';
                    fab += '\n Left:  ' + Math.round(riserLH) + 'mm horiz + ' + Math.round(riserLV) + 'mm vert = ' + riserLeftLM.toFixed(2) + ' LM';
                    fab += '\n Right: ' + Math.round(riserRH) + 'mm horiz + ' + Math.round(riserRV) + 'mm vert = ' + riserRightLM.toFixed(2) + ' LM';
                    fab += '\n Total riser steel: ' + riserTotalLM.toFixed(2) + ' LM (' + nTruss + ' trusses)';
                }

                fab += '\n\n\u2500\u2500 Material \u2500\u2500';
                fab += '\n Truss LM/ea: ' + totalLM.toFixed(3) + ' LM';
                fab += '\n Truss total: ' + totalAllLM.toFixed(2) + ' LM';
                if (riserTotalLM > 0) fab += '\n Riser total: ' + riserTotalLM.toFixed(2) + ' LM';
                fab += '\n Grand total: ' + (totalAllLM + riserTotalLM).toFixed(2) + ' LM';
                fab += '\n Order:       ' + Math.ceil(((totalAllLM + riserTotalLM) * 1000) / stickLength) + ' \u00D7 6m sticks';

                document.getElementById('fabOrder').textContent = fab;

                // Store truss data for PDF export
                calc.trussData = {
                    steelName, bmt, clr, nTruss, trussSpan: Math.round(trussSpan),
                    rise: Math.round(rise), pitch, overhang, chordCut, rafterCut,
                    apexAngle, heelAngle, webText, webMembers, totalLM, totalAllLM, totalSticks,
                    trussStyle, trussChord, kingPostH: Math.round(kingPostH),
                    riserLeft: { enabled: trussRiserOn, length: riserLH, height: riserLV, lm: riserLeftLM },
                    riserRight: { enabled: trussRiserOn, length: riserRH, height: riserRV, lm: riserRightLM },
                    riserTotalLM: riserTotalLM,
                    extender: { enabled: trussExtOn, length: trussExtLen }
                };
            }

            return calc;
        }

        // ==================== 2D PLAN ====================
        function draw2DPlan() {
            const canvas = document.getElementById('plan2d');
            const p = canvas.parentElement;
            canvas.width = p.clientWidth; canvas.height = p.clientHeight;
            const ctx = canvas.getContext('2d');
            const c = calc;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            const planL = c.lenInput;
            const planW = c.projInput;

            const scale = Math.min((canvas.width-60)/planL, (canvas.height-60)/planW) * 0.85;
            const ox = (canvas.width - planL*scale)/2;
            const oy = (canvas.height - planW*scale)/2 + 10;

            if (c.connection !== 'freestanding') {
                ctx.fillStyle = '#D4C4B0';
                ctx.fillRect(ox-5, oy-20, planL*scale+10, 18);
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('HOUSE', ox+planL*scale/2, oy-6);
            }

            ctx.strokeStyle = steelColor.hex;
            ctx.lineWidth = 2;
            ctx.strokeRect(ox, oy, planL*scale, planW*scale);

            ctx.strokeStyle = '#F15A29';
            ctx.lineWidth = 2;
            if (c.isGable) {
                if (c.orientation === 'lengthways') {
                    ctx.beginPath();
                    ctx.moveTo(ox, oy + planW*scale/2);
                    ctx.lineTo(ox + planL*scale, oy + planW*scale/2);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.fillText('RIDGE', ox + planL*scale/2, oy + planW*scale/2 - 5);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(ox + planL*scale/2, oy);
                    ctx.lineTo(ox + planL*scale/2, oy + planW*scale);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.save();
                    ctx.translate(ox + planL*scale/2 + 12, oy + planW*scale/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.fillText('RIDGE', 0, 0);
                    ctx.restore();
                }
            } else {
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2, oy + 15);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2 - 6, oy + planW*scale - 25);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.lineTo(ox + planL*scale/2 + 6, oy + planW*scale - 25);
                ctx.stroke();
                ctx.fillStyle = '#F15A29';
                ctx.font = '9px sans-serif';
                ctx.fillText('FALL ' + calc.pitch.toFixed(1) + 'Â°', ox + planL*scale/2 + 30, oy + planW*scale/2);
            }

            ctx.fillStyle = steelColor.hex;
            for (let i = 0; i < c.nPosts; i++) {
                const x = ox + (planL*scale/(c.nPosts-1)) * i;
                ctx.fillRect(x-4, oy + planW*scale - 4, 8, 8);
            }

            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = ox + (planL*scale/(c.nPosts-1)) * i;
                    ctx.fillRect(x-4, oy - 4, 8, 8);
                }
            }

            if (c.isAttached) {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.lineTo(ox + planL*scale, oy);
                ctx.stroke();
                ctx.fillStyle = '#666';
                ctx.font = '8px sans-serif';
                ctx.fillText('FASCIA', ox + planL*scale/2, oy + 10);
            }

            ctx.fillStyle = '#333';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(planL + 'mm', ox + planL*scale/2, oy + planW*scale + 20);
            ctx.save();
            ctx.translate(ox - 15, oy + planW*scale/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText(planW + 'mm', 0, 0);
            ctx.restore();
        }

        // ==================== TRUSS 3D (Section 2) ====================
        let trussScene, trussCam, trussRend, trussGroup, trussControls;

        function initTruss3D() {
            const container = document.getElementById('trussViewport');
            const canvas = document.getElementById('trussCanvas');
            var w = container.clientWidth || 600;
            var h = container.clientHeight || 420;
            trussScene = new THREE.Scene();
            trussScene.background = new THREE.Color(0xF0F2F5);
            trussCam = new THREE.PerspectiveCamera(35, w/h, 0.01, 50);
            trussRend = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true});
            trussRend.setSize(w, h);
            trussRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            trussRend.outputEncoding = THREE.sRGBEncoding;

            // Simple neutral lighting for truss detail view
            trussScene.add(new THREE.AmbientLight(0xffffff, 0.55));
            const keyLight = new THREE.DirectionalLight(0xffffff, 0.85);
            keyLight.position.set(3, 5, 4);
            trussScene.add(keyLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-2, 3, -3);
            trussScene.add(fillLight);

            trussGroup = new THREE.Group();
            trussScene.add(trussGroup);

            // OrbitControls - pan/zoom only (no orbit rotation)
            trussControls = new THREE.OrbitControls(trussCam, canvas);
            trussControls.enableDamping = true;
            trussControls.dampingFactor = 0.05;
            trussControls.screenSpacePanning = true;
            trussControls.enablePan = true;
            trussControls.enableZoom = true;
            trussControls.enableRotate = false;
            trussControls.minDistance = 0.15;
            trussControls.maxDistance = 15;
            trussControls.mouseButtons = {
                LEFT: THREE.MOUSE.PAN,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            trussControls.touches = {
                ONE: THREE.TOUCH.PAN,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            // Default to front view
            setTrussView('front', document.querySelector('.truss-view-btn.active'));
            buildTruss3D();

            // Click-to-select for truss
            canvas.addEventListener('click', onTrussClick);

            // Edge panning disabled - truss uses pan/grab instead of orbit
            // setupEdgePanning3D(container, trussCam, trussControls);

            animateTruss();
        }

        // Truss is built in XY plane: X = span (horizontal), Y = rise (vertical), Z = depth
        function buildTruss3D() {
            // Clear selection state on rebuild
            if (trussSelectedObject) { trussSelectedObject = null; }
            hidePropertiesPanel(document.getElementById('trussPropertiesPanel'));
            while (trussGroup.children.length) trussGroup.remove(trussGroup.children[0]);
            if (!calc.isGable) return;

            const c = calc;
            const span = c.trussSpan / 1000;
            const rise = c.rise / 1000;
            const halfSpan = span / 2;
            const tw = c.steel.w;
            const th = c.steel.h;
            const overhang = (parseFloat(document.getElementById('inOverhang')?.value) || 0) / 1000;
            const mat = new THREE.MeshLambertMaterial({color: new THREE.Color(steelColor.hex)});

            // Truss options (mm â†’ m)
            const extOn = c.trussExtender.enabled;
            const extLen = c.trussExtender.length / 1000;
            const riserOn = c.trussRiserLeft.enabled;
            const rLH = c.trussRiserLeft.length / 1000;
            const rLV = c.trussRiserLeft.height / 1000;
            const rRH = c.trussRiserRight.length / 1000;
            const rRV = c.trussRiserRight.height / 1000;
            const chordType = c.trussChord;
            const heelY = th;           // both heels at same level (standard gable)
            const apexY = th + rise;
            const jt = th * 0.6;        // joint overlap extension

            // Helper: box member between two 2D points
            // extS/extE = extend start/end past endpoints for joint overlap
            // memberType/memberName = optional metadata for selection
            function mbr(x1, y1, x2, y2, extS, extE, memberType, memberName) {
                if (extS === undefined) extS = 0;
                if (extE === undefined) extE = 0;
                const dx = x2 - x1, dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len < 0.001) return;
                const ux = dx / len, uy = dy / len;
                const ax = x1 - ux * extS, ay = y1 - uy * extS;
                const bx = x2 + ux * extE, by = y2 + uy * extE;
                const totalLen = len + extS + extE;
                const geo = new THREE.BoxGeometry(totalLen, th, tw);
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.position.set((ax + bx) / 2, (ay + by) / 2, 0);
                mesh.rotation.z = Math.atan2(dy, dx);
                mesh.userData = {
                    selectable: true,
                    type: memberType || 'Member',
                    specs: {
                        'Name': memberName || (memberType || 'Member'),
                        'Size': c.steel.name + ' RHS',
                        'Length': Math.round(totalLen * 1000) + 'mm',
                        'Material': 'Steel',
                        'Colour': steelColor.name
                    }
                };
                trussGroup.add(mesh);
                return mesh;
            }

            // --- Bottom Chord (standard horizontal, full span) ---
            if (chordType === 'bottom') {
                mbr(-halfSpan, th / 2, halfSpan, th / 2, jt, jt, 'Bottom Chord', 'Bottom Chord');
                if (extOn) {
                    mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2, 0, jt, 'Extender', 'Left Extender');
                    mbr(halfSpan, th / 2, halfSpan + extLen, th / 2, jt, 0, 'Extender', 'Right Extender');
                }
            } else if (chordType === 'mid') {
                const midY = th + rise / 3;
                const lT = (midY - heelY) / (apexY - heelY);
                const midLeftX = lT > 0 ? -halfSpan * (1 - lT) : -halfSpan;
                const midRightX = lT > 0 ? halfSpan * (1 - lT) : halfSpan;
                if (midLeftX < midRightX) mbr(midLeftX, midY, midRightX, midY, jt, jt, 'Mid Chord', 'Mid Chord');
                if (extOn) {
                    mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2, 0, jt, 'Extender', 'Left Extender');
                    mbr(halfSpan, th / 2, halfSpan + extLen, th / 2, jt, 0, 'Extender', 'Right Extender');
                }
            } else if (extOn) {
                mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2, 0, 0, 'Extender', 'Left Extender');
                mbr(halfSpan, th / 2, halfSpan + extLen, th / 2, 0, 0, 'Extender', 'Right Extender');
            }

            // --- Rafters (symmetrical, both from heelY to apex) ---
            {
                const rdx = halfSpan, rdy = apexY - heelY;
                const rd = Math.sqrt(rdx * rdx + rdy * rdy);
                // Left rafter - extends past heel and apex for clean joints
                const lsX = overhang > 0 ? -halfSpan - (rdx / rd) * overhang : -halfSpan;
                const lsY = overhang > 0 ? heelY - (rdy / rd) * overhang : heelY;
                mbr(lsX, lsY, 0, apexY, overhang > 0 ? 0 : jt, jt, 'Rafter', 'Left Rafter');
                // Right rafter
                const rsX = overhang > 0 ? halfSpan + (rdx / rd) * overhang : halfSpan;
                const rsY = overhang > 0 ? heelY - (rdy / rd) * overhang : heelY;
                mbr(rsX, rsY, 0, apexY, overhang > 0 ? 0 : jt, jt, 'Rafter', 'Right Rafter');
            }

            // --- Web Members ---
            // Helper: get rafter Y at distance x from center (in meters)
            function rafterYat(x) { return th + rise * (1 - x / halfSpan); }

            const chordYm = chordType === 'mid' ? (th + rise / 3) : th;
            const kBottom = chordType === 'mid' ? (chordYm + th / 2) : th;
            const kTop = apexY - th;
            const qpX = halfSpan / 2;  // quarter-point X from center (meters)

            // Legacy style mapping for 3D view
            var eff3d = c.trussStyle;
            if (eff3d === 'kingfan' || eff3d === 'queenpost') eff3d = 'kingverticals';
            if (eff3d === 'kingstrut' || eff3d === 'fink' || eff3d === 'open') eff3d = 'web';

            if (eff3d === 'kingpost') {
                // Single center vertical from bottom chord to ridge
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop, jt, jt, 'Web', 'King Post');
                }

            } else if (eff3d === 'kingverticals') {
                // King post + verticals at quarter-span points
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop, jt, jt, 'Web', 'King Post');
                }
                var kvChordTop = chordYm + th / 2;
                var kvRafterBot = rafterYat(qpX) - th / 2;
                if (kvRafterBot > kvChordTop + th * 0.5) {
                    mbr(-qpX, kvChordTop, -qpX, kvRafterBot, jt, jt, 'Web', 'Left Vertical');
                    mbr(qpX, kvChordTop, qpX, kvRafterBot, jt, jt, 'Web', 'Right Vertical');
                }

            } else if (eff3d === 'web') {
                // King post + diagonal struts from king post base to rafter quarter-points
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop, jt, jt, 'Web', 'King Post');
                }
                var webChordTop = chordYm + th / 2;
                var webRafterBot = rafterYat(qpX) - th / 2;
                if (webRafterBot > webChordTop + th * 0.5) {
                    mbr(0, webChordTop, -qpX, webRafterBot, jt, jt, 'Web', 'Left Web Diagonal');
                    mbr(0, webChordTop, qpX, webRafterBot, jt, jt, 'Web', 'Right Web Diagonal');
                }
            }

            // --- Risers (L-shaped pieces at heel ends) ---
            if (riserOn) {
                const riserType = c.riserType || 'welded';
                const riserTypeLabel = riserType === 'welded' ? 'Welded to Truss' : 'Separate Piece';
                const sepMat = riserType === 'separate' ? new THREE.MeshLambertMaterial({color: 0x888888}) : null;
                const gap = riserType === 'separate' ? 0.005 : 0;
                function applyRiserMat(mesh) { if (sepMat && mesh) mesh.material = sepMat.clone(); }
                function riserSpecs(mesh, dim) {
                    if (!mesh) return;
                    var s = mesh.userData.specs;
                    mesh.userData.specs = { 'Name': s['Name'], 'Size': s['Size'], 'Dimension': dim, 'Cut Length': s['Length'], 'Type': riserTypeLabel, 'Material': s['Material'], 'Colour': s['Colour'] };
                }

                const lHeelX = extOn ? -halfSpan - extLen : -halfSpan;
                var mLV = mbr(lHeelX, th / 2 - gap, lHeelX, th / 2 - rLV, jt, 0, 'Riser', 'Left Riser (Vert)');
                applyRiserMat(mLV);
                riserSpecs(mLV, Math.round(rLV * 1000) + 'mm');
                var mLH = mbr(lHeelX, th / 2 - rLV, lHeelX - rLH, th / 2 - rLV, jt, 0, 'Riser', 'Left Riser (Horiz)');
                applyRiserMat(mLH);
                riserSpecs(mLH, Math.round(rLH * 1000) + 'mm');

                const rHeelX = extOn ? halfSpan + extLen : halfSpan;
                var mRV = mbr(rHeelX, th / 2 - gap, rHeelX, th / 2 - rRV, jt, 0, 'Riser', 'Right Riser (Vert)');
                applyRiserMat(mRV);
                riserSpecs(mRV, Math.round(rRV * 1000) + 'mm');
                var mRH = mbr(rHeelX, th / 2 - rRV, rHeelX + rRH, th / 2 - rRV, jt, 0, 'Riser', 'Right Riser (Horiz)');
                applyRiserMat(mRH);
                riserSpecs(mRH, Math.round(rRH * 1000) + 'mm');
            }

            // --- Dimension annotations (clean technical drawing style) ---
            const dimColor = 0x555555;
            const dimMat = new THREE.LineBasicMaterial({color: dimColor});
            const accentMat = new THREE.LineBasicMaterial({color: 0xF15A29});
            const off = 0.08;

            // Lowest point for span baseline
            const lowestY = (riserOn ? Math.min(th / 2 - rLV, th / 2 - rRV) : 0) - off;
            const spBaseY = Math.min(-off, lowestY);

            // SPAN - horizontal dimension below truss, with witness lines from chord bottom
            addDimLineWithExt(
                -halfSpan, spBaseY, halfSpan, spBaseY,
                -halfSpan, 0, halfSpan, 0,
                dimMat
            );
            addCleanLabel(Math.round(c.trussSpan) + '', 0, spBaseY - 0.06);

            // HEIGHT - vertical dimension to right of truss, with witness lines
            const htX = halfSpan + off * 1.5 + (extOn ? extLen : 0);
            addDimLineWithExt(
                htX, th, htX, apexY,
                halfSpan + (extOn ? extLen : 0), th,
                0, apexY,
                dimMat
            );
            addCleanLabel(Math.round(c.rise) + '', htX + 0.12, th + rise / 2);

            // RAFTER - dimension line along left rafter slope, offset outward
            {
                const rLen = Math.sqrt(halfSpan * halfSpan + rise * rise);
                const rnx = -rise / rLen;       // outward normal x (upper-left)
                const rny = halfSpan / rLen;    // outward normal y (upper-left)
                const rOff = off * 1.8;

                addDimLineWithExt(
                    -halfSpan + rnx * rOff, heelY + rny * rOff,
                    rnx * rOff, apexY + rny * rOff,
                    -halfSpan + rnx * (th / 2), heelY + rny * (th / 2),
                    rnx * (th / 2), apexY + rny * (th / 2),
                    dimMat
                );
                addCleanLabel(Math.round(c.rafter) + '',
                    (-halfSpan) / 2 + rnx * (rOff + 0.04),
                    heelY + (apexY - heelY) / 2 + rny * (rOff + 0.04));
            }

            // --- Web member dimensions ---
            if (c.trussStyle !== 'open' && c.trussData && c.trussData.webMembers) {
                var wms = c.trussData.webMembers;
                function webLen(t) {
                    for (var wi = 0; wi < wms.length; wi++) {
                        if (wms[wi].type === t) return wms[wi].length;
                    }
                    return 0;
                }

                // King post height label (right of king post)
                if (kTop > kBottom) {
                    var kpL = webLen('King Post');
                    if (kpL) addCleanLabel(kpL + '', off * 1.5, (kBottom + kTop) / 2, true);
                }

                // Use effective style for dimension annotations
                var effDim = c.trussStyle;
                if (effDim === 'kingfan' || effDim === 'queenpost') effDim = 'kingverticals';
                if (effDim === 'kingstrut' || effDim === 'fink' || effDim === 'open') effDim = 'web';

                if (effDim === 'kingverticals') {
                    var _kvCT = chordYm + th / 2;
                    var _kvRB = rafterYat(qpX) - th / 2;
                    if (_kvRB > _kvCT + th * 0.5) {
                        var vL = webLen('Vertical') || webLen('Queen Post') || webLen('Fan Web');
                        if (vL) addCleanLabel(vL + '', -qpX - off * 1.5, (_kvCT + _kvRB) / 2, true);
                    }

                } else if (effDim === 'web') {
                    var _wCT = chordYm + th / 2;
                    var _wRB = rafterYat(qpX) - th / 2;
                    if (_wRB > _wCT + th * 0.5) {
                        var wdL = webLen('Web Diagonal') || webLen('Strut') || webLen('Inner Diagonal');
                        if (wdL) {
                            addCleanLabel(wdL + '', -qpX / 2 - off * 1.5, (_wCT + _wRB) / 2 + off * 0.5, true);
                        }
                    }
                }
            }

            // Extender labels
            if (extOn) {
                const eMat = new THREE.LineBasicMaterial({color: 0x999999});
                const extY = -off * 0.5;
                addDimLineWithExt(
                    halfSpan, extY, halfSpan + extLen, extY,
                    halfSpan, 0, halfSpan + extLen, 0,
                    eMat
                );
                addCleanLabel(Math.round(c.trussExtender.length) + '', halfSpan + extLen / 2, extY - off * 0.8);
                addDimLineWithExt(
                    -halfSpan - extLen, extY, -halfSpan, extY,
                    -halfSpan - extLen, 0, -halfSpan, 0,
                    eMat
                );
                addCleanLabel(Math.round(c.trussExtender.length) + '', -halfSpan - extLen / 2, extY - off * 0.8);
            }

            // Riser labels - clean numbers only, with extension lines touching geometry
            if (riserOn) {
                const rMat = new THREE.LineBasicMaterial({color: 0x999999});
                // Left riser
                const lhx = extOn ? -halfSpan - extLen : -halfSpan;
                // Vertical dim: extension lines from left face of vertical steel to dimension line
                addDimLineWithExt(
                    lhx - off, th / 2, lhx - off, th / 2 - rLV,        // dim line (offset left)
                    lhx - th / 2, th / 2, lhx - th / 2, th / 2 - rLV   // geometry edge (left face of steel)
                , rMat);
                addCleanLabel(Math.round(c.trussRiserLeft.height) + '', lhx - off * 2.2, th / 2 - rLV / 2);
                // Horizontal dim: extension lines from bottom face of horizontal steel to dimension line
                addDimLineWithExt(
                    lhx - rLH, th / 2 - rLV - off, lhx, th / 2 - rLV - off,           // dim line (offset below)
                    lhx - rLH, th / 2 - rLV - th / 2, lhx, th / 2 - rLV - th / 2      // geometry edge (bottom face)
                , rMat);
                addCleanLabel(Math.round(c.trussRiserLeft.length) + '', lhx - rLH / 2, th / 2 - rLV - off * 1.8);
                // Right riser
                const rhx = extOn ? halfSpan + extLen : halfSpan;
                // Vertical dim: extension lines from right face of vertical steel to dimension line
                addDimLineWithExt(
                    rhx + off, th / 2, rhx + off, th / 2 - rRV,        // dim line (offset right)
                    rhx + th / 2, th / 2, rhx + th / 2, th / 2 - rRV   // geometry edge (right face of steel)
                , rMat);
                addCleanLabel(Math.round(c.trussRiserRight.height) + '', rhx + off * 2.2, th / 2 - rRV / 2);
                // Horizontal dim: extension lines from bottom face of horizontal steel to dimension line
                addDimLineWithExt(
                    rhx, th / 2 - rRV - off, rhx + rRH, th / 2 - rRV - off,           // dim line (offset below)
                    rhx, th / 2 - rRV - th / 2, rhx + rRH, th / 2 - rRV - th / 2      // geometry edge (bottom face)
                , rMat);
                addCleanLabel(Math.round(c.trussRiserRight.length) + '', rhx + rRH / 2, th / 2 - rRV - off * 1.8);
            }

            // PITCH ANGLE - arc INSIDE the triangle at left heel
            addInsideAngleArc(-halfSpan, heelY, 0.12, c.pitchRad, accentMat, 'heel-left');
            addCleanLabel(c.pitch.toFixed(1) + '\u00B0', -halfSpan + 0.14, heelY + 0.06, true);

            // PITCH ANGLE - arc INSIDE the triangle at right heel
            addInsideAngleArc(halfSpan, heelY, 0.12, c.pitchRad, accentMat, 'heel-right');
            addCleanLabel(c.pitch.toFixed(1) + '\u00B0', halfSpan - 0.14, heelY + 0.06, true);

            // RIDGE ANGLE - arc INSIDE at apex (between rafters, pointing down)
            addInsideAngleArc(0, apexY, 0.1, c.pitchRad, accentMat, 'apex');
            addCleanLabel((180 - c.pitch * 2).toFixed(1) + '\u00B0', 0, apexY - 0.08, true);

            if (trussControls) trussControls.update();
        }

        function addDimLine(x1, y1, x2, y2, mat) {
            const pts = [new THREE.Vector3(x1, y1, 0.005), new THREE.Vector3(x2, y2, 0.005)];
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            trussGroup.add(new THREE.Line(geo, mat));
            const tick = 0.035;
            const isVert = Math.abs(y2 - y1) > Math.abs(x2 - x1);
            [pts[0], pts[1]].forEach(p => {
                const t = isVert
                    ? [new THREE.Vector3(p.x - tick, p.y, 0.005), new THREE.Vector3(p.x + tick, p.y, 0.005)]
                    : [new THREE.Vector3(p.x, p.y - tick, 0.005), new THREE.Vector3(p.x, p.y + tick, 0.005)];
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(t), mat));
            });
        }

        // Dimension line with extension lines from geometry edges to dimension line
        function addDimLineWithExt(dimX1, dimY1, dimX2, dimY2, geomX1, geomY1, geomX2, geomY2, mat) {
            const z = 0.005;
            const gap = 0;           // Extension lines start at the steel edge
            const overshoot = 0.012; // Extension line overshoots past dimension line

            // Extension line 1: from geometry point 1 toward dimension point 1
            var dx1 = dimX1 - geomX1, dy1 = dimY1 - geomY1;
            var dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            if (dist1 > 0.001) {
                var ux1 = dx1 / dist1, uy1 = dy1 / dist1;
                var ext1Start = new THREE.Vector3(geomX1 + ux1 * gap, geomY1 + uy1 * gap, z);
                var ext1End = new THREE.Vector3(dimX1 + ux1 * overshoot, dimY1 + uy1 * overshoot, z);
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([ext1Start, ext1End]), mat));
            }

            // Extension line 2: from geometry point 2 toward dimension point 2
            var dx2 = dimX2 - geomX2, dy2 = dimY2 - geomY2;
            var dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            if (dist2 > 0.001) {
                var ux2 = dx2 / dist2, uy2 = dy2 / dist2;
                var ext2Start = new THREE.Vector3(geomX2 + ux2 * gap, geomY2 + uy2 * gap, z);
                var ext2End = new THREE.Vector3(dimX2 + ux2 * overshoot, dimY2 + uy2 * overshoot, z);
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([ext2Start, ext2End]), mat));
            }

            // Main dimension line
            trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(dimX1, dimY1, z), new THREE.Vector3(dimX2, dimY2, z)
            ]), mat));

            // Tick marks at dimension line endpoints
            const tick = 0.035;
            const isVert = Math.abs(dimY2 - dimY1) > Math.abs(dimX2 - dimX1);
            [new THREE.Vector3(dimX1, dimY1, z), new THREE.Vector3(dimX2, dimY2, z)].forEach(p => {
                const t = isVert
                    ? [new THREE.Vector3(p.x - tick, p.y, z), new THREE.Vector3(p.x + tick, p.y, z)]
                    : [new THREE.Vector3(p.x, p.y - tick, z), new THREE.Vector3(p.x, p.y + tick, z)];
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(t), mat));
            });
        }

        // Angle arc drawn INSIDE the triangle geometry
        function addInsideAngleArc(cx, cy, radius, pitchRad, mat, position) {
            const pts = [];
            const segs = 20;
            if (position === 'apex') {
                // Arc between the two rafters pointing downward from apex
                // Rafters go down-left and down-right at pitchRad from vertical
                var startA = Math.PI + pitchRad;
                var endA = 2 * Math.PI - pitchRad;
                for (var i = 0; i <= segs; i++) {
                    var a = startA + (endA - startA) * (i / segs);
                    pts.push(new THREE.Vector3(cx + radius * Math.cos(a), cy + radius * Math.sin(a), 0.005));
                }
            } else if (position === 'heel-left') {
                // Arc at left heel: between bottom chord (going right) and left rafter (going up-right)
                var startA2 = 0;  // along bottom chord toward right
                var endA2 = pitchRad;  // up along rafter
                for (var i2 = 0; i2 <= segs; i2++) {
                    var a2 = startA2 + (endA2 - startA2) * (i2 / segs);
                    pts.push(new THREE.Vector3(cx + radius * Math.cos(a2), cy + radius * Math.sin(a2), 0.005));
                }
            } else if (position === 'heel-right') {
                // Arc at right heel: between right rafter (going up-left) and bottom chord (going left)
                var startA3 = Math.PI - pitchRad;  // up along rafter
                var endA3 = Math.PI;  // along bottom chord toward left
                for (var i3 = 0; i3 <= segs; i3++) {
                    var a3 = startA3 + (endA3 - startA3) * (i3 / segs);
                    pts.push(new THREE.Vector3(cx + radius * Math.cos(a3), cy + radius * Math.sin(a3), 0.005));
                }
            }
            if (pts.length > 1) {
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
            }
        }

        // Clean dimension label - just a number on a subtle white pill background
        function addCleanLabel(text, x, y, isSmall) {
            var dpr = 2;
            var cv = document.createElement('canvas');
            var w = isSmall ? 180 : 220;
            var h = isSmall ? 32 : 36;
            cv.width = w * dpr; cv.height = h * dpr;
            var ctx = cv.getContext('2d');
            ctx.scale(dpr, dpr);
            // Subtle white pill background for readability
            ctx.fillStyle = 'rgba(255,255,255,0.88)';
            ctx.beginPath(); ctx.roundRect(2, 2, w - 4, h - 4, 4); ctx.fill();
            // Clean dark text
            ctx.fillStyle = '#333';
            ctx.font = (isSmall ? 'bold 14px' : 'bold 17px') + ' "SF Mono", Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, w / 2, h / 2);
            var tex = new THREE.CanvasTexture(cv);
            tex.minFilter = THREE.LinearFilter;
            var sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex, depthTest: false}));
            sprite.scale.set(isSmall ? 0.18 : 0.24, isSmall ? 0.035 : 0.042, 1);
            sprite.position.set(x, y, 0.03);
            trussGroup.add(sprite);
        }

        // ==================== FABRICATION CUT LIST ====================
        const JOINT_TYPES = {
            BUTT: 'butt',
            LAP_OVER: 'lap_over',
            LAP_UNDER: 'lap_under',
            MITRE: 'mitre',
            SADDLE: 'saddle'
        };

        const TUBING = {
            '76x38': { width: 76, height: 38, wall: 1.6 },
            '75x50': { width: 75, height: 50, wall: 2.0 },
            '100x50': { width: 100, height: 50, wall: 2.0 }
        };

        function generateCutList(trussData) {
            var tubing = TUBING[calc.trussSteel] || TUBING['76x38'];
            var cutList = [];
            var span = trussData.trussSpan;
            var rise = trussData.rise;
            var pitch = trussData.pitch;
            var pitchRad = pitch * Math.PI / 180;
            var cosP = Math.cos(pitchRad);
            var sinP = Math.sin(pitchRad);
            var steelH = tubing.height;
            var steelW = tubing.width;
            var halfSpan = span / 2;

            // Rafter theoretical length
            var rafterTheoretical = Math.sqrt(halfSpan * halfSpan + rise * rise);

            // Bottom chord cut: deduct rafter heel overlap at each end
            var chordDeduction = steelH * cosP;
            var chordCut = Math.round(span - 2 * chordDeduction);

            cutList.push({
                id: 'BC1',
                name: 'Bottom Chord',
                quantity: 1,
                theoretical: { length: span, description: 'Full span' },
                actual: {
                    length: chordCut,
                    leftEnd: { cut: 'square', angle: 90, description: 'Square cut' },
                    rightEnd: { cut: 'square', angle: 90, description: 'Square cut' }
                },
                tubing: tubing,
                orientation: steelW + 'mm vertical',
                notes: chordCut === span ? 'Full span' : 'Deduct ' + Math.round(chordDeduction) + 'mm each end for rafter heel'
            });

            // Rafter cut lengths (matching existing calculation)
            var apexDeduct = steelH / (2 * sinP);
            var heelAllowance = steelH * cosP;
            var overhang = parseFloat(document.getElementById('inOverhang')?.value) || 0;
            var rafterCut = Math.round(rafterTheoretical - apexDeduct - heelAllowance + overhang);
            var heelAngle = pitch;
            var apexAngle = 90 - pitch;

            // Left Rafter
            cutList.push({
                id: 'LR1',
                name: 'Left Rafter',
                quantity: 1,
                theoretical: { length: Math.round(rafterTheoretical), description: 'Slope length to ridge' },
                actual: {
                    length: rafterCut,
                    leftEnd: { cut: 'mitre', angle: heelAngle, description: heelAngle.toFixed(1) + '\u00B0 mitre (sits on bottom chord)' },
                    rightEnd: { cut: 'mitre', angle: apexAngle, description: apexAngle.toFixed(1) + '\u00B0 mitre (meets right rafter at ridge)' }
                },
                tubing: tubing,
                orientation: steelW + 'mm perpendicular to slope',
                notes: 'Mitre both ends' + (overhang > 0 ? ' (+' + overhang + 'mm overhang)' : '')
            });

            // Right Rafter (mirror)
            cutList.push({
                id: 'RR1',
                name: 'Right Rafter',
                quantity: 1,
                theoretical: { length: Math.round(rafterTheoretical), description: 'Slope length to ridge' },
                actual: {
                    length: rafterCut,
                    leftEnd: { cut: 'mitre', angle: apexAngle, description: apexAngle.toFixed(1) + '\u00B0 mitre (meets left rafter at ridge)' },
                    rightEnd: { cut: 'mitre', angle: heelAngle, description: heelAngle.toFixed(1) + '\u00B0 mitre (sits on bottom chord)' }
                },
                tubing: tubing,
                orientation: steelW + 'mm perpendicular to slope',
                notes: 'Mitre both ends - MIRROR of Left Rafter'
            });

            // Extender pieces
            if (trussData.extender && trussData.extender.enabled) {
                var extLen = trussData.extender.length;
                cutList.push({
                    id: 'EX1',
                    name: 'Extender',
                    quantity: 2,
                    theoretical: { length: extLen, description: 'Extension beyond heel' },
                    actual: {
                        length: Math.round(extLen),
                        leftEnd: { cut: 'square', angle: 90, description: 'Welds/bolts to chord end' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Outer edge' }
                    },
                    tubing: tubing,
                    orientation: steelW + 'mm vertical',
                    notes: 'Extends bottom chord at both ends'
                });
            }

            // Web members
            if (trussData.webMembers && trussData.webMembers.length > 0) {
                for (var wi = 0; wi < trussData.webMembers.length; wi++) {
                    var wm = trussData.webMembers[wi];
                    var webIdMap = {'King Post':'KP1','Fan Web':'FW1','Queen Post':'QP1','Inner Diagonal':'ID1','Outer Diagonal':'OD1','Strut':'ST1'};
                    var webId = webIdMap[wm.type] || ('W' + (wi + 1));
                    cutList.push({
                        id: webId,
                        name: wm.type,
                        quantity: wm.count,
                        theoretical: { length: wm.length, description: wm.type + ' web member' },
                        actual: {
                            length: wm.length,
                            leftEnd: { cut: 'square', angle: 90, description: 'Welds to chord/rafter' },
                            rightEnd: { cut: 'square', angle: 90, description: 'Welds to chord/rafter' }
                        },
                        tubing: tubing,
                        orientation: steelW + 'mm facing outward',
                        notes: wm.type + ' member'
                    });
                }
            }

            // Riser pieces (separate steel, bolted on)
            if (trussData.riserLeft && trussData.riserLeft.enabled) {
                var rLV = trussData.riserLeft.height;
                var rLH = trussData.riserLeft.length;
                var riserVertActual = Math.round(rLV - steelH);

                cutList.push({
                    id: 'RVL',
                    name: 'Riser Vertical (L)',
                    quantity: 1,
                    theoretical: { length: Math.round(rLV), description: 'Vertical drop from chord' },
                    actual: {
                        length: riserVertActual > 0 ? riserVertActual : Math.round(rLV),
                        leftEnd: { cut: 'square', angle: 90, description: 'Bolts to chord face' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Meets horizontal' }
                    },
                    tubing: tubing,
                    orientation: steelW + 'mm facing outward',
                    notes: riserVertActual > 0 ? 'Deduct ' + steelH + 'mm (chord thickness)' : 'Separate piece, bolted'
                });

                cutList.push({
                    id: 'RHL',
                    name: 'Riser Horizontal (L)',
                    quantity: 1,
                    theoretical: { length: Math.round(rLH), description: 'Horizontal extension' },
                    actual: {
                        length: Math.round(rLH),
                        leftEnd: { cut: 'square', angle: 90, description: 'Outer edge' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Meets vertical' }
                    },
                    tubing: tubing,
                    orientation: steelH + 'mm vertical (laid flat)',
                    notes: 'House-side extension'
                });
            }

            if (trussData.riserRight && trussData.riserRight.enabled) {
                var rRV = trussData.riserRight.height;
                var rRH = trussData.riserRight.length;
                var riserRVertActual = Math.round(rRV - steelH);

                cutList.push({
                    id: 'RVR',
                    name: 'Riser Vertical (R)',
                    quantity: 1,
                    theoretical: { length: Math.round(rRV), description: 'Vertical drop from chord' },
                    actual: {
                        length: riserRVertActual > 0 ? riserRVertActual : Math.round(rRV),
                        leftEnd: { cut: 'square', angle: 90, description: 'Bolts to chord face' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Meets horizontal' }
                    },
                    tubing: tubing,
                    orientation: steelW + 'mm facing outward',
                    notes: riserRVertActual > 0 ? 'Deduct ' + steelH + 'mm (chord thickness)' : 'Separate piece, bolted'
                });

                cutList.push({
                    id: 'RHR',
                    name: 'Riser Horizontal (R)',
                    quantity: 1,
                    theoretical: { length: Math.round(rRH), description: 'Horizontal extension' },
                    actual: {
                        length: Math.round(rRH),
                        leftEnd: { cut: 'square', angle: 90, description: 'Outer edge' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Meets vertical' }
                    },
                    tubing: tubing,
                    orientation: steelH + 'mm vertical (laid flat)',
                    notes: 'House-side extension'
                });
            }

            return cutList;
        }

        function renderCutList(cutList) {
            var tbody = document.getElementById('cutListBody');
            if (!tbody) return;
            tbody.innerHTML = '';

            var totalPieces = 0;
            var totalLinear = 0;

            for (var i = 0; i < cutList.length; i++) {
                var item = cutList[i];
                var row = document.createElement('tr');

                var end1 = item.actual.leftEnd || item.actual.bottomEnd || item.actual.innerEnd;
                var end2 = item.actual.rightEnd || item.actual.topEnd || item.actual.outerEnd;

                function formatEnd(end) {
                    if (!end) return '-';
                    if (end.cut === 'square') {
                        return '<span class="square">SQUARE</span><span class="angle-info">90\u00B0</span>';
                    } else if (end.cut === 'mitre') {
                        return '<span class="mitre">MITRE</span><span class="angle-info">' + end.angle.toFixed(1) + '\u00B0</span>';
                    }
                    return end.cut;
                }

                row.innerHTML =
                    '<td><strong>' + item.id + '</strong></td>' +
                    '<td>' + item.name + '<span class="angle-info">' + item.orientation + '</span></td>' +
                    '<td>' + item.quantity + '</td>' +
                    '<td><span class="cut-length">' + item.actual.length + '</span><span class="angle-info">mm</span></td>' +
                    '<td>' + formatEnd(end1) + '</td>' +
                    '<td>' + formatEnd(end2) + '</td>' +
                    '<td><small>' + (item.notes || '') + '</small></td>';

                tbody.appendChild(row);

                totalPieces += item.quantity;
                totalLinear += item.actual.length * item.quantity;
            }

            document.getElementById('totalPieces').textContent = totalPieces;
            document.getElementById('totalLinear').textContent = (totalLinear / 1000).toFixed(2) + 'm';
            document.getElementById('stockLengths').textContent = Math.ceil(totalLinear / 6500);
        }

        function updateCutListPanel() {
            var panel = document.getElementById('cutListPanel');
            if (!panel) return;
            if (!calc.isGable || !calc.trussData) {
                return;
            }
            var tubing = TUBING[calc.trussSteel] || TUBING['76x38'];
            var steelInfo = STEEL[calc.trussSteel] || STEEL['76x38'];
            document.getElementById('cutListTubing').textContent = steelInfo.name + ' RHS';
            var cutList = generateCutList(calc.trussData);
            calc.cutList = cutList;
            renderCutList(cutList);
        }

        function printCutList() {
            var panel = document.getElementById('cutListPanel');
            if (!panel) return;
            var printWin = window.open('', '_blank', 'width=900,height=700');
            printWin.document.write('<html><head><title>Fabrication Cut List</title>');
            printWin.document.write('<style>');
            printWin.document.write('body{font-family:"SF Mono",Consolas,monospace;margin:20px;font-size:13px;}');
            printWin.document.write('table{width:100%;border-collapse:collapse;}');
            printWin.document.write('th{background:#333;color:#fff;padding:8px 12px;text-align:left;font-size:11px;text-transform:uppercase;-webkit-print-color-adjust:exact;print-color-adjust:exact;}');
            printWin.document.write('td{padding:10px 12px;border-bottom:1px solid #ddd;vertical-align:top;}');
            printWin.document.write('.cut-length{font-size:18px;font-weight:bold;color:#d32f2f;}');
            printWin.document.write('.angle-info{font-size:11px;color:#666;display:block;}');
            printWin.document.write('.mitre{color:#1976d2;font-weight:600;}');
            printWin.document.write('.square{color:#388e3c;}');
            printWin.document.write('.totals{display:flex;gap:24px;margin-top:16px;padding-top:12px;border-top:2px solid #333;}');
            printWin.document.write('.total-item{display:flex;flex-direction:column;}');
            printWin.document.write('.total-item span:first-child{font-size:11px;color:#666;text-transform:uppercase;}');
            printWin.document.write('.total-item span:last-child{font-size:20px;font-weight:bold;}');
            printWin.document.write('.btn-small{display:none;}');
            printWin.document.write('h4{margin:0 0 16px 0;font-size:16px;letter-spacing:1px;border-bottom:2px solid #333;padding-bottom:12px;}');
            printWin.document.write('</style></head><body>');
            printWin.document.write(panel.innerHTML);
            printWin.document.write('</body></html>');
            printWin.document.close();
            printWin.focus();
            printWin.print();
        }

        function copyCutList() {
            if (!calc.cutList) return;
            var lines = ['ID\tPart\tQty\tCut Length (mm)\tEnd 1\tEnd 2\tNotes'];
            for (var i = 0; i < calc.cutList.length; i++) {
                var item = calc.cutList[i];
                var end1 = item.actual.leftEnd || item.actual.bottomEnd || item.actual.innerEnd;
                var end2 = item.actual.rightEnd || item.actual.topEnd || item.actual.outerEnd;
                var e1 = end1 ? (end1.cut === 'mitre' ? 'MITRE ' + end1.angle.toFixed(1) + '\u00B0' : 'SQUARE 90\u00B0') : '-';
                var e2 = end2 ? (end2.cut === 'mitre' ? 'MITRE ' + end2.angle.toFixed(1) + '\u00B0' : 'SQUARE 90\u00B0') : '-';
                lines.push(item.id + '\t' + item.name + '\t' + item.quantity + '\t' + item.actual.length + '\t' + e1 + '\t' + e2 + '\t' + (item.notes || ''));
            }
            var totalPieces = 0, totalLinear = 0;
            for (var j = 0; j < calc.cutList.length; j++) {
                totalPieces += calc.cutList[j].quantity;
                totalLinear += calc.cutList[j].actual.length * calc.cutList[j].quantity;
            }
            lines.push('');
            lines.push('Total Pieces:\t' + totalPieces);
            lines.push('Total Linear:\t' + (totalLinear / 1000).toFixed(2) + 'm');
            lines.push('Stock Lengths (6.5m):\t' + Math.ceil(totalLinear / 6500));
            var text = lines.join('\n');
            navigator.clipboard.writeText(text).then(function() {
                showToast('Cut list copied to clipboard', 'success');
            }).catch(function() {
                // Fallback
                var ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                showToast('Cut list copied to clipboard', 'success');
            });
        }

        function setTrussView(v, btn) {
            document.querySelectorAll('.truss-view-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            const span = (calc.trussSpan || 3000) / 1000;
            const rise = (calc.rise || 264) / 1000;
            const apexY = (calc.steel ? calc.steel.h : 0.038) + rise;
            const targetY = apexY * 0.4;
            const baseDist = Math.max(2.5, span * 0.75);
            const target = new THREE.Vector3(0, targetY, 0);

            if (trussControls) trussControls.target.copy(target);
            if (v === '3d') {
                trussCam.position.set(baseDist * 0.4, targetY + baseDist * 0.3, baseDist * 0.85);
            } else if (v === 'front') {
                trussCam.position.set(0, targetY, baseDist);
            } else if (v === 'side') {
                trussCam.position.set(baseDist * 0.5, targetY + 0.05, 0.01);
            } else if (v === 'top') {
                trussCam.position.set(0, targetY + baseDist, 0.01);
            }
            trussCam.lookAt(target);
            if (trussControls) trussControls.update();
        }

        function toggleTrussFullscreen() {
            const viewer = document.getElementById('trussViewport');
            if (!document.fullscreenElement) {
                viewer.requestFullscreen().then(() => resizeTruss());
            } else {
                document.exitFullscreen().then(() => resizeTruss());
            }
        }

        function toggleTrussDimensions() {
            const show = document.getElementById('showTrussDims').checked;
            if (!trussGroup) return;
            trussGroup.children.forEach(child => {
                if (child.isSprite || child.isLine) {
                    child.visible = show;
                }
            });
        }

        function animateTruss() {
            requestAnimationFrame(animateTruss);
            if (trussControls) trussControls.update();
            if (trussRend && trussScene && trussCam) {
                trussRend.render(trussScene, trussCam);
            }
        }

        // ==================== BOX GUTTER CALCULATOR ====================
        const PERTH_RAINFALL_100YR = 207; // mm/hr - 100 year ARI
        const DOWNPIPE_CAP = {'100x75': 3.5, '100x100': 5.0, '90round': 2.8};
        const GUTTER_MIN = {width: 200, depth: 75, freeboard: 30, backUpstand: 50, frontUpstand: 40, turnIn: 25};

        function openGutterDesigner() {
            // Route to flashing creator's Box Gutter tab
            openFlashModalBoxGutter();
            return;
            var modal = document.getElementById('gutterDesignerModal');
            if (!modal) return;
            modal.style.display = 'flex';
            syncRiserToBoxGutter();
            calcBoxGutter();
            // Delay canvas redraw so modal renders first and has dimensions
            setTimeout(function() { calcBoxGutter(); }, 50);
        }

        function closeGutterDesigner() {
            var modal = document.getElementById('gutterDesignerModal');
            if (modal) modal.style.display = 'none';
        }

        function saveGutterToTruss() {
            document.getElementById('trussBoxGutterOn').value = '1';
            var btn = document.getElementById('trussBoxGutterBtn');
            if (btn) btn.classList.add('active');
            closeGutterDesigner();
            rebuildAll();
        }

        function removeGutterFromTruss() {
            document.getElementById('trussBoxGutterOn').value = '0';
            var btn = document.getElementById('trussBoxGutterBtn');
            if (btn) btn.classList.remove('active');
            closeGutterDesigner();
            rebuildAll();
        }

        function calcBoxGutter() {
            var el = document.getElementById('bgResults');
            if (!el) return;
            var houseCatch = parseFloat(document.getElementById('bgHouseCatch').value) || 0;
            var patioCatch = parseFloat(document.getElementById('bgPatioCatch').value) || 0;
            var availW = parseFloat(document.getElementById('bgAvailWidth').value) || 300;
            var availD = parseFloat(document.getElementById('bgAvailDepth').value) || 150;
            var runLen = parseFloat(document.getElementById('bgRunLength').value) || 6000;
            var fallRatio = parseFloat(document.getElementById('bgFallRatio').value) || 60;
            var dpSize = document.getElementById('bgDownpipe').value || '100x75';

            var totalCatch = houseCatch + patioCatch;
            // Q = (A * I) / 3600  (L/s)
            var flowRate = (totalCatch * PERTH_RAINFALL_100YR) / 3600;

            // Fall
            var fallPerM = 1000 / fallRatio; // mm per metre
            var fallTotal = (runLen / 1000) * fallPerM;

            // Gutter sole width (must be calculated before depth)
            var soleW = Math.max(GUTTER_MIN.width, Math.min(availW - 20, 400));

            // Manning equation for wide rectangular channel
            // Water depth d = (Q * n / (w * sqrt(S)))^(3/5)
            // n = 0.014 (Manning's n for Colorbond steel)
            var manningN = 0.014;
            var Q = flowRate / 1000;        // L/s to mÂ³/s
            var S = fallPerM / 1000;        // mm/m to dimensionless slope
            var w = soleW / 1000;           // mm to m
            var waterDepthM = (S > 0 && w > 0 && Q > 0)
                ? Math.pow(Q * manningN / (w * Math.sqrt(S)), 0.6)
                : 0;
            var reqDepth = Math.ceil(waterDepthM * 1000);  // back to mm
            var soleD = Math.max(reqDepth + GUTTER_MIN.freeboard, GUTTER_MIN.depth + GUTTER_MIN.freeboard);
            var freeboard = soleD - reqDepth;

            var backUp = 60;   // Standard back upstand - laps under house roof flashing
            var frontUp = 50;  // Standard front upstand - laps over patio roofing
            var turnIn = GUTTER_MIN.turnIn;
            var totalGirth = backUp + soleW + soleD + frontUp + turnIn + 50; // +50 for bends

            // Downpipes
            var dpCap = DOWNPIPE_CAP[dpSize] || 3.5;
            var dpCount = Math.max(1, Math.ceil(flowRate / dpCap));

            // Validation
            var issues = [];
            var status = 'ok';
            if (soleW < GUTTER_MIN.width) { issues.push('Width ' + soleW + 'mm below min ' + GUTTER_MIN.width + 'mm'); status = 'fail'; }
            if (soleD > availD) { issues.push('Required depth ' + soleD + 'mm exceeds available ' + availD + 'mm'); status = 'fail'; }
            if (freeboard < GUTTER_MIN.freeboard) { issues.push('Freeboard ' + freeboard + 'mm below min ' + GUTTER_MIN.freeboard + 'mm'); if (status !== 'fail') status = 'warn'; }
            if (runLen > 12000 && dpCount < 2) { issues.push('Run > 12m may need mid-point downpipe'); if (status !== 'fail') status = 'warn'; }

            // Update UI
            document.getElementById('bgResCatch').textContent = totalCatch + ' m\u00B2';
            document.getElementById('bgResFlow').textContent = flowRate.toFixed(2) + ' L/s';
            document.getElementById('bgResDP').textContent = dpCount + '\u00D7 ' + dpSize;
            document.getElementById('bgResBack').textContent = backUp + 'mm';
            document.getElementById('bgResSoleW').textContent = soleW + 'mm';
            document.getElementById('bgResSoleD').textContent = soleD + 'mm';
            document.getElementById('bgResFront').textContent = frontUp + 'mm';
            document.getElementById('bgResTurnIn').textContent = turnIn + 'mm';
            document.getElementById('bgResGirth').textContent = totalGirth + 'mm';
            document.getElementById('bgResFB').textContent = freeboard + 'mm';
            document.getElementById('bgResFall').textContent = fallTotal.toFixed(0) + 'mm / ' + (runLen/1000).toFixed(1) + 'm';

            var stEl = document.getElementById('bgStatus');
            if (status === 'ok') {
                stEl.innerHTML = '<span class="gutter-badge ok">\u2713 COMPLIANT</span>';
            } else if (status === 'warn') {
                stEl.innerHTML = '<span class="gutter-badge warn">\u26A0 WARNING</span><div class="gutter-issues">' + issues.join('<br>') + '</div>';
            } else {
                stEl.innerHTML = '<span class="gutter-badge fail">\u2717 DOES NOT FIT</span><div class="gutter-issues">' + issues.join('<br>') + '</div>';
            }

            // Pass riser + steel context for the full cross-section view
            var riserH = parseFloat(document.getElementById('riserLH')?.value) || availW;
            var riserV = parseFloat(document.getElementById('riserLV')?.value) || availD;
            var steelName = (calc.steel ? calc.steel.name : '76x38x1.6');
            var steelW = calc.steel ? calc.steel.w * 1000 : 38;
            var steelH = calc.steel ? calc.steel.h * 1000 : 76;
            drawGutterProfile({backUp: backUp, soleW: soleW, soleD: soleD, frontUp: frontUp, turnIn: turnIn, waterLevel: reqDepth, status: status, riserH: riserH, riserV: riserV, steelW: steelW, steelH: steelH, steelName: steelName});
        }

        function drawGutterProfile(d) {
            var box = document.getElementById('bgCrossSectionBox');
            var canvas = document.getElementById('bgCanvas');
            if (!box || !canvas) return;
            canvas.width = box.clientWidth * 2;
            canvas.height = box.clientHeight * 2;
            canvas.style.width = box.clientWidth + 'px';
            canvas.style.height = box.clientHeight + 'px';
            var ctx = canvas.getContext('2d');
            ctx.scale(2, 2);
            var cw = box.clientWidth, ch = box.clientHeight;

            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, cw, ch);

            // Get riser/steel context
            var rH = d.riserH || d.soleW + 20;  // riser horizontal (gap width)
            var rV = d.riserV || d.soleD + 40;   // riser vertical (drop)
            var stW = d.steelW || 38;             // steel tube width
            var stH = d.steelH || 76;             // steel tube height
            var steelName = d.steelName || '';

            // Total scene dimensions (mm) â€” show the full riser context
            var houseWallW = 40;  // house wall/fascia thickness visual
            var roofOverhang = 60; // visual roof overhang
            var sceneW = houseWallW + rH + stW + 60;
            var sceneH = Math.max(rV + stH + 40, d.backUp + 80);
            var sc = Math.min((cw - 120) / sceneW, (ch - 90) / sceneH);

            // Origin: bottom-left of the gutter sole, centered in canvas
            var ox = cw / 2 - (sceneW * sc) / 2 + (houseWallW + 10) * sc;
            var oy = ch - 45;

            function sx(v) { return ox + v * sc; }
            function sy(v) { return oy - v * sc; }

            // === HOUSE WALL / FASCIA (left side) ===
            ctx.fillStyle = '#e0ddd8';
            ctx.fillRect(sx(-houseWallW - 10), sy(rV + stH + 30), houseWallW * sc, (rV + stH + 30) * sc);
            // Fascia board
            ctx.fillStyle = '#c5bfb5';
            ctx.fillRect(sx(-10), sy(rV + 20), 10 * sc, (rV + 20) * sc);

            // House roof line (angled, coming down from top-left)
            ctx.beginPath();
            ctx.moveTo(sx(-houseWallW - roofOverhang), sy(rV + stH + 60));
            ctx.lineTo(sx(-10), sy(rV + 20));
            ctx.strokeStyle = '#8b7d6b';
            ctx.lineWidth = 3;
            ctx.stroke();
            // Roof label
            ctx.fillStyle = '#8b7d6b';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('HOUSE ROOF', sx(-houseWallW / 2 - roofOverhang / 2), sy(rV + stH + 50));

            // === TRUSS RISER STEEL (right side) â€” the RHS tube ===
            // Vertical riser piece
            ctx.fillStyle = '#b0b0b0';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            ctx.fillRect(sx(rH), sy(rV), stW * sc, rV * sc);
            ctx.strokeRect(sx(rH), sy(rV), stW * sc, rV * sc);
            // Horizontal riser piece (extending right from bottom of vertical)
            ctx.fillRect(sx(rH), sy(stH), (stW + 30) * sc, stH * sc);
            ctx.strokeRect(sx(rH), sy(stH), (stW + 30) * sc, stH * sc);

            // Steel section label
            ctx.fillStyle = '#666';
            ctx.font = 'bold 8px "SF Mono", monospace';
            ctx.textAlign = 'left';
            ctx.fillText(steelName + ' RHS', sx(rH + stW + 4), sy(rV / 2));

            // Patio roof line (angled, going right from top of riser)
            ctx.beginPath();
            ctx.moveTo(sx(rH + stW / 2), sy(rV));
            ctx.lineTo(sx(rH + stW + 80), sy(rV - 30));
            ctx.strokeStyle = '#F15A29';
            ctx.lineWidth = 2.5;
            ctx.stroke();
            // Roof label
            ctx.fillStyle = '#F15A29';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('PATIO ROOF', sx(rH + stW + 20), sy(rV - 18));

            // === BOX GUTTER (in the gap) ===
            // Gutter profile outline
            ctx.beginPath();
            ctx.moveTo(sx(0), sy(0));
            ctx.lineTo(sx(0), sy(d.backUp));                          // Back upstand (against house)
            ctx.moveTo(sx(0), sy(0));
            ctx.lineTo(sx(d.soleW), sy(0));                           // Sole
            ctx.lineTo(sx(d.soleW), sy(d.frontUp));                   // Front upstand
            ctx.lineTo(sx(d.soleW + d.turnIn), sy(d.frontUp - 10));   // Turn-in
            ctx.strokeStyle = d.status === 'fail' ? '#c62828' : '#333';
            ctx.lineWidth = 2.5;
            ctx.lineJoin = 'round';
            ctx.stroke();

            // Fill gutter body
            ctx.beginPath();
            ctx.moveTo(sx(0), sy(0));
            ctx.lineTo(sx(0), sy(d.soleD));
            ctx.lineTo(sx(d.soleW), sy(d.soleD));
            ctx.lineTo(sx(d.soleW), sy(0));
            ctx.closePath();
            ctx.fillStyle = 'rgba(200,200,200,0.15)';
            ctx.fill();

            // Water fill
            if (d.waterLevel > 0) {
                ctx.beginPath();
                ctx.moveTo(sx(2), sy(1));
                ctx.lineTo(sx(2), sy(d.waterLevel));
                ctx.lineTo(sx(d.soleW - 2), sy(d.waterLevel));
                ctx.lineTo(sx(d.soleW - 2), sy(1));
                ctx.closePath();
                ctx.fillStyle = 'rgba(33,150,243,0.2)';
                ctx.fill();

                // Water level line
                ctx.beginPath();
                ctx.moveTo(sx(4), sy(d.waterLevel));
                ctx.lineTo(sx(d.soleW - 4), sy(d.waterLevel));
                ctx.strokeStyle = '#2196f3';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // === DIMENSION LABELS ===
            ctx.font = 'bold 10px "SF Mono", Consolas, monospace';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';

            // Sole width
            ctx.fillText(d.soleW + 'mm', (sx(0) + sx(d.soleW)) / 2, oy + 18);
            drawArrow(ctx, sx(0), oy + 10, sx(d.soleW), oy + 10);

            // Back upstand (left)
            ctx.save();
            ctx.translate(sx(0) - 14, (sy(0) + sy(d.backUp)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(d.backUp + 'mm', 0, 0);
            ctx.restore();

            // Sole depth
            ctx.save();
            ctx.translate(sx(d.soleW) + 14, (sy(0) + sy(d.soleD)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(d.soleD + 'mm', 0, 0);
            ctx.restore();

            // Front upstand
            ctx.save();
            ctx.translate(sx(d.soleW + d.turnIn) + 16, (sy(0) + sy(d.frontUp)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(d.frontUp + 'mm', 0, 0);
            ctx.restore();

            // === RISER DIMENSION LABELS (blue) ===
            ctx.fillStyle = '#2196F3';
            ctx.font = 'bold 10px "SF Mono", Consolas, monospace';

            // Riser horizontal (gap width) â€” shown below the gutter
            ctx.textAlign = 'center';
            ctx.fillText(Math.round(rH) + 'mm horiz', (sx(0) + sx(rH)) / 2, oy + 32);
            drawArrow(ctx, sx(0), oy + 25, sx(rH), oy + 25);

            // Riser vertical (drop) â€” shown on right side
            ctx.save();
            ctx.translate(sx(rH + stW + 6), (sy(0) + sy(rV)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(Math.round(rV) + 'mm vert', 0, 0);
            ctx.restore();

            // Freeboard label
            if (d.soleD > d.waterLevel + 5) {
                ctx.fillStyle = '#4caf50';
                ctx.font = 'bold 9px "SF Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(d.soleD - d.waterLevel) + 'mm FB', (sx(0) + sx(d.soleW)) / 2, sy(d.soleD) - 6);
            }

            // Water level label
            if (d.waterLevel > 0) {
                ctx.fillStyle = '#2196f3';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Water Level', (sx(0) + sx(d.soleW)) / 2, sy(d.waterLevel) - 6);
            }

            // Title and orientation labels
            ctx.fillStyle = '#555';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('BOX GUTTER CROSS-SECTION', 8, 14);
            ctx.fillStyle = '#8b7d6b';
            ctx.font = 'bold 9px Arial';
            ctx.fillText('\u2190 HOUSE (High)', 8, 27);
            ctx.fillStyle = '#F15A29';
            ctx.textAlign = 'right';
            ctx.fillText('PATIO (Low) \u2192', cw - 8, 27);
        }

        function drawArrow(ctx, x1, y, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y);
            ctx.lineTo(x2, y);
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.stroke();
            // Arrow heads
            ctx.fillStyle = '#999';
            ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x1 + 4, y - 3); ctx.lineTo(x1 + 4, y + 3); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(x2, y); ctx.lineTo(x2 - 4, y - 3); ctx.lineTo(x2 - 4, y + 3); ctx.closePath(); ctx.fill();
        }

        function updatePatioCatchment() {
            var w = parseFloat(document.getElementById('inWidth').value) || 3;
            var l = parseFloat(document.getElementById('inLength').value) || 6;
            var el = document.getElementById('bgPatioCatch');
            if (el) el.value = (w * l).toFixed(1);
            // Sync riser offset to available width
            var rOff = parseFloat(document.getElementById('inRiserOffset')?.value);
            var wEl = document.getElementById('bgAvailWidth');
            if (rOff && wEl) wEl.value = rOff;
            // Sync gutter run to patio length
            var runEl = document.getElementById('bgRunLength');
            if (runEl && calc.L) runEl.value = calc.L;
            // Sync gutter data if box gutter is active
            var trussRiserBG = document.getElementById('trussRiserOn')?.checked && document.getElementById('trussBoxGutterOn')?.value === '1';
            if (trussRiserBG) syncRiserToBoxGutter();
            calcBoxGutter();
        }

        // ==================== ASSEMBLY 3D (Section 3) ====================
        let asmScene, asmCam, asmRend, asmRay, asmMouse, asmControls;
        // rpRend removed â€” single renderer now lives in right panel as asmRend
        let steelGrp, roofGrp, accGrp, houseGrp;
        let compData = new Map();
        let hovered = null;

        // Dimension display system
        let dimensionGroup = null;       // THREE.Group for all dimension objects
        let dimensionsVisible = false;   // Toggle state
        let asmOrthoCamera = null;       // Orthographic camera for elevation views
        let asmCurrentView = '3d';       // Current view preset
        let asmCurrentSection = '';      // Current section cut
        let asmClippingPlane = null;     // Active clipping plane

        function initAsm3D() {
            const container = document.getElementById('asmViewport');
            const canvas = document.getElementById('asmCanvas');
            var w = container.clientWidth || 600;
            var h = container.clientHeight || 360;
            asmScene = new THREE.Scene();
            asmScene.background = new THREE.Color(0x87CEEB);
            asmCam = new THREE.PerspectiveCamera(35, w/h, 0.1, 100);
            asmRend = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true, preserveDrawingBuffer: true});
            asmRend.setSize(w, h);
            asmRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            asmRend.shadowMap.enabled = true;
            asmRend.shadowMap.type = THREE.PCFSoftShadowMap;
            asmRend.outputEncoding = THREE.sRGBEncoding;

            asmRay = new THREE.Raycaster();
            asmMouse = new THREE.Vector2();

            // Simple neutral lighting - white lights preserve Colorbond colours
            asmScene.add(new THREE.AmbientLight(0xffffff, 0.5));

            const sun = new THREE.DirectionalLight(0xffffff, 0.85);
            sun.position.set(5, 10, 7);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 50;
            sun.shadow.camera.left = -20;
            sun.shadow.camera.right = 20;
            sun.shadow.camera.top = 20;
            sun.shadow.camera.bottom = -20;
            asmScene.add(sun);

            const fill = new THREE.DirectionalLight(0xffffff, 0.3);
            fill.position.set(-3, 2, -3);
            asmScene.add(fill);


            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshLambertMaterial({color: 0x8C8475})
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            asmScene.add(ground);

            steelGrp = new THREE.Group();
            roofGrp = new THREE.Group();
            accGrp = new THREE.Group();
            houseGrp = new THREE.Group();
            dimensionGroup = new THREE.Group();
            dimensionGroup.visible = false;
            asmScene.add(steelGrp);
            asmScene.add(roofGrp);
            asmScene.add(accGrp);
            asmScene.add(houseGrp);
            asmScene.add(dimensionGroup);

            // Orthographic camera for elevation views
            var aspect = w / h;
            var frustum = 10;
            asmOrthoCamera = new THREE.OrthographicCamera(
                frustum * aspect / -2, frustum * aspect / 2,
                frustum / 2, frustum / -2, 0.1, 1000
            );
            asmOrthoCamera.position.set(0, 1.5, 15);
            asmOrthoCamera.zoom = 0.5;
            asmOrthoCamera.updateProjectionMatrix();

            // OrbitControls - full pan/zoom/rotate
            asmControls = new THREE.OrbitControls(asmCam, canvas);
            asmControls.enableDamping = true;
            asmControls.dampingFactor = 0.05;
            asmControls.screenSpacePanning = true;
            asmControls.enablePan = true;
            asmControls.enableZoom = true;
            asmControls.enableRotate = true;
            asmControls.minDistance = 0.5;
            asmControls.maxDistance = 25;
            asmControls.target.set(0, 1.5, 0);
            asmControls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            asmControls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            // Hover detection (keep for tooltip)
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                asmMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                asmMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                checkHover(e.clientX - rect.left, e.clientY - rect.top);
            });
            canvas.addEventListener('mouseleave', () => { clearHover(); });

            // Click-to-select
            canvas.addEventListener('click', onAsmClick);

            // Set default 3D view position
            asmCam.position.set(8, 5, 8);
            asmCam.lookAt(0, 1.5, 0);
            asmControls.update();

            buildAsm3D();

            // Edge panning for assembly 3D viewer
            setupEdgePanning3D(container, asmCam, asmControls);

            animateAsm();
        }

        function createCorrugatedGeometry(width, length, segments = 20) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const waveHeight = 0.012;
            const waveFreq = 15;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                pos.setZ(i, Math.sin(x * waveFreq * Math.PI) * waveHeight);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createTrimdekGeometry(width, length, segments = 30) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const ribHeight = 0.025;
            const ribWidth = 0.04;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const phase = ((x / ribWidth) % 1 + 1) % 1;
                let z = 0;
                if (phase < 0.3) z = ribHeight * (phase / 0.3);
                else if (phase < 0.7) z = ribHeight;
                else z = ribHeight * (1 - (phase - 0.7) / 0.3);
                pos.setZ(i, z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createInsulatedGeometry(width, length, thickness) {
            // SolarSpan panel thickness: 75mm or 100mm (default 75mm)
            const t = thickness || 0.075;
            return new THREE.BoxGeometry(width, length, t);
        }

        function buildAsm3D() {
            if (!steelGrp || !calc.W) return;
            // Clear selection state on rebuild
            if (selectedObject) { selectedObject = null; }
            hidePropertiesPanel(document.getElementById('asmPropertiesPanel'));
            originalMaterials.clear();
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => { while(g.children.length) g.remove(g.children[0]); });
            compData.clear();

            const c = calc;
            const W = c.W / 1000;
            const L = c.L / 1000;
            const postH = c.postH / 1000;
            const rise = c.rise / 1000;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;
            const th = c.steel.h;
            const frontBeamY = c.frontBeamY / 1000;
            const backBeamY = c.backBeamY / 1000;
            const fasciaBeamY = c.fasciaBeamY ? c.fasciaBeamY / 1000 : null;

            const steelCol = new THREE.Color(steelColor.hex);
            const sheetCol = new THREE.Color(sheetColor.hex);
            console.log('Steel colour:', steelColor.name, steelColor.hex);
            console.log('Sheet colour:', sheetColor.name, sheetColor.hex);
            // Structural steel (posts, beams) - simple flat colour, no metallic reflections
            const sMat = () => new THREE.MeshLambertMaterial({color: steelCol});
            // Roofing sheets - flat Colorbond colour
            const rMat = () => new THREE.MeshLambertMaterial({color: sheetCol, side: THREE.DoubleSide});

            // SolarSpan ceiling material (bottom colour locked to Surfmist)
            const solarspanCeilingCol = new THREE.Color(COLORBOND_COLOURS['Surfmist']);
            const ceilingMat = () => new THREE.MeshLambertMaterial({
                color: solarspanCeilingCol, side: THREE.DoubleSide
            });

            // EPS foam core material (white insulation)
            const coreMat = () => new THREE.MeshLambertMaterial({color: 0xf5f5f5});

            // For insulated panels, use array of materials: top=sheetColor, bottom=Surfmist, sides=core
            function insulatedMaterials() {
                return [
                    coreMat(), coreMat(),   // +X, -X faces (visible core edge)
                    rMat(),                 // +Y face (top - sheet colour)
                    ceilingMat(),           // -Y face (bottom - Surfmist ceiling)
                    coreMat(), coreMat()    // +Z, -Z faces (visible core edge)
                ];
            }

            const fasciaCol = new THREE.Color(steelColor.hex);
            const fasciaMat = () => new THREE.MeshLambertMaterial({color: fasciaCol});

            const riserCol = new THREE.Color(0x8B4513);
            const riserMat = () => new THREE.MeshLambertMaterial({color: riserCol});

            const beamW = c.frameBeam.w, beamH = c.frameBeam.h, postW = c.framePost.w;

            const isPerpendicular = c.isGable && c.orientation === 'perpendicular';

            // ===== FRONT POSTS (Gutter side) =====
            const fpostH = frontBeamY;  // May be elevated for gable+riser
            for (let i = 0; i < c.nPosts; i++) {
                const x = -L/2 + (L / (c.nPosts - 1)) * i;
                const post = new THREE.Mesh(new THREE.BoxGeometry(postW, fpostH, postW), sMat());
                if (isPerpendicular) {
                    post.position.set(W/2, fpostH/2, x);
                } else {
                    post.position.set(x, fpostH/2, W/2);
                }
                post.castShadow = true;
                steelGrp.add(post);
                regComp(post, 'Front Post ' + (i+1), {'Size': c.framePost.name, 'Height': Math.round(fpostH*1000) + 'mm'});
            }

            // ===== BACK POSTS (freestanding only) =====
            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = -L/2 + (L / (c.nPosts - 1)) * i;
                    const bpostH = backBeamY;
                    const post = new THREE.Mesh(new THREE.BoxGeometry(postW, bpostH, postW), sMat());
                    if (isPerpendicular) {
                        post.position.set(-W/2, bpostH/2, x);
                    } else {
                        post.position.set(x, bpostH/2, -W/2);
                    }
                    post.castShadow = true;
                    steelGrp.add(post);
                    regComp(post, 'Back Post ' + (i+1), {'Size': c.framePost.name, 'Height': Math.round(bpostH*1000) + 'mm'});
                }
            }

            // ===== GUTTER BEAM (Front beam on posts) =====
            const gutterBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamH, beamW), sMat());
            if (isPerpendicular) {
                gutterBeam.rotation.y = Math.PI / 2;
                gutterBeam.position.set(W/2, frontBeamY + beamH/2, 0);
            } else {
                gutterBeam.position.set(0, frontBeamY + beamH/2, W/2);
            }
            gutterBeam.castShadow = true;
            steelGrp.add(gutterBeam);
            regComp(gutterBeam, 'Gutter Beam', {'Size': c.frameBeam.name, 'Length': c.L + 'mm'});

            // ===== FASCIA BEAM (on house - for attached only) =====
            // Against house fascia board face, below gutter in exposed fascia zone
            if (c.isAttached && fasciaBeamY !== null) {
                const fasciaBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamW * 1.1, beamH * 1.2), fasciaMat());
                // Z: against house fascia face (wall face + fascia board thickness offset)
                const fbmZ = -W/2 - 0.02;
                if (isPerpendicular) {
                    fasciaBeam.rotation.y = Math.PI / 2;
                    fasciaBeam.position.set(fbmZ, fasciaBeamY + beamW/2, 0);
                } else {
                    fasciaBeam.position.set(0, fasciaBeamY + beamW/2, fbmZ);
                }
                fasciaBeam.castShadow = true;
                steelGrp.add(fasciaBeam);
                regComp(fasciaBeam, 'Fascia Beam', {'Size': c.frameBeam.name, 'Length': c.L + 'mm', 'Height': c.fasciaH + 'mm', 'Note': 'House connection'});
            }

            // ===== RAFTER BRACKETS (for fascia connections only) =====
            if (c.connection === 'fascia') {
                const bracketLen = 0.5;
                const bracketH = 0.006;
                const bracketW = 0.05;
                const bracketCount = Math.max(3, Math.ceil(L / 1.0));
                for (let i = 0; i < bracketCount; i++) {
                    const x = -L/2 + (L / (bracketCount - 1)) * i;
                    const bracket = new THREE.Mesh(
                        new THREE.BoxGeometry(bracketW, bracketH, bracketLen),
                        sMat()
                    );
                    if (isPerpendicular) {
                        bracket.rotation.y = Math.PI / 2;
                        bracket.position.set(-W/2 - bracketLen/2 - 0.08, fasciaBeamY + beamH + 0.1, x);
                    } else {
                        bracket.position.set(x, fasciaBeamY + beamH + 0.1, -W/2 - bracketLen/2 - 0.08);
                    }
                    steelGrp.add(bracket);
                }
            }

            // ===== V18 FIX: RISERS with correct stacking =====
            if (c.connection === 'riser') {
                // V18: Riser beam sits ON TOP of risers
                const riserOff = c.riserOffset / 1000;
                const riserSize = postW;  // riser elbows match post size
                const count = c.riserQty;

                // Calculate actual vertical rise of risers
                // Span from fascia beam top (horiz piece) up to riser beam bottom (backBeamY)
                const actualRiserH = backBeamY - (fasciaBeamY + beamH + riserSize);

                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;

                    // HORIZONTAL piece (comes out from fascia beam)
                    const horizPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, riserSize, riserOff),
                        riserMat()
                    );

                    // VERTICAL piece (rises up)
                    const vertPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, actualRiserH, riserSize),
                        riserMat()
                    );

                    if (isPerpendicular) {
                        horizPiece.rotation.y = Math.PI / 2;
                        horizPiece.position.set(-W/2 + riserOff/2, fasciaBeamY + beamH + riserSize/2, x);
                        vertPiece.position.set(-W/2 + riserOff, fasciaBeamY + beamH + riserSize + actualRiserH/2, x);
                    } else {
                        horizPiece.position.set(x, fasciaBeamY + beamH + riserSize/2, -W/2 + riserOff/2);
                        vertPiece.position.set(x, fasciaBeamY + beamH + riserSize + actualRiserH/2, -W/2 + riserOff);
                    }

                    horizPiece.castShadow = true;
                    vertPiece.castShadow = true;
                    steelGrp.add(horizPiece);
                    steelGrp.add(vertPiece);
                    regComp(vertPiece, 'Riser Elbow ' + (i+1), {
                        'Size': c.framePost.name,
                        'Offset': c.riserOffset + 'mm',
                        'Rise': Math.round(actualRiserH * 1000) + 'mm',
                        'Note': '90Â° elbow clears house gutter'
                    });
                }

                // Riser brackets â€“ threaded rod through house fascia, clamps fascia beam tight
                // Strip lays along rafter top, threaded rod pokes through fascia board
                const galvMat = () => new THREE.MeshLambertMaterial({color: 0xC0C0C0});
                const fasciaHmR = c.fasciaH / 1000; // rafter base Y (independent of fascia beam)
                const fasciaBdH = 0.15; // house fascia board height
                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;
                    const stripLen = 0.45;   // 450mm long
                    const stripW = 0.03;     // 30mm wide
                    const stripT = 0.006;    // 6mm thick galv plate
                    // Y: vertically centred on house fascia board
                    const bkY = fasciaHmR - fasciaBdH / 2;
                    // House fascia front face is 50mm behind patio edge
                    // Fascia beam front face is 10mm past patio edge
                    const fasciaFaceOff = -0.05; // house fascia front face relative to -W/2
                    const fbmFrontOff = 0.01;    // fascia beam front face relative to -W/2
                    // Threaded rod: from fascia face through to fascia beam front face
                    const rodLen = fbmFrontOff - fasciaFaceOff; // 60mm
                    const rodD = 0.012; // M12 threaded rod
                    // Strip: mostly behind wall, tip at house fascia face
                    const strip = new THREE.Mesh(
                        new THREE.BoxGeometry(stripW, stripT, stripLen),
                        galvMat()
                    );
                    // Threaded rod: pokes through fascia, does NOT protrude past fascia beam
                    const bolt = new THREE.Mesh(
                        new THREE.BoxGeometry(rodD, rodD, rodLen),
                        galvMat()
                    );
                    if (isPerpendicular) {
                        strip.rotation.y = Math.PI / 2;
                        strip.position.set(-W/2 + fasciaFaceOff - stripLen/2, bkY, x);
                        bolt.rotation.y = Math.PI / 2;
                        bolt.position.set(-W/2 + fasciaFaceOff + rodLen/2, bkY, x);
                    } else {
                        strip.position.set(x, bkY, -W/2 + fasciaFaceOff - stripLen/2);
                        bolt.position.set(x, bkY, -W/2 + fasciaFaceOff + rodLen/2);
                    }
                    steelGrp.add(strip);
                    steelGrp.add(bolt);
                    regComp(strip, 'Riser Bracket ' + (i+1), {'Size': '450Ã—30Ã—6mm Galv Flat Bar', 'Rod': 'M12 threaded rod', 'Note': 'Threaded rod through fascia, clamps fascia beam tight'});
                }

                // Box gutter (if selected) - sits in gap between house wall and riser beam
                if (c.houseGutter === 'box') {
                    // Width sized to fit the gap between house fascia and riser beam
                    const boxGutterW = riserOff;
                    const boxGutterD = 0.1;       // inner wall height (house side)
                    const boxGutterOuter = 0.12;  // outer wall height (riser side, taller to catch water)
                    const wallT = 0.01;

                    // U-shaped cross-section: X=0 is house side, X=boxGutterW is riser side
                    const gutterShape = new THREE.Shape();
                    gutterShape.moveTo(0, 0);
                    gutterShape.lineTo(boxGutterW, 0);
                    gutterShape.lineTo(boxGutterW, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, wallT);
                    gutterShape.lineTo(wallT, wallT);
                    gutterShape.lineTo(wallT, boxGutterD);
                    gutterShape.lineTo(0, boxGutterD);
                    gutterShape.closePath();

                    const extrudeSettings = { depth: L, bevelEnabled: false };
                    const gutterGeo = new THREE.ExtrudeGeometry(gutterShape, extrudeSettings);
                    const boxGutter = new THREE.Mesh(gutterGeo, sMat());

                    // Y: gutter bottom sits ON TOP of the riser elbow horizontal pieces
                    // horiz piece top = fasciaBeamY + beamH + riserSize
                    const boxGutterY = fasciaBeamY + beamH + riserSize;

                    if (isPerpendicular) {
                        // House wall at X = -W/2, riser beam at X = -W/2 + riserOff
                        // rotation.y = Ï€: local X â†’ world -X, local +Z â†’ world -Z
                        // Shape X=0 (house side) â†’ world X = position.x (riser beam)
                        // Shape X=gutterW (riser side) â†’ world X = position.x - gutterW = -W/2 (house)
                        // So we need to flip: position at -W/2, no extra rotation for X direction
                        // Use rotation.y = 0: local X â†’ world +X, local Z â†’ world +Z
                        // Shape X=0 (house side) at world X = -W/2, X=gutterW at -W/2 + riserOff
                        boxGutter.rotation.y = 0;
                        boxGutter.position.set(-W/2, boxGutterY, -L/2);
                    } else {
                        // House wall at Z = -W/2, riser beam at Z = -W/2 + riserOff
                        // rotation.y = -Ï€/2: local X â†’ world +Z, local +Z â†’ world -X
                        // Shape X=0 (house side) at world Z = -W/2
                        // Shape X=gutterW (riser side) at world Z = -W/2 + riserOff
                        // Extrusion goes -X, so position at X = +L/2
                        boxGutter.rotation.y = -Math.PI / 2;
                        boxGutter.position.set(L/2, boxGutterY, -W/2);
                    }
                    accGrp.add(boxGutter);
                    regComp(boxGutter, 'Box Gutter', {'Width': Math.round(riserOff*1000)+'mm', 'Inner Depth': '100mm', 'Outer Depth': '120mm'});
                }

                // Patio gutter on riser beam (gable only) - catches back slope water
                if (c.isGable && c.riserGutter === 'quad') {
                    const rgW = 0.115;     // 115mm quad gutter
                    const rgFront = 0.076; // 76mm front face
                    const rgBack = 0.045;  // 45mm back face
                    const rgT = 0.001;     // 1mm sheet steel
                    const rgs = new THREE.Shape();
                    rgs.moveTo(0, 0);
                    rgs.lineTo(rgW, 0);
                    rgs.lineTo(rgW, rgFront);
                    rgs.lineTo(rgW - rgT, rgFront);
                    rgs.lineTo(rgW - rgT, rgT);
                    rgs.lineTo(rgT, rgT);
                    rgs.lineTo(rgT, rgBack);
                    rgs.lineTo(0, rgBack);
                    rgs.closePath();
                    const rgGeo = new THREE.ExtrudeGeometry(rgs, { depth: L, bevelEnabled: false });
                    const riserGutterMesh = new THREE.Mesh(rgGeo, sMat());
                    // Sits on top of riser beam
                    const riserBeamTop = backBeamY + beamW; // riser beam on edge: height = beam width
                    if (isPerpendicular) {
                        riserGutterMesh.position.set(-W/2 + riserOff - rgW/2, riserBeamTop, -L/2);
                    } else {
                        riserGutterMesh.rotation.y = -Math.PI / 2;
                        riserGutterMesh.position.set(L/2, riserBeamTop, -W/2 + riserOff - rgW/2);
                    }
                    accGrp.add(riserGutterMesh);
                    regComp(riserGutterMesh, 'Riser Beam Gutter', {'Type': '115mm Quad', 'Length': c.L + 'mm', 'Note': 'Catches gable back slope water'});
                }
            }

            // ===== CARRY / BACK BEAM - NOT for receiving channel (fascia/wall use channel instead) =====
            if (c.connection !== 'fascia' && c.connection !== 'wall') {
                const isRiser = c.connection === 'riser';
                const isFlyover = c.connection === 'flyover';
                // Riser: beam on edge (swap w/h), Flyover: always 150Ã—50, Default: selected beam
                const beamHeight = isRiser ? beamW : (isFlyover ? 0.05 : beamH);
                const beamWidth = isRiser ? beamH : (isFlyover ? 0.15 : beamW);
                const riserOff = isRiser ? c.riserOffset/1000 : 0;

                const carryBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamHeight, beamWidth), sMat());
                if (isPerpendicular) {
                    carryBeam.rotation.y = Math.PI / 2;
                    carryBeam.position.set(-W/2 + riserOff, backBeamY + beamHeight/2, 0);
                } else {
                    carryBeam.position.set(0, backBeamY + beamHeight/2, -W/2 + riserOff);
                }
                carryBeam.castShadow = true;
                steelGrp.add(carryBeam);
                const beamName = isRiser ? 'Riser Beam' : (isFlyover ? 'Flyover Beam' : 'Back Beam');
                const beamSpec = isRiser ? (c.frameBeam.name + ' (on edge)') : (isFlyover ? '150Ã—50Ã—2 RHS' : c.frameBeam.name);
                regComp(carryBeam, beamName, {'Size': beamSpec, 'Length': c.L + 'mm', 'Height': Math.round(backBeamY*1000) + 'mm'});
            }

            // ===== FLYOVER VERTICAL STRUTS - sit ON TOP of house roof =====
            // Struts penetrate through roof sheets and bolt to house rafters
            if (c.connection === 'flyover') {
                const fasciaHm = c.fasciaH / 1000;
                const hRafterH = 0.09; // house rafter height
                // Struts positioned on house roof near the eave, directly under the flyover beam
                // Roof surface at the eave = rafter top = fasciaHm + hRafterH
                const roofSurfaceY = fasciaHm + hRafterH;
                const strutSize = postW; // struts match post size
                const strutH = Math.max(0.15, backBeamY - roofSurfaceY);
                const strutCount = Math.max(2, Math.ceil(L / 1.2));
                // Struts are at same Z as the flyover beam (at patio back edge)
                // They go through the roof/fascia and bolt to the house rafters below

                for (let i = 0; i < strutCount; i++) {
                    const x = -L/2 + (L / (strutCount - 1)) * i;
                    const strut = new THREE.Mesh(
                        new THREE.BoxGeometry(strutSize, strutH, strutSize),
                        sMat()
                    );
                    if (isPerpendicular) {
                        strut.position.set(-W/2, roofSurfaceY + strutH/2, x);
                    } else {
                        strut.position.set(x, roofSurfaceY + strutH/2, -W/2);
                    }
                    strut.castShadow = true;
                    steelGrp.add(strut);
                    regComp(strut, 'Flyover Strut ' + (i+1), {'Size': c.framePost.name, 'Height': Math.round(strutH*1000) + 'mm'});
                }
            }

            // ===== ROOF STRUCTURE =====
            const frontTop = frontBeamY + beamH;
            const backTop = backBeamY + beamH;
            const sheetW = c.sheetCoverage / 1000;

            // V18: Calculate actual gutter height for downpipes
            let gutterY;

            if (c.isGable) {
                // ========== GABLE ROOF ==========
                const trussBaseY = (frontTop + backTop) / 2;
                const tiltAngle = Math.atan2(backTop - frontTop, W);
                gutterY = frontTop - 0.04;

                // Trusses (peak from internal geometry; tilt spans between beams when heights differ)
                for (let i = 0; i < c.nTruss; i++) {
                    const x = -L/2 + (L / (c.nTruss - 1)) * i;
                    const truss = createTrussUnit(W, rise, rafter, tw, th, sMat(), c);
                    if (isPerpendicular) {
                        truss.rotation.order = 'ZYX';
                        truss.rotation.y = Math.PI / 2;
                        truss.rotation.z = -tiltAngle;
                        truss.position.set(0, trussBaseY, x);
                    } else {
                        truss.rotation.x = tiltAngle;
                        truss.position.set(x, trussBaseY, 0);
                    }
                    steelGrp.add(truss);
                    regComp(truss, 'Truss ' + (i+1), {'Span': Math.round(c.trussSpan) + 'mm', 'Rise': Math.round(c.rise) + 'mm'});

                    // Gable infill
                    if ((i === 0 || i === c.nTruss - 1) && c.infill !== 'none') {
                        const shape = new THREE.Shape();
                        shape.moveTo(-W/2, th);
                        shape.lineTo(0, rise + th);
                        shape.lineTo(W/2, th);
                        shape.closePath();
                        const isTransparent = c.infill === 'polycarbonate';
                        const isLouvre = c.infill === 'louvre';
                        const infillMat = isTransparent
                            ? new THREE.MeshLambertMaterial({color: 0xDDEEEE, transparent: true, opacity: 0.6, side: THREE.DoubleSide})
                            : new THREE.MeshLambertMaterial({color: isLouvre ? 0xCCCCCC : sheetCol, side: THREE.DoubleSide});
                        const infillMesh = new THREE.Mesh(new THREE.ShapeGeometry(shape), infillMat);

                        if (isPerpendicular) {
                            infillMesh.rotation.y = x > 0 ? Math.PI : 0;
                            infillMesh.position.set(0, trussBaseY, x);
                        } else {
                            infillMesh.rotation.y = Math.PI / 2;
                            infillMesh.position.set(x, trussBaseY, 0);
                        }
                        roofGrp.add(infillMesh);
                        const infillLabel = {colorbond:'Colorbond', polycarbonate:'Polycarbonate', louvre:'Louvre'}[c.infill] || c.infill;
                        regComp(infillMesh, 'Gable Infill', {'Material': infillLabel});
                    }
                }

                // Purlins - use gable batten calculator positions
                const gbc = c.gableBattenCalc;
                if (gbc && gbc.totalBattens > 0) {
                    const rafterMm = rafter * 1000;
                    const apexOffset = 75;
                    for (let side = -1; side <= 1; side += 2) {
                        for (let i = 0; i < gbc.positionsPerSide.length; i++) {
                            const pos = gbc.positionsPerSide[i];
                            const frac = (apexOffset + pos) / rafterMm;
                            const zPos = (W/2) * frac * side;
                            const yPos = trussBaseY + th + rise * (1 - frac);
                            const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                            if (isPerpendicular) {
                                purlin.rotation.y = Math.PI / 2;
                                purlin.position.set(zPos, yPos, 0);
                            } else {
                                purlin.position.set(0, yPos, zPos);
                            }
                            steelGrp.add(purlin);
                            const sideLabel = side === -1 ? 'L' : 'R';
                            regComp(purlin, 'Purlin ' + sideLabel + (i+1), {'Size': c.steel.name, 'Length': Math.round(c.L) + 'mm', 'Position': Math.round(apexOffset + pos) + 'mm from ridge'});
                        }
                    }
                } else if (!gbc) {
                    // Fallback if calculator not available
                    const purlinCount = Math.max(2, Math.ceil(rafter / 0.8));
                    for (let side = -1; side <= 1; side += 2) {
                        for (let p = 1; p <= purlinCount; p++) {
                            const frac = p / (purlinCount + 1);
                            const zPos = (W/2) * frac * side;
                            const yPos = trussBaseY + th + rise * (1 - frac);
                            const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                            if (isPerpendicular) {
                                purlin.rotation.y = Math.PI / 2;
                                purlin.position.set(zPos, yPos, 0);
                            } else {
                                purlin.position.set(0, yPos, zPos);
                            }
                            steelGrp.add(purlin);
                        }
                    }
                }

                // V18 FIX: Roof sheets - corrected rotation for perpendicular mode
                const numSheets = Math.ceil(L / sheetW);
                const gableSc = c.sheetCalc;
                const gablePc = hasPolycarbMatch(c.roofing) ? getPolycarbConfig() : null;
                for (let side = -1; side <= 1; side += 2) {
                    for (let s = 0; s < numSheets; s++) {
                        // Partial sheet: last sheet uses actual remaining width
                        const isPartial = gableSc && gableSc.hasPartialSheet && s === numSheets - 1;
                        const thisW = isPartial ? (gableSc.partialSheetWidth / 1000) : sheetW;
                        const sheetPos = -L/2 + (s * sheetW) + thisW / 2;
                        const isPolySheet = gablePc && ((s + 1) % gablePc.patternN === 0);
                        let sheetGeo;
                        if (c.roofing === 'corrugated') {
                            sheetGeo = createCorrugatedGeometry(thisW, rafter + 0.05);
                        } else if (c.roofing === 'trimdek' || c.roofing === 'spandek') {
                            sheetGeo = createTrimdekGeometry(thisW, rafter + 0.05);
                        } else {
                            sheetGeo = createInsulatedGeometry(thisW, rafter + 0.05, c.roofing === 'solarspan100' ? 0.1 : 0.075);
                        }

                        let sheetMat;
                        if (isPolySheet) {
                            const tintData = POLYCARB_3D_TINTS[gablePc.tint] || POLYCARB_3D_TINTS['Clear'];
                            sheetMat = new THREE.MeshLambertMaterial({
                                color: tintData.color, transparent: true, opacity: tintData.opacity,
                                side: THREE.DoubleSide
                            });
                        } else if (isInsulated(c.roofing)) {
                            sheetMat = insulatedMaterials();
                        } else {
                            sheetMat = rMat();
                        }
                        const sheet = new THREE.Mesh(sheetGeo, sheetMat);

                        if (isPerpendicular) {
                            sheet.rotation.order = 'YXZ';
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                            sheet.rotation.y = Math.PI / 2;

                            const midHeight = trussBaseY + th + rise/2;
                            sheet.position.set(side * W/4, midHeight + th/2 + 0.02, sheetPos);
                        } else {
                            sheet.position.set(sheetPos, trussBaseY + th + th/2 + rise/2 + 0.01, side * W/4);
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                        }
                        sheet.castShadow = !isPolySheet;
                        roofGrp.add(sheet);
                        const sideLabel = side === -1 ? 'A' : 'B';
                        const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                        const widthNote = isPartial ? ' (cut to ' + gableSc.partialSheetWidth + 'mm)' : '';
                        regComp(sheet, 'Roof Sheet ' + sideLabel + (s+1), {'Profile': sheetType, 'Width': Math.round(thisW * 1000) + 'mm' + widthNote, 'Length': Math.round((rafter + 0.05)*1000) + 'mm', 'Side': side === -1 ? 'Left slope' : 'Right slope'});
                    }
                }

                // Ridge capping
                const ridge = new THREE.Mesh(new THREE.BoxGeometry(L, 0.04, 0.3), rMat());
                if (isPerpendicular) {
                    ridge.rotation.y = Math.PI / 2;
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                } else {
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                }
                accGrp.add(ridge);
                regComp(ridge, 'Ridge Cap', {'Length': c.L + 'mm'});

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                if (isPerpendicular) {
                    gutter.rotation.y = Math.PI / 2;
                    gutter.position.set(W/2 + 0.07, gutterY, 0);
                } else {
                    gutter.position.set(0, gutterY, W/2 + 0.07);
                }
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.L + 'mm'});

                // Gable barges
                const bargeThick = 0.003;
                const bargeWidth = 0.15;
                const bargeLen = rafter + 0.05;

                if (isPerpendicular) {
                    [-L/2, L/2].forEach((zEnd) => {
                        const bargeL = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeL.position.set(-W/4, trussBaseY + th + rise/2, zEnd);
                        bargeL.rotation.z = c.pitchRad;
                        accGrp.add(bargeL);

                        const bargeR = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeR.position.set(W/4, trussBaseY + th + rise/2, zEnd);
                        bargeR.rotation.z = -c.pitchRad;
                        accGrp.add(bargeR);
                    });
                } else {
                    [-L/2, L/2].forEach((xEnd) => {
                        const bargeHouse = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeHouse.position.set(xEnd, trussBaseY + th + rise/2, -W/4);
                        bargeHouse.rotation.x = -c.pitchRad;
                        accGrp.add(bargeHouse);

                        const bargeGutter = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeGutter.position.set(xEnd, trussBaseY + th + rise/2, W/4);
                        bargeGutter.rotation.x = c.pitchRad;
                        accGrp.add(bargeGutter);
                    });
                }

            } else {
                // ========== SKILLION ROOF ==========
                gutterY = frontTop - 0.04;  // V18: Store gutter Y for downpipes

                const riserOff = c.connection === 'riser' ? c.riserOffset / 1000 : 0;
                const backEdgeZ = -W/2 + riserOff;

                // Rafters (use rafter calculator count and size)
                const raftCount = c.rafterCalc ? c.rafterCalc.rafterCount : c.nRafters;
                const raftW = c.rafterSize ? c.rafterSize.w : tw;
                const raftH = c.rafterSize ? c.rafterSize.h : th;
                const raftName = c.rafterSize ? c.rafterSize.name : c.steel.name;
                for (let i = 0; i < raftCount; i++) {
                    const x = -L/2 + (raftCount > 1 ? (L / (raftCount - 1)) * i : 0);
                    const rafterGeo = new THREE.BoxGeometry(raftW, raftH, rafter);
                    rafterGeo.translate(0, 0, rafter/2);
                    const raft = new THREE.Mesh(rafterGeo, sMat());
                    raft.position.set(x, backTop + raftH/2, backEdgeZ);
                    raft.rotation.x = c.pitchRad;
                    steelGrp.add(raft);
                    regComp(raft, 'Rafter ' + (i+1), {'Size': raftName, 'Length': Math.round(c.rafter) + 'mm'});
                }

                // Purlins / Battens - use batten calculator positions when available
                const effectiveW = W - riserOff;
                const bc = c.battenCalc;
                let purlinPositionsFrac;
                if (bc && bc.battensNeeded > 0) {
                    // Use calculated batten positions (mm from back beam) converted to fractions
                    purlinPositionsFrac = bc.battenPositions.map(p => p / (effectiveW * 1000));
                } else if (!isInsulated(c.roofing) && !(bc && bc.battensNeeded === 0)) {
                    // Fallback: even spacing (skip for SpanPlus/sheets that span full projection)
                    const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9));
                    purlinPositionsFrac = [];
                    for (let p = 1; p < purlinCount; p++) purlinPositionsFrac.push(p / purlinCount);
                } else {
                    purlinPositionsFrac = [];
                }
                for (let p = 0; p < purlinPositionsFrac.length; p++) {
                    const frac = purlinPositionsFrac[p];
                    const zPos = backEdgeZ + effectiveW * frac;
                    const yPos = backTop + th - (backTop - frontTop) * frac;
                    const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, 0.038, 0.076), sMat());
                    purlin.position.set(0, yPos, zPos);
                    steelGrp.add(purlin);
                    regComp(purlin, 'Batten ' + (p+1), {'Size': '76\u00D738\u00D71.6 RHS', 'Length': Math.round(c.L) + 'mm', 'Position': Math.round(frac * effectiveW * 1000) + 'mm from back'});
                }

                // Roof sheets
                const sheetInset = c.isRecvChan ? 0.03 : 0; // 30mm into channel
                const numSheets = Math.ceil(L / sheetW);
                const skillSc = c.sheetCalc;
                const skillPc = hasPolycarbMatch(c.roofing) ? getPolycarbConfig() : null;
                for (let s = 0; s < numSheets; s++) {
                    // Partial sheet: last sheet uses actual remaining width
                    const isPartial = skillSc && skillSc.hasPartialSheet && s === numSheets - 1;
                    const thisW = isPartial ? (skillSc.partialSheetWidth / 1000) : sheetW;
                    const xPos = -L/2 + (s * sheetW) + thisW / 2;
                    const isPolySheet = skillPc && ((s + 1) % skillPc.patternN === 0);
                    let sheetGeo;
                    if (c.roofing === 'corrugated') {
                        sheetGeo = createCorrugatedGeometry(thisW, rafter);
                    } else if (c.roofing === 'trimdek' || c.roofing === 'spandek') {
                        sheetGeo = createTrimdekGeometry(thisW, rafter);
                    } else {
                        sheetGeo = createInsulatedGeometry(thisW, rafter, c.roofing === 'solarspan100' ? 0.1 : 0.075);
                    }
                    sheetGeo.translate(0, rafter/2, 0);

                    let sheetMat;
                    if (isPolySheet) {
                        const tintData = POLYCARB_3D_TINTS[skillPc.tint] || POLYCARB_3D_TINTS['Clear'];
                        sheetMat = new THREE.MeshLambertMaterial({
                            color: tintData.color, transparent: true, opacity: tintData.opacity,
                            side: THREE.DoubleSide
                        });
                    } else if (isInsulated(c.roofing)) {
                        sheetMat = insulatedMaterials();
                    } else {
                        sheetMat = rMat();
                    }
                    const sheet = new THREE.Mesh(sheetGeo, sheetMat);
                    sheet.position.set(xPos, backTop + th + th/2 + 0.01, backEdgeZ - sheetInset);
                    sheet.rotation.x = Math.PI/2 + c.pitchRad;
                    sheet.castShadow = !isPolySheet;
                    roofGrp.add(sheet);
                    const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                    const widthNote = isPartial ? ' (cut to ' + skillSc.partialSheetWidth + 'mm)' : '';
                    regComp(sheet, 'Roof Sheet ' + (s+1), {'Profile': sheetType, 'Width': Math.round(thisW * 1000) + 'mm' + widthNote, 'Length': Math.round(rafter*1000) + 'mm'});
                }

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                gutter.position.set(0, gutterY, W/2 + 0.07);
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.lenInput + 'mm'});

                // Back flashing - skip for riser+box gutter AND receiving channel (channel acts as flashing)
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    const flash = new THREE.Mesh(new THREE.BoxGeometry(L, 0.15, 0.003), sMat());
                    flash.position.set(0, backTop + 0.08, backEdgeZ - 0.05);
                    flash.rotation.x = -0.3;
                    accGrp.add(flash);
                    regComp(flash, 'Back Flashing', {'Length': c.lenInput + 'mm'});
                }

                // Barge flashings
                [-L/2, L/2].forEach((xPos, idx) => {
                    const barge = new THREE.Mesh(new THREE.BoxGeometry(0.1, rafter, 0.003), sMat());
                    barge.position.set(xPos, (backTop + frontTop)/2 + th, 0);
                    barge.rotation.x = -(Math.PI/2 - c.pitchRad);
                    accGrp.add(barge);
                });
            }

            // ===== V18 FIX: DOWNPIPES - Use actual gutter height =====
            let dpPositions;
            if (isPerpendicular) {
                dpPositions = [[W/2 + 0.1, -L/2 + 0.1], [W/2 + 0.1, L/2 - 0.1]];
            } else {
                dpPositions = [[-L/2 + 0.1, W/2 + 0.1], [L/2 - 0.1, W/2 + 0.1]];
            }
            dpPositions.forEach((pos, idx) => {
                // V18 FIX: Downpipe height = from ground to gutter, not postH
                const dpHeight = gutterY + 0.04;  // Gutter bottom + 40mm into gutter
                const dp = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, dpHeight, 12), sMat());
                dp.position.set(pos[0], dpHeight/2, pos[1]);
                accGrp.add(dp);
                regComp(dp, 'Downpipe ' + (idx+1), {'Size': '90mm Round', 'Height': Math.round(dpHeight*1000) + 'mm'});
            });

            // ===== HOUSE / WALL REPRESENTATION =====
            // riser, fascia, flyover: house with wall + fascia board + Colorbond roof
            // wall: flat wall only (receiving channel bolts to wall surface)
            // freestanding: no wall
            if (c.isAttached) {
                const fasciaHm = c.fasciaH / 1000;
                const wallThick = 0.15;
                const wallLen = L + 0.2;
                const wallMat = new THREE.MeshLambertMaterial({color: 0xC8B89A});
                const fasciaTimberMat = new THREE.MeshLambertMaterial({color: 0x8B7355});
                // Monument colour for existing house Colorbond roof
                const roofColorbondMat = new THREE.MeshLambertMaterial({color: new THREE.Color(COLORBOND_COLOURS['Monument'])});

                if (c.connection === 'wall') {
                    // === WALL MODE: just a flat brick/render wall ===
                    const wallH = Math.max(backBeamY + 0.5, fasciaHm + 0.5);
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                } else {
                    // === HOUSE MODE (riser, fascia, flyover): wall + fascia + roof ===
                    // Wall: only up to fascia height (roof sits above)
                    const wallH = fasciaHm;
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                    // Fascia board (timber) covers the full rafter end face
                    if (fasciaHm > 0) {
                        const fasciaBoardH = 0.15;   // 150mm tall
                        const fasciaBoardT = 0.025;  // 25mm thick
                        const fasciaBoard = new THREE.Mesh(
                            new THREE.BoxGeometry(wallLen, fasciaBoardH, fasciaBoardT),
                            fasciaTimberMat
                        );
                        // Fascia board top aligns with rafter bottom (fasciaHm)
                        // Gutter sits against fascia front face at the top half
                        const fbZ = -W/2 - wallThick/2 + fasciaBoardT/2;
                        const fbY = fasciaHm - fasciaBoardH/2; // center of board, top at rafter bottom
                        if (isPerpendicular) {
                            fasciaBoard.rotation.y = Math.PI / 2;
                            fasciaBoard.position.set(fbZ, fbY, 0);
                        } else {
                            fasciaBoard.position.set(0, fbY, fbZ);
                        }
                        fasciaBoard.castShadow = true;
                        houseGrp.add(fasciaBoard);
                        regComp(fasciaBoard, 'House Fascia Board', {'Size': '150Ã—25mm Timber', 'Height': c.fasciaH + 'mm'});
                    }

                    // House roof: timber rafters + individual Colorbond sheets
                    const roofDepth = 1.5;       // 1.5m visible depth
                    const roofPitch = 15 * Math.PI / 180;
                    const roofRise = roofDepth * Math.tan(roofPitch);
                    const roofBaseY = fasciaHm;  // rafters sit on wall top plate
                    const roofCenterY = roofBaseY + roofRise / 2;
                    const roofZCenter = -W/2 - wallThick/2 - roofDepth/2;

                    // Timber rafters (45Ã—90mm) at 600mm spacing
                    const rafterW = 0.045, rafterH = 0.09, rafterSpacing = 0.6;
                    const rafterCount = Math.max(2, Math.ceil(wallLen / rafterSpacing) + 1);
                    for (let i = 0; i < rafterCount; i++) {
                        const pos = -wallLen/2 + (wallLen / (rafterCount - 1)) * i;
                        const rafter = new THREE.Mesh(
                            new THREE.BoxGeometry(rafterW, rafterH, roofDepth),
                            fasciaTimberMat
                        );
                        if (isPerpendicular) {
                            rafter.rotation.order = 'YXZ';
                            rafter.rotation.y = Math.PI / 2;
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(roofZCenter, roofCenterY, pos);
                        } else {
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(pos, roofCenterY, roofZCenter);
                        }
                        rafter.castShadow = true;
                        houseGrp.add(rafter);
                    }
                    // Register first rafter for tooltip
                    if (houseGrp.children.length > 0) {
                        const lastRafter = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastRafter, 'House Rafter', {'Size': '45Ã—90mm Timber', 'Spacing': '600mm', 'Qty': rafterCount});
                    }

                    // Individual Colorbond roof sheets on top of rafters
                    // Sheets overhang 50mm past fascia into gutter
                    const hSheetW = 0.762;  // corrugated sheet cover width
                    const hSheetT = 0.001;  // ~1mm Colorbond
                    const hOverhang = 0.05; // 50mm overhang past fascia
                    const hSheetDepth = roofDepth + hOverhang;
                    const hSheetZCenter = roofZCenter + hOverhang/2; // shift toward fascia
                    const hSheetCount = Math.max(1, Math.ceil(wallLen / hSheetW));
                    const hSheetCenterY = roofCenterY + rafterH/2 + hSheetT/2;
                    for (let i = 0; i < hSheetCount; i++) {
                        const sw = (i === hSheetCount - 1) ? (wallLen - hSheetW * i) : hSheetW;
                        const pos = -wallLen/2 + hSheetW * i + sw/2;
                        const hSheet = new THREE.Mesh(
                            new THREE.BoxGeometry(sw, hSheetT, hSheetDepth),
                            roofColorbondMat.clone()
                        );
                        if (isPerpendicular) {
                            hSheet.rotation.order = 'YXZ';
                            hSheet.rotation.y = Math.PI / 2;
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(hSheetZCenter, hSheetCenterY, pos);
                        } else {
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(pos, hSheetCenterY, hSheetZCenter);
                        }
                        hSheet.castShadow = true;
                        hSheet.receiveShadow = true;
                        houseGrp.add(hSheet);
                    }
                    const roofLabel = c.connection === 'flyover' ? 'Existing House Roof (Flyover)' : 'Existing House Roof';
                    if (houseGrp.children.length > 0) {
                        const lastSheet = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastSheet, roofLabel, {'Pitch': '15Â°', 'Material': 'Colorbond', 'Sheets': hSheetCount});
                    }

                    // House quad gutter â€“ sits against front face of fascia, at the top half
                    // Hidden when box gutter is selected (box gutter replaces it)
                    const showHouseGutter = !(c.connection === 'riser' && c.houseGutter === 'box');
                    if (showHouseGutter) {
                    const hGutterW = 0.115;    // 115mm wide
                    const hGutterFront = 0.076; // 76mm front face
                    const hGutterBack = 0.045;  // 45mm back face
                    const hGutterT = 0.001;     // 1mm sheet steel
                    const hgs = new THREE.Shape();
                    hgs.moveTo(0, 0);
                    hgs.lineTo(hGutterW, 0);
                    hgs.lineTo(hGutterW, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterBack);
                    hgs.lineTo(0, hGutterBack);
                    hgs.closePath();
                    const hGutterGeo = new THREE.ExtrudeGeometry(hgs, { depth: L, bevelEnabled: false });
                    const hGutter = new THREE.Mesh(hGutterGeo, roofColorbondMat.clone());
                    // Back lip top at fasciaHm â€“ gutter against top half of fascia face
                    const hGutterY = fasciaHm - hGutterBack;
                    const hGutterZ = -W/2 - wallThick/2 + 0.025; // at fascia board front face
                    if (isPerpendicular) {
                        // extrude along +Z; rotation.y=0 keeps local Z=world Z
                        hGutter.position.set(hGutterZ, hGutterY, -L/2);
                    } else {
                        // rotation.y=-Ï€/2: local +Z â†’ world -X, shape X â†’ world +Z
                        hGutter.rotation.y = -Math.PI / 2;
                        hGutter.position.set(L/2, hGutterY, hGutterZ);
                    }
                    houseGrp.add(hGutter);
                    regComp(hGutter, 'House Quad Gutter', {'Size': '115mm Quad', 'Front': '76mm', 'Back': '45mm'});
                    } // end showHouseGutter
                }

                // C-Channel - for receiving channel modes (fascia and wall only)
                if (c.isRecvChan) {
                    const chanW = 0.075;  // 75mm wide â€“ captures sheet edges
                    const chanH = 0.03;   // 30mm tall
                    const chanT = 0.003;  // 3mm steel thickness
                    // C-channel profile (U-shape opening toward patio)
                    const chanShape = new THREE.Shape();
                    chanShape.moveTo(0, 0);
                    chanShape.lineTo(chanW, 0);
                    chanShape.lineTo(chanW, chanT);
                    chanShape.lineTo(chanT, chanT);
                    chanShape.lineTo(chanT, chanH - chanT);
                    chanShape.lineTo(chanW, chanH - chanT);
                    chanShape.lineTo(chanW, chanH);
                    chanShape.lineTo(0, chanH);
                    chanShape.closePath();

                    const chanGeo = new THREE.ExtrudeGeometry(chanShape, { depth: L, bevelEnabled: false });
                    const channel = new THREE.Mesh(chanGeo, sMat());

                    if (c.connection === 'fascia') {
                        // On fascia board face, at fascia beam height
                        const chanY = fasciaHm + beamH/2 - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    } else {
                        // Wall mode: on wall surface at connection height
                        const chanY = fasciaHm - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    }
                    steelGrp.add(channel);
                    regComp(channel, 'Receiving Channel', {'Size': '75Ã—30mm C-Channel', 'Length': c.L + 'mm', 'Type': c.connection === 'fascia' ? 'Fascia mount' : 'Wall mount'});
                }
            }

            updateMatList();

            // Update camera orbit target to center of combined patio + house
            const bbox = new THREE.Box3();
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => {
                if (g.children.length > 0) bbox.expandByObject(g);
            });
            if (!bbox.isEmpty() && asmControls) {
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                asmControls.target.copy(center);
                asmControls.update();
            }

            // Refresh dimension labels/lines if visible
            if (dimensionsVisible) updateAsmDimensions();
        }

        function createTrussUnit(W, rise, rafter, tw, th, mat, c) {
            const g = new THREE.Group();
            const halfW = W / 2;
            const heelY = th;
            const apexY = th + rise;

            const extOn = c.trussExtender.enabled;
            const extLen = c.trussExtender.length / 1000;
            const riserOn = c.trussRiserLeft.enabled;
            const rLH = c.trussRiserLeft.length / 1000;
            const rLV = c.trussRiserLeft.height / 1000;
            const rRH = c.trussRiserRight.length / 1000;
            const rRV = c.trussRiserRight.height / 1000;
            const chordType = c.trussChord;
            const style = c.trussStyle;

            // Helper: box member between two ZY points (Z = span, Y = height)
            function mbr(z1, y1, z2, y2) {
                const dz = z2 - z1, dy = y2 - y1;
                const len = Math.sqrt(dz * dz + dy * dy);
                if (len < 0.001) return;
                const geo = new THREE.BoxGeometry(tw, th, len);
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.position.set(0, (y1 + y2) / 2, (z1 + z2) / 2);
                mesh.rotation.x = -Math.atan2(dy, dz);
                g.add(mesh);
            }

            // --- Bottom Chord (standard horizontal, full span) ---
            if (chordType === 'bottom') {
                mbr(-halfW, th / 2, halfW, th / 2);
                if (extOn) {
                    mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                    mbr(halfW, th / 2, halfW + extLen, th / 2);
                }
            } else if (chordType === 'mid') {
                const midY = th + rise / 3;
                const lT = (midY - heelY) / (apexY - heelY);
                const midHalfZ = lT > 0 ? halfW * (1 - lT) : halfW;
                mbr(-midHalfZ, midY, midHalfZ, midY);
                if (extOn) {
                    mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                    mbr(halfW, th / 2, halfW + extLen, th / 2);
                }
            } else if (extOn) {
                mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                mbr(halfW, th / 2, halfW + extLen, th / 2);
            }

            // --- Rafters (symmetrical) ---
            mbr(-halfW, heelY, 0, apexY);
            mbr(halfW, heelY, 0, apexY);

            // --- Web Members ---
            function asmRafterY(x) { return th + rise * (1 - x / halfW); }
            const asmChordYm = chordType === 'mid' ? (th + rise / 3) : th;
            const asmKBottom = chordType === 'mid' ? (asmChordYm + th / 2) : th;
            const asmKTop = apexY - th;
            const asmQpX = halfW / 2;

            // Legacy style mapping for assembly view
            var asmEff = style;
            if (asmEff === 'kingfan' || asmEff === 'queenpost') asmEff = 'kingverticals';
            if (asmEff === 'kingstrut' || asmEff === 'fink' || asmEff === 'open') asmEff = 'web';

            if (asmEff === 'kingpost') {
                if (asmKTop > asmKBottom) mbr(0, asmKBottom, 0, asmKTop);

            } else if (asmEff === 'kingverticals') {
                if (asmKTop > asmKBottom) mbr(0, asmKBottom, 0, asmKTop);
                var akvChordTop = asmChordYm + th / 2;
                var akvRafterBot = asmRafterY(asmQpX) - th / 2;
                if (akvRafterBot > akvChordTop + th * 0.5) {
                    mbr(-asmQpX, akvChordTop, -asmQpX, akvRafterBot);
                    mbr(asmQpX, akvChordTop, asmQpX, akvRafterBot);
                }

            } else if (asmEff === 'web') {
                if (asmKTop > asmKBottom) mbr(0, asmKBottom, 0, asmKTop);
                var awChordTop = asmChordYm + th / 2;
                var awRafterBot = asmRafterY(asmQpX) - th / 2;
                if (awRafterBot > awChordTop + th * 0.5) {
                    mbr(0, awChordTop, -asmQpX, awRafterBot);
                    mbr(0, awChordTop, asmQpX, awRafterBot);
                }
            }

            // --- Risers (L-shaped pieces at heel ends) ---
            if (riserOn) {
                const riserType = c.riserType || 'welded';
                // Separate risers use a distinct shade; welded use same truss material
                const sepMat = new THREE.MeshLambertMaterial({color: 0x888888});
                function rmbr(z1, y1, z2, y2) {
                    const dz = z2 - z1, dy = y2 - y1;
                    const len = Math.sqrt(dz * dz + dy * dy);
                    if (len < 0.001) return;
                    const geo = new THREE.BoxGeometry(tw, th, len);
                    const m = riserType === 'separate' ? sepMat.clone() : mat.clone();
                    const mesh = new THREE.Mesh(geo, m);
                    mesh.position.set(0, (y1 + y2) / 2, (z1 + z2) / 2);
                    mesh.rotation.x = -Math.atan2(dy, dz);
                    g.add(mesh);
                }
                // Small gap for separate type to show joint line
                const gap = riserType === 'separate' ? 0.005 : 0;
                const lhz = extOn ? -halfW - extLen : -halfW;
                rmbr(lhz, th / 2 - gap, lhz, th / 2 - rLV);
                rmbr(lhz, th / 2 - rLV, lhz - rLH, th / 2 - rLV);
                const rhz = extOn ? halfW + extLen : halfW;
                rmbr(rhz, th / 2 - gap, rhz, th / 2 - rRV);
                rmbr(rhz, th / 2 - rRV, rhz + rRH, th / 2 - rRV);
            }

            return g;
        }

        function regComp(mesh, name, specs) {
            mesh.userData.selectable = true;
            compData.set(mesh.uuid, {name, specs});
        }

        function checkHover(mx, my) {
            asmRay.setFromCamera(asmMouse, asmCam);
            const all = [];
            if (steelGrp.visible) all.push(...steelGrp.children);
            if (roofGrp.visible) all.push(...roofGrp.children);
            if (accGrp.visible) all.push(...accGrp.children);
            if (houseGrp.visible) all.push(...houseGrp.children);
            const hits = asmRay.intersectObjects(all, true);
            if (hits.length > 0) {
                let obj = hits[0].object;
                while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;
                if (compData.has(obj.uuid)) {
                    // Don't override selection highlight with hover
                    if (obj === selectedObject) {
                        showTooltip(mx, my, compData.get(obj.uuid));
                        return;
                    }
                    if (hovered !== obj) { clearHover(); hovered = obj; highlight(obj); }
                    showTooltip(mx, my, compData.get(obj.uuid));
                    return;
                }
            }
            clearHover();
        }

        function highlight(mesh) {
            const hl = new THREE.Color(0xF15A29);
            if (mesh.material) { mesh.material.emissive = hl; mesh.material.emissiveIntensity = 0.3; }
            mesh.traverse(c => { if (c.material) { c.material.emissive = hl; c.material.emissiveIntensity = 0.3; }});
        }

        function clearHover() {
            if (hovered) {
                // Don't clear if this is the selected object
                if (hovered === selectedObject) { hovered = null; hideTooltip(); return; }
                if (hovered.material) { hovered.material.emissive = new THREE.Color(0); hovered.material.emissiveIntensity = 0; }
                hovered.traverse(c => { if (c.material) { c.material.emissive = new THREE.Color(0); c.material.emissiveIntensity = 0; }});
                hovered = null;
            }
            hideTooltip();
        }

        function showTooltip(x, y, data) {
            const tt = document.getElementById('tooltip');
            document.getElementById('ttTitle').textContent = data.name;
            document.getElementById('ttContent').innerHTML = Object.entries(data.specs)
                .map(([k,v]) => `<div class="tooltip-row"><span class="tooltip-label">${k}</span><span class="tooltip-value">${v}</span></div>`).join('');
            tt.style.left = (x + 15) + 'px';
            tt.style.top = (y + 15) + 'px';
            tt.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        // ==================== 3D SELECTION SYSTEM ====================
        let selectedObject = null;
        let trussSelectedObject = null;
        const originalMaterials = new Map();

        const selectHighlightColor = new THREE.Color(0x00aaff);
        const hoverHighlightColor = new THREE.Color(0xF15A29);

        function storeOriginalMaterial(obj) {
            if (!originalMaterials.has(obj.uuid) && obj.material) {
                originalMaterials.set(obj.uuid, {
                    emissive: obj.material.emissive ? obj.material.emissive.clone() : new THREE.Color(0),
                    emissiveIntensity: obj.material.emissiveIntensity || 0
                });
            }
        }

        function restoreOriginalMaterial(obj) {
            if (originalMaterials.has(obj.uuid) && obj.material) {
                const stored = originalMaterials.get(obj.uuid);
                obj.material.emissive = stored.emissive;
                obj.material.emissiveIntensity = stored.emissiveIntensity;
                originalMaterials.delete(obj.uuid);
            }
            obj.traverse(c => {
                if (originalMaterials.has(c.uuid) && c.material) {
                    const stored = originalMaterials.get(c.uuid);
                    c.material.emissive = stored.emissive;
                    c.material.emissiveIntensity = stored.emissiveIntensity;
                    originalMaterials.delete(c.uuid);
                }
            });
        }

        function applySelectHighlight(obj) {
            if (obj.material) {
                storeOriginalMaterial(obj);
                obj.material.emissive = selectHighlightColor;
                obj.material.emissiveIntensity = 0.5;
            }
            obj.traverse(c => {
                if (c.material) {
                    storeOriginalMaterial(c);
                    c.material.emissive = selectHighlightColor;
                    c.material.emissiveIntensity = 0.5;
                }
            });
        }

        // Assembly 3D click handler
        function onAsmClick(event) {
            const canvas = document.getElementById('asmCanvas');
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const ray = new THREE.Raycaster();
            ray.setFromCamera(mouse, asmCam);
            const all = [];
            if (steelGrp && steelGrp.visible) all.push(...steelGrp.children);
            if (roofGrp && roofGrp.visible) all.push(...roofGrp.children);
            if (accGrp && accGrp.visible) all.push(...accGrp.children);
            const hits = ray.intersectObjects(all, true);

            // Clear previous selection
            if (selectedObject) {
                restoreOriginalMaterial(selectedObject);
                selectedObject = null;
            }

            const panel = document.getElementById('asmPropertiesPanel');

            if (hits.length > 0) {
                let obj = hits[0].object;
                while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;
                if (compData.has(obj.uuid)) {
                    selectedObject = obj;
                    applySelectHighlight(obj);
                    const data = compData.get(obj.uuid);
                    showPropertiesPanel(panel, data.name, data.specs);
                    return;
                }
            }
            hidePropertiesPanel(panel);
        }

        // Truss 3D click handler
        function onTrussClick(event) {
            const canvas = document.getElementById('trussCanvas');
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const ray = new THREE.Raycaster();
            ray.setFromCamera(mouse, trussCam);
            const hits = ray.intersectObjects(trussGroup ? trussGroup.children : [], true);

            // Clear previous selection
            if (trussSelectedObject) {
                restoreOriginalMaterial(trussSelectedObject);
                trussSelectedObject = null;
            }

            const panel = document.getElementById('trussPropertiesPanel');

            if (hits.length > 0) {
                const obj = hits[0].object;
                if (obj.userData && obj.userData.selectable) {
                    trussSelectedObject = obj;
                    applySelectHighlight(obj);
                    showPropertiesPanel(panel, obj.userData.type || 'Component', obj.userData.specs || {});
                    return;
                }
            }
            hidePropertiesPanel(panel);
        }

        function showPropertiesPanel(panel, name, specs) {
            panel.style.display = 'block';
            let content = '';
            if (specs) {
                Object.entries(specs).forEach(([k, v]) => {
                    content += '<div><strong>' + k + ':</strong> ' + v + '</div>';
                });
            }
            panel.innerHTML =
                '<div class="props-header"><span>' + name + '</span><button onclick="hidePropertiesPanel(this.parentElement.parentElement)">Ã—</button></div>' +
                '<div class="props-content">' + (content || '<div>No details</div>') + '</div>';
        }

        function hidePropertiesPanel(panel) {
            if (panel) panel.style.display = 'none';
        }

        function toggleLayer(layer, el) {
            el.classList.toggle('active');
            const vis = el.classList.contains('active');
            if (layer === 'steel') steelGrp.visible = vis;
            if (layer === 'roof') roofGrp.visible = vis;
            if (layer === 'acc') accGrp.visible = vis;
            if (layer === 'house') houseGrp.visible = vis;
        }

        function toggleFullscreen() {
            const container = document.getElementById('asmViewport');

            function resizeRenderer() {
                setTimeout(() => {
                    if (asmRend && container) {
                        var w = container.clientWidth, h = container.clientHeight;
                        if (w > 0 && h > 0) {
                            if (asmCam) {
                                asmCam.aspect = w / h;
                                asmCam.updateProjectionMatrix();
                            }
                            if (asmOrthoCamera) {
                                var aspect = w / h;
                                var halfH = (asmOrthoCamera.top - asmOrthoCamera.bottom) / 2;
                                asmOrthoCamera.left = -halfH * aspect;
                                asmOrthoCamera.right = halfH * aspect;
                                asmOrthoCamera.updateProjectionMatrix();
                            }
                            asmRend.setSize(w, h);
                        }
                    }
                }, 100);
            }

            if (!document.fullscreenElement) {
                container.classList.add('fullscreen-mode');
                container.requestFullscreen().catch(err => {
                    // Fallback: use fixed position maximise
                    container.classList.add('fullscreen');
                });
                resizeRenderer();
            } else {
                document.exitFullscreen();
                container.classList.remove('fullscreen-mode');
                container.classList.remove('fullscreen');
                resizeRenderer();
            }
        }

        document.addEventListener('fullscreenchange', () => {
            const container = document.getElementById('asmViewport');
            if (!document.fullscreenElement) {
                container.classList.remove('fullscreen-mode');
                container.classList.remove('fullscreen');
                setTimeout(() => {
                    if (asmRend && container) {
                        var w = container.clientWidth, h = container.clientHeight;
                        if (w > 0 && h > 0) {
                            if (asmCam) {
                                asmCam.aspect = w / h;
                                asmCam.updateProjectionMatrix();
                            }
                            if (asmOrthoCamera) {
                                var aspect = w / h;
                                var halfH = (asmOrthoCamera.top - asmOrthoCamera.bottom) / 2;
                                asmOrthoCamera.left = -halfH * aspect;
                                asmOrthoCamera.right = halfH * aspect;
                                asmOrthoCamera.updateProjectionMatrix();
                            }
                            asmRend.setSize(w, h);
                        }
                    }
                }, 100);
            }
        });

        function getSheetMatEntries(numSheets, roofing) {
            const pc = hasPolycarbMatch(roofing) ? getPolycarbConfig() : null;
            var sc = calc ? calc.sheetCalc : null;
            var cutNote = sc && sc.hasPartialSheet ? ' \u2014 last sheet cut to ' + sc.partialSheetWidth + 'mm' : '';
            if (!pc) return [{d: roofingLabel(roofing) + ' Sheets' + cutNote, q: numSheets}];
            const split = getPolycarbSheetSplit(numSheets);
            const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
            const colorbondColour = sheetColor ? sheetColor.name : '';
            const pcProfileLabel = pc.profileName || 'Polycarb';
            const levelLabel = pc.level ? ' Lv' + pc.level : '';
            const entries = [];
            if (split.colorbond > 0) entries.push({d: roofingLabel(roofing) + (colorbondColour ? ' ' + colorbondColour : '') + ' Sheets', q: split.colorbond});
            if (split.polycarb > 0) entries.push({d: brandLabel + ' ' + pcProfileLabel + ' ' + pc.tint + levelLabel + ' Sheets', q: split.polycarb});
            if (cutNote) entries.push({d: 'Note: ' + sc.orderNote, q: '', isNote: true});
            return entries;
        }

        function updateMatList() {
            const c = calc;
            let mats = [];
            const sheetCover = c.sheetCoverage;

            if (c.isGable) {
                const gsc = c.sheetCalc;
                const numSheets = gsc ? gsc.totalSheets * 2 : Math.ceil(c.L / sheetCover) * 2;
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                const riserCount = c.riserQty;
                // Beam count depends on connection type
                let beamCount;
                if (c.connection === 'freestanding') {
                    beamCount = 2;  // Gutter beam + back beam
                } else if (c.connection === 'riser') {
                    beamCount = 3;  // Gutter beam + fascia beam + riser beam
                } else {
                    beamCount = 2;  // Gutter beam + fascia/back beam
                }
                const purlinCount = (c.gableBattenCalc && c.gableBattenCalc.totalBattens > 0) ? c.gableBattenCalc.totalBattens : Math.max(2, Math.ceil(c.rafter / 1000 / 0.8)) * 2;
                // Truss riser type affects material listing
                const trussRiserOn = c.trussRiserLeft.enabled;
                const trussRiserType = c.riserType || 'welded';
                const trussLabel = trussRiserOn && trussRiserType === 'welded'
                    ? 'Trusses ' + c.steel.name + ' (risers welded \u2014 ' + Math.round(c.trussRiserLeft.length) + 'H\u00D7' + Math.round(c.trussRiserLeft.height) + 'V)'
                    : 'Trusses ' + c.steel.name + (trussRiserOn ? ' (flat ends)' : '');
                mats = [
                    {d: 'Posts ' + c.framePost.label, q: postCount},
                    {d: 'Beams ' + c.frameBeam.label, q: beamCount},
                    {d: trussLabel, q: c.nTruss},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Ridge Cap', q: 1},
                    {d: 'Gable Barges', q: 4},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                if (c.infill !== 'none') mats.push({d: 'Gable Infill', q: 2});
                // Separate truss risers get their own line item
                if (trussRiserOn && trussRiserType === 'separate') {
                    mats.push({d: 'Riser Pieces ' + c.steel.name + ' (' + Math.round(c.trussRiserLeft.length) + 'H\u00D7' + Math.round(c.trussRiserLeft.height) + 'V)', q: c.nTruss, note: 'Site-installed, 1 set per truss'});
                }
                if (c.connection === 'fascia') {
                    // Direct to fascia: fascia brackets instead of riser
                    mats.push({d: 'Fascia Brackets', q: c.fasciaBracketQty});
                } else if (c.connection === 'riser') {
                    mats.push({d: 'Riser Elbows ' + c.framePost.label, q: riserCount});
                    mats.push({d: 'Riser Beam ' + c.frameBeam.label, q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                    if (c.riserGutter === 'quad') {
                        mats.push({d: 'Riser Beam Gutter 115mm Quad', q: 1});
                    }
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            } else {
                const ssc = c.sheetCalc;
                const numSheets = ssc ? ssc.totalSheets : Math.ceil(c.L / sheetCover);
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                let beamCount;
                if (c.connection === 'riser') {
                    beamCount = 3;  // gutter + fascia + riser beam
                } else if (c.isRecvChan) {
                    beamCount = 1;  // gutter beam only (channel replaces back beam)
                } else {
                    beamCount = 2;  // gutter + back/flyover beam
                }
                const riserCount = c.riserQty;
                const bc = c.battenCalc;
                const bk = c.bracketCalc;
                // Use batten calculator for purlin/batten count, fallback to old logic
                // SpanPlus/sheets that span full projection without battens: purlinCount = 0
                const effectiveW = (c.W - (c.connection === 'riser' ? c.riserOffset : 0)) / 1000;
                const purlinCount = (bc && bc.battensNeeded > 0) ? bc.battensNeeded : ((isInsulated(c.roofing) || (bc && bc.battensNeeded === 0)) ? 0 : Math.max(2, Math.ceil(effectiveW / 0.9)) + 1);
                mats = [
                    {d: 'Posts ' + c.framePost.label, q: postCount},
                    {d: 'Beams ' + c.frameBeam.label, q: beamCount},
                    {d: 'Rafters ' + (c.rafterSize ? c.rafterSize.name : c.steel.name), q: (c.rafterCalc ? c.rafterCalc.rafterCount : c.nRafters)},
                ];
                if (purlinCount > 0) {
                    mats.push({d: 'Battens 76\u00D738\u00D71.6 RHS', q: purlinCount});
                }
                if (bk && bk.bracketsNeeded > 0) {
                    var btLabel = c.bracketType === 'external' ? 'External' : 'Internal';
                    mats.push({d: 'Tubing Brackets (' + btLabel + ')', q: bk.bracketsNeeded});
                }
                mats.push(
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Barge Flashings', q: 2},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                );
                // Back flashing - skip for riser+box gutter AND receiving channel
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    mats.splice(5, 0, {d: 'Back Flashing', q: 1});
                }
                if (c.connection === 'riser') {
                    mats.splice(2, 0, {d: 'Riser Elbows ' + c.framePost.label, q: riserCount});
                    mats.splice(3, 0, {d: 'Riser Beam ' + c.frameBeam.label, q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                }
                if (c.connection === 'flyover') {
                    const strutCount = Math.max(2, Math.ceil(c.L / 1200));
                    mats.push({d: 'Flyover Struts ' + c.framePost.label, q: strutCount});
                    mats.push({d: 'Flyover Beam 150Ã—50Ã—2', q: 1});
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                    mats.push({d: 'Foam Backfill Strips (' + c.roofing + ')', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            }

            // Group materials by build sequence
            const groups = [
                { id: 'cfg-structure',  num: '1', name: 'Structure',  items: [] },
                { id: 'cfg-roofing',    num: '2', name: 'Roofing',    items: [] },
                { id: 'cfg-drainage',   num: '3', name: 'Drainage',   items: [] },
                { id: 'cfg-finishing',   num: '4', name: 'Finishing',  items: [] },
                { id: 'cfg-fixings',    num: '5', name: 'Fixings',    items: [] }
            ];

            mats.forEach(function(m) {
                const d = m.d.toLowerCase();
                if (d.includes('post') || d.includes('beam') ||
                    d.includes('purlin') || d.includes('truss') || d.includes('rafter') ||
                    d.includes('riser elbow') || d.includes('strut') ||
                    d.includes('batten') || d.includes('bracket') || d.includes('fascia bracket')) {
                    groups[0].items.push(m);
                } else if (d.includes('sheet') || d.includes('solarspan') || d.includes('trimdek') ||
                           d.includes('corrugated') || d.includes('spanplus') || d.includes('ridge cap') ||
                           d.includes('polycarb')) {
                    groups[1].items.push(m);
                } else if (d.includes('gutter') || d.includes('downpipe') || d.includes('box gutter')) {
                    groups[2].items.push(m);
                } else if (d.includes('barge') || d.includes('infill') || d.includes('flashing') ||
                           d.includes('fascia') || d.includes('channel') || d.includes('foam')) {
                    groups[3].items.push(m);
                } else {
                    groups[4].items.push(m);
                }
            });

            // Helpers to extract size, display name, length, colour for each material
            function matSize(desc) {
                var d = desc.toLowerCase();
                if (d.includes('65Ã—65'))    return '65Ã—65Ã—2 SHS';
                if (d.includes('75Ã—75'))    return '75Ã—75Ã—2 SHS';
                if (d.includes('90Ã—90'))    return '90Ã—90Ã—2 SHS';
                if (d.includes('100Ã—100'))  return '100Ã—100Ã—2 SHS';
                if (d.includes('125Ã—125'))  return '125Ã—125Ã—3 SHS';
                if (d.includes('150Ã—150'))  return '150Ã—150Ã—3 SHS';
                if (d.includes('c200'))     return 'C200 Purlin';
                if (d.includes('c150'))     return 'C150 Purlin';
                if (d.includes('150Ã—50'))   return '150Ã—50Ã—2 RHS';
                if (d.includes('125Ã—50'))   return '125Ã—50Ã—2 RHS';
                if (d.includes('100Ã—50'))   return '100Ã—50Ã—2 RHS';
                if (d.includes('75Ã—50'))    return '75Ã—50Ã—2 RHS';
                if (d.includes('76Ã—38'))    return '76Ã—38Ã—1.6 RHS';
                if (d.includes('solarspan'))return 'Insulated Panel';
                if (d.includes('trimdek'))  return 'Trimdek';
                if (d.includes('corrugated'))return 'Corrugated';
                if (d.includes('spanplus')) return 'SpanPlus 330';
                if (d.includes('115mm'))    return '115mm Quad';
                return '\u2014';
            }
            function matName(desc) {
                var d = desc.toLowerCase();
                if (d.includes('post'))         return 'Posts';
                if (d.includes('riser beam gutter')) return 'Riser Beam Gutter';
                if (d.includes('riser beam'))   return 'Riser Beam';
                if (d.includes('riser elbow'))  return 'Riser Elbows';
                if (d.includes('flyover beam')) return 'Flyover Beam';
                if (d.includes('flyover strut'))return 'Flyover Struts';
                if (d.includes('beam'))         return 'Beams';
                if (d.includes('truss'))        return 'Trusses';
                if (d.includes('rafter'))       return 'Rafters';
                if (d.includes('batten'))       return 'Battens';
                if (d.includes('tubing bracket')) return 'Tubing Brackets';
                if (d.includes('purlin'))       return 'Purlins';
                if (d.includes('ridge cap'))    return 'Ridge Cap';
                if (d.includes('downpipe'))     return 'Downpipes';
                if (d.includes('box gutter'))   return 'Box Gutter';
                if (d.includes('gutter'))       return 'Gutter';
                if (d.includes('barge'))        return 'Barge Flashings';
                if (d.includes('back flashing'))return 'Back Flashing';
                if (d.includes('infill'))       return 'Gable Infill';
                if (d.includes('fascia bracket')) return 'Fascia Brackets';
                if (d.includes('fascia board')) return 'House Fascia Board';
                if (d.includes('channel'))      return 'Receiving Channel';
                if (d.includes('foam'))         return 'Foam Backfill';
                if (d.includes('polycarb'))     return 'Polycarb Sheets';
                if (d.includes('sheet'))        return 'Sheets';
                return desc;
            }
            function matLen(desc) {
                var len = getItemLength(desc);
                if (len <= 0) return '\u2014';
                // Show nesting info for steel items
                if (isSteelItem(desc)) {
                    var dLow = desc.toLowerCase();
                    var plan = c.steelNestingPlan || [];
                    var entry = null;
                    if (dLow.includes('post')) entry = plan.find(function(p){return p.label==='Posts';});
                    else if (dLow.includes('flyover beam')) entry = plan.find(function(p){return p.label==='Flyover Beam';});
                    else if (dLow.includes('flyover strut')) entry = plan.find(function(p){return p.label==='Flyover Struts';});
                    else if (dLow.includes('riser beam')) entry = plan.find(function(p){return p.label==='Riser Beam';});
                    else if (dLow.includes('riser elbow')) entry = plan.find(function(p){return p.label==='Riser Elbows';});
                    else if (dLow.includes('beam')) entry = plan.find(function(p){return p.label==='Beams';});
                    else if (dLow.includes('truss')) entry = plan.find(function(p){return p.label==='Trusses';});
                    else if (dLow.includes('rafter')) entry = plan.find(function(p){return p.label==='Rafters';});
                    else if (dLow.includes('batten') || dLow.includes('purlin')) entry = plan.find(function(p){return p.label==='Battens'||p.label==='Purlins';});

                    if (entry && entry.nesting) {
                        var n = entry.nesting;
                        if (n.specialOrder) {
                            return entry.cutMm + 'mm cut<br><span style="font-size:9px;color:#c00;font-weight:600">REQUIRES SPECIAL ORDER</span>';
                        }
                        var stockM = (n.stockLength / 1000).toFixed(1);
                        var line1 = entry.cutMm + 'mm cut';
                        var line2 = '<span style="font-size:9px;color:var(--sw-text-sec)">\u2192 ' + n.totalSticks + '\u00D7 ' + stockM + 'm sticks';
                        if (n.piecesPerStick > 1) line2 += ' (' + n.piecesPerStick + '/stick)';
                        line2 += '</span>';
                        return line1 + '<br>' + line2;
                    }
                }
                return len.toFixed(1) + 'm';
            }
            function matColour(desc) {
                var d = desc.toLowerCase();
                if (d.includes('post') || d.includes('beam') || d.includes('purlin') ||
                    d.includes('batten') || d.includes('bracket') ||
                    d.includes('truss') || d.includes('rafter') || d.includes('strut') ||
                    d.includes('75Ã—75') || d.includes('barge') || d.includes('gutter') ||
                    d.includes('downpipe') || d.includes('ridge') || d.includes('flashing') ||
                    d.includes('channel')) return steelColor.name;
                if (d.includes('polycarb')) return '\u2014';
                if (d.includes('sheet') || d.includes('infill')) return sheetColor.name;
                return '\u2014';
            }

            var hdrRow = '<div class="mat-hdr"><span>Item</span><span style="text-align:right">Qty</span><span>Size</span><span style="text-align:right">Length</span><span>Colour</span></div>';

            let html = '';
            groups.forEach(function(g, idx) {
                const isOpen = idx === 0;
                var rows = '';
                if (g.items.length > 0) {
                    rows = hdrRow + g.items.map(function(m) {
                        return '<div class="mat-row" data-desc="' + m.d.replace(/"/g, '&quot;') + '">' +
                            '<span>' + matName(m.d) + '</span>' +
                            '<span class="mat-qty">' + m.q + 'Ã—</span>' +
                            '<span class="mat-size">' + matSize(m.d) + '</span>' +
                            '<span class="mat-len">' + matLen(m.d) + '</span>' +
                            '<span class="mat-clr">' + matColour(m.d) + '</span>' +
                            '</div>';
                    }).join('');
                }
                const body = g.items.length > 0 ? rows : '<div class="cfg-group-empty">No items in this category</div>';
                html += '<div class="cfg-group">' +
                    '<div class="cfg-group-hdr" onclick="toggleCfgGroup(\'' + g.id + '\')">' +
                        '<span class="cfg-group-arrow' + (isOpen ? ' open' : '') + '" id="' + g.id + '-arrow">&#9654;</span>' +
                        '<span class="cfg-group-num">' + g.num + '.</span> ' + g.name +
                    '</div>' +
                    '<div class="cfg-group-body' + (isOpen ? ' open' : '') + '" id="' + g.id + '-body">' + body + '</div>' +
                '</div>';
            });

            // Steel Order Summary
            var nestPlan = c.steelNestingPlan || [];
            if (nestPlan.length > 0) {
                var soHtml = '<div class="cfg-group">' +
                    '<div class="cfg-group-hdr" onclick="toggleCfgGroup(\'cfg-steelorder\')">' +
                        '<span class="cfg-group-arrow" id="cfg-steelorder-arrow">&#9654;</span>' +
                        '<span class="cfg-group-num">\u2692</span> Steel Order Summary' +
                    '</div>' +
                    '<div class="cfg-group-body" id="cfg-steelorder-body">' +
                    '<div style="padding:8px 14px">';
                // Table header
                soHtml += '<div style="display:grid;grid-template-columns:100px 1fr 70px 90px;gap:4px;font-size:10px;font-weight:600;color:var(--sw-text-sec);border-bottom:1px solid var(--sw-border);padding-bottom:4px;margin-bottom:4px">' +
                    '<span>Item</span><span>Nesting</span><span style="text-align:right">Order</span><span style="text-align:right">Cost</span></div>';
                var totalSticks = 0, totalCost = 0;
                nestPlan.forEach(function(p) {
                    var n = p.nesting;
                    var rate = STEEL_RATES[p.sizeKey] || 0;
                    var stickCost = 0;
                    if (n.specialOrder) {
                        stickCost = (p.cutMm / 1000) * rate * p.qty;
                    } else {
                        n.sticks.forEach(function(st) { stickCost += (st.stockLength / 1000) * rate; });
                    }
                    totalCost += stickCost;
                    totalSticks += n.totalSticks;
                    var nestDesc = '';
                    if (n.specialOrder) {
                        nestDesc = '<span style="color:#c00;font-weight:600">SPECIAL ORDER &gt;' + (Math.max.apply(null, getStockLengthsForSize(p.sizeKey)) / 1000).toFixed(1) + 'm</span>';
                    } else if (n.piecesPerStick > 1) {
                        nestDesc = p.qty + '\u00D7 ' + p.cutMm + 'mm \u2192 ' + n.totalSticks + '\u00D7 ' + (n.stockLength / 1000).toFixed(1) + 'm (' + n.piecesPerStick + ' pcs/stick, ' + Math.round(n.totalWaste) + 'mm waste)';
                    } else {
                        nestDesc = p.qty + '\u00D7 ' + p.cutMm + 'mm \u2192 ' + n.totalSticks + '\u00D7 ' + (n.stockLength / 1000).toFixed(1) + 'm (' + Math.round(n.totalWaste) + 'mm waste)';
                    }
                    var orderStr = n.totalSticks + '\u00D7 ' + (n.specialOrder ? 'SPL' : (n.stockLength / 1000).toFixed(1) + 'm');
                    soHtml += '<div style="display:grid;grid-template-columns:100px 1fr 70px 90px;gap:4px;font-size:11px;padding:3px 0;border-bottom:1px solid #f5f5f5;align-items:baseline">' +
                        '<span style="font-weight:600">' + p.label + '</span>' +
                        '<span style="font-size:10px;color:var(--sw-text-sec)">' + nestDesc + '</span>' +
                        '<span style="text-align:right;font-family:\'SF Mono\',monospace;font-size:10px">' + orderStr + '</span>' +
                        '<span style="text-align:right;font-family:\'SF Mono\',monospace;font-size:10px">$' + stickCost.toFixed(0) + ' (' + p.sizeName + ')</span>' +
                        '</div>';
                });
                // Totals
                soHtml += '<div style="display:grid;grid-template-columns:100px 1fr 70px 90px;gap:4px;font-size:11px;padding:6px 0 2px;border-top:2px solid var(--sw-border);font-weight:700">' +
                    '<span>TOTAL</span><span></span>' +
                    '<span style="text-align:right">' + totalSticks + ' sticks</span>' +
                    '<span style="text-align:right;font-family:\'SF Mono\',monospace">$' + totalCost.toFixed(0) + '</span></div>';
                soHtml += '</div></div></div>';
                html += soHtml;
            }

            document.getElementById('matList').innerHTML = html;

            // Pre-order validation checks
            var checks = [];

            // 1. Sheet coverage check
            var totalSheets = 0;
            mats.forEach(function(m) {
                if (m.d.toLowerCase().includes('sheet')) totalSheets += m.q;
            });
            // For gable, sheets cover one side; coverage = sheets/2 * coverWidth vs L
            var coverageMm, requiredMm;
            if (c.isGable) {
                coverageMm = Math.floor(totalSheets / 2) * sheetCover;
                requiredMm = c.L;
            } else {
                coverageMm = totalSheets * sheetCover;
                requiredMm = c.L;
            }
            if (coverageMm < requiredMm) {
                var shortBy = requiredMm - coverageMm;
                checks.push({ ok: false, text: 'May be short by ' + Math.round(shortBy) + 'mm \u2014 check sheet count' });
            } else {
                checks.push({ ok: true, text: 'Sheet coverage OK' });
            }

            // 2. Gutter overhang check
            var sheetLenMm = c.isGable ? c.rafter : c.rafter;
            var projMm = c.W;
            var overhangNeeded = projMm + 50;
            if (sheetLenMm < overhangNeeded) {
                checks.push({ ok: false, text: 'Add 50mm for gutter overhang' });
            } else {
                checks.push({ ok: true, text: 'Gutter overhang OK' });
            }

            // 3. Downpipe count
            var dpCount = 0;
            mats.forEach(function(m) {
                if (m.d.toLowerCase().includes('downpipe')) dpCount += m.q;
            });
            var widthMm = c.L;
            if (widthMm > 12000 && dpCount < 2) {
                checks.push({ ok: false, text: 'Consider 2 downpipes for 12m+ gutter' });
            } else {
                checks.push({ ok: true, text: 'Downpipe count OK' });
            }

            var checksHtml = '<div class="preorder-box"><div class="preorder-title">Pre-Order Checks</div>';
            checks.forEach(function(ch) {
                if (ch.ok) {
                    checksHtml += '<div class="preorder-item preorder-ok">\u2713 ' + ch.text + '</div>';
                } else {
                    checksHtml += '<div class="preorder-item preorder-warn">\u26A0\uFE0F ' + ch.text + '</div>';
                }
            });
            checksHtml += '</div>';
            document.getElementById('preOrderChecks').innerHTML = checksHtml;
        }

        function toggleCfgGroup(id) {
            var body = document.getElementById(id + '-body');
            var arrow = document.getElementById(id + '-arrow');
            body.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        function getActiveAsmCamera() {
            return (asmCurrentView !== '3d' && asmOrthoCamera) ? asmOrthoCamera : asmCam;
        }

        function animateAsm() {
            requestAnimationFrame(animateAsm);
            if (asmControls) asmControls.update();
            var cam = getActiveAsmCamera();
            if (asmRend && asmScene && cam) {
                asmRend.render(asmScene, cam);
            }
        }

        // ==================== DIMENSION DISPLAY SYSTEM ====================

        function createDimSprite(text) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            ctx.font = 'bold 28px Arial, sans-serif';
            var tw = ctx.measureText(text).width;
            canvas.width = Math.ceil(tw + 16);
            canvas.height = 36;
            ctx.font = 'bold 28px Arial, sans-serif';
            // Background pill
            ctx.fillStyle = 'rgba(255,255,255,0.92)';
            ctx.strokeStyle = '#bbb';
            ctx.lineWidth = 1.5;
            var r = 6;
            var w = canvas.width, h = canvas.height;
            ctx.beginPath();
            ctx.moveTo(r, 0); ctx.lineTo(w - r, 0); ctx.quadraticCurveTo(w, 0, w, r);
            ctx.lineTo(w, h - r); ctx.quadraticCurveTo(w, h, w - r, h);
            ctx.lineTo(r, h); ctx.quadraticCurveTo(0, h, 0, h - r);
            ctx.lineTo(0, r); ctx.quadraticCurveTo(0, 0, r, 0);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            // Text
            ctx.fillStyle = '#1a365d';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, w / 2, h / 2);

            var tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            var spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false });
            var sprite = new THREE.Sprite(spriteMat);
            var scale = 0.004; // world units per pixel
            sprite.scale.set(canvas.width * scale, canvas.height * scale, 1);
            return sprite;
        }

        function createDimensionLine(start, end, offset, labelText) {
            var group = new THREE.Group();
            var dir = new THREE.Vector3().subVectors(end, start);
            var len = dir.length();
            if (len < 0.01) return group;
            dir.normalize();

            // Perpendicular offset direction (in XZ plane for horizontal, in XY for vertical)
            var perp;
            if (Math.abs(dir.y) > 0.9) {
                // Vertical line - offset in X or Z
                perp = new THREE.Vector3(offset > 0 ? 1 : -1, 0, 0).multiplyScalar(Math.abs(offset));
            } else {
                perp = new THREE.Vector3(-dir.z, 0, dir.x).normalize().multiplyScalar(offset);
            }

            var s = start.clone().add(perp);
            var e = end.clone().add(perp);

            var lineMat = new THREE.LineBasicMaterial({ color: 0x1a365d, depthTest: false });

            // Main dimension line
            var mainGeo = new THREE.BufferGeometry().setFromPoints([s, e]);
            group.add(new THREE.Line(mainGeo, lineMat));

            // Extension lines
            var ext1Geo = new THREE.BufferGeometry().setFromPoints([start, s]);
            var ext2Geo = new THREE.BufferGeometry().setFromPoints([end, e]);
            group.add(new THREE.Line(ext1Geo, lineMat));
            group.add(new THREE.Line(ext2Geo, lineMat));

            // Tick marks at ends (small perpendicular ticks)
            var tickSize = 0.04;
            var tickPerp = dir.clone().multiplyScalar(tickSize);
            var t1a = s.clone().sub(tickPerp), t1b = s.clone().add(tickPerp);
            var t2a = e.clone().sub(tickPerp), t2b = e.clone().add(tickPerp);
            group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([t1a, t1b]), lineMat));
            group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([t2a, t2b]), lineMat));

            // Label sprite at midpoint
            var mid = s.clone().add(e).multiplyScalar(0.5);
            var label = createDimSprite(labelText);
            label.position.copy(mid);
            group.add(label);

            group.renderOrder = 999;
            return group;
        }

        function updateAsmDimensions() {
            if (!dimensionGroup || !calc || !calc.W) return;
            // Clear existing
            while (dimensionGroup.children.length > 0) {
                var child = dimensionGroup.children[0];
                dimensionGroup.remove(child);
                if (child.traverse) child.traverse(function(o) {
                    if (o.geometry) o.geometry.dispose();
                    if (o.material) { if (o.material.map) o.material.map.dispose(); o.material.dispose(); }
                });
            }

            var c = calc;
            var W = c.W / 1000;    // projection (depth)
            var L = c.L / 1000;    // length
            var postH = c.frontBeamY / 1000;
            var backH = c.backBeamY / 1000;
            var fasciaH = c.fasciaBeamY ? c.fasciaBeamY / 1000 : null;
            var rise = c.rise / 1000;
            var pitch = c.pitch;
            var riserH = c.riserH / 1000;
            var riserOffset = c.riserOffset / 1000;
            var isPerpendicular = c.isGable && c.orientation === 'perpendicular';

            var off = 0.3; // offset for dimension lines

            // ===== OVERALL DIMENSIONS =====

            if (isPerpendicular) {
                // Length along front (Z axis)
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(W / 2, 0, -L / 2),
                    new THREE.Vector3(W / 2, 0, L / 2),
                    off,
                    Math.round(c.L) + 'mm'
                ));
                // Projection depth (X axis)
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(-W / 2, 0, L / 2 + off),
                    new THREE.Vector3(W / 2, 0, L / 2 + off),
                    off,
                    Math.round(c.W) + 'mm'
                ));
            } else {
                // Length along front (X axis)
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(-L / 2, 0, W / 2),
                    new THREE.Vector3(L / 2, 0, W / 2),
                    off,
                    Math.round(c.L) + 'mm'
                ));
                // Projection depth (Z axis)
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(L / 2 + off, 0, 0),
                    new THREE.Vector3(L / 2 + off, 0, W / 2),
                    off,
                    Math.round(c.W) + 'mm'
                ));
            }

            // Post height (front right post)
            var phX = isPerpendicular ? W / 2 : L / 2;
            var phZ = isPerpendicular ? L / 2 : W / 2;
            dimensionGroup.add(createDimensionLine(
                new THREE.Vector3(phX, 0, phZ),
                new THREE.Vector3(phX, postH, phZ),
                off,
                Math.round(c.frontBeamY) + 'mm'
            ));

            // Back/fascia height (if different from front)
            if (fasciaH && Math.abs(fasciaH - postH) > 0.05) {
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(isPerpendicular ? -W / 2 : -L / 2, 0, isPerpendicular ? 0 : 0),
                    new THREE.Vector3(isPerpendicular ? -W / 2 : -L / 2, fasciaH, isPerpendicular ? 0 : 0),
                    -off,
                    Math.round(c.fasciaBeamY) + 'mm'
                ));
            }

            // Ridge height (for gable)
            if (c.isGable && rise > 0.05) {
                var ridgeY = postH + rise;
                var ridgeLabel = createDimSprite(Math.round(ridgeY * 1000) + 'mm');
                ridgeLabel.position.set(isPerpendicular ? 0 : 0, ridgeY + 0.15, isPerpendicular ? 0 : W / 4);
                dimensionGroup.add(ridgeLabel);
            }

            // ===== SPACING DIMENSIONS =====

            // Post-to-post spacing along front
            if (c.nPosts > 1) {
                var spacing = L / (c.nPosts - 1);
                var sp0X = isPerpendicular ? W / 2 : -L / 2;
                var sp0Z = isPerpendicular ? -L / 2 : W / 2;
                var sp1X = isPerpendicular ? W / 2 : -L / 2 + spacing;
                var sp1Z = isPerpendicular ? -L / 2 + spacing : W / 2;
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(sp0X, -0.1, sp0Z),
                    new THREE.Vector3(sp1X, -0.1, sp1Z),
                    off * 2,
                    Math.round(c.postSpacing) + 'mm'
                ));
            }

            // ===== ROOF DIMENSIONS =====

            // Pitch angle label
            if (pitch > 0.5) {
                var pitchLabel = createDimSprite(pitch.toFixed(1) + '\u00B0');
                if (isPerpendicular) {
                    pitchLabel.position.set(W / 4, postH + rise * 0.3, 0);
                } else {
                    pitchLabel.position.set(0, (postH + backH) / 2 + 0.15, W / 4);
                }
                dimensionGroup.add(pitchLabel);
            }

            // Riser height (if applicable)
            if (c.connection === 'riser' && riserH > 0.05) {
                var rLabel = createDimSprite(Math.round(c.riserH) + 'mm riser');
                rLabel.position.set(0, backH - riserH / 2, isPerpendicular ? 0 : -0.1);
                dimensionGroup.add(rLabel);
            }
        }

        function toggleAsmDimensions() {
            dimensionsVisible = !dimensionsVisible;
            if (dimensionGroup) dimensionGroup.visible = dimensionsVisible;
            var btn = document.getElementById('dimToggleBtn');
            if (btn) btn.classList.toggle('active', dimensionsVisible);
            if (dimensionsVisible) updateAsmDimensions();
        }

        // ==================== ORTHOGRAPHIC CAMERA & PRESET VIEWS ====================

        function setAsmView(v, btn) {
            document.querySelectorAll('.view-panel .view-btn').forEach(function(b) { b.classList.remove('active'); });
            if (btn) btn.classList.add('active');

            var container = document.getElementById('asmViewport');
            var w = container ? container.clientWidth : 600;
            var h = container ? container.clientHeight : 400;
            var aspect = w / h;

            // Compute scene center and distance
            var box = new THREE.Box3();
            if (steelGrp && steelGrp.children.length) box.expandByObject(steelGrp);
            if (roofGrp && roofGrp.children.length) box.expandByObject(roofGrp);
            var center = new THREE.Vector3();
            var size = new THREE.Vector3();
            box.getCenter(center);
            box.getSize(size);
            if (size.length() === 0) { size.set(6, 3, 4); center.set(0, 1.5, 0); }
            var maxDim = Math.max(size.x, size.y, size.z);

            asmCurrentView = v;

            if (v === '3d') {
                // Switch to perspective camera
                if (asmControls.object !== asmCam) {
                    asmControls.object = asmCam;
                }
                asmCam.aspect = aspect;
                asmCam.updateProjectionMatrix();
                asmControls.enableRotate = true;

                var d = maxDim * 1.5;
                asmCam.position.set(center.x + d * 0.55, center.y + d * 0.4, center.z + d * 0.7);
                asmControls.target.copy(center);
                asmControls.update();
            } else {
                // Switch to orthographic camera for elevation views
                var frustum = maxDim * 1.2;
                asmOrthoCamera.left = frustum * aspect / -2;
                asmOrthoCamera.right = frustum * aspect / 2;
                asmOrthoCamera.top = frustum / 2;
                asmOrthoCamera.bottom = frustum / -2;
                asmOrthoCamera.zoom = 1;
                asmOrthoCamera.updateProjectionMatrix();

                if (asmControls.object !== asmOrthoCamera) {
                    asmControls.object = asmOrthoCamera;
                }
                asmControls.enableRotate = false; // Pan only in ortho views

                if (v === 'front') {
                    asmOrthoCamera.position.set(center.x, center.y, center.z + maxDim * 2);
                    asmControls.target.copy(center);
                } else if (v === 'side') {
                    asmOrthoCamera.position.set(center.x + maxDim * 2, center.y, center.z);
                    asmControls.target.copy(center);
                } else if (v === 'top') {
                    asmOrthoCamera.position.set(center.x, center.y + maxDim * 2, center.z + 0.01);
                    asmControls.target.copy(center);
                }

                asmOrthoCamera.lookAt(asmControls.target);
                asmOrthoCamera.updateProjectionMatrix();
                asmControls.update();
            }

            // Update dimensions if visible
            if (dimensionsVisible) updateAsmDimensions();
        }

        // ==================== SECTION CUT VIEWS ====================

        function handleAsmSectionChange(val) {
            if (!val) {
                clearAsmSectionView();
                return;
            }
            setAsmSectionView(val);
        }

        function setAsmSectionView(sectionName) {
            if (!asmRend || !asmScene) return;
            asmCurrentSection = sectionName;

            var box = new THREE.Box3();
            if (steelGrp && steelGrp.children.length) box.expandByObject(steelGrp);
            if (roofGrp && roofGrp.children.length) box.expandByObject(roofGrp);
            var center = new THREE.Vector3();
            var size = new THREE.Vector3();
            box.getCenter(center);
            box.getSize(size);
            if (size.length() === 0) { size.set(6, 3, 4); center.set(0, 1.5, 0); }

            // Enable clipping
            asmRend.localClippingEnabled = true;

            var plane, camPos, camTarget, visLayers;

            if (sectionName === 'riser') {
                plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), center.z * 0.3);
                camPos = new THREE.Vector3(center.x - size.x * 1.5, center.y + size.y * 0.3, center.z);
                camTarget = center.clone();
                visLayers = { steel: true, roof: false, acc: false, house: true };
            } else if (sectionName === 'post') {
                plane = new THREE.Plane(new THREE.Vector3(-1, 0, 0), center.x + size.x * 0.3);
                camPos = new THREE.Vector3(center.x + size.x * 1.5, center.y, center.z + size.z * 0.5);
                camTarget = new THREE.Vector3(center.x, center.y, center.z + size.z * 0.3);
                visLayers = { steel: true, roof: false, acc: false, house: false };
            } else if (sectionName === 'gutter') {
                plane = new THREE.Plane(new THREE.Vector3(0, 0, -1), -(center.z + size.z * 0.3));
                camPos = new THREE.Vector3(center.x, center.y + size.y * 0.5, center.z + size.z * 1.5);
                camTarget = new THREE.Vector3(center.x, center.y + size.y * 0.2, center.z + size.z * 0.3);
                visLayers = { steel: true, roof: true, acc: true, house: false };
            } else if (sectionName === 'ridge') {
                plane = new THREE.Plane(new THREE.Vector3(1, 0, 0), -center.x);
                camPos = new THREE.Vector3(center.x - size.x * 1.5, center.y + size.y * 0.5, center.z);
                camTarget = new THREE.Vector3(center.x, center.y + size.y * 0.3, center.z);
                visLayers = { steel: true, roof: true, acc: false, house: false };
            } else {
                clearAsmSectionView();
                return;
            }

            asmClippingPlane = plane;

            // Apply clipping plane to all meshes
            asmScene.traverse(function(obj) {
                if (obj.isMesh && obj.material) {
                    var mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                    mats.forEach(function(m) {
                        m.clippingPlanes = [plane];
                        m.clipShadows = true;
                        m.needsUpdate = true;
                    });
                }
            });

            // Set layer visibility
            if (steelGrp) steelGrp.visible = visLayers.steel;
            if (roofGrp) roofGrp.visible = visLayers.roof;
            if (accGrp) accGrp.visible = visLayers.acc;
            if (houseGrp) houseGrp.visible = visLayers.house;

            // Update layer panel UI to reflect
            document.querySelectorAll('.layer-item').forEach(function(el) {
                var layer = el.getAttribute('data-layer');
                var vis = visLayers[layer] !== undefined ? visLayers[layer] : true;
                el.classList.toggle('active', vis);
            });

            // Move camera to section view
            asmCam.position.copy(camPos);
            asmControls.target.copy(camTarget);
            asmCam.lookAt(camTarget);
            asmControls.update();
            asmCurrentView = '3d'; // Use perspective for section views
            if (asmControls.object !== asmCam) asmControls.object = asmCam;
            asmControls.enableRotate = true;

            document.querySelectorAll('.view-panel .view-btn').forEach(function(b) { b.classList.remove('active'); });
        }

        function clearAsmSectionView() {
            asmCurrentSection = '';
            asmClippingPlane = null;
            if (asmRend) asmRend.localClippingEnabled = false;

            // Remove clipping planes from all meshes
            if (asmScene) {
                asmScene.traverse(function(obj) {
                    if (obj.isMesh && obj.material) {
                        var mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                        mats.forEach(function(m) {
                            m.clippingPlanes = [];
                            m.needsUpdate = true;
                        });
                    }
                });
            }

            // Restore all layers visible
            if (steelGrp) steelGrp.visible = true;
            if (roofGrp) roofGrp.visible = true;
            if (accGrp) accGrp.visible = true;
            if (houseGrp) houseGrp.visible = true;
            document.querySelectorAll('.layer-item').forEach(function(el) { el.classList.add('active'); });

            // Reset dropdown
            var sel = document.getElementById('asmSectionSelect');
            if (sel) sel.value = '';

            // Reset to 3D view
            setAsmView('3d');
        }

        // ==================== EXPORT VIEWS FOR WORK ORDER ====================

        async function exportWorkOrderViews() {
            if (!asmRend || !asmScene || !asmCam || !asmControls) { alert('3D viewer not ready'); return; }

            var exports = {};
            // Save current state
            var origPos = asmCam.position.clone();
            var origTarget = asmControls.target.clone();
            var origOrthoPos = asmOrthoCamera ? asmOrthoCamera.position.clone() : null;
            var origDims = dimensionsVisible;
            var origView = asmCurrentView;
            var origSection = asmCurrentSection;

            // Enable dimensions
            if (!dimensionsVisible) toggleAsmDimensions();

            // Ensure high res
            var container = document.getElementById('asmViewport');
            var origW = asmRend.domElement.width;
            var origH = asmRend.domElement.height;

            function waitFrame() {
                return new Promise(function(resolve) {
                    requestAnimationFrame(function() { requestAnimationFrame(resolve); });
                });
            }

            function captureCurrentView() {
                var cam = getActiveAsmCamera();
                asmRend.render(asmScene, cam);
                return asmRend.domElement.toDataURL('image/png');
            }

            // Set white background for work order (saves ink, better readability)
            var origBackground = asmScene.background ? asmScene.background.clone() : null;
            asmScene.background = new THREE.Color(0xFFFFFF);

            try {
                // 1. Hero shot (3D perspective)
                setAsmView('3d');
                await waitFrame();
                exports.hero = captureCurrentView();

                // 2. Front elevation
                setAsmView('front');
                await waitFrame();
                exports.frontElevation = captureCurrentView();

                // 3. Side elevation
                setAsmView('side');
                await waitFrame();
                exports.sideElevation = captureCurrentView();

                // 4. Top/site plan
                setAsmView('top');
                await waitFrame();
                exports.sitePlan = captureCurrentView();

                // 5. Section details
                setAsmSectionView('riser');
                await waitFrame();
                exports.riserDetail = captureCurrentView();
                clearAsmSectionView();

                setAsmSectionView('post');
                await waitFrame();
                exports.postDetail = captureCurrentView();
                clearAsmSectionView();

                setAsmSectionView('gutter');
                await waitFrame();
                exports.gutterDetail = captureCurrentView();
                clearAsmSectionView();

                if (calc && calc.isGable) {
                    setAsmSectionView('ridge');
                    await waitFrame();
                    exports.ridgeDetail = captureCurrentView();
                    clearAsmSectionView();
                }
            } catch (err) {
                console.error('Export views error:', err);
            }

            // Restore state
            asmScene.background = origBackground || new THREE.Color(0x87CEEB);
            asmCam.position.copy(origPos);
            asmControls.target.copy(origTarget);
            if (origOrthoPos && asmOrthoCamera) asmOrthoCamera.position.copy(origOrthoPos);
            asmControls.update();
            if (origView !== '3d') {
                setAsmView(origView);
            } else {
                setAsmView('3d');
            }
            if (origSection) setAsmSectionView(origSection);
            if (!origDims && dimensionsVisible) toggleAsmDimensions();

            // Store exports globally for work order PDF
            window._workOrderViews = exports;
            showToast('Exported ' + Object.keys(exports).length + ' views for work order');
            return exports;
        }

        // ==================== PRICING ====================
        const DEFAULT_RATES = {
            // Steel ($/LM)
            '65Ã—65Ã—2 SHS':     22.00,
            '75Ã—75Ã—2 SHS':     28.00,
            '90Ã—90Ã—2 SHS':     35.50,
            '100Ã—100Ã—2 SHS':   42.00,
            '125Ã—125Ã—3 SHS':   58.00,
            '150Ã—150Ã—3 SHS':   72.00,
            '76Ã—38Ã—1.6 RHS':   15.50,
            '75Ã—50Ã—2 RHS':     26.00,
            '100Ã—50Ã—2 RHS':    30.00,
            '125Ã—50Ã—2 RHS':    34.00,
            '150Ã—50Ã—2 RHS':    39.05,
            '150Ã—50Ã—3 RHS':    50.00,
            'C150 Purlin':     28.00,
            'C200 Purlin':     35.00,
            // Roofing ($/LM)
            'Solarspan 75mm':  110.00,
            'Corrugated Colorbond': 12.04,
            'Trimdek Colorbond':   14.00,
            'Spandek Colorbond':   14.50,
            'Ampelite Solasafe 5-Rib': 25.00,
            'Ampelite Solasafe Corrugated': 23.00,
            'Laserlite 2000 5-Rib':    27.00,
            // Flashings ($/LM)
            'Ridge Cap':       15.00,
            'Barge Flashing':  12.00,
            'Back Flashing':   14.00,
            'Gutter Flashing': 10.00,
            // Gutters & Drainage ($/LM)
            'Quad Gutter 115mm': 18.00,
            'Box Gutter':      45.00,
            'Downpipe 90mm':   12.00,
            // Extras
            'Gable Infill (sqm)': 45.00,
            'Riser 76Ã—38 (ea)':  50.00,
            'Riser 75Ã—50 (ea)':  55.00,
            'Riser 100Ã—50 (ea)': 60.00,
            'Riser Bracket (ea)': 12.00,
            'Tubing Bracket (ea)': 2.50,
            'Fixings ($/sqm)': 2.50,
            'Foam Strip':      3.00,
            // Labour ($/day)
            'Skilled Trade':   400.00,
            'Labourer':        250.00,
            'Electrician':     450.00
        };

        const DEFAULT_SELL_MARKUP = 1.35; // 35% default markup on cost for sell price

        // ==================== STEEL STOCK LENGTHS ====================
        // Per-size stock lengths (mm) â€” powder coated, Australian suppliers
        const STEEL_STOCK_LENGTHS_BY_SIZE = {
            '76Ã—38Ã—1.6':  [3000, 4000, 6100, 7300, 8000],
            '75Ã—50Ã—2':    [8000],
            '100Ã—50Ã—2':   [5500, 6500, 8000],
            '150Ã—50Ã—2':   [5500, 6500, 8000],
            '150Ã—50Ã—3':   [8000],
            '125Ã—50Ã—2':   [6500, 8000],
            '90Ã—90Ã—2':    [3100, 4100, 6200, 8000],
            '65Ã—65Ã—2':    [6500, 8000],
            '75Ã—75Ã—2':    [6500, 8000],
            '100Ã—100Ã—2':  [6500, 8000],
            '125Ã—125Ã—3':  [6500, 8000],
            '150Ã—150Ã—3':  [6500, 8000],
            'C150 Purlin':[6500, 8000],
            'C200 Purlin':[6500, 8000]
        };
        // Backward compat wrapper
        const STEEL_STOCK_LENGTHS = {
            'RHS': [6500, 8000],
            'SHS': [6500, 8000],
            'PATIO_TUBE': [3000, 4000, 6100, 7300, 8000]
        };
        // Fixed-price riser items (powder coated, each)
        const RISER_PRICES = {
            '76Ã—38Ã—1.6': 50,
            '75Ã—50Ã—2':   55,
            '100Ã—50Ã—2':  60
        };

        function getStockLengthsForSize(sizeKey) {
            return STEEL_STOCK_LENGTHS_BY_SIZE[sizeKey] || [6500, 8000];
        }

        const STEEL_RATES = {
            '76Ã—38Ã—1.6': 15.50,
            '75Ã—50Ã—2': 26.00,
            '100Ã—50Ã—2': 30.00,
            '150Ã—50Ã—2': 39.05,
            '150Ã—50Ã—3': 50.00,
            '90Ã—90Ã—2': 35.50,
            '65Ã—65Ã—2': 22.00,
            '75Ã—75Ã—2': 28.00,
            '100Ã—100Ã—2': 42.00,
            '125Ã—125Ã—3': 58.00,
            '150Ã—150Ã—3': 72.00,
            '125Ã—50Ã—2': 34.00,
            'C150 Purlin': 28.00,
            'C200 Purlin': 35.00
        };

        function calculateStockRequired(requiredLengthMm, stockLengths) {
            const sorted = [...stockLengths].sort((a, b) => a - b);
            for (const stockLen of sorted) {
                if (requiredLengthMm <= stockLen) {
                    return { stockLength: stockLen, waste: stockLen - requiredLengthMm, qty: 1, needsJoiner: false };
                }
            }
            const maxStock = sorted[sorted.length - 1];
            const qty = Math.ceil(requiredLengthMm / maxStock);
            return { stockLength: maxStock, waste: (qty * maxStock) - requiredLengthMm, qty, needsJoiner: true };
        }

        // Nesting: pack multiple cut pieces into minimum stock lengths (first-fit decreasing)
        // Returns { sticks: [{stockLength, cuts:[mm,...], waste},...], totalSticks, totalWaste, specialOrder }
        function nestCuts(cutLengthMm, qty, stockLengths) {
            const SAW_KERF = 3; // 3mm saw cut allowance
            const sorted = [...stockLengths].sort((a, b) => a - b);
            const maxStock = sorted[sorted.length - 1];

            // Check for special order (single piece too long for any stock)
            if (cutLengthMm > maxStock) {
                return {
                    sticks: [],
                    totalSticks: qty,
                    totalWaste: 0,
                    specialOrder: true,
                    cutLength: cutLengthMm,
                    piecesPerStick: 1,
                    orderSummary: qty + 'Ã— SPECIAL ORDER (>' + (maxStock / 1000).toFixed(1) + 'm)'
                };
            }

            // Pick the smallest stock that fits at least one piece
            var bestStock = maxStock;
            for (var si = 0; si < sorted.length; si++) {
                if (sorted[si] >= cutLengthMm) {
                    bestStock = sorted[si];
                    break;
                }
            }

            // How many pieces fit in one stick?
            var piecesPerStick = 0;
            var testLen = 0;
            while (testLen + cutLengthMm <= bestStock) {
                piecesPerStick++;
                testLen += cutLengthMm + SAW_KERF;
            }
            if (piecesPerStick < 1) piecesPerStick = 1;

            // Could we fit more pieces using a longer stock?
            for (var li = sorted.indexOf(bestStock) + 1; li < sorted.length; li++) {
                var bigStock = sorted[li];
                var bigPieces = 0;
                var tl = 0;
                while (tl + cutLengthMm <= bigStock) {
                    bigPieces++;
                    tl += cutLengthMm + SAW_KERF;
                }
                // Only use longer stock if it reduces total sticks needed
                var sticksSmall = Math.ceil(qty / piecesPerStick);
                var sticksBig = Math.ceil(qty / bigPieces);
                if (sticksBig < sticksSmall) {
                    bestStock = bigStock;
                    piecesPerStick = bigPieces;
                }
            }

            var totalSticks = Math.ceil(qty / piecesPerStick);
            var sticks = [];
            var remaining = qty;
            for (var i = 0; i < totalSticks; i++) {
                var n = Math.min(remaining, piecesPerStick);
                var used = n * cutLengthMm + (n - 1) * SAW_KERF;
                var waste = bestStock - used;
                var cuts = [];
                for (var j = 0; j < n; j++) cuts.push(cutLengthMm);
                sticks.push({ stockLength: bestStock, cuts: cuts, waste: waste });
                remaining -= n;
            }

            var totalWaste = sticks.reduce(function(s, st) { return s + st.waste; }, 0);
            var stockLabel = (bestStock / 1000).toFixed(1) + 'm';
            var orderSummary = totalSticks + 'Ã— ' + stockLabel + ' sticks';
            if (piecesPerStick > 1) {
                orderSummary += ' (' + piecesPerStick + ' pcs/stick';
                if (sticks.length > 0 && sticks[sticks.length - 1].cuts.length < piecesPerStick) {
                    orderSummary += ', last stick ' + sticks[sticks.length - 1].cuts.length + ' pcs';
                }
                orderSummary += ')';
            }

            return {
                sticks: sticks,
                totalSticks: totalSticks,
                totalWaste: totalWaste,
                specialOrder: false,
                cutLength: cutLengthMm,
                piecesPerStick: piecesPerStick,
                stockLength: bestStock,
                orderSummary: orderSummary
            };
        }

        // Build complete steel nesting plan from current calc state
        // Returns array of { label, sizeKey, sizeName, cutMm, qty, nesting:{...} }
        function buildSteelNestingPlan() {
            var c = calc;
            if (!c || !c.L) return [];
            var plan = [];
            var Lmm = c.lenInput || c.L;
            var Wmm = c.projInput || c.W;
            var postHmm = c.postH || 2400;
            var postFix = (document.getElementById('inPostFix') || {}).value || 'concrete';
            var postCut = postFix === 'concrete' ? postHmm + 300 : postHmm;
            var postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;

            // Posts
            var postSizeKey = c.framePost ? getSteelSizeKey(c.framePost.name) : '90Ã—90Ã—2';
            var postSizeName = c.framePost ? c.framePost.name : '90Ã—90Ã—2 SHS';
            plan.push({
                label: 'Posts',
                sizeKey: postSizeKey,
                sizeName: postSizeName,
                cutMm: Math.round(postCut),
                qty: postCount,
                nesting: nestCuts(Math.round(postCut), postCount, getStockLengthsForSize(postSizeKey))
            });

            // Beams
            var beamSizeKey = c.frameBeam ? getSteelSizeKey(c.frameBeam.name) : '100Ã—50Ã—2';
            var beamSizeName = c.frameBeam ? c.frameBeam.name : '100Ã—50Ã—2 RHS';
            var beamCount;
            if (c.isGable) {
                beamCount = c.connection === 'freestanding' ? 2 : (c.connection === 'riser' ? 3 : 2);
            } else {
                beamCount = c.connection === 'riser' ? 3 : (c.isRecvChan ? 1 : 2);
            }
            plan.push({
                label: 'Beams',
                sizeKey: beamSizeKey,
                sizeName: beamSizeName,
                cutMm: Math.round(Lmm),
                qty: beamCount,
                nesting: nestCuts(Math.round(Lmm), beamCount, getStockLengthsForSize(beamSizeKey))
            });

            // Trusses (gable) or Rafters (skillion)
            if (c.isGable) {
                var trussSizeKey = c.steel ? getSteelSizeKey(c.steel.name) : '76Ã—38Ã—1.6';
                var trussSizeName = c.steel ? c.steel.name : '76Ã—38Ã—1.6';
                var trussCutMm = Math.round(c.rafter || (Wmm / Math.cos(c.pitchRad || 0)));
                plan.push({
                    label: 'Trusses',
                    sizeKey: trussSizeKey,
                    sizeName: trussSizeName,
                    cutMm: trussCutMm,
                    qty: c.nTruss || 4,
                    nesting: nestCuts(trussCutMm, c.nTruss || 4, getStockLengthsForSize(trussSizeKey))
                });
            } else {
                var rafterSizeKey = c.rafterSize ? getSteelSizeKey(c.rafterSize.name) : (c.steel ? getSteelSizeKey(c.steel.name) : '76Ã—38Ã—1.6');
                var rafterSizeName = c.rafterSize ? c.rafterSize.name : (c.steel ? c.steel.name : '76Ã—38Ã—1.6');
                var rafterCutMm = Math.round(c.rafter || Wmm);
                var rafterQty = c.rafterCalc ? c.rafterCalc.rafterCount : (c.nRafters || 4);
                plan.push({
                    label: 'Rafters',
                    sizeKey: rafterSizeKey,
                    sizeName: rafterSizeName,
                    cutMm: rafterCutMm,
                    qty: rafterQty,
                    nesting: nestCuts(rafterCutMm, rafterQty, getStockLengthsForSize(rafterSizeKey))
                });
            }

            // Purlins / Battens
            var purlinCount = 0;
            if (c.isGable) {
                purlinCount = (c.gableBattenCalc && c.gableBattenCalc.totalBattens > 0) ? c.gableBattenCalc.totalBattens : Math.max(2, Math.ceil(c.rafter / 1000 / 0.8)) * 2;
            } else {
                var bc = c.battenCalc;
                purlinCount = (bc && bc.battensNeeded > 0) ? bc.battensNeeded : 0;
            }
            if (purlinCount > 0) {
                var purlinSizeKey = '76Ã—38Ã—1.6';
                var purlinSizeName = '76Ã—38Ã—1.6 RHS';
                plan.push({
                    label: c.isGable ? 'Purlins' : 'Battens',
                    sizeKey: purlinSizeKey,
                    sizeName: purlinSizeName,
                    cutMm: Math.round(Lmm),
                    qty: purlinCount,
                    nesting: nestCuts(Math.round(Lmm), purlinCount, getStockLengthsForSize(purlinSizeKey))
                });
            }

            // Flyover struts
            if (!c.isGable && c.connection === 'flyover') {
                var strutCount = Math.max(2, Math.ceil(c.L / 1200));
                var strutSizeKey = c.framePost ? getSteelSizeKey(c.framePost.name) : '90Ã—90Ã—2';
                plan.push({
                    label: 'Flyover Struts',
                    sizeKey: strutSizeKey,
                    sizeName: c.framePost ? c.framePost.name : '90Ã—90Ã—2 SHS',
                    cutMm: 500,
                    qty: strutCount,
                    nesting: nestCuts(500, strutCount, getStockLengthsForSize(strutSizeKey))
                });
            }

            // Flyover beam (150Ã—50Ã—2)
            if (!c.isGable && c.connection === 'flyover') {
                plan.push({
                    label: 'Flyover Beam',
                    sizeKey: '150Ã—50Ã—2',
                    sizeName: '150Ã—50Ã—2 RHS',
                    cutMm: Math.round(Lmm),
                    qty: 1,
                    nesting: nestCuts(Math.round(Lmm), 1, getStockLengthsForSize('150Ã—50Ã—2'))
                });
            }

            // Riser beam (connection=riser) â€” elbows are pre-made, not cut from stock
            if (c.connection === 'riser') {
                plan.push({
                    label: 'Riser Beam',
                    sizeKey: c.frameBeam ? getSteelSizeKey(c.frameBeam.name) : '100Ã—50Ã—2',
                    sizeName: c.frameBeam ? c.frameBeam.name : '100Ã—50Ã—2 RHS',
                    cutMm: Math.round(Lmm),
                    qty: 1,
                    nesting: nestCuts(Math.round(Lmm), 1, getStockLengthsForSize(c.frameBeam ? getSteelSizeKey(c.frameBeam.name) : '100Ã—50Ã—2'))
                });
            }

            // Cache on calc for other consumers
            c.steelNestingPlan = plan;
            return plan;
        }

        function getSteelCategory(desc) {
            const d = desc.toLowerCase();
            if (d.includes('76Ã—38') || d.includes('76x38') || d.includes('patio tub')) return 'PATIO_TUBE';
            if (d.includes('shs') || d.includes('post') || d.includes('strut')) return 'SHS';
            if (d.includes('c150') || d.includes('c200')) return 'RHS';
            return 'RHS';
        }

        function getSteelSizeKey(desc) {
            const d = desc.toLowerCase();
            if (d.includes('c200 purlin') || d.includes('c200')) return 'C200 Purlin';
            if (d.includes('c150 purlin') || d.includes('c150')) return 'C150 Purlin';
            if (d.includes('150Ã—50') || d.includes('150x50')) return '150Ã—50Ã—2';
            if (d.includes('125Ã—50') || d.includes('125x50')) return '125Ã—50Ã—2';
            if (d.includes('100Ã—50') || d.includes('100x50')) return '100Ã—50Ã—2';
            if (d.includes('150Ã—150') || d.includes('150x150')) return '150Ã—150Ã—3';
            if (d.includes('125Ã—125') || d.includes('125x125')) return '125Ã—125Ã—3';
            if (d.includes('100Ã—100') || d.includes('100x100')) return '100Ã—100Ã—2';
            if (d.includes('90Ã—90') || d.includes('90x90')) return '90Ã—90Ã—2';
            if (d.includes('76Ã—38') || d.includes('76x38')) return '76Ã—38Ã—1.6';
            if (d.includes('75Ã—75') || d.includes('75x75')) return '75Ã—75Ã—2';
            if (d.includes('75Ã—50') || d.includes('75x50')) return '75Ã—50Ã—2';
            if (d.includes('65Ã—65') || d.includes('65x65')) return '65Ã—65Ã—2';
            return null;
        }

        function isSteelItem(desc) {
            const d = desc.toLowerCase();
            return d.includes('post') || d.includes('beam') || d.includes('rafter') ||
                   d.includes('truss') || d.includes('batten') || d.includes('purlin') ||
                   d.includes('strut') || d.includes('flyover beam');
        }

        // Gutter rates
        const GUTTER_RATES = { standard: 22, box: 30 };
        const FLASHING_RATES = { standard: 25, solarspan: 30 };
        const LABOUR_RATES = { roof_plumber_day: 800 };

        let storedRates = {};
        let jobRows = [];      // {desc, qty, length, unitCost, unitSell, isAddon, stockInfo}
        let labourRows = [];   // {desc, trades, days, dayRate, sell}
        let extrasRows = [];   // {desc, qty, unitCost, unitSell, type}
        let pricingState = {}; // cached pricing calcs for PDF access

        function loadRates() {
            try {
                const saved = localStorage.getItem('patioRates');
                storedRates = saved ? JSON.parse(saved) : { ...DEFAULT_RATES };
                // Merge in any new default keys missing from saved data
                Object.keys(DEFAULT_RATES).forEach(k => {
                    if (!(k in storedRates)) storedRates[k] = DEFAULT_RATES[k];
                });
            } catch (e) {
                storedRates = { ...DEFAULT_RATES };
            }
        }

        function saveRates() {
            localStorage.setItem('patioRates', JSON.stringify(storedRates));
        }

        function renderRatesPanel() {
            const body = document.getElementById('ratesBody');
            body.innerHTML = Object.entries(storedRates).map(([k, v]) =>
                `<tr><td>${k}</td><td><input type="number" class="rate-input" step="0.01" value="${v.toFixed(2)}" onchange="updateRate('${k}', this.value)"></td></tr>`
            ).join('');
        }

        function updateRate(key, val) {
            storedRates[key] = parseFloat(val) || 0;
            saveRates();
            buildJobRows();
            updatePricing();
        }

        function openRatesModal() {
            loadSettingsDefaults();
            renderRatesPanel();
            document.getElementById('ratesModal').style.display = '';
        }

        function saveSettingsDefaults() {
            var defs = {
                markup: parseFloat(document.getElementById('settingsDefaultMarkup').value) || 35,
                tradesCostHr: parseFloat(document.getElementById('settingsTradesCostHr').value) || 45,
                tradesSellHr: parseFloat(document.getElementById('settingsTradesSellHr').value) || 110,
                labourerCostHr: parseFloat(document.getElementById('settingsLabourerCostHr').value) || 35,
                labourerSellHr: parseFloat(document.getElementById('settingsLabourerSellHr').value) || 90,
                hoursPerDay: parseFloat(document.getElementById('settingsHoursPerDay').value) || 8,
                scopeFootings: parseFloat(document.getElementById('settingsScopeFootings').value) || 85,
                scopeDemo: parseFloat(document.getElementById('settingsScopeDemo').value) || 500,
                scopeCrane: parseFloat(document.getElementById('settingsScopeCrane').value) || 600,
                scopePermit: parseFloat(document.getElementById('settingsScopePermit').value) || 350,
                scopeSoakwell: parseFloat(document.getElementById('settingsScopeSoakwell').value) || 800,
                scopeSkip: parseFloat(document.getElementById('settingsScopeSkip').value) || 350,
                scopeDelivery: parseFloat(document.getElementById('settingsScopeDelivery').value) || 200,
                scopeElectrical: parseFloat(document.getElementById('settingsScopeElectrical').value) || 0,
                showWoCosts: document.getElementById('settingsShowWoCosts').checked,
                itemisedQuote: document.getElementById('settingsItemisedQuote').checked
            };
            try { localStorage.setItem('patioSettingsDefaults', JSON.stringify(defs)); } catch(e) {}
        }

        function loadSettingsDefaults() {
            try {
                var saved = localStorage.getItem('patioSettingsDefaults');
                if (saved) {
                    var d = JSON.parse(saved);
                    if (d.markup != null) document.getElementById('settingsDefaultMarkup').value = d.markup;
                    if (d.tradesCostHr != null) document.getElementById('settingsTradesCostHr').value = d.tradesCostHr;
                    if (d.tradesSellHr != null) document.getElementById('settingsTradesSellHr').value = d.tradesSellHr;
                    if (d.labourerCostHr != null) document.getElementById('settingsLabourerCostHr').value = d.labourerCostHr;
                    if (d.labourerSellHr != null) document.getElementById('settingsLabourerSellHr').value = d.labourerSellHr;
                    if (d.hoursPerDay != null) document.getElementById('settingsHoursPerDay').value = d.hoursPerDay;
                    if (d.scopeFootings != null) document.getElementById('settingsScopeFootings').value = d.scopeFootings;
                    if (d.scopeDemo != null) document.getElementById('settingsScopeDemo').value = d.scopeDemo;
                    if (d.scopeCrane != null) document.getElementById('settingsScopeCrane').value = d.scopeCrane;
                    if (d.scopePermit != null) document.getElementById('settingsScopePermit').value = d.scopePermit;
                    if (d.scopeSoakwell != null) document.getElementById('settingsScopeSoakwell').value = d.scopeSoakwell;
                    if (d.scopeSkip != null) document.getElementById('settingsScopeSkip').value = d.scopeSkip;
                    if (d.scopeDelivery != null) document.getElementById('settingsScopeDelivery').value = d.scopeDelivery;
                    if (d.scopeElectrical != null) document.getElementById('settingsScopeElectrical').value = d.scopeElectrical;
                    if (d.showWoCosts != null) document.getElementById('settingsShowWoCosts').checked = d.showWoCosts;
                    if (d.itemisedQuote != null) document.getElementById('settingsItemisedQuote').checked = d.itemisedQuote;
                }
            } catch(e) {}
        }

        function getSettingsDefaults() {
            try {
                var saved = localStorage.getItem('patioSettingsDefaults');
                if (saved) return JSON.parse(saved);
            } catch(e) {}
            return { markup: 35, dayRate: 400, trades: 2, days: 1.5, scopeFootings: 85, scopeDemo: 500, scopeCrane: 600, scopePermit: 350, scopeSoakwell: 800, scopeSkip: 350, scopeDelivery: 200, scopeElectrical: 0, showWoCosts: false, itemisedQuote: false };
        }


        function matchRate(desc) {
            const d = desc.toLowerCase();
            // Steel - SHS (posts/struts/risers)
            if (d.includes('65Ã—65') || d.includes('65x65')) return storedRates['65Ã—65Ã—2 SHS'] || 0;
            if (d.includes('75Ã—75') || d.includes('75x75')) return storedRates['75Ã—75Ã—2 SHS'] || 0;
            if (d.includes('90Ã—90') || d.includes('90x90')) return storedRates['90Ã—90Ã—2 SHS'] || 0;
            if (d.includes('100Ã—100') || d.includes('100x100')) return storedRates['100Ã—100Ã—2 SHS'] || 0;
            if (d.includes('125Ã—125') || d.includes('125x125')) return storedRates['125Ã—125Ã—3 SHS'] || 0;
            if (d.includes('150Ã—150') || d.includes('150x150')) return storedRates['150Ã—150Ã—3 SHS'] || 0;
            // Steel - RHS (beams/trusses/rafters)
            if (d.includes('c200 purlin') || d.includes('c200')) return storedRates['C200 Purlin'] || 0;
            if (d.includes('c150 purlin') || d.includes('c150')) return storedRates['C150 Purlin'] || 0;
            if (d.includes('76Ã—38') || d.includes('76x38')) return storedRates['76Ã—38Ã—1.6 RHS'] || 0;
            if (d.includes('125Ã—50') || d.includes('125x50')) return storedRates['125Ã—50Ã—2 RHS'] || 0;
            if (d.includes('75Ã—50') || d.includes('75x50')) return storedRates['75Ã—50Ã—2 RHS'] || 0;
            if (d.includes('150Ã—50') || d.includes('150x50')) return storedRates['150Ã—50Ã—2 RHS'] || 0;
            if (d.includes('100Ã—50') || d.includes('100x50')) return storedRates['100Ã—50Ã—2 RHS'] || 0;
            // Roofing
            if (d.includes('solarspan')) return storedRates['Solarspan 75mm'] || 0;
            if (d.includes('polycarb') && d.includes('laserlite')) return storedRates['Laserlite 2000 5-Rib'] || 0;
            if (d.includes('polycarb') && d.includes('corrugated')) return storedRates['Ampelite Solasafe Corrugated'] || storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('polycarb') && d.includes('ampelite')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('polycarb')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('trimdek') && d.includes('sheet')) return storedRates['Trimdek Colorbond'] || 0;
            if (d.includes('spandek') && d.includes('sheet')) return storedRates['Spandek Colorbond'] || 0;
            if (d.includes('sheet') && !d.includes('solarspan')) return storedRates['Corrugated Colorbond'] || 0;
            // Flashings
            if (d.includes('ridge cap') || d.includes('ridge flash')) return storedRates['Ridge Cap'] || 0;
            if (d.includes('barge')) return storedRates['Barge Flashing'] || 0;
            if (d.includes('back flash') || d.includes('wall flash')) return storedRates['Back Flashing'] || 0;
            if (d.includes('gutter flash')) return storedRates['Gutter Flashing'] || 0;
            // Gutters & drainage
            if (d.includes('box gutter')) return storedRates['Box Gutter'] || 0;
            if (d.includes('gutter') && !d.includes('box') && !d.includes('downpipe') && !d.includes('flash')) return storedRates['Quad Gutter 115mm'] || 0;
            if (d.includes('downpipe')) return storedRates['Downpipe 90mm'] || 0;
            // Extras
            if (d.includes('infill')) return storedRates['Gable Infill (sqm)'] || 0;
            if (d.includes('riser elbow') && d.includes('100Ã—50')) return storedRates['Riser 100Ã—50 (ea)'] || 60;
            if (d.includes('riser elbow') && d.includes('75Ã—50')) return storedRates['Riser 75Ã—50 (ea)'] || 55;
            if (d.includes('riser elbow') && d.includes('76Ã—38')) return storedRates['Riser 76Ã—38 (ea)'] || 50;
            if (d.includes('riser elbow')) return storedRates['Riser 76Ã—38 (ea)'] || 50;
            if (d.includes('riser') && d.includes('bracket')) return storedRates['Riser Bracket (ea)'] || 0;
            if (d.includes('foam')) return storedRates['Foam Strip'] || 0;
            if (d.includes('channel') && !d.includes('gutter')) return storedRates['Back Flashing'] || 0;
            if (d.includes('batten')) return storedRates['76Ã—38Ã—1.6 RHS'] || 0;
            if (d.includes('tubing bracket')) return storedRates['Tubing Bracket (ea)'] || 0;
            if (d.includes('strut')) return storedRates['76Ã—38Ã—1.6 RHS'] || 0;
            if (d.includes('elbow')) return storedRates['Downpipe 90mm'] || 0;
            if (d.includes('fascia bracket')) return storedRates['Riser Bracket (ea)'] || 12;
            if (d.includes('fascia board')) return storedRates['Barge Flashing'] || 0;
            return 0;
        }

        function getItemLength(desc) {
            const c = calc;
            const d = desc.toLowerCase();
            const Lm = c.L / 1000;
            const Wm = c.W / 1000;
            if (d.includes('post')) return c.postH / 1000;
            if (d.includes('beam') || d.includes('ridge') || d.includes('barge') || d.includes('flashing') || d.includes('channel') || d.includes('gutter') || d.includes('fascia board')) return Lm;
            if (d.includes('truss') || d.includes('rafter')) return c.rafter / 1000;
            if (d.includes('batten')) return Lm;  // battens run side-to-side = patio length
            if (d.includes('tubing bracket')) return 1;  // per piece
            if (d.includes('fascia bracket')) return 1;  // per piece
            if (d.includes('purlin')) return Lm;
            if (d.includes('sheet') && d.includes('solarspan')) return Wm;
            if (d.includes('sheet')) return c.rafter / 1000;
            if (d.includes('downpipe')) return c.postH / 1000;
            if (d.includes('strut')) return 0.5;
            if (d.includes('riser elbow')) return 0.5;
            if (d.includes('infill')) return c.rafter / 1000;
            if (d.includes('foam')) return Lm;
            return 1;
        }

        // Build jobRows from the materials list (called after rebuildAll)
        function buildJobRows() {
            const matRowEls = document.querySelectorAll('#matList .mat-row');
            // Preserve existing addon rows
            const addons = jobRows.filter(r => r.isAddon);
            jobRows = [];

            // Build nesting plan for steel items
            const nestingPlan = buildSteelNestingPlan();
            // Index nesting plan by label for quick lookup
            const nestingByLabel = {};
            nestingPlan.forEach(function(p) { nestingByLabel[p.label] = p; });

            matRowEls.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length < 2) return;
                const desc = row.dataset.desc || spans[0].textContent.trim();
                const qty = parseInt(spans[1].textContent.trim().replace('Ã—', '')) || 1;
                const length = getItemLength(desc);
                const unitCost = matchRate(desc);

                // Steel: use nesting-based stock costing
                if (isSteelItem(desc) && length > 0) {
                    const sizeKey = getSteelSizeKey(desc);
                    if (sizeKey && STEEL_RATES[sizeKey]) {
                        // Find matching nesting plan entry
                        var nestEntry = null;
                        var dLow = desc.toLowerCase();
                        if (dLow.includes('post') && nestingByLabel['Posts']) nestEntry = nestingByLabel['Posts'];
                        else if (dLow.includes('flyover beam') && nestingByLabel['Flyover Beam']) nestEntry = nestingByLabel['Flyover Beam'];
                        else if (dLow.includes('flyover strut') && nestingByLabel['Flyover Struts']) nestEntry = nestingByLabel['Flyover Struts'];
                        else if (dLow.includes('riser beam') && nestingByLabel['Riser Beam']) nestEntry = nestingByLabel['Riser Beam'];
                        else if (dLow.includes('riser elbow') && nestingByLabel['Riser Elbows']) nestEntry = nestingByLabel['Riser Elbows'];
                        else if (dLow.includes('beam') && nestingByLabel['Beams']) nestEntry = nestingByLabel['Beams'];
                        else if (dLow.includes('truss') && nestingByLabel['Trusses']) nestEntry = nestingByLabel['Trusses'];
                        else if (dLow.includes('rafter') && nestingByLabel['Rafters']) nestEntry = nestingByLabel['Rafters'];
                        else if ((dLow.includes('batten') || dLow.includes('purlin')) && (nestingByLabel['Battens'] || nestingByLabel['Purlins'])) nestEntry = nestingByLabel['Battens'] || nestingByLabel['Purlins'];

                        if (nestEntry && nestEntry.nesting && !nestEntry.nesting.specialOrder) {
                            var n = nestEntry.nesting;
                            // Cost = total sticks Ã— stock length in metres Ã— $/m
                            var totalStockCost = 0;
                            n.sticks.forEach(function(st) {
                                totalStockCost += (st.stockLength / 1000) * STEEL_RATES[sizeKey];
                            });
                            var totalStockSell = +(totalStockCost * DEFAULT_SELL_MARKUP).toFixed(2);
                            jobRows.push({
                                desc: desc, qty: qty, length: length, unit: 'nested',
                                unitCost: totalStockCost, unitSell: totalStockSell,
                                isAddon: false, stockInfo: null, nestEntry: nestEntry
                            });
                            return;
                        }

                        // Fallback: per-piece stock costing
                        var stockLengths = getStockLengthsForSize(sizeKey);
                        var requiredMm = Math.round(length * 1000);
                        var stockInfo = calculateStockRequired(requiredMm, stockLengths);
                        var stockCostPerItem = (stockInfo.stockLength / 1000) * STEEL_RATES[sizeKey] * stockInfo.qty;
                        var perUnitSell = +(stockCostPerItem * DEFAULT_SELL_MARKUP).toFixed(2);
                        jobRows.push({ desc, qty, length, unit: 'stock', unitCost: stockCostPerItem, unitSell: perUnitSell, isAddon: false, stockInfo });
                        return;
                    }
                }

                // Check for riser items with fixed pricing
                var dLow2 = desc.toLowerCase();
                if (dLow2.includes('riser elbow')) {
                    var riserKey = getSteelSizeKey(desc);
                    var riserPrice = riserKey ? (RISER_PRICES[riserKey] || 0) : 0;
                    if (riserPrice > 0) {
                        var riserSell = +(riserPrice * DEFAULT_SELL_MARKUP).toFixed(2);
                        jobRows.push({ desc, qty, length: 1, unit: 'each', unitCost: riserPrice, unitSell: riserSell, isAddon: false });
                        return;
                    }
                }

                const unitSell = +(unitCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc, qty, length, unit: 'LM', unitCost, unitSell, isAddon: false, stockInfo: null });
            });
            // Auto-add fixings estimate based on patio area
            const c = calc;
            if (c.L && c.W) {
                const areaSqm = (c.L / 1000) * (c.W / 1000);
                const fixCost = storedRates['Fixings ($/sqm)'] || 2.50;
                const fixSell = +(fixCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc: 'Fixings (screws, anchors, silicone, foam)', qty: +areaSqm.toFixed(1), length: 1, unit: 'sqm', unitCost: fixCost, unitSell: fixSell, isAddon: false });
            }
            // Auto-add roof plumber day rate when box gutter is present
            if (c.houseGutter === 'box' && c.connection === 'riser') {
                const rpCost = LABOUR_RATES.roof_plumber_day;
                const rpSell = +(rpCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc: 'Roof Plumber (box gutter install)', qty: 1, length: 1, unit: 'each', unitCost: rpCost, unitSell: rpSell, isAddon: false });
            }
            // Re-append addons
            addons.forEach(a => { if (!a.unit) a.unit = 'each'; jobRows.push(a); });
        }

        const UNIT_OPTIONS = ['each', 'LM', 'sqm', 'hours', 'days', 'lot'];

        // Keep renderJobTable for compatibility (materials modal uses it internally)
        function renderJobTable() { /* now handled by materials modal */ }

        // Extras presets
        function addExtra(type) {
            const nPosts = calc.nPosts ? (calc.connection === 'freestanding' ? calc.nPosts * 2 : calc.nPosts) : 6;
            const sd = getSettingsDefaults();
            const mk = (sd.markup || 35) / 100 + 1; // markup multiplier
            const presets = {
                footings:    { desc: 'Concrete Footings (' + nPosts + ')', qty: nPosts, unitCost: sd.scopeFootings || 85, unitSell: Math.round((sd.scopeFootings || 85) * mk), type: 'footings' },
                electrical:  { desc: 'Electrical',        qty: 1,      unitCost: sd.scopeElectrical || 0, unitSell: Math.round((sd.scopeElectrical || 0) * mk), type: 'electrical' },
                downlights:  { desc: 'Downlights',        qty: 4,      unitCost: 50,  unitSell: 85,  type: 'downlights' },
                demo:        { desc: 'Demo/Removal',      qty: 1,      unitCost: sd.scopeDemo || 500, unitSell: Math.round((sd.scopeDemo || 500) * mk), type: 'demo' },
                delivery:    { desc: 'Delivery',           qty: 1,      unitCost: sd.scopeDelivery || 200, unitSell: Math.round((sd.scopeDelivery || 200) * mk), type: 'delivery' },
                crane:       { desc: 'Crane Hire',         qty: 1,      unitCost: sd.scopeCrane || 600, unitSell: Math.round((sd.scopeCrane || 600) * mk), type: 'crane' },
                permit:      { desc: 'Council/Permit',     qty: 1,      unitCost: sd.scopePermit || 350, unitSell: Math.round((sd.scopePermit || 350) * mk), type: 'permit' },
                soakwell:    { desc: 'Soakwell',           qty: 1,      unitCost: sd.scopeSoakwell || 800, unitSell: Math.round((sd.scopeSoakwell || 800) * mk), type: 'soakwell' },
                skip:        { desc: 'Skip Bin',           qty: 1,      unitCost: sd.scopeSkip || 350, unitSell: Math.round((sd.scopeSkip || 350) * mk), type: 'skip' },
                other:       { desc: '',                   qty: 1,      unitCost: 0,   unitSell: 0,   type: 'other' }
            };
            const p = presets[type];
            if (!p) return;
            extrasRows.push({ ...p });
            renderExtras();
            updatePricing();
        }

        function removeExtra(idx) {
            extrasRows.splice(idx, 1);
            renderExtras();
            updatePricing();
        }

        function renderExtras() {
            const container = document.getElementById('extrasRowsContainer');
            if (extrasRows.length === 0) {
                container.innerHTML = '';
                return;
            }
            container.innerHTML = extrasRows.map((r, i) => {
                const totalCost = r.qty * r.unitCost;
                const totalSell = r.qty * r.unitSell;
                return `<div class="extras-row">
                    <div class="ex-desc"><input type="text" class="ex-input desc-input" value="${(r.desc||'').replace(/"/g,'&quot;')}" placeholder="Description" onchange="extrasRows[${i}].desc=this.value"></div>
                    <div class="ex-field">Qty: <input type="number" class="ex-input" style="width:50px" value="${r.qty}" min="1" step="1" onchange="extrasRows[${i}].qty=parseFloat(this.value)||1;renderExtras();updatePricing()"></div>
                    <div class="ex-field">Cost: <input type="number" class="ex-input" value="${totalCost.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitCost=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <div class="ex-field">Sell: <input type="number" class="ex-input" value="${totalSell.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitSell=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <button class="ex-remove" onclick="removeExtra(${i})">&times;</button>
                </div>`;
            }).join('');
        }

        // Legacy addon compat: migrate old addon rows to extras on import
        function addSmartAddon(type) {
            const typeMap = { concrete: 'footings', electrical: 'electrical', downlights: 'downlights', demo: 'demo', fan: 'other', fascia: 'other', posts: 'other', permit: 'other' };
            addExtra(typeMap[type] || 'other');
        }
        function addCustomLine() { addExtra('other'); }
        function removeJobRow(idx) { jobRows.splice(idx, 1); updatePricing(); }

        // Labour â€” read from inline card inputs
        function getLabourFromCard() {
            const trades = parseFloat(document.getElementById('labTrades').value) || 0;
            const labourers = parseFloat(document.getElementById('labLabourers')?.value) || 0;
            const days = parseFloat(document.getElementById('labDays').value) || 0;
            const hoursPerDay = parseFloat(document.getElementById('settingsHoursPerDay')?.value) || 8;
            const tradeCostHr = parseFloat(document.getElementById('settingsTradesCostHr')?.value) || 45;
            const tradeSellHr = parseFloat(document.getElementById('settingsTradesSellHr')?.value) || 110;
            const labCostHr = parseFloat(document.getElementById('settingsLabourerCostHr')?.value) || 35;
            const labSellHr = parseFloat(document.getElementById('settingsLabourerSellHr')?.value) || 90;
            const tradeHours = trades * days * hoursPerDay;
            const labourerHours = labourers * days * hoursPerDay;
            const cost = (tradeHours * tradeCostHr) + (labourerHours * labCostHr);
            const sell = (tradeHours * tradeSellHr) + (labourerHours * labSellHr);
            // Sync hidden compat fields
            var drEl = document.getElementById('labDayRate');
            if (drEl) drEl.value = (trades > 0 && days > 0) ? Math.round(cost / (trades * days)) : 0;
            var slEl = document.getElementById('labSellInput');
            if (slEl) slEl.value = Math.round(sell);
            return { trades, labourers, days, cost, sell, dayRate: drEl ? drEl.value : 0 };
        }

        function updateLabour() {
            var lab = getLabourFromCard();
            var fmtShort = function(v) { return '$' + Math.round(v).toLocaleString(); };
            var costEl = document.getElementById('labCostDisplay');
            if (costEl) costEl.textContent = fmtShort(lab.cost);
            var sellEl = document.getElementById('labSellDisplay');
            if (sellEl) sellEl.textContent = fmtShort(lab.sell);
            updatePricing();
        }

        // Sync labourRows from card for PDF/export compat
        function syncLabourRows() {
            const l = getLabourFromCard();
            labourRows = [{ role: 'Skilled (Patio Install)', trades: l.trades, days: l.days, dayRate: l.dayRate, sell: l.sell }];
        }

        // Kept for export/import compat
        function renderLabourTable() {}
        function addLabourRole() {}
        function matchDayRate(role) {
            const r = role.toLowerCase();
            if (r.includes('electrician')) return storedRates['Electrician'] || 450;
            if (r.includes('labourer')) return storedRates['Labourer'] || 250;
            return storedRates['Skilled Trade'] || 400;
        }

        // Complexity â€” kept for export/import compat (hidden inputs)
        function updateComplexity() {}

        // ==================== MATERIALS MODAL ====================
        function openMaterialsModal() {
            var mk = document.getElementById('globalMarkupPct');
            var mmk = document.getElementById('modalMarkupPct');
            if (mk && mmk) mmk.value = mk.value;
            renderMaterialsModal();
            document.getElementById('materialsModal').style.display = '';
        }

        function closeMaterialsModal() {
            document.getElementById('materialsModal').style.display = 'none';
            updatePricing();
        }

        function renderMaterialsModal() {
            const showCost = document.getElementById('showCostToggle').checked;
            const body = document.getElementById('matModalBody');
            // Show only non-addon material rows
            const matRows = jobRows.filter(r => !r.isAddon);
            let totalSell = 0;

            body.innerHTML = matRows.map((r, realIdx) => {
                const i = jobRows.indexOf(r);
                const mult = (r.unit === 'LM') ? r.length : 1;
                const lineCost = r.qty * mult * r.unitCost;
                const lineSell = r.qty * mult * r.unitSell;
                totalSell += lineSell;
                const markupPct = r.unitCost > 0 ? ((r.unitSell - r.unitCost) / r.unitCost * 100) : 0;
                const globalMk = parseFloat((document.getElementById('modalMarkupPct') || document.getElementById('globalMarkupPct')).value) || 35;
                const isCustom = Math.abs(markupPct - globalMk) > 1;
                let qtyStr;
                if (r.unit === 'stock' && r.stockInfo) {
                    const si = r.stockInfo;
                    qtyStr = r.qty + (si.qty > 1 ? ' \u00D7 ' + si.qty : '') + ' \u00D7 ' + (si.stockLength / 1000).toFixed(1) + 'm stock';
                } else {
                    qtyStr = r.qty + (r.unit === 'LM' && r.length > 0 ? ' \u00D7 ' + r.length.toFixed(1) + 'm' : r.unit !== 'LM' ? ' ' + r.unit : '');
                }

                // Stock info annotation
                let descDisplay = r.desc;
                if (r.stockInfo) {
                    const si = r.stockInfo;
                    const cutLen = Math.round(r.length * 1000);
                    descDisplay += `<br><span style="font-size:10px;color:var(--sw-text-sec)">${cutLen}mm from ${si.stockLength}mm stock, ${si.waste}mm waste${si.needsJoiner ? ' (needs joiner)' : ''}</span>`;
                }

                return `<tr>
                    <td>${descDisplay}</td>
                    <td>${qtyStr}</td>
                    ${showCost ? `<td class="r mono">$${lineCost.toFixed(2)}</td>` : `<td class="r cost-col" style="display:none"></td>`}
                    <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" onchange="updateMatSellFromModal(${i},this.value)" style="width:90px"></td>
                    <td class="r"><span class="markup-badge${isCustom ? ' custom' : ''}">${markupPct.toFixed(0)}%${isCustom ? '*' : ''}</span></td>
                    <td></td>
                </tr>`;
            }).join('');

            // Also show custom addon rows in modal
            const addonRows = jobRows.filter(r => r.isAddon);
            if (addonRows.length > 0) {
                body.innerHTML += `<tr><td colspan="6" style="font-size:11px;font-weight:600;text-transform:uppercase;color:var(--sw-text-sec);padding-top:12px;border-bottom:1px solid var(--sw-border)">Custom Items</td></tr>`;
                body.innerHTML += addonRows.map(r => {
                    const i = jobRows.indexOf(r);
                    const mult = r.unit === 'LM' ? r.length : 1;
                    const lineSell = r.qty * mult * r.unitSell;
                    totalSell += lineSell;
                    return `<tr>
                        <td><input type="text" value="${r.desc}" style="width:160px;padding:4px 6px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px" onchange="jobRows[${i}].desc=this.value"></td>
                        <td><input type="number" value="${r.qty}" min="0" step="1" style="width:50px;padding:4px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px;text-align:center" onchange="jobRows[${i}].qty=parseFloat(this.value)||0;renderMaterialsModal()"></td>
                        ${showCost ? `<td class="r"><input type="number" value="${(r.qty*mult*r.unitCost).toFixed(2)}" min="0" step="1" style="width:80px" onchange="jobRows[${i}].unitCost=parseFloat(this.value)/(jobRows[${i}].qty*(jobRows[${i}].unit==='LM'?jobRows[${i}].length:1)||1);renderMaterialsModal()"></td>` : `<td style="display:none"></td>`}
                        <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" style="width:90px" onchange="updateMatSellFromModal(${i},this.value)"></td>
                        <td class="r"></td>
                        <td><button style="background:none;border:none;color:#ccc;cursor:pointer;font-size:16px" onclick="jobRows.splice(${i},1);renderMaterialsModal()" onmouseover="this.style.color='#FF3B30'" onmouseout="this.style.color='#ccc'">&times;</button></td>
                    </tr>`;
                }).join('');
            }

            // Update cost column visibility (header + all cost cells)
            document.querySelectorAll('.mat-modal-table .cost-col').forEach(el => el.style.display = showCost ? '' : 'none');

            document.getElementById('matModalTotal').textContent = '$' + totalSell.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        function updateMatSellFromModal(idx, val) {
            const r = jobRows[idx];
            const mult = (r.unit === 'LM') ? r.length : 1;
            const totalQty = r.qty * mult;
            r.unitSell = totalQty > 0 ? parseFloat(val) / totalQty : 0;
            renderMaterialsModal();
        }

        function applyMarkupAll(fromModal) {
            var srcId = fromModal ? 'modalMarkupPct' : 'globalMarkupPct';
            const pct = parseFloat(document.getElementById(srcId).value) || 35;
            // Sync both markup inputs
            var gEl = document.getElementById('globalMarkupPct');
            var mEl = document.getElementById('modalMarkupPct');
            if (gEl) gEl.value = pct;
            if (mEl) mEl.value = pct;
            jobRows.forEach(r => {
                if (!r.isAddon) {
                    if (r.unit === 'nested') {
                        r.unitSell = +(r.unitCost * (1 + pct / 100)).toFixed(2);
                    } else {
                        r.unitSell = +(r.unitCost * (1 + pct / 100)).toFixed(2);
                    }
                }
            });
            updatePricing();
        }

        function addCustomMaterialRow() {
            jobRows.push({ desc: 'Custom item', qty: 1, length: 1, unit: 'each', unitCost: 0, unitSell: 0, isAddon: true });
            renderMaterialsModal();
        }

        // ==================== PATIO MATERIALS TABLE ====================
        function categorizeJobRow(desc) {
            var d = desc.toLowerCase();
            if (d.includes('post') || d.includes('beam') || d.includes('truss') || d.includes('rafter') ||
                d.includes('purlin') || d.includes('batten') || d.includes('strut') || d.includes('bracket') ||
                d.includes('riser')) return 'Structure';
            if (d.includes('sheet') || d.includes('solarspan') || d.includes('trimdek') || d.includes('corrugated') ||
                d.includes('ridge cap') || d.includes('polycarb') || d.includes('spanplus')) return 'Roofing';
            if (d.includes('gutter') || d.includes('downpipe') || d.includes('box gutter')) return 'Drainage';
            if (d.includes('barge') || d.includes('infill') || d.includes('flashing') || d.includes('fascia') ||
                d.includes('channel') || d.includes('foam')) return 'Finishing';
            return 'Fixings';
        }

        function pmItemName(desc) {
            var d = desc.toLowerCase();
            if (d.includes('post'))         return 'Posts';
            if (d.includes('riser beam gutter')) return 'Riser Beam Gutter';
            if (d.includes('riser beam'))   return 'Riser Beam';
            if (d.includes('riser piece')) return 'Riser Pieces';
            if (d.includes('riser elbow'))  return 'Riser Elbows';
            if (d.includes('flyover beam')) return 'Flyover Beam';
            if (d.includes('flyover strut'))return 'Flyover Struts';
            if (d.includes('beam'))         return 'Beams';
            if (d.includes('truss'))        return 'Trusses';
            if (d.includes('rafter'))       return 'Rafters';
            if (d.includes('batten'))       return 'Battens';
            if (d.includes('tubing bracket')) return 'Tubing Brackets';
            if (d.includes('fascia bracket')) return 'Fascia Brackets';
            if (d.includes('purlin'))       return 'Purlins';
            if (d.includes('ridge cap'))    return 'Ridge Cap';
            if (d.includes('downpipe'))     return 'Downpipes';
            if (d.includes('box gutter'))   return 'Box Gutter';
            if (d.includes('gutter'))       return 'Gutter';
            if (d.includes('barge'))        return 'Barge Flashings';
            if (d.includes('back flashing'))return 'Back Flashing';
            if (d.includes('gutter flashing'))return 'Gutter Flashing';
            if (d.includes('infill'))       return 'Gable Infill';
            if (d.includes('fascia board')) return 'House Fascia Board';
            if (d.includes('channel'))      return 'Receiving Channel';
            if (d.includes('foam'))         return 'Foam';
            if (d.includes('polycarb'))     return 'Polycarb Sheets';
            if (d.includes('sheet'))        return 'Sheets';
            if (d.includes('fixing'))       return 'Fixings';
            if (d.includes('roof plumber')) return 'Roof Plumber';
            return desc;
        }

        function pmSize(desc) {
            var d = desc.toLowerCase();
            if (d.includes('65\u00D765'))    return '65\u00D765\u00D72 SHS';
            if (d.includes('75\u00D775'))    return '75\u00D775\u00D72 SHS';
            if (d.includes('90\u00D790'))    return '90\u00D790\u00D72 SHS';
            if (d.includes('100\u00D7100'))  return '100\u00D7100\u00D72 SHS';
            if (d.includes('125\u00D7125'))  return '125\u00D7125\u00D73 SHS';
            if (d.includes('150\u00D7150'))  return '150\u00D7150\u00D73 SHS';
            if (d.includes('c200'))     return 'C200 Purlin';
            if (d.includes('c150'))     return 'C150 Purlin';
            if (d.includes('150\u00D750\u00D73')) return '150\u00D750\u00D73 RHS';
            if (d.includes('150\u00D750'))   return '150\u00D750\u00D72 RHS';
            if (d.includes('125\u00D750'))   return '125\u00D750\u00D72 RHS';
            if (d.includes('100\u00D750'))   return '100\u00D750\u00D72 RHS';
            if (d.includes('75\u00D750'))    return '75\u00D750\u00D72 RHS';
            if (d.includes('76\u00D738'))    return '76\u00D738\u00D71.6 RHS';
            if (d.includes('solarspan'))return 'Insulated';
            if (d.includes('trimdek'))  return 'Trimdek';
            if (d.includes('corrugated'))return 'Corrugated';
            if (d.includes('spanplus')) return 'SpanPlus';
            if (d.includes('115mm'))    return '115mm Quad';
            return '\u2014';
        }

        function pmColour(desc) {
            var d = desc.toLowerCase();
            if (d.includes('post') || d.includes('beam') || d.includes('purlin') ||
                d.includes('batten') || d.includes('bracket') || d.includes('truss') ||
                d.includes('rafter') || d.includes('strut') || d.includes('riser') ||
                d.includes('barge') || d.includes('gutter') || d.includes('downpipe') ||
                d.includes('ridge') || d.includes('flashing') || d.includes('channel'))
                return steelColor ? steelColor.name : '\u2014';
            if (d.includes('polycarb')) return '\u2014';
            if (d.includes('sheet') || d.includes('infill'))
                return sheetColor ? sheetColor.name : '\u2014';
            return '\u2014';
        }

        function pmNestingTooltip(r) {
            if (r.nestEntry && r.nestEntry.nesting) {
                var n = r.nestEntry.nesting;
                if (n.specialOrder) return 'SPECIAL ORDER required';
                var stockM = (n.stockLength / 1000).toFixed(1);
                var tip = n.totalSticks + '\u00D7 ' + stockM + 'm stock';
                if (n.piecesPerStick > 1) tip += ', ' + n.piecesPerStick + ' pcs/stick';
                tip += ', ' + Math.round(n.totalWaste) + 'mm waste';
                return tip;
            }
            if (r.stockInfo) {
                var si = r.stockInfo;
                return si.qty + '\u00D7 ' + (si.stockLength / 1000).toFixed(1) + 'm stock, ' + si.waste + 'mm waste';
            }
            return '';
        }

        function renderPatioMaterialsTable() {
            var container = document.getElementById('patioMaterialsTable');
            if (!container) return;
            var matRows = jobRows.filter(function(r) { return !r.isAddon; });
            if (matRows.length === 0) {
                container.innerHTML = '<div style="font-size:12px;color:var(--sw-text-sec);padding:8px 0;font-style:italic">No materials calculated yet</div>';
                return;
            }

            // Group by category
            var cats = ['Structure', 'Roofing', 'Drainage', 'Finishing', 'Fixings'];
            var grouped = {};
            cats.forEach(function(c) { grouped[c] = []; });
            matRows.forEach(function(r, idx) {
                var cat = categorizeJobRow(r.desc);
                grouped[cat].push({ row: r, idx: jobRows.indexOf(r) });
            });

            var html = '<table class="pm-table"><thead><tr>' +
                '<th>Item</th><th>Size</th><th class="r">Qty</th><th class="r">Length</th><th>Colour</th>' +
                '<th class="r">Cost</th><th class="r">Sell</th><th class="r">Markup</th><th style="width:28px"></th>' +
                '</tr></thead><tbody>';

            cats.forEach(function(cat) {
                if (grouped[cat].length === 0) return;
                html += '<tr class="pm-cat-hdr"><td colspan="9">' + cat + '</td></tr>';
                grouped[cat].forEach(function(item) {
                    var r = item.row;
                    var i = item.idx;
                    var mult = (r.unit === 'LM') ? r.length : 1;
                    var lineCost, lineSell;
                    if (r.unit === 'nested') {
                        lineCost = r.unitCost;
                        lineSell = r.unitSell;
                    } else {
                        lineCost = r.qty * mult * r.unitCost;
                        lineSell = r.qty * mult * r.unitSell;
                    }
                    var markupPct = lineCost > 0 ? ((lineSell - lineCost) / lineCost * 100) : 0;
                    var mClass = markupPct > 30 ? ' high' : markupPct < 20 ? ' low' : '';

                    // Length display
                    var lenStr = '\u2014';
                    if (r.length > 0 && r.unit !== 'sqm' && r.unit !== 'each') {
                        lenStr = Math.round(r.length * 1000) + 'mm';
                    }

                    // Qty with nesting tooltip
                    var tip = pmNestingTooltip(r);
                    var qtyStr = r.qty + '\u00D7';
                    if (tip) qtyStr = '<span title="' + tip.replace(/"/g, '&quot;') + '" style="cursor:help;border-bottom:1px dotted var(--sw-text-sec)">' + qtyStr + '</span>';

                    html += '<tr>' +
                        '<td>' + pmItemName(r.desc) + '</td>' +
                        '<td style="font-size:10px;font-family:\'SF Mono\',monospace">' + pmSize(r.desc) + '</td>' +
                        '<td class="r" style="font-weight:600;color:var(--sw-orange)">' + qtyStr + '</td>' +
                        '<td class="r">' + lenStr + '</td>' +
                        '<td style="font-size:10px;color:var(--sw-text-sec)">' + pmColour(r.desc) + '</td>' +
                        '<td class="r cost-cell">$' + lineCost.toFixed(0) + '</td>' +
                        '<td class="r"><input type="number" class="pm-sell-input" value="' + lineSell.toFixed(0) + '" min="0" step="5" onchange="updatePmSell(' + i + ',this.value)"></td>' +
                        '<td class="r"><span class="markup-badge' + mClass + '">' + markupPct.toFixed(0) + '%</span></td>' +
                        '<td><button class="pm-dupe-btn" onclick="dupeToAdditional(' + i + ')" title="Duplicate to Additional Materials">&#8853;</button></td>' +
                        '</tr>';
                });
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function updatePmSell(idx, val) {
            var r = jobRows[idx];
            if (!r) return;
            var newSell = parseFloat(val) || 0;
            if (r.unit === 'nested') {
                r.unitSell = newSell;
            } else {
                var mult = (r.unit === 'LM') ? r.length : 1;
                var totalQty = r.qty * mult;
                r.unitSell = totalQty > 0 ? newSell / totalQty : 0;
            }
            updatePricing();
        }

        // ==================== ADDITIONAL MATERIALS ====================
        var additionalMaterials = [];

        function dupeToAdditional(jobRowIdx) {
            var r = jobRows[jobRowIdx];
            if (!r) return;
            var mult = (r.unit === 'LM') ? r.length : 1;
            var lineCost, lineSell;
            if (r.unit === 'nested') { lineCost = r.unitCost; lineSell = r.unitSell; }
            else { lineCost = r.qty * mult * r.unitCost; lineSell = r.qty * mult * r.unitSell; }
            additionalMaterials.push({ desc: r.desc, qty: 1, unitCost: Math.round(lineCost), unitSell: Math.round(lineSell) });
            renderAdditionalMaterials();
            updatePricing();
            // Flash the additional materials section briefly
            var amSec = document.getElementById('additionalMaterialsTable');
            if (amSec) { amSec.style.outline = '2px solid var(--sw-orange)'; setTimeout(function() { amSec.style.outline = ''; }, 800); }
        }

        function addAdditionalMaterial(prefill) {
            var m = { desc: '', qty: 1, unitCost: 0, unitSell: 0 };
            if (prefill) { m.desc = prefill.desc || ''; m.qty = prefill.qty || 1; m.unitCost = prefill.unitCost || 0; m.unitSell = prefill.unitSell || 0; }
            additionalMaterials.push(m);
            renderAdditionalMaterials();
            updatePricing();
        }

        function removeAdditionalMaterial(idx) {
            additionalMaterials.splice(idx, 1);
            renderAdditionalMaterials();
            updatePricing();
        }

        function quickAddMaterial(type) {
            var sd = getSettingsDefaults();
            var mk = (sd.markup || 35) / 100 + 1;
            var presets = {
                electrical: { desc: 'Electrical - ', qty: 1, unitCost: sd.scopeElectrical || 0, unitSell: Math.round((sd.scopeElectrical || 0) * mk) },
                post:       { desc: 'Additional post - 90\u00D790\u00D72 SHS', qty: 1, unitCost: 120, unitSell: Math.round(120 * mk) },
                skip:       { desc: 'Skip bin hire', qty: 1, unitCost: sd.scopeSkip || 350, unitSell: Math.round((sd.scopeSkip || 350) * mk) },
                permit:     { desc: 'Council permit application', qty: 1, unitCost: sd.scopePermit || 350, unitSell: Math.round((sd.scopePermit || 350) * mk) },
                other:      { desc: '', qty: 1, unitCost: 0, unitSell: 0 }
            };
            var p = presets[type] || presets.other;
            addAdditionalMaterial(p);
            // Focus the description field of the newly added row
            setTimeout(function() {
                var inputs = document.querySelectorAll('#additionalMaterialsTable .am-table input[type="text"]');
                if (inputs.length > 0) inputs[inputs.length - 1].focus();
            }, 50);
        }

        function ensureMinAdditionalRows() {
            // Ensure at least 5 visible rows in the table
            var minRows = 5;
            while (additionalMaterials.length < minRows) {
                additionalMaterials.push({ desc: '', qty: 1, unitCost: 0, unitSell: 0 });
            }
            // Auto-add row if last row has content
            var last = additionalMaterials[additionalMaterials.length - 1];
            if (last && (last.desc || last.unitCost > 0 || last.unitSell > 0)) {
                additionalMaterials.push({ desc: '', qty: 1, unitCost: 0, unitSell: 0 });
            }
        }

        function renderAdditionalMaterials() {
            var container = document.getElementById('additionalMaterialsTable');
            if (!container) return;

            ensureMinAdditionalRows();

            var html = '<table class="am-table"><thead><tr><th>Description</th><th class="r">Qty</th><th class="r">Cost</th><th class="r">Sell</th><th style="width:20px"></th></tr></thead><tbody>';
            additionalMaterials.forEach(function(m, i) {
                var isEmpty = !m.desc && m.unitCost === 0 && m.unitSell === 0;
                html += '<tr class="' + (isEmpty ? 'am-empty-row' : '') + '">' +
                    '<td><input type="text" data-am-idx="' + i + '" data-am-col="0" value="' + (m.desc || '').replace(/"/g, '&quot;') + '" placeholder="Item description" oninput="amCellUpdate(' + i + ',\'desc\',this.value)" onkeydown="amTabNav(event,' + i + ',0)"></td>' +
                    '<td><input type="number" data-am-idx="' + i + '" data-am-col="1" value="' + m.qty + '" min="1" step="1" style="width:50px" oninput="amCellUpdate(' + i + ',\'qty\',this.value)" onkeydown="amTabNav(event,' + i + ',1)"></td>' +
                    '<td><input type="number" data-am-idx="' + i + '" data-am-col="2" value="' + (m.qty * m.unitCost > 0 ? (m.qty * m.unitCost).toFixed(0) : '') + '" min="0" step="5" placeholder="0" oninput="amCellUpdate(' + i + ',\'cost\',this.value)" onkeydown="amTabNav(event,' + i + ',2)"></td>' +
                    '<td><input type="number" data-am-idx="' + i + '" data-am-col="3" value="' + (m.qty * m.unitSell > 0 ? (m.qty * m.unitSell).toFixed(0) : '') + '" min="0" step="5" placeholder="0" oninput="amCellUpdate(' + i + ',\'sell\',this.value)" onkeydown="amTabNav(event,' + i + ',3)"></td>' +
                    '<td><button class="am-del" onclick="removeAdditionalMaterial(' + i + ')" title="Remove">&times;</button></td>' +
                    '</tr>';
            });
            html += '</tbody></table>';
            container.innerHTML = html;

            // Show subtotal if any real rows
            var hasReal = additionalMaterials.some(function(m) { return m.desc || m.unitCost > 0 || m.unitSell > 0; });
            var sub = document.getElementById('addMatSubtotal');
            if (sub) sub.style.display = hasReal ? '' : 'none';
        }

        function amCellUpdate(idx, field, val) {
            var m = additionalMaterials[idx];
            if (!m) return;
            if (field === 'desc') { m.desc = val; }
            else if (field === 'qty') { m.qty = parseFloat(val) || 1; }
            else if (field === 'cost') { m.unitCost = (parseFloat(val) || 0) / (m.qty || 1); }
            else if (field === 'sell') { m.unitSell = (parseFloat(val) || 0) / (m.qty || 1); }
            // Auto-add row if typing in last row
            if (idx === additionalMaterials.length - 1 && (m.desc || m.unitCost > 0 || m.unitSell > 0)) {
                additionalMaterials.push({ desc: '', qty: 1, unitCost: 0, unitSell: 0 });
                // Re-render but try to preserve focus
                var activeEl = document.activeElement;
                var activeIdx = activeEl ? activeEl.getAttribute('data-am-idx') : null;
                var activeCol = activeEl ? activeEl.getAttribute('data-am-col') : null;
                renderAdditionalMaterials();
                if (activeIdx !== null && activeCol !== null) {
                    var target = document.querySelector('#additionalMaterialsTable input[data-am-idx="' + activeIdx + '"][data-am-col="' + activeCol + '"]');
                    if (target) target.focus();
                }
            }
            updatePricing();
        }

        function amTabNav(e, rowIdx, colIdx) {
            if (e.key !== 'Tab') return;
            var maxCol = 3;
            var nextRow = rowIdx, nextCol = colIdx;
            if (e.shiftKey) {
                // Shift+Tab: go back
                nextCol--;
                if (nextCol < 0) { nextCol = maxCol; nextRow--; }
            } else {
                // Tab: go forward
                nextCol++;
                if (nextCol > maxCol) { nextCol = 0; nextRow++; }
            }
            if (nextRow < 0 || nextRow >= additionalMaterials.length) return; // let default browser behavior handle
            var target = document.querySelector('#additionalMaterialsTable input[data-am-idx="' + nextRow + '"][data-am-col="' + nextCol + '"]');
            if (target) { e.preventDefault(); target.focus(); target.select(); }
        }

        // ==================== MAIN PRICING UPDATE ====================
        function updatePricing() {
            const fmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            const fmtShort = v => '$' + Math.round(v).toLocaleString();

            // Render the patio materials table
            renderPatioMaterialsTable();
            renderAdditionalMaterials();

            // Materials from jobRows
            let matCost = 0, matSell = 0;
            jobRows.forEach(r => {
                if (r.unit === 'nested') {
                    matCost += r.unitCost;
                    matSell += r.unitSell;
                } else {
                    const mult = (r.unit === 'LM') ? r.length : 1;
                    matCost += r.qty * mult * r.unitCost;
                    matSell += r.qty * mult * r.unitSell;
                }
            });

            // Patio materials subtotal display
            const matMarkup = matCost > 0 ? ((matSell - matCost) / matCost * 100) : 0;
            var matSellEl = document.getElementById('matSellDisplay');
            if (matSellEl) matSellEl.textContent = fmtShort(matSell);
            var matCostEl = document.getElementById('matCostDisplay');
            if (matCostEl) matCostEl.textContent = fmtShort(matCost);
            var matMkEl = document.getElementById('matMarkupPct');
            if (matMkEl) matMkEl.textContent = matMarkup.toFixed(0) + '%';

            // Additional materials (only count rows with actual data)
            let addMatCost = 0, addMatSell = 0;
            additionalMaterials.forEach(r => {
                if (r.desc || r.unitCost > 0 || r.unitSell > 0) {
                    addMatCost += r.qty * r.unitCost;
                    addMatSell += r.qty * r.unitSell;
                }
            });
            var hasRealAddMat = additionalMaterials.some(function(r) { return r.desc || r.unitCost > 0 || r.unitSell > 0; });
            var addMatSubEl = document.getElementById('addMatSubtotal');
            if (addMatSubEl) addMatSubEl.style.display = hasRealAddMat ? '' : 'none';
            var addMatSellEl = document.getElementById('addMatSellDisplay');
            if (addMatSellEl) addMatSellEl.textContent = fmtShort(addMatSell);
            var addMatCostEl = document.getElementById('addMatCostDisplay');
            if (addMatCostEl) addMatCostEl.textContent = fmtShort(addMatCost);

            // Labour from card inputs
            const lab = getLabourFromCard();
            const labCost = lab.cost;
            const labSell = lab.sell;
            var labCostEl = document.getElementById('labCostDisplay');
            if (labCostEl) labCostEl.textContent = fmtShort(labCost);
            var labSellEl = document.getElementById('labSellDisplay');
            if (labSellEl) labSellEl.textContent = fmtShort(labSell);
            syncLabourRows();

            // Scope items (extras)
            let extrasCost = 0, extrasSell = 0;
            extrasRows.forEach(r => {
                extrasCost += r.qty * r.unitCost;
                extrasSell += r.qty * r.unitSell;
            });
            var scopeSubEl = document.getElementById('scopeSubtotal');
            if (scopeSubEl) scopeSubEl.style.display = extrasRows.length > 0 ? '' : 'none';
            var scopeSellEl = document.getElementById('scopeSellDisplay');
            if (scopeSellEl) scopeSellEl.textContent = fmtShort(extrasSell);

            // Demo cost
            const demoCost = calculateDemoCost();

            // Totals (include additional materials)
            const totalCost = matCost + addMatCost + labCost + extrasCost + demoCost;
            const totalSell = matSell + addMatSell + labSell + extrasSell + demoCost;
            const gst = totalSell * 0.10;
            const totalIncGST = totalSell + gst;
            const margin = totalSell - totalCost;
            const marginPct = totalSell > 0 ? (margin / totalSell * 100) : 0;

            // Totals table
            var ttEl = function(id, val) { var el = document.getElementById(id); if (el) el.textContent = fmtShort(val); };
            ttEl('ttMatCost', matCost); ttEl('ttMatSell', matSell);
            ttEl('ttAddCost', addMatCost); ttEl('ttAddSell', addMatSell);
            var ttAddRow = document.getElementById('ttAddRow');
            if (ttAddRow) ttAddRow.style.display = hasRealAddMat ? '' : 'none';
            ttEl('ttScopeCost', extrasCost + demoCost); ttEl('ttScopeSell', extrasSell + demoCost);
            var ttScopeRow = document.getElementById('ttScopeRow');
            if (ttScopeRow) ttScopeRow.style.display = (extrasSell + demoCost) > 0 ? '' : 'none';
            ttEl('ttLabCost', labCost); ttEl('ttLabSell', labSell);
            ttEl('ttSubCost', totalCost); ttEl('ttSubSell', totalSell);
            ttEl('ttGst', gst); ttEl('ttTotal', totalIncGST);
            var ttMarginEl = document.getElementById('ttMargin');
            if (ttMarginEl) {
                ttMarginEl.textContent = fmtShort(margin) + ' (' + marginPct.toFixed(1) + '%)';
                ttMarginEl.style.color = marginPct > 20 ? '#34C759' : marginPct >= 10 ? '#FF9500' : '#FF3B30';
            }

            // Total card + breakdown
            document.getElementById('totalAmountDisplay').textContent = 'TOTAL ' + fmtShort(totalIncGST) + ' inc GST';
            var bdMatEl = document.getElementById('bdMatVal');
            if (bdMatEl) bdMatEl.textContent = fmtShort(matSell);
            var bdAddEl = document.getElementById('bdAddVal');
            if (bdAddEl) { bdAddEl.textContent = fmtShort(addMatSell); bdAddEl.parentElement.style.display = addMatSell > 0 ? '' : 'none'; }
            var bdScopeEl = document.getElementById('bdScopeVal');
            if (bdScopeEl) { bdScopeEl.textContent = fmtShort(extrasSell + demoCost); bdScopeEl.parentElement.style.display = (extrasSell + demoCost) > 0 ? '' : 'none'; }
            var bdLabEl = document.getElementById('bdLabVal');
            if (bdLabEl) bdLabEl.textContent = fmtShort(labSell);

            // Sticky price card in right panel
            var rpPT = document.getElementById('rpPriceTotal');
            if (rpPT) rpPT.textContent = fmtShort(totalIncGST) + ' inc GST';
            // Sticky margin
            var rpMg = document.getElementById('rpPriceMargin');
            if (rpMg) {
                rpMg.textContent = fmtShort(margin) + ' margin (' + marginPct.toFixed(0) + '%)';
                rpMg.style.color = marginPct > 20 ? '#34C759' : marginPct >= 10 ? '#FF9500' : '#FF3B30';
            }
            // Sticky breakdown
            var allMatSell = matSell + addMatSell;
            var rpBdMat = document.getElementById('rpBdMat');
            if (rpBdMat) rpBdMat.textContent = fmtShort(allMatSell);
            var rpBdLab = document.getElementById('rpBdLab');
            if (rpBdLab) rpBdLab.textContent = fmtShort(labSell);
            var rpBdScopeRow = document.getElementById('rpBdScopeRow');
            var rpBdScope = document.getElementById('rpBdScope');
            if (rpBdScopeRow) rpBdScopeRow.style.display = (extrasSell + demoCost) > 0 ? '' : 'none';
            if (rpBdScope) rpBdScope.textContent = fmtShort(extrasSell + demoCost);
            var rpBdSub = document.getElementById('rpBdSubtotal');
            if (rpBdSub) rpBdSub.textContent = fmtShort(totalSell);
            var rpBdGst = document.getElementById('rpBdGst');
            if (rpBdGst) rpBdGst.textContent = fmtShort(gst);

            const marginEl = document.getElementById('totalMarginDisplay');
            const marginIcon = marginPct > 20 ? '  \u2713' : marginPct >= 10 ? '' : '  \u2717';
            marginEl.textContent = 'Margin ' + fmtShort(margin) + ' (' + marginPct.toFixed(1) + '%)' + marginIcon;
            if (marginPct > 20) {
                marginEl.className = 'total-margin margin-green';
            } else if (marginPct >= 10) {
                marginEl.className = 'total-margin margin-orange';
            } else {
                marginEl.className = 'total-margin margin-red';
            }

            // Cache pricing state for PDF generators
            pricingState = {
                matCost, matSell, addMatCost, addMatSell, labCost, labSell, extrasCost, extrasSell,
                totalCost, totalSell, gst, totalIncGST, margin, marginPct,
                fmt
            };
        }

        // ==================== COLLAPSIBLE SECTIONS ====================
        const SECTION_IDS = ['sec-job', 'sec-design', 'sec-structure', 'sec-truss', 'sec-battens', 'sec-finishing', 'sec-extras', 'sec-pricing', 'sec-notes'];
        const DEFAULT_COLLAPSED = ['sec-design', 'sec-structure', 'sec-truss', 'sec-battens', 'sec-finishing', 'sec-extras', 'sec-notes', 'sec-pricing'];

        function loadCollapseState() {
            try {
                const saved = localStorage.getItem('patioCollapseState');
                return saved ? JSON.parse(saved) : null;
            } catch(e) { return null; }
        }

        function saveCollapseState() {
            const state = {};
            SECTION_IDS.forEach(id => {
                const hdr = document.querySelector('#' + id + ' > .collapse-header');
                if (hdr) state[id] = hdr.classList.contains('collapsed');
            });
            localStorage.setItem('patioCollapseState', JSON.stringify(state));
        }

        function toggleSection(id) {
            const sec = document.getElementById(id);
            if (!sec) return;
            const hdr = sec.querySelector('.collapse-header');
            const body = sec.querySelector('.collapse-body');
            if (!hdr || !body) return;
            const isCollapsed = hdr.classList.contains('collapsed');
            if (isCollapsed) {
                // Expand
                hdr.classList.remove('collapsed');
                body.style.maxHeight = body.scrollHeight + 'px';
                body.classList.remove('shut');
                setTimeout(() => {
                    body.style.maxHeight = '';
                    if (id === 'sec-truss') { resizeTruss(); if (trussRend) trussRend.render(trussScene, trussCam); }
                    if (id === 'sec-flashings') { updateFlashSummary(); }
                }, 350);
            } else {
                // Collapse
                body.style.maxHeight = body.scrollHeight + 'px';
                requestAnimationFrame(() => {
                    body.style.maxHeight = '0';
                    body.classList.add('shut');
                    hdr.classList.add('collapsed');
                });
            }
            saveCollapseState();
        }

        function initCollapseSections() {
            const saved = loadCollapseState();
            SECTION_IDS.forEach(id => {
                const sec = document.getElementById(id);
                if (!sec) return;
                const hdr = sec.querySelector('.collapse-header');
                const body = sec.querySelector('.collapse-body');
                if (!hdr || !body) return;
                const shouldCollapse = saved ? saved[id] : DEFAULT_COLLAPSED.includes(id);
                if (shouldCollapse) {
                    hdr.classList.add('collapsed');
                    body.classList.add('shut');
                    body.style.maxHeight = '0';
                } else {
                    hdr.classList.remove('collapsed');
                    body.classList.remove('shut');
                }
            });
        }

        // ==================== EDGE PANNING ====================
        function setupEdgePanning2D(canvas, panState, redrawFn) {
            var edgeThreshold = 50;
            var maxPanSpeed = 8;
            var animationId = null;

            function updatePan() {
                if (!panState.isHovering) return;
                var rect = canvas.getBoundingClientRect();
                var mouseX = panState.mouseX - rect.left;
                var mouseY = panState.mouseY - rect.top;
                var panX = 0, panY = 0;

                if (mouseX >= 0 && mouseX < edgeThreshold) {
                    panX = maxPanSpeed * (1 - mouseX / edgeThreshold);
                }
                if (mouseX > rect.width - edgeThreshold && mouseX <= rect.width) {
                    panX = -maxPanSpeed * (1 - (rect.width - mouseX) / edgeThreshold);
                }
                if (mouseY >= 0 && mouseY < edgeThreshold) {
                    panY = maxPanSpeed * (1 - mouseY / edgeThreshold);
                }
                if (mouseY > rect.height - edgeThreshold && mouseY <= rect.height) {
                    panY = -maxPanSpeed * (1 - (rect.height - mouseY) / edgeThreshold);
                }

                if (panX !== 0 || panY !== 0) {
                    panState.offsetX += panX;
                    panState.offsetY += panY;
                    if (redrawFn) redrawFn();
                }

                animationId = requestAnimationFrame(updatePan);
            }

            canvas.addEventListener('mouseenter', function() {
                panState.isHovering = true;
                updatePan();
            });
            canvas.addEventListener('mouseleave', function() {
                panState.isHovering = false;
                if (animationId) cancelAnimationFrame(animationId);
                animationId = null;
            });
            canvas.addEventListener('mousemove', function(e) {
                panState.mouseX = e.clientX;
                panState.mouseY = e.clientY;
            });
        }

        function setupEdgePanning3D(container, camera, controls) {
            var edgeThreshold = 50;
            var maxRotateSpeed = 0.02;
            var animationId = null;
            var mouseX = 0, mouseY = 0;
            var isHovering = false;

            function updatePan() {
                if (!isHovering) return;
                var rect = container.getBoundingClientRect();
                var localX = mouseX - rect.left;
                var localY = mouseY - rect.top;
                var rotateH = 0, rotateV = 0;

                if (localX >= 0 && localX < edgeThreshold) {
                    rotateH = maxRotateSpeed * (1 - localX / edgeThreshold);
                }
                if (localX > rect.width - edgeThreshold && localX <= rect.width) {
                    rotateH = -maxRotateSpeed * (1 - (rect.width - localX) / edgeThreshold);
                }
                if (localY >= 0 && localY < edgeThreshold) {
                    rotateV = maxRotateSpeed * (1 - localY / edgeThreshold);
                }
                if (localY > rect.height - edgeThreshold && localY <= rect.height) {
                    rotateV = -maxRotateSpeed * (1 - (rect.height - localY) / edgeThreshold);
                }

                if ((rotateH !== 0 || rotateV !== 0) && controls && camera) {
                    var spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position.clone().sub(controls.target));
                    spherical.theta += rotateH;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + rotateV));
                    camera.position.setFromSpherical(spherical).add(controls.target);
                    camera.lookAt(controls.target);
                }

                animationId = requestAnimationFrame(updatePan);
            }

            container.addEventListener('mouseenter', function() {
                isHovering = true;
                updatePan();
            });
            container.addEventListener('mouseleave', function() {
                isHovering = false;
                if (animationId) cancelAnimationFrame(animationId);
                animationId = null;
            });
            container.addEventListener('mousemove', function(e) {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
        }

        // ==================== FLASHING PROFILE EDITOR ====================
        let flashingProfiles = [];
        let flashingTemplates = [];
        let flashCurrentPoints = [];
        let flashUndoStack = [];
        // flashTool removed - unified interaction model (pan=click-drag, add point=dbl-click)
        let flashColourSide = 'inside';
        let flashDrawing = false; // legacy compat â€” use flashMode instead
        let flashMode = 'viewing'; // 'viewing' | 'extending' | 'selected'
        let flashSelectedSeg = -1; // selected segment index
        let flashPanOffset = { x: 0, y: 0 };
        let flashZoomLevel = 10; // mm per grid square
        let flashSelectedIdx = -1;
        let flashSelectedLeg = -1;
        let flashEditingId = null;
        let flashDragging = false;
        let flashDragStart = { x: 0, y: 0 };
        let flashPanStart = { x: 0, y: 0 };
        let flashHoverPoint = -1;
        let flashMouseMM = { x: 0, y: 0 };
        let flashSnapAngle = false;
        let flashAutoSnap = false;
        let flashNextId = 1;
        let flashStartTreatment = null; // null or { type: 'miniBreak', size: 10, angle: 45, direction: 'out' } or { type: 'hem' }
        let flashEndTreatment = null;

        const FLASH_GAUGES = [0.42, 0.48, 0.55];

        const FLASH_DEFAULT_TEMPLATES = [
            // Skillion / Flat Roof
            { name: 'Barge', folder: 'Skillion / Flat', points: [{x:0,y:0},{x:0,y:30},{x:15,y:45},{x:15,y:200},{x:165,y:200}], colourSide: 'inside' },
            { name: 'Apron', folder: 'Skillion / Flat', points: [{x:0,y:0},{x:0,y:100},{x:270,y:100},{x:270,y:180}], colourSide: 'inside' },
            // Gable Roof
            { name: 'Barge', folder: 'Gable', points: [{x:0,y:0},{x:0,y:30},{x:15,y:45},{x:15,y:200},{x:165,y:200}], colourSide: 'inside' },
            { name: 'Ridge Cap (Trimdek)', folder: 'Gable', points: [{x:0,y:150},{x:150,y:0},{x:300,y:150}], colourSide: 'inside' },
            { name: 'Ridge Cap (Corrugated)', folder: 'Gable', points: [{x:0,y:140},{x:140,y:0},{x:280,y:140}], colourSide: 'inside' },
            // SolarSpan 50mm
            { name: 'Barge', folder: 'SolarSpan 50mm', points: [{x:0,y:0},{x:0,y:50},{x:60,y:50},{x:60,y:0}], colourSide: 'inside' },
            { name: 'Gutter Flashing', folder: 'SolarSpan 50mm', points: [{x:0,y:0},{x:0,y:50},{x:80,y:50},{x:80,y:130}], colourSide: 'inside' },
            { name: 'Top Flashing', folder: 'SolarSpan 50mm', points: [{x:0,y:0},{x:0,y:50},{x:200,y:50},{x:200,y:130}], colourSide: 'inside' },
            { name: 'Receiver Channel', folder: 'SolarSpan 50mm', points: [{x:0,y:0},{x:0,y:50},{x:25,y:50},{x:25,y:0}], colourSide: 'inside' },
            // SolarSpan 75mm
            { name: 'Barge', folder: 'SolarSpan 75mm', points: [{x:0,y:0},{x:0,y:75},{x:60,y:75},{x:60,y:0}], colourSide: 'inside' },
            { name: 'Gutter Flashing', folder: 'SolarSpan 75mm', points: [{x:0,y:0},{x:0,y:75},{x:80,y:75},{x:80,y:155}], colourSide: 'inside' },
            { name: 'Top Flashing', folder: 'SolarSpan 75mm', points: [{x:0,y:0},{x:0,y:75},{x:200,y:75},{x:200,y:155}], colourSide: 'inside' },
            { name: 'Receiver Channel', folder: 'SolarSpan 75mm', points: [{x:0,y:0},{x:0,y:75},{x:25,y:75},{x:25,y:0}], colourSide: 'inside' },
            // SolarSpan 100mm
            { name: 'Barge', folder: 'SolarSpan 100mm', points: [{x:0,y:0},{x:0,y:100},{x:60,y:100},{x:60,y:0}], colourSide: 'inside' },
            { name: 'Gutter Flashing', folder: 'SolarSpan 100mm', points: [{x:0,y:0},{x:0,y:100},{x:80,y:100},{x:80,y:180}], colourSide: 'inside' },
            { name: 'Top Flashing', folder: 'SolarSpan 100mm', points: [{x:0,y:0},{x:0,y:100},{x:200,y:100},{x:200,y:180}], colourSide: 'inside' },
            { name: 'Receiver Channel', folder: 'SolarSpan 100mm', points: [{x:0,y:0},{x:0,y:100},{x:25,y:100},{x:25,y:0}], colourSide: 'inside' },
            // Custom
            { name: 'Blank', folder: 'Custom', points: [], colourSide: 'inside' }
        ];

        function initFlashingEditor() {
            // Load saved templates from localStorage or use defaults
            var saved = localStorage.getItem('flashingTemplates');
            if (saved) {
                try { flashingTemplates = JSON.parse(saved); } catch(e) { flashingTemplates = []; }
            }
            // Ensure defaults always present (match by name+folder)
            FLASH_DEFAULT_TEMPLATES.forEach(function(dt) {
                if (!flashingTemplates.find(function(t) { return t.name === dt.name && t.folder === dt.folder; })) {
                    flashingTemplates.push(JSON.parse(JSON.stringify(dt)));
                }
            });

            renderFlashTemplates();
            renderFlashJobTable();
        }

        let flashModalOpen = false;
        let flashCanvasInited = false;
        let flashIsPanning = false; // true when a click-drag pan is active (not point drag)

        var flashResizeObserver = null;
        function openFlashModal() {
            var overlay = document.getElementById('flashModalOverlay');
            if (!overlay) return;
            overlay.classList.add('open');
            flashModalOpen = true;
            if (!flashCanvasInited) {
                setupFlashCanvas();
                flashCanvasInited = true;
                // Watch for viewport resizes inside modal
                if (typeof ResizeObserver !== 'undefined') {
                    var vp = document.getElementById('flashViewport');
                    if (vp) {
                        flashResizeObserver = new ResizeObserver(function() {
                            if (flashModalOpen) { resizeFlashCanvas(); drawFlashCanvas(); }
                        });
                        flashResizeObserver.observe(vp);
                    }
                }
            }
            setTimeout(function() {
                resizeFlashCanvas();
                drawFlashCanvas();
            }, 50);
        }

        function closeFlashModal() {
            var overlay = document.getElementById('flashModalOverlay');
            if (!overlay) return;
            overlay.classList.remove('open');
            flashModalOpen = false;
            updateFlashSummary();
        }

        // ---- Tab switching ----
        function switchFlashTab(tab) {
            var stdBody = document.getElementById('flashBodyStandard');
            var bgBody = document.getElementById('flashBodyBoxGutter');
            var stdTab = document.getElementById('flashTabStandard');
            var bgTab = document.getElementById('flashTabBoxGutter');
            if (tab === 'boxgutter') {
                if (stdBody) stdBody.style.display = 'none';
                if (bgBody) bgBody.style.display = 'flex';
                if (stdTab) stdTab.classList.remove('active');
                if (bgTab) bgTab.classList.add('active');
                updateBGDesigner();
            } else {
                if (stdBody) stdBody.style.display = '';
                if (bgBody) bgBody.style.display = 'none';
                if (stdTab) stdTab.classList.add('active');
                if (bgTab) bgTab.classList.remove('active');
                setTimeout(function() { resizeFlashCanvas(); drawFlashCanvas(); }, 50);
            }
        }

        function openFlashModalBoxGutter() {
            openFlashModal();
            switchFlashTab('boxgutter');
            // Sync catchment from main form
            var mainCatch = document.getElementById('inBoxGutterCatchment');
            var bgCatch = document.getElementById('bgCatchment');
            if (mainCatch && bgCatch) bgCatch.value = mainCatch.value;
            // Auto-fill length from patio length
            var patioLen = parseInt(document.getElementById('inLength')?.value) || 6000;
            var bgLen = document.getElementById('bgLength');
            if (bgLen) bgLen.value = patioLen + 200;
            updateBGDesigner();
        }

        // ---- Box Gutter calculations (AS/NZS 3500.3) ----
        function calculateBoxGutterWidth(catchmentM2) {
            var intensity = 207; // Perth mm/h
            var flowRequired = (catchmentM2 * intensity) / 3600;
            var designFlow = Math.max(flowRequired, 3.0);
            if (designFlow <= 3.0) return 250;
            if (designFlow <= 5.0) return 300;
            if (designFlow <= 7.0) return 350;
            if (designFlow <= 10.0) return 400;
            if (designFlow <= 14.0) return 450;
            return null; // exceeds standard
        }

        function updateBGDesigner() {
            var catchEl = document.getElementById('bgCatchment');
            var patioCatchEl = document.getElementById('bgPatioCatch');
            if (!catchEl) return;
            var houseCatch = parseFloat(catchEl.value) || 85;
            var addPatio = patioCatchEl && patioCatchEl.value === 'yes';
            var patioCatch = 0;
            if (addPatio) {
                var pw = parseFloat(document.getElementById('inWidth')?.value) || 4000;
                var pl = parseFloat(document.getElementById('inLength')?.value) || 6000;
                patioCatch = Math.round((pw / 1000) * (pl / 1000));
            }
            var totalCatch = houseCatch + patioCatch;
            var summaryEl = document.getElementById('bgCatchSummary');
            if (summaryEl) summaryEl.textContent = 'Total catchment: ' + totalCatch + ' m\u00B2' + (addPatio ? ' (' + houseCatch + ' house + ' + patioCatch + ' patio)' : '');

            var recWidth = calculateBoxGutterWidth(totalCatch);
            var widthRecEl = document.getElementById('bgWidthRec');
            var warnEl = document.getElementById('bgCatchWarn');
            if (recWidth) {
                if (widthRecEl) widthRecEl.textContent = 'Minimum width required: ' + recWidth + 'mm (per AS/NZS 3500.3)';
                if (warnEl) warnEl.style.display = 'none';
                // Auto-set width if user hasn't manually changed it
                var widthEl = document.getElementById('bgWidth');
                if (widthEl && parseInt(widthEl.value) < recWidth) widthEl.value = recWidth;
            } else {
                if (widthRecEl) widthRecEl.textContent = 'Exceeds standard box gutter capacity';
                if (warnEl) { warnEl.textContent = '\u26A0 Catchment exceeds 243m\u00B2 \u2014 engineering review required'; warnEl.style.display = 'block'; }
            }

            // Dimension validation
            var dimWarn = [];
            var width = parseInt(document.getElementById('bgWidth')?.value) || 300;
            var depth = parseInt(document.getElementById('bgDepth')?.value) || 100;
            var backH = parseInt(document.getElementById('bgBackH')?.value) || 70;
            var frontH = parseInt(document.getElementById('bgFrontH')?.value) || 130;
            if (width < 250) dimWarn.push('Width below minimum 250mm');
            if (recWidth && width < recWidth) dimWarn.push('Width ' + width + 'mm may be undersized for ' + totalCatch + 'm\u00B2 catchment (need ' + recWidth + 'mm)');
            if (depth < 75) dimWarn.push('Depth below minimum 75mm for slope');
            if (frontH < depth + 25) dimWarn.push('Insufficient freeboard \u2014 front height should be at least depth + 25mm');
            if (backH !== 70) dimWarn.push('Non-standard back height \u2014 verify fit under house sheets');
            var dimWarnEl = document.getElementById('bgDimWarn');
            if (dimWarnEl) {
                if (dimWarn.length > 0) {
                    dimWarnEl.innerHTML = dimWarn.map(function(w) { return '\u26A0 ' + w; }).join('<br>');
                    dimWarnEl.style.display = 'block';
                } else {
                    dimWarnEl.style.display = 'none';
                }
            }

            drawBGPreview();
        }

        function drawBGPreview() {
            var canvas = document.getElementById('bgPreviewCanvas');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            var cw = canvas.width, ch = canvas.height;
            ctx.clearRect(0, 0, cw, ch);

            var width = parseInt(document.getElementById('bgWidth')?.value) || 300;
            var depth = parseInt(document.getElementById('bgDepth')?.value) || 100;
            var backH = parseInt(document.getElementById('bgBackH')?.value) || 70;
            var frontH = parseInt(document.getElementById('bgFrontH')?.value) || 130;

            // Scale to fit canvas with padding
            var totalW = width + 40; // extra for lip
            var totalH = Math.max(frontH, backH) + depth + 10;
            var scale = Math.min((cw - 80) / totalW, (ch - 60) / totalH);
            var ox = (cw - totalW * scale) / 2;
            var oy = ch - 30;

            // Profile points (bottom-left origin, going clockwise)
            var pts = [
                { x: 0, y: backH + depth }, // top of back wall
                { x: 0, y: depth },          // back wall meets sole
                { x: width, y: depth },      // sole front
                { x: width, y: frontH + depth }, // top of front wall
            ];

            // Draw filled channel (colour side = inside)
            ctx.fillStyle = 'rgba(232, 90, 28, 0.08)';
            ctx.beginPath();
            ctx.moveTo(ox + pts[0].x * scale, oy - pts[0].y * scale);
            for (var i = 1; i < pts.length; i++) {
                ctx.lineTo(ox + pts[i].x * scale, oy - pts[i].y * scale);
            }
            ctx.lineTo(ox + pts[3].x * scale, oy - pts[0].y * scale); // close top
            ctx.closePath();
            ctx.fill();

            // Hatching inside channel
            ctx.strokeStyle = 'rgba(232, 90, 28, 0.15)';
            ctx.lineWidth = 0.5;
            var soleY = oy - depth * scale;
            var topY = oy - Math.max(frontH, backH, depth) * scale - 10;
            for (var hx = ox + 4; hx < ox + width * scale; hx += 8) {
                ctx.beginPath();
                ctx.moveTo(hx, soleY);
                ctx.lineTo(hx, topY);
                ctx.stroke();
            }

            // Draw profile line
            ctx.strokeStyle = '#293C46';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(ox + pts[0].x * scale, oy - pts[0].y * scale);
            for (var j = 1; j < pts.length; j++) {
                ctx.lineTo(ox + pts[j].x * scale, oy - pts[j].y * scale);
            }
            ctx.stroke();

            // Dimension labels
            ctx.font = 'bold 12px Arial, sans-serif';
            ctx.textAlign = 'center';

            // Width (top)
            var dimY = oy - (Math.max(frontH, backH) + depth) * scale - 12;
            ctx.fillStyle = '#1a365d';
            ctx.fillText(width + 'mm', ox + width * scale / 2, dimY);
            // Arrows for width
            ctx.strokeStyle = '#1a365d';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(ox, dimY + 4);
            ctx.lineTo(ox + width * scale, dimY + 4);
            ctx.stroke();

            // Back height (left)
            ctx.save();
            ctx.translate(ox - 16, oy - (depth + backH / 2) * scale);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#1a365d';
            ctx.fillText(backH + 'mm', 0, 0);
            ctx.restore();

            // Front height (right)
            ctx.save();
            ctx.translate(ox + width * scale + 22, oy - (depth + frontH / 2) * scale);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#1a365d';
            ctx.fillText(frontH + 'mm', 0, 0);
            ctx.restore();

            // Depth (bottom)
            ctx.fillStyle = '#1a365d';
            ctx.fillText('depth ' + depth + 'mm', ox + width * scale / 2, oy + 16);

            // Legend
            ctx.font = '10px Arial, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(232, 90, 28, 0.5)';
            ctx.fillRect(10, 10, 12, 12);
            ctx.fillStyle = '#666';
            ctx.fillText('= Colorbond inside', 26, 20);
        }

        function bgAddToJob() {
            var width = parseInt(document.getElementById('bgWidth')?.value) || 300;
            var depth = parseInt(document.getElementById('bgDepth')?.value) || 100;
            var backH = parseInt(document.getElementById('bgBackH')?.value) || 70;
            var frontH = parseInt(document.getElementById('bgFrontH')?.value) || 130;
            var length = parseInt(document.getElementById('bgLength')?.value) || 6200;
            var gauge = parseFloat(document.getElementById('bgGauge')?.value) || 0.55;
            var colour = document.getElementById('bgColour')?.value || 'Deep Ocean';
            var outletPos = document.getElementById('bgOutletPos')?.value || 'right';
            var outletSize = document.getElementById('bgOutletSize')?.value || '100round';

            // Build profile points for the box gutter cross-section
            var pts = [
                { x: 0, y: backH + depth },
                { x: 0, y: depth },
                { x: width, y: depth },
                { x: width, y: frontH + depth }
            ];

            var girth = backH + width + frontH; // total developed width
            var legs = [
                { length: backH, angle: 90 },
                { length: width, angle: 90 },
                { length: frontH, angle: null }
            ];

            var outletLabel = outletSize.replace('round', 'mm round');
            var outletPosLabel = { left: 'left end', right: 'right end', centre: 'centre', both: 'both ends' }[outletPos] || outletPos;

            flashingProfiles.push({
                id: 'flashing_' + String(flashNextId++).padStart(3, '0'),
                name: 'Box Gutter',
                colour: colour,
                gauge: gauge,
                length: length,
                qty: 1,
                colourSide: 'inside',
                points: pts,
                girth: girth,
                legs: legs,
                startTreatment: null,
                endTreatment: null,
                isBoxGutter: true,
                boxGutterData: {
                    width: width, depth: depth, backH: backH, frontH: frontH,
                    outlet: outletPosLabel + ' \u2014 ' + outletLabel,
                    notes: 'Slope sole 1:200 toward ' + outletPosLabel
                }
            });

            renderFlashJobTable();
            updateFlashSummary();
            switchFlashTab('standard');
            alert('Box Gutter added to flashings list.');
        }

        // Update box gutter summary in main form
        function updateBoxGutterSummary() {
            var catchEl = document.getElementById('inBoxGutterCatchment');
            if (!catchEl) return;
            var catchment = parseFloat(catchEl.value) || 85;
            var recWidth = calculateBoxGutterWidth(catchment);
            var widthEl = document.getElementById('boxGutterWidthRec');
            var profileEl = document.getElementById('boxGutterProfileRec');
            var warnEl = document.getElementById('boxGutterWarn');
            if (recWidth) {
                if (widthEl) widthEl.textContent = 'Recommended width: ' + recWidth + 'mm (based on ' + catchment + 'm\u00B2 catchment)';
                if (profileEl) profileEl.textContent = 'Profile: 100mm deep \u00D7 70mm back \u00D7 ' + (recWidth > 250 ? recWidth + 30 : 130) + 'mm front';
                if (warnEl) warnEl.style.display = 'none';
            } else {
                if (widthEl) widthEl.textContent = 'Catchment exceeds standard capacity';
                if (warnEl) { warnEl.textContent = '\u26A0 Engineering review required'; warnEl.style.display = 'block'; }
            }
        }

        function updateFlashSummary() {
            var el = document.getElementById('flashSummaryCount');
            if (el) el.textContent = flashingProfiles.length;
        }

        function setupFlashCanvas() {
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;

            canvas.addEventListener('mousedown', flashMouseDown);
            canvas.addEventListener('mousemove', flashMouseMove);
            canvas.addEventListener('mouseup', flashMouseUp);
            canvas.addEventListener('dblclick', flashDblClick);
            canvas.addEventListener('wheel', flashWheel, { passive: false });
            canvas.addEventListener('contextmenu', function(e) { e.preventDefault(); });

            document.addEventListener('keydown', flashKeyDown);

            resizeFlashCanvas();
            drawFlashCanvas();
        }

        function resizeFlashCanvas() {
            var canvas = document.getElementById('flashCanvas');
            var vp = document.getElementById('flashViewport');
            if (!canvas || !vp) return;
            var w = vp.clientWidth || 600;
            var h = vp.clientHeight || 400;
            canvas.width = w;
            canvas.height = h;
        }

        // ---- Coordinate conversion ----
        function flashMMToCanvas(mx, my) {
            var canvas = document.getElementById('flashCanvas');
            var cw = canvas.width, ch = canvas.height;
            var scale = flashZoomLevel; // mm per grid cell, grid cell = 20px on screen
            var pxPerMM = 20 / scale;
            var cx = cw / 2 + flashPanOffset.x + mx * pxPerMM;
            var cy = ch / 2 + flashPanOffset.y - my * pxPerMM; // y inverted
            return { x: cx, y: cy };
        }

        function flashCanvasToMM(cx, cy) {
            var canvas = document.getElementById('flashCanvas');
            var cw = canvas.width, ch = canvas.height;
            var scale = flashZoomLevel;
            var pxPerMM = 20 / scale;
            var mx = (cx - cw / 2 - flashPanOffset.x) / pxPerMM;
            var my = -(cy - ch / 2 - flashPanOffset.y) / pxPerMM;
            return { x: mx, y: my };
        }

        function flashSnapToGrid(mm) {
            var snap = flashZoomLevel;
            return { x: Math.round(mm.x / snap) * snap, y: Math.round(mm.y / snap) * snap };
        }

        // ---- Drawing ----
        function drawFlashCanvas() {
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            var cw = canvas.width, ch = canvas.height;
            ctx.clearRect(0, 0, cw, ch);

            // Background
            ctx.fillStyle = '#FAFBFC';
            ctx.fillRect(0, 0, cw, ch);

            var pxPerMM = 20 / flashZoomLevel;
            var gridPx = 20; // grid spacing in pixels

            // Draw grid (light grey)
            ctx.strokeStyle = '#e5e5e5';
            ctx.lineWidth = 0.5;
            var startX = ((cw / 2 + flashPanOffset.x) % gridPx);
            var startY = ((ch / 2 + flashPanOffset.y) % gridPx);
            for (var gx = startX; gx < cw; gx += gridPx) {
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, ch); ctx.stroke();
            }
            for (var gy = startY; gy < ch; gy += gridPx) {
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(cw, gy); ctx.stroke();
            }

            // Heavier lines every 5 grid squares
            ctx.strokeStyle = '#D0D4DA';
            ctx.lineWidth = 0.8;
            var majorPx = gridPx * 5;
            var mjStartX = ((cw / 2 + flashPanOffset.x) % majorPx);
            var mjStartY = ((ch / 2 + flashPanOffset.y) % majorPx);
            for (var gx2 = mjStartX; gx2 < cw; gx2 += majorPx) {
                ctx.beginPath(); ctx.moveTo(gx2, 0); ctx.lineTo(gx2, ch); ctx.stroke();
            }
            for (var gy2 = mjStartY; gy2 < ch; gy2 += majorPx) {
                ctx.beginPath(); ctx.moveTo(0, gy2); ctx.lineTo(cw, gy2); ctx.stroke();
            }

            // Origin crosshair (red, subtle)
            var o = flashMMToCanvas(0, 0);
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 0.8;
            ctx.setLineDash([4, 4]);
            ctx.beginPath(); ctx.moveTo(o.x, 0); ctx.lineTo(o.x, ch); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, o.y); ctx.lineTo(cw, o.y); ctx.stroke();
            ctx.setLineDash([]);

            // Draw profile
            var pts = flashCurrentPoints;
            if (pts.length > 0) {
                // Colour side indicator (thicker line on colour side)
                drawFlashProfile(ctx, pts, true);
                // Draw end treatments (mini break / hem)
                if (flashStartTreatment && pts.length >= 2) drawEndTreatment(ctx, pts, flashStartTreatment, true);
                if (flashEndTreatment && pts.length >= 2) drawEndTreatment(ctx, pts, flashEndTreatment, false);
            }

            // Highlight selected segment (thicker, highlighted)
            if (flashSelectedSeg >= 0 && flashSelectedSeg < pts.length - 1) {
                var ssa = pts[flashSelectedSeg], ssb = pts[flashSelectedSeg + 1];
                var sca = flashMMToCanvas(ssa.x, ssa.y);
                var scb = flashMMToCanvas(ssb.x, ssb.y);
                ctx.strokeStyle = '#F15A29';
                ctx.lineWidth = 5;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(sca.x, sca.y);
                ctx.lineTo(scb.x, scb.y);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Ghost preview line from last point to cursor (EXTEND MODE)
            if (flashMode === 'extending' && pts.length > 0 && !flashIsPanning) {
                var lastPt = pts[pts.length - 1];
                var lp = flashMMToCanvas(lastPt.x, lastPt.y);
                var previewMM = flashSnapToGrid(flashMouseMM);
                var isSnapped = false;
                if (flashSnapAngle || flashAutoSnap) {
                    var unsnapped = previewMM;
                    previewMM = constrainAngle(lastPt, previewMM);
                    isSnapped = (previewMM.x !== unsnapped.x || previewMM.y !== unsnapped.y);
                }
                var mp = flashMMToCanvas(previewMM.x, previewMM.y);

                // Dashed preview line (semi-transparent)
                ctx.setLineDash([8, 5]);
                ctx.strokeStyle = isSnapped ? '#22c55e' : '#60a5fa';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath(); ctx.moveTo(lp.x, lp.y); ctx.lineTo(mp.x, mp.y); ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;

                // Preview dot
                ctx.fillStyle = isSnapped ? '#22c55e' : '#60a5fa';
                ctx.beginPath();
                ctx.arc(mp.x, mp.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Preview length pill badge
                var gdx = previewMM.x - lastPt.x;
                var gdy = previewMM.y - lastPt.y;
                var gDist = Math.round(Math.sqrt(gdx * gdx + gdy * gdy));
                if (gDist > 5) {
                    drawFlashPill(ctx, mp.x + 30, mp.y - 16, gDist + 'mm', '#1a365d', '#fff');
                }

                // Live angle badge at the bend point (if 2+ existing points)
                if (pts.length >= 2) {
                    var prevPt = pts[pts.length - 2];
                    var previewAngle = calcBendAngle(prevPt, lastPt, previewMM);
                    if (gDist > 5) {
                        var anglePill = Math.round(previewAngle) + '\u00B0';
                        var pillColor = isSnapped ? '#22c55e' : '#e85a1c';
                        // Position at the bend point, offset outward
                        var pp3 = flashMMToCanvas(prevPt.x, prevPt.y);
                        var a1 = Math.atan2(pp3.y - lp.y, pp3.x - lp.x);
                        var a2 = Math.atan2(mp.y - lp.y, mp.x - lp.x);
                        var mid = (a1 + a2) / 2;
                        // If angles are more than PI apart, flip
                        if (Math.abs(a1 - a2) > Math.PI) mid += Math.PI;
                        var badgeX = lp.x + Math.cos(mid) * 32;
                        var badgeY = lp.y + Math.sin(mid) * 32;
                        drawFlashPill(ctx, badgeX, badgeY, anglePill, pillColor, '#fff');
                    }
                }

                // Snap indicator flash
                if (isSnapped) {
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(mp.x, mp.y, 12, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }

            // Update info bar
            updateFlashInfo();
        }

        function drawFlashProfile(ctx, pts, showDims) {
            if (pts.length < 2) {
                if (pts.length === 1) {
                    var sp = flashMMToCanvas(pts[0].x, pts[0].y);
                    ctx.beginPath();
                    ctx.arc(sp.x, sp.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = var_sw_orange();
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                return;
            }

            // Draw main profile line
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            var fp = flashMMToCanvas(pts[0].x, pts[0].y);
            ctx.moveTo(fp.x, fp.y);
            for (var i = 1; i < pts.length; i++) {
                var pp = flashMMToCanvas(pts[i].x, pts[i].y);
                ctx.lineTo(pp.x, pp.y);
            }
            ctx.stroke();

            // Colour side indicator - thick coloured line offset to one side with hatching
            var csOffset = flashColourSide === 'inside' ? -6 : 6;
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3.5;
            ctx.globalAlpha = 0.55;
            ctx.beginPath();
            for (var j = 0; j < pts.length - 1; j++) {
                var a = pts[j], b = pts[j + 1];
                var ddx = b.x - a.x, ddy = b.y - a.y;
                var dl = Math.sqrt(ddx * ddx + ddy * ddy);
                if (dl === 0) continue;
                var nx = -ddy / dl * csOffset, ny = ddx / dl * csOffset;
                var pa = flashMMToCanvas(a.x, a.y);
                var pb = flashMMToCanvas(b.x, b.y);
                if (j === 0) ctx.moveTo(pa.x + nx, pa.y + ny);
                else ctx.lineTo(pa.x + nx, pa.y + ny);
                ctx.lineTo(pb.x + nx, pb.y + ny);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;

            // Hatching between profile and colour side line
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 0.6;
            ctx.globalAlpha = 0.25;
            for (var hj = 0; hj < pts.length - 1; hj++) {
                var ha = pts[hj], hb = pts[hj + 1];
                var hdx = hb.x - ha.x, hdy = hb.y - ha.y;
                var hLen = Math.sqrt(hdx * hdx + hdy * hdy);
                if (hLen === 0) continue;
                var hNx = -hdy / hLen * csOffset, hNy = hdx / hLen * csOffset;
                var hSteps = Math.max(2, Math.floor(hLen / 4));
                for (var hs = 0; hs <= hSteps; hs++) {
                    var t = hs / hSteps;
                    var hpx = ha.x + hdx * t, hpy = ha.y + hdy * t;
                    var hc = flashMMToCanvas(hpx, hpy);
                    ctx.beginPath();
                    ctx.moveTo(hc.x, hc.y);
                    ctx.lineTo(hc.x + hNx, hc.y + hNy);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;

            // "COLOUR" marker at start of profile
            var csStart = flashMMToCanvas(pts[0].x, pts[0].y);
            var csDir = flashColourSide === 'inside' ? -1 : 1;
            var csDotY = csStart.y + csDir * 14;
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(csStart.x, csDotY, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.font = 'bold 8px sans-serif';
            ctx.fillStyle = '#e74c3c';
            ctx.textAlign = 'left';
            ctx.fillText('COLOUR', csStart.x + 7, csDotY + 3);

            // Draw points â€” visible circles at each vertex
            for (var k = 0; k < pts.length; k++) {
                var pt = flashMMToCanvas(pts[k].x, pts[k].y);
                var isHover = (k === flashHoverPoint);
                var isSel = (k === flashSelectedIdx);
                var radius = isSel ? 7 : (isHover ? 5.5 : 4);
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = isSel ? var_sw_orange() : (isHover ? '#60a5fa' : '#293C46');
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = isSel ? 2 : 1.5;
                ctx.stroke();
            }

            if (!showDims) return;

            // === ALWAYS-VISIBLE DIMENSIONS (pill badges) ===
            for (var m = 0; m < pts.length - 1; m++) {
                var p1 = pts[m], p2 = pts[m + 1];
                var dx2 = p2.x - p1.x, dy2 = p2.y - p1.y;
                var legLen = Math.round(Math.sqrt(dx2 * dx2 + dy2 * dy2));
                if (legLen < 1) continue;
                var c1 = flashMMToCanvas(p1.x, p1.y);
                var c2 = flashMMToCanvas(p2.x, p2.y);
                var mx2 = (c1.x + c2.x) / 2, my2 = (c1.y + c2.y) / 2;

                // Perpendicular offset so label doesn't overlap line
                var segAngle = Math.atan2(c2.y - c1.y, c2.x - c1.x);
                var offsetPx = 16;
                var offsetX = Math.sin(segAngle) * offsetPx;
                var offsetY = -Math.cos(segAngle) * offsetPx;

                var text = legLen + 'mm';
                drawFlashPill(ctx, mx2 + offsetX, my2 + offsetY, text, '#1a365d', '#fff');

                // === ANGLE BADGES at each bend (skip near-straight bends) ===
                if (m > 0) {
                    var prev = pts[m - 1], curr = pts[m], next = pts[m + 1];
                    var ang = calcBendAngle(prev, curr, next);
                    if (ang < 175) {
                        drawFlashAngleBadge(ctx, curr, prev, next, ang);
                    }
                }
            }
            // Angle badge at last internal bend (last segment doesn't draw it in the loop)
            if (pts.length >= 3) {
                var lm = pts.length - 2;
                var lprev = pts[lm - 1], lcurr = pts[lm], lnext = pts[lm + 1];
                var lang = calcBendAngle(lprev, lcurr, lnext);
                // Already drawn in loop above for m > 0
            }
        }

        // Pill-shaped badge for dimensions
        function drawFlashPill(ctx, cx, cy, text, bgColor, textColor) {
            ctx.font = 'bold 11px Arial, sans-serif';
            var tw = ctx.measureText(text).width;
            var pw = tw + 10, ph = 18, pr = 9;
            var px = cx - pw / 2, py = cy - ph / 2;

            // Rounded rect background
            ctx.fillStyle = bgColor;
            ctx.globalAlpha = 0.88;
            ctx.beginPath();
            ctx.moveTo(px + pr, py);
            ctx.lineTo(px + pw - pr, py);
            ctx.arcTo(px + pw, py, px + pw, py + pr, pr);
            ctx.lineTo(px + pw, py + ph - pr);
            ctx.arcTo(px + pw, py + ph, px + pw - pr, py + ph, pr);
            ctx.lineTo(px + pr, py + ph);
            ctx.arcTo(px, py + ph, px, py + ph - pr, pr);
            ctx.lineTo(px, py + pr);
            ctx.arcTo(px, py, px + pr, py, pr);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;

            // Text
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.fillText(text, cx, cy + 4);
            ctx.textAlign = 'left';
        }

        // Angle badge at bends â€” pill with arc indicator
        function drawFlashAngleBadge(ctx, point, prevPoint, nextPoint, includedAngle) {
            var cp = flashMMToCanvas(point.x, point.y);
            var arcRadius = 18;

            // Calculate angles of both legs (canvas space)
            var pp2 = flashMMToCanvas(prevPoint.x, prevPoint.y);
            var np2 = flashMMToCanvas(nextPoint.x, nextPoint.y);
            var angle1 = Math.atan2(pp2.y - cp.y, pp2.x - cp.x);
            var angle2 = Math.atan2(np2.y - cp.y, np2.x - cp.x);

            // Inside of bend (shorter arc)
            var diff = angle2 - angle1;
            while (diff > Math.PI) diff -= 2 * Math.PI;
            while (diff < -Math.PI) diff += 2 * Math.PI;
            var counterclockwise = diff < 0;

            // Draw arc on the interior (short) side of the bend
            ctx.beginPath();
            ctx.arc(cp.x, cp.y, arcRadius, angle1, angle2, counterclockwise);
            ctx.strokeStyle = '#e85a1c';
            ctx.lineWidth = 1.2;
            ctx.stroke();

            // Position label at midpoint of arc, outside
            var midAngle;
            if (counterclockwise) {
                var arcSpan = angle1 - angle2;
                while (arcSpan < 0) arcSpan += 2 * Math.PI;
                midAngle = angle1 - arcSpan / 2;
            } else {
                var arcSpan2 = angle2 - angle1;
                while (arcSpan2 < 0) arcSpan2 += 2 * Math.PI;
                midAngle = angle1 + arcSpan2 / 2;
            }
            var labelRadius = arcRadius + 14;
            var labelX = cp.x + Math.cos(midAngle) * labelRadius;
            var labelY = cp.y + Math.sin(midAngle) * labelRadius;

            var angText = Math.round(includedAngle) + '\u00B0';
            drawFlashPill(ctx, labelX, labelY, angText, '#e85a1c', '#fff');
        }

        function var_sw_orange() { return '#F15A29'; }

        // Generate profile dimension string: "80 Ã— 270 Ã— 100"
        function flashProfileDimString(pts) {
            if (!pts || pts.length < 2) return '--';
            var legs = calcLegs(pts);
            return legs.map(function(l) { return l.length; }).join(' \u00D7 ');
        }

        // List non-90Â° angles in profile
        function flashNon90Angles(pts) {
            if (!pts || pts.length < 3) return [];
            var result = [];
            for (var i = 1; i < pts.length - 1; i++) {
                var ang = Math.round(calcBendAngle(pts[i - 1], pts[i], pts[i + 1]));
                if (ang !== 90) {
                    result.push({ point: i + 1, angle: ang });
                }
            }
            return result;
        }

        // Format colour side for display (maps legacy 'top'/'bottom' to 'Inside'/'Outside')
        function flashColourSideLabel(cs) {
            if (cs === 'inside' || cs === 'top') return 'Inside';
            if (cs === 'outside' || cs === 'bottom') return 'Outside';
            return cs;
        }

        function calcBendAngle(a, b, c) {
            var v1x = a.x - b.x, v1y = a.y - b.y;
            var v2x = c.x - b.x, v2y = c.y - b.y;
            var dot = v1x * v2x + v1y * v2y;
            var cross = v1x * v2y - v1y * v2x;
            var angle = Math.atan2(Math.abs(cross), dot) * 180 / Math.PI;
            return angle;
        }

        function calcGirth(pts) {
            var total = 0;
            for (var i = 0; i < pts.length - 1; i++) {
                var dx = pts[i + 1].x - pts[i].x;
                var dy = pts[i + 1].y - pts[i].y;
                total += Math.sqrt(dx * dx + dy * dy);
            }
            return Math.round(total);
        }

        function calcLegs(pts) {
            var legs = [];
            for (var i = 0; i < pts.length - 1; i++) {
                var dx = pts[i + 1].x - pts[i].x;
                var dy = pts[i + 1].y - pts[i].y;
                var len = Math.round(Math.sqrt(dx * dx + dy * dy));
                var angle = null;
                if (i < pts.length - 2) {
                    angle = Math.round(calcBendAngle(pts[i], pts[i + 1], pts[i + 2]));
                }
                legs.push({ length: len, angle: angle });
            }
            return legs;
        }

        function updateFlashInfo() {
            var gEl = document.getElementById('flashGirth');
            var lEl = document.getElementById('flashLegs');
            var zEl = document.getElementById('flashZoom');
            if (gEl) gEl.textContent = calcGirth(flashCurrentPoints);
            if (lEl) lEl.textContent = Math.max(0, flashCurrentPoints.length - 1);
            if (zEl) zEl.textContent = flashZoomLevel;
        }

        // ---- Mouse handlers ----
        function getFlashCanvasPos(e) {
            var canvas = document.getElementById('flashCanvas');
            var rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function flashFindNearPoint(canvasPos, threshold) {
            threshold = threshold || 10;
            for (var i = 0; i < flashCurrentPoints.length; i++) {
                var cp = flashMMToCanvas(flashCurrentPoints[i].x, flashCurrentPoints[i].y);
                var dx = cp.x - canvasPos.x, dy = cp.y - canvasPos.y;
                if (Math.sqrt(dx * dx + dy * dy) < threshold) return i;
            }
            return -1;
        }

        // ---- Mode management ----
        function setFlashMode(mode) {
            flashMode = mode;
            flashDrawing = (mode === 'extending'); // legacy compat
            if (mode === 'viewing') {
                flashSelectedIdx = -1;
                flashSelectedSeg = -1;
            }
            updateFlashStatusBar();
            updateFlashCursor();
            updateFlashInspector();
            drawFlashCanvas();
        }

        function updateFlashStatusBar() {
            var modeEl = document.getElementById('flashStatusMode');
            var hintsEl = document.getElementById('flashStatusHints');
            var btnEl = document.getElementById('flashStatusBtn');
            if (!modeEl) return;

            modeEl.className = 'flash-status-mode';
            switch (flashMode) {
                case 'viewing':
                    modeEl.textContent = 'VIEWING';
                    hintsEl.textContent = 'Double-click to start drawing \u2022 Click point to select \u2022 Scroll to zoom';
                    btnEl.style.display = 'none';
                    break;
                case 'extending':
                    modeEl.textContent = 'EXTENDING';
                    modeEl.classList.add('extending');
                    hintsEl.textContent = 'Click to place point \u2022 Shift = 45\u00B0 snap \u2022 ESC = cancel';
                    btnEl.style.display = '';
                    btnEl.textContent = 'Cancel';
                    break;
                case 'selected':
                    modeEl.textContent = flashSelectedSeg >= 0 ? 'SEGMENT' : 'POINT';
                    modeEl.classList.add('selected');
                    hintsEl.textContent = flashSelectedSeg >= 0
                        ? 'Segment selected \u2022 Click elsewhere to deselect'
                        : 'Drag to move \u2022 Delete to remove \u2022 Click elsewhere to deselect';
                    btnEl.style.display = '';
                    btnEl.textContent = 'Deselect';
                    break;
            }
        }

        function flashStatusAction() {
            if (flashMode === 'extending') {
                setFlashMode('viewing');
            } else if (flashMode === 'selected') {
                flashSelectedIdx = -1;
                flashSelectedSeg = -1;
                setFlashMode('viewing');
            }
        }

        function updateFlashCursor() {
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;
            switch (flashMode) {
                case 'extending': canvas.style.cursor = 'crosshair'; break;
                case 'selected': canvas.style.cursor = flashHoverPoint !== -1 ? 'pointer' : 'grab'; break;
                default: canvas.style.cursor = flashHoverPoint !== -1 ? 'pointer' : 'grab'; break;
            }
        }

        // ---- Inspector panel ----
        function updateFlashInspector() {
            var panel = document.getElementById('flashInspector');
            var title = document.getElementById('flashInspTitle');
            var body = document.getElementById('flashInspBody');
            if (!panel) return;

            if (flashMode !== 'selected' || (flashSelectedIdx < 0 && flashSelectedSeg < 0)) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = '';

            if (flashSelectedIdx >= 0) {
                // POINT inspector
                var pt = flashCurrentPoints[flashSelectedIdx];
                title.textContent = 'Point ' + (flashSelectedIdx + 1);
                var html = '';
                html += '<div class="flash-insp-row"><label>X:</label><input type="number" id="flashInspX" value="' + Math.round(pt.x) + '" step="1" oninput="flashInspSetPoint(\'x\',this.value)"><span class="flash-insp-unit">mm</span></div>';
                html += '<div class="flash-insp-row"><label>Y:</label><input type="number" id="flashInspY" value="' + Math.round(pt.y) + '" step="1" oninput="flashInspSetPoint(\'y\',this.value)"><span class="flash-insp-unit">mm</span></div>';

                // Angle at this point (if between two segments)
                if (flashSelectedIdx > 0 && flashSelectedIdx < flashCurrentPoints.length - 1) {
                    var ang = calcBendAngle(flashCurrentPoints[flashSelectedIdx - 1], pt, flashCurrentPoints[flashSelectedIdx + 1]);
                    html += '<div class="flash-insp-info">Angle at this point: ' + Math.round(ang) + '\u00B0</div>';
                }

                html += '<button class="flash-insp-btn danger" onclick="flashInspDeletePoint()">Delete Point</button>';
                body.innerHTML = html;
            } else if (flashSelectedSeg >= 0) {
                // SEGMENT inspector
                var a = flashCurrentPoints[flashSelectedSeg];
                var b = flashCurrentPoints[flashSelectedSeg + 1];
                title.textContent = 'Segment ' + (flashSelectedSeg + 1) + '\u2192' + (flashSelectedSeg + 2);
                var dx = b.x - a.x, dy = b.y - a.y;
                var len = Math.round(Math.sqrt(dx * dx + dy * dy));
                var segAng = Math.round(Math.atan2(dy, dx) * 180 / Math.PI);

                var html = '';
                html += '<div class="flash-insp-row"><label>Len:</label><input type="number" id="flashInspLen" value="' + len + '" min="1" step="1" oninput="flashInspSetLength(this.value)"><span class="flash-insp-unit">mm</span></div>';
                html += '<div class="flash-insp-info">Direction: ' + segAng + '\u00B0' + (segAng === 0 ? ' (horizontal)' : segAng === 90 || segAng === -90 ? ' (vertical)' : '') + '</div>';
                html += '<button class="flash-insp-btn" onclick="flashInspInsertPoint()">Insert Point</button>';
                html += '<button class="flash-insp-btn danger" onclick="flashInspDeleteSegment()">Delete Segment</button>';
                body.innerHTML = html;
            }
        }

        function flashInspSetPoint(axis, value) {
            if (flashSelectedIdx < 0) return;
            var val = parseInt(value);
            if (isNaN(val)) return;
            flashCurrentPoints[flashSelectedIdx][axis] = val;
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashInspSetLength(value) {
            if (flashSelectedSeg < 0) return;
            var newLen = parseInt(value);
            if (isNaN(newLen) || newLen < 1) return;
            var a = flashCurrentPoints[flashSelectedSeg];
            var b = flashCurrentPoints[flashSelectedSeg + 1];
            var dx = b.x - a.x, dy = b.y - a.y;
            var curLen = Math.sqrt(dx * dx + dy * dy);
            if (curLen === 0) return;
            var scale = newLen / curLen;
            flashCurrentPoints[flashSelectedSeg + 1] = {
                x: Math.round(a.x + dx * scale),
                y: Math.round(a.y + dy * scale)
            };
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashInspInsertPoint() {
            if (flashSelectedSeg < 0) return;
            var a = flashCurrentPoints[flashSelectedSeg];
            var b = flashCurrentPoints[flashSelectedSeg + 1];
            var mid = { x: Math.round((a.x + b.x) / 2), y: Math.round((a.y + b.y) / 2) };
            flashPushUndo();
            flashCurrentPoints.splice(flashSelectedSeg + 1, 0, mid);
            flashSelectedIdx = flashSelectedSeg + 1;
            flashSelectedSeg = -1;
            updateFlashInspector();
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashInspDeleteSegment() {
            if (flashSelectedSeg < 0) return;
            // Remove the end point of the segment
            flashPushUndo();
            flashCurrentPoints.splice(flashSelectedSeg + 1, 1);
            flashSelectedSeg = -1;
            setFlashMode('viewing');
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashInspDeletePoint() {
            if (flashSelectedIdx < 0) return;
            flashPushUndo();
            flashCurrentPoints.splice(flashSelectedIdx, 1);
            flashSelectedIdx = -1;
            setFlashMode('viewing');
            drawFlashCanvas();
            updateFlashInfo();
        }

        function closeFlashInspector() {
            flashSelectedIdx = -1;
            flashSelectedSeg = -1;
            setFlashMode('viewing');
        }

        // Find nearest segment (not point) within threshold pixels
        function flashFindNearSegment(canvasPos, threshold) {
            threshold = threshold || 8;
            for (var i = 0; i < flashCurrentPoints.length - 1; i++) {
                var a = flashMMToCanvas(flashCurrentPoints[i].x, flashCurrentPoints[i].y);
                var b = flashMMToCanvas(flashCurrentPoints[i + 1].x, flashCurrentPoints[i + 1].y);
                var dist = pointToSegmentDist(canvasPos, a, b);
                if (dist < threshold) return i;
            }
            return -1;
        }

        function pointToSegmentDist(p, a, b) {
            var dx = b.x - a.x, dy = b.y - a.y;
            var lenSq = dx * dx + dy * dy;
            if (lenSq === 0) return Math.sqrt((p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a.y));
            var t = Math.max(0, Math.min(1, ((p.x - a.x) * dx + (p.y - a.y) * dy) / lenSq));
            var projX = a.x + t * dx, projY = a.y + t * dy;
            return Math.sqrt((p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY));
        }

        // ---- Mouse handlers ----
        function flashMouseDown(e) {
            var canvas = e.target;
            var pos = getFlashCanvasPos(e);
            var mm = flashCanvasToMM(pos.x, pos.y);

            if (e.button === 0) {
                if (flashMode === 'extending') {
                    // EXTEND MODE: click places a point
                    var snapped = flashSnapToGrid(mm);
                    if (flashSnapAngle || flashAutoSnap) {
                        if (flashCurrentPoints.length > 0) {
                            snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
                        }
                    }
                    flashPushUndo();
                    flashCurrentPoints.push({ x: snapped.x, y: snapped.y });
                    // Stay in extending mode (chaining)
                    drawFlashCanvas();
                    updateFlashInfo();
                    return;
                }

                // VIEWING / SELECTED mode
                var nearIdx = flashFindNearPoint(pos, 12);
                if (nearIdx !== -1) {
                    // Click on point â†’ select it
                    flashSelectedIdx = nearIdx;
                    flashSelectedSeg = -1;
                    flashDragging = true;
                    flashIsPanning = false;
                    flashDragStart = pos;
                    setFlashMode('selected');
                    return;
                }

                // Check near segment
                var nearSeg = flashFindNearSegment(pos, 10);
                if (nearSeg !== -1) {
                    flashSelectedIdx = -1;
                    flashSelectedSeg = nearSeg;
                    setFlashMode('selected');
                    drawFlashCanvas();
                    return;
                }

                // Click empty space â†’ deselect or pan
                if (flashMode === 'selected') {
                    flashSelectedIdx = -1;
                    flashSelectedSeg = -1;
                    setFlashMode('viewing');
                }
                // Start panning
                flashDragging = true;
                flashIsPanning = true;
                flashDragStart = pos;
                flashPanStart = { x: flashPanOffset.x, y: flashPanOffset.y };
                canvas.style.cursor = 'grabbing';
            } else if (e.button === 1) {
                // Middle: always pan
                flashDragging = true;
                flashIsPanning = true;
                flashDragStart = pos;
                flashPanStart = { x: flashPanOffset.x, y: flashPanOffset.y };
                canvas.style.cursor = 'grabbing';
            } else if (e.button === 2) {
                // Right-click: exit extending mode
                e.preventDefault();
                if (flashMode === 'extending') {
                    setFlashMode('viewing');
                }
            }
            drawFlashCanvas();
        }

        function flashMouseMove(e) {
            var canvas = e.target;
            var pos = getFlashCanvasPos(e);
            var mm = flashCanvasToMM(pos.x, pos.y);
            var snapped = flashSnapToGrid(mm);

            if ((flashSnapAngle || flashAutoSnap) && flashCurrentPoints.length > 0 && flashMode === 'extending') {
                snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
            }
            flashMouseMM = snapped;

            if (flashDragging) {
                if (flashIsPanning) {
                    flashPanOffset.x = flashPanStart.x + (pos.x - flashDragStart.x);
                    flashPanOffset.y = flashPanStart.y + (pos.y - flashDragStart.y);
                } else if (flashSelectedIdx >= 0) {
                    // Dragging a selected point
                    var dragSnapped = flashSnapToGrid(mm);
                    if ((flashSnapAngle || flashAutoSnap) && flashSelectedIdx > 0) {
                        dragSnapped = constrainAngle(flashCurrentPoints[flashSelectedIdx - 1], dragSnapped);
                    }
                    flashCurrentPoints[flashSelectedIdx] = { x: dragSnapped.x, y: dragSnapped.y };
                }
            } else {
                // Hovering
                flashHoverPoint = flashFindNearPoint(pos, 12);
                updateFlashCursor();
            }

            drawFlashCanvas();
        }

        function flashMouseUp(e) {
            flashDragging = false;
            flashIsPanning = false;
            updateFlashCursor();
        }

        function flashDblClick(e) {
            e.preventDefault();
            var pos = getFlashCanvasPos(e);
            var mm = flashCanvasToMM(pos.x, pos.y);
            var snapped = flashSnapToGrid(mm);

            if (flashMode === 'extending') return; // ignore dblclick while extending

            var nearIdx = flashFindNearPoint(pos, 12);
            if (nearIdx !== -1) {
                // Double-click existing point â†’ enter EXTEND mode from that point
                // Reorder so this becomes the last point (extend from endpoint)
                // Only allow extending from first or last point
                if (nearIdx === 0) {
                    flashCurrentPoints.reverse();
                }
                // Now last point is the extend origin
                flashSelectedIdx = -1;
                flashSelectedSeg = -1;
                setFlashMode('extending');
            } else {
                // Double-click empty canvas â†’ add new start point, enter EXTEND mode
                if (flashSnapAngle && flashCurrentPoints.length > 0) {
                    snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
                }
                flashPushUndo();
                flashCurrentPoints.push({ x: snapped.x, y: snapped.y });
                setFlashMode('extending');
            }
            drawFlashCanvas();
            updateFlashInfo();
        }

        var flashWheelAccum = 0;
        var flashWheelThreshold = 80; // accumulated delta before zoom step triggers
        function flashWheel(e) {
            e.preventDefault();
            flashWheelAccum += e.deltaY;
            if (Math.abs(flashWheelAccum) < flashWheelThreshold) return;
            var zoomLevels = [2, 5, 10, 20, 50];
            var curIdx = zoomLevels.indexOf(flashZoomLevel);
            if (curIdx === -1) curIdx = 2;
            if (flashWheelAccum < 0) {
                if (curIdx > 0) flashZoomLevel = zoomLevels[curIdx - 1];
            } else {
                if (curIdx < zoomLevels.length - 1) flashZoomLevel = zoomLevels[curIdx + 1];
            }
            flashWheelAccum = 0;
            drawFlashCanvas();
        }

        function flashZoomIn() {
            var zoomLevels = [2, 5, 10, 20, 50];
            var curIdx = zoomLevels.indexOf(flashZoomLevel);
            if (curIdx === -1) curIdx = 2;
            if (curIdx > 0) flashZoomLevel = zoomLevels[curIdx - 1];
            drawFlashCanvas();
        }

        function flashZoomOut() {
            var zoomLevels = [2, 5, 10, 20, 50];
            var curIdx = zoomLevels.indexOf(flashZoomLevel);
            if (curIdx === -1) curIdx = 2;
            if (curIdx < zoomLevels.length - 1) flashZoomLevel = zoomLevels[curIdx + 1];
            drawFlashCanvas();
        }

        function flashZoomFit() {
            if (flashCurrentPoints.length < 2) return;
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;
            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (var i = 0; i < flashCurrentPoints.length; i++) {
                var p = flashCurrentPoints[i];
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            }
            var spanX = maxX - minX, spanY = maxY - minY;
            var span = Math.max(spanX, spanY, 10);
            var cw = canvas.width, ch = canvas.height;
            var availPx = Math.min(cw, ch) * 0.7;
            var idealMmPerGrid = span / (availPx / 20);
            var zoomLevels = [2, 5, 10, 20, 50];
            var best = zoomLevels[zoomLevels.length - 1];
            for (var z = 0; z < zoomLevels.length; z++) {
                if (zoomLevels[z] >= idealMmPerGrid) { best = zoomLevels[z]; break; }
            }
            flashZoomLevel = best;
            var midX = (minX + maxX) / 2, midY = (minY + maxY) / 2;
            var pxPerMM = 20 / flashZoomLevel;
            flashPanOffset.x = -midX * pxPerMM;
            flashPanOffset.y = midY * pxPerMM;
            drawFlashCanvas();
        }

        function flashKeyDown(e) {
            if (!flashModalOpen) return;

            if (e.key === 'Shift') { flashSnapAngle = true; return; }

            if (e.key === 'Enter') {
                if (flashMode === 'extending') {
                    setFlashMode('viewing');
                }
            }
            if (e.key === 'Escape') {
                if (flashMode === 'extending') {
                    setFlashMode('viewing');
                } else if (flashMode === 'selected') {
                    flashSelectedIdx = -1;
                    flashSelectedSeg = -1;
                    setFlashMode('viewing');
                } else {
                    closeFlashModal();
                }
            }
            if ((e.key === 'Delete' || e.key === 'Backspace') && flashSelectedIdx >= 0) {
                flashPushUndo();
                flashCurrentPoints.splice(flashSelectedIdx, 1);
                flashSelectedIdx = -1;
                setFlashMode('viewing');
                drawFlashCanvas();
                e.preventDefault();
            }
            if (e.ctrlKey && e.key === 'z') {
                flashUndo();
                e.preventDefault();
            }
            if (e.ctrlKey && e.key === 'y') {
                flashRedo();
                e.preventDefault();
            }
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
            if (e.key === 'h' || e.key === 'H') flashFlipH();
            if (e.key === 'v' || e.key === 'V') flashFlipV();
        }

        document.addEventListener('keyup', function(e) {
            if (e.key === 'Shift') flashSnapAngle = false;
        });

        function constrainAngle(from, to) {
            var dx = to.x - from.x;
            var dy = to.y - from.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return to;
            var angle = Math.atan2(dy, dx) * 180 / Math.PI;
            // Snap to nearest 45
            var snapAngles = [0, 45, 90, 135, 180, -45, -90, -135, -180];
            var closest = 0, minDiff = 999;
            snapAngles.forEach(function(sa) {
                var diff = Math.abs(angle - sa);
                if (diff < minDiff) { minDiff = diff; closest = sa; }
            });
            // Also snap near 90 (within Â±5Â°)
            if (Math.abs(angle - 90) <= 5) closest = 90;
            if (Math.abs(angle + 90) <= 5) closest = -90;
            if (Math.abs(angle) <= 5) closest = 0;
            if (Math.abs(Math.abs(angle) - 180) <= 5) closest = angle > 0 ? 180 : -180;

            var rad = closest * Math.PI / 180;
            var snappedDist = Math.round(dist / flashZoomLevel) * flashZoomLevel;
            if (snappedDist === 0) snappedDist = flashZoomLevel;
            return {
                x: from.x + Math.round(Math.cos(rad) * snappedDist),
                y: from.y + Math.round(Math.sin(rad) * snappedDist)
            };
        }

        // ---- Tool actions ----

        function setColourSide(side, btn) {
            flashColourSide = side;
            document.querySelectorAll('.flash-cs-btn').forEach(function(b) { b.classList.remove('active'); });
            if (btn) btn.classList.add('active');
            drawFlashCanvas();
        }

        function flashFlipH() {
            if (flashCurrentPoints.length < 2) return;
            flashPushUndo();
            var minX = Infinity, maxX = -Infinity;
            flashCurrentPoints.forEach(function(p) { if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x; });
            var cx = (minX + maxX) / 2;
            flashCurrentPoints.forEach(function(p) { p.x = 2 * cx - p.x; });
            drawFlashCanvas();
        }

        function flashFlipV() {
            if (flashCurrentPoints.length < 2) return;
            flashPushUndo();
            var minY = Infinity, maxY = -Infinity;
            flashCurrentPoints.forEach(function(p) { if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y; });
            var cy = (minY + maxY) / 2;
            flashCurrentPoints.forEach(function(p) { p.y = 2 * cy - p.y; });
            drawFlashCanvas();
        }

        let flashRedoStack = [];

        function flashPushUndo() {
            flashPushUndo();
            flashRedoStack = []; // new action clears redo
        }

        function flashUndo() {
            if (flashUndoStack.length === 0) return;
            flashRedoStack.push(JSON.parse(JSON.stringify(flashCurrentPoints)));
            flashCurrentPoints = flashUndoStack.pop();
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashRedo() {
            if (flashRedoStack.length === 0) return;
            flashPushUndo();
            flashCurrentPoints = flashRedoStack.pop();
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashClearConfirm() {
            if (flashCurrentPoints.length === 0) return;
            if (!confirm('Clear entire profile? This can be undone.')) return;
            flashClear();
        }

        function toggleFlashSnap() {
            flashAutoSnap = !flashAutoSnap;
            var btn = document.getElementById('flashSnapToggle');
            if (btn) {
                btn.textContent = 'Snap: ' + (flashAutoSnap ? 'ON' : 'OFF');
                btn.classList.toggle('active', flashAutoSnap);
            }
            drawFlashCanvas();
        }

        function flashClear() {
            flashPushUndo();
            flashCurrentPoints = [];
            flashSelectedIdx = -1;
            flashSelectedSeg = -1;
            setFlashMode('viewing');
            flashEditingId = null;
            flashStartTreatment = null;
            flashEndTreatment = null;
            var stSel = document.getElementById('flashStartTreat');
            var enSel = document.getElementById('flashEndTreat');
            if (stSel) stSel.value = 'none';
            if (enSel) enSel.value = 'none';
            var treatOpts2 = document.getElementById('flashTreatOpts');
            if (treatOpts2) treatOpts2.style.display = 'none';
            drawFlashCanvas();
        }

        // ---- End Treatment functions ----
        function updateFlashTreatment(which) {
            var sel = document.getElementById(which === 'start' ? 'flashStartTreat' : 'flashEndTreat');
            var val = sel.value;
            var treatment = null;
            if (val === 'miniBreak') {
                var size = parseInt(document.getElementById('flashTreatSize').value) || 10;
                var angle = parseInt(document.getElementById('flashTreatAngle').value) || 45;
                var dirOut = document.getElementById('flashTreatDirOut').classList.contains('active');
                treatment = { type: 'miniBreak', size: size, angle: angle, direction: dirOut ? 'out' : 'in' };
            } else if (val === 'hem') {
                treatment = { type: 'hem' };
            }
            if (which === 'start') flashStartTreatment = treatment;
            else flashEndTreatment = treatment;

            // Show/hide treatment options
            var hasMiniBrk = document.getElementById('flashStartTreat').value === 'miniBreak' || document.getElementById('flashEndTreat').value === 'miniBreak';
            document.getElementById('flashTreatOpts').style.display = hasMiniBrk ? 'flex' : 'none';
            drawFlashCanvas();
        }

        function setTreatDir(dir) {
            document.getElementById('flashTreatDirOut').classList.toggle('active', dir === 'out');
            document.getElementById('flashTreatDirIn').classList.toggle('active', dir === 'in');
            // Re-apply to whichever treatments are miniBreak
            if (flashStartTreatment && flashStartTreatment.type === 'miniBreak') flashStartTreatment.direction = dir;
            if (flashEndTreatment && flashEndTreatment.type === 'miniBreak') flashEndTreatment.direction = dir;
            drawFlashCanvas();
        }

        function drawEndTreatment(ctx, pts, treatment, isStart) {
            if (!treatment || pts.length < 2) return;
            var idx, prevIdx;
            if (isStart) { idx = 0; prevIdx = 1; }
            else { idx = pts.length - 1; prevIdx = pts.length - 2; }

            var pt = flashMMToCanvas(pts[idx].x, pts[idx].y);
            var prev = flashMMToCanvas(pts[prevIdx].x, pts[prevIdx].y);

            // Direction along the leg toward the end
            var dx = pt.x - prev.x, dy = pt.y - prev.y;
            var len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) return;
            var ux = dx / len, uy = dy / len; // unit vector along leg toward endpoint
            // Normal (perpendicular)
            var nx = -uy, ny = ux;

            var pxPerMM = 20 / flashZoomLevel;

            if (treatment.type === 'miniBreak') {
                var sz = (treatment.size || 10) * pxPerMM;
                var ang = (treatment.angle || 45) * Math.PI / 180;
                var dirSign = treatment.direction === 'in' ? -1 : 1;
                // Kick goes outward from the endpoint at the given angle
                var kickX = pt.x + (ux * Math.cos(ang) + nx * dirSign * Math.sin(ang)) * sz;
                var kickY = pt.y + (uy * Math.cos(ang) + ny * dirSign * Math.sin(ang)) * sz;

                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y);
                ctx.lineTo(kickX, kickY);
                ctx.strokeStyle = '#293C46';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                var lblX = (pt.x + kickX) / 2 + nx * dirSign * 10;
                var lblY = (pt.y + kickY) / 2 + ny * dirSign * 10;
                ctx.font = '8px SF Mono, monospace';
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.fillText('MB ' + (treatment.size || 10), lblX, lblY);
                ctx.textAlign = 'left';
            } else if (treatment.type === 'hem') {
                // Draw small U-loop at the end
                var hemSize = 6 * pxPerMM;
                var csDir = flashColourSide === 'inside' ? -1 : 1;
                // Hem folds back on itself
                var hemEnd = { x: pt.x - ux * hemSize, y: pt.y - uy * hemSize };
                var hemMid = { x: pt.x + nx * csDir * hemSize * 0.5, y: pt.y + ny * csDir * hemSize * 0.5 };

                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y);
                ctx.quadraticCurveTo(hemMid.x + ux * hemSize * 0.3, hemMid.y + uy * hemSize * 0.3, hemEnd.x + nx * csDir * hemSize * 0.3, hemEnd.y + ny * csDir * hemSize * 0.3);
                ctx.strokeStyle = '#293C46';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.font = '8px SF Mono, monospace';
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.fillText('HEM', pt.x + nx * csDir * 14, pt.y + ny * csDir * 14);
                ctx.textAlign = 'left';
            }
        }

        // ---- Templates ----
        function getTemplateFolderState() {
            try { return JSON.parse(localStorage.getItem('flashFolderState') || '{}'); } catch(e) { return {}; }
        }
        function saveTemplateFolderState(state) {
            localStorage.setItem('flashFolderState', JSON.stringify(state));
        }
        function toggleTemplateFolder(folderId) {
            var state = getTemplateFolderState();
            state[folderId] = !state[folderId]; // true = collapsed
            saveTemplateFolderState(state);
            var contents = document.getElementById('folder-' + folderId);
            var icon = document.getElementById('ficon-' + folderId);
            if (contents) contents.classList.toggle('collapsed', state[folderId]);
            if (icon) icon.textContent = state[folderId] ? '\uD83D\uDCC1' : '\uD83D\uDCC2';
        }

        function renderFlashTemplates() {
            var container = document.getElementById('flashTemplates');
            if (!container) return;
            container.innerHTML = '';
            var folderState = getTemplateFolderState();

            // Group templates by folder
            var folders = {};
            var folderOrder = ['Skillion / Flat', 'Gable', 'SolarSpan 50mm', 'SolarSpan 75mm', 'SolarSpan 100mm', 'Custom'];
            flashingTemplates.forEach(function(tpl, idx) {
                var f = tpl.folder || 'Standard';
                if (!folders[f]) folders[f] = [];
                folders[f].push({ tpl: tpl, idx: idx });
            });

            // Render each folder
            folderOrder.forEach(function(folderName) {
                var items = folders[folderName];
                if (!items || items.length === 0) return;
                var fid = folderName.replace(/\s+/g, '-').toLowerCase();
                var isCollapsed = folderState[fid] || false;

                var folderDiv = document.createElement('div');
                folderDiv.className = 'template-folder';

                var header = document.createElement('div');
                header.className = 'folder-header';
                header.onclick = function() { toggleTemplateFolder(fid); };
                header.innerHTML = '<span class="folder-icon" id="ficon-' + fid + '">' + (isCollapsed ? '\uD83D\uDCC1' : '\uD83D\uDCC2') + '</span> ' + folderName;
                folderDiv.appendChild(header);

                var contents = document.createElement('div');
                contents.className = 'folder-contents' + (isCollapsed ? ' collapsed' : '');
                contents.id = 'folder-' + fid;

                items.forEach(function(item) {
                    var div = document.createElement('div');
                    div.className = 'flash-tpl';
                    div.onclick = function() { loadFlashTemplate(item.idx); };
                    var cvs = document.createElement('canvas');
                    cvs.width = 56; cvs.height = 34;
                    drawMiniProfile(cvs, item.tpl.points);
                    div.appendChild(cvs);
                    var nm = document.createElement('div');
                    nm.className = 'flash-tpl-name';
                    nm.textContent = item.tpl.name;
                    div.appendChild(nm);
                    contents.appendChild(div);
                });

                folderDiv.appendChild(contents);
                container.appendChild(folderDiv);
            });

        }

        function drawMiniProfile(cvs, pts) {
            if (!pts || pts.length < 2) return;
            var ctx = cvs.getContext('2d');
            var w = cvs.width, h = cvs.height;
            var pad = 6;

            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            pts.forEach(function(p) {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
            });
            var rangeX = maxX - minX || 1;
            var rangeY = maxY - minY || 1;
            var scale = Math.min((w - pad * 2) / rangeX, (h - pad * 2) / rangeY);
            var ox = (w - rangeX * scale) / 2;
            var oy = (h - rangeY * scale) / 2;

            ctx.strokeStyle = '#293C46';
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            pts.forEach(function(p, i) {
                var px = ox + (p.x - minX) * scale;
                var py = oy + (maxY - p.y) * scale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();
        }

        function loadFlashTemplate(idx) {
            if (idx < 0 || idx >= flashingTemplates.length) return;
            var tpl = flashingTemplates[idx];
            flashCurrentPoints = JSON.parse(JSON.stringify(tpl.points));
            flashColourSide = tpl.colourSide || 'inside';
            setFlashMode('viewing');
            flashEditingId = null;
            flashUndoStack = [];

            // Update colour side buttons
            document.querySelectorAll('.flash-cs-btn').forEach(function(b) {
                b.classList.toggle('active', b.dataset.cs === flashColourSide);
            });

            // Update template active state
            document.querySelectorAll('.flash-tpl').forEach(function(t, i) {
                t.classList.toggle('active', i === idx);
            });

            // Center view on profile
            centerFlashView();
            drawFlashCanvas();
        }

        function centerFlashView() {
            if (flashCurrentPoints.length === 0) {
                flashPanOffset = { x: 0, y: 0 };
                return;
            }
            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            flashCurrentPoints.forEach(function(p) {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
            });
            var cx = (minX + maxX) / 2;
            var cy = (minY + maxY) / 2;
            var pxPerMM = 20 / flashZoomLevel;
            flashPanOffset = { x: -cx * pxPerMM, y: cy * pxPerMM };
        }

        function saveFlashTemplate() {
            if (flashCurrentPoints.length < 2) { alert('Draw a profile first before saving as template.'); return; }
            var name = prompt('Template name:', document.getElementById('flashName').value || 'Custom');
            if (!name) return;
            flashingTemplates.push({
                name: name,
                folder: 'Custom',
                points: JSON.parse(JSON.stringify(flashCurrentPoints)),
                colourSide: flashColourSide
            });
            localStorage.setItem('flashingTemplates', JSON.stringify(flashingTemplates));
            renderFlashTemplates();
        }

        // ---- Job flashings list ----
        function flashAddToJob() {
            if (flashCurrentPoints.length < 2) { alert('Draw a profile first.'); return; }
            var name = document.getElementById('flashName').value.trim() || 'Unnamed Flashing';
            var colour = document.getElementById('flashColour').value;
            var gauge = parseFloat(document.getElementById('flashGauge').value) || 0.42;
            var length = parseInt(document.getElementById('flashLength').value) || 3000;
            var qty = parseInt(document.getElementById('flashQty').value) || 1;
            var girth = calcGirth(flashCurrentPoints);
            var legs = calcLegs(flashCurrentPoints);

            if (flashEditingId) {
                // Update existing
                var existing = flashingProfiles.find(function(p) { return p.id === flashEditingId; });
                if (existing) {
                    existing.name = name;
                    existing.colour = colour;
                    existing.gauge = gauge;
                    existing.length = length;
                    existing.qty = qty;
                    existing.colourSide = flashColourSide;
                    existing.points = JSON.parse(JSON.stringify(flashCurrentPoints));
                    existing.girth = girth;
                    existing.legs = legs;
                    existing.startTreatment = flashStartTreatment ? JSON.parse(JSON.stringify(flashStartTreatment)) : null;
                    existing.endTreatment = flashEndTreatment ? JSON.parse(JSON.stringify(flashEndTreatment)) : null;
                }
                flashEditingId = null;
            } else {
                flashingProfiles.push({
                    id: 'flashing_' + String(flashNextId++).padStart(3, '0'),
                    name: name,
                    colour: colour,
                    gauge: gauge,
                    length: length,
                    qty: qty,
                    colourSide: flashColourSide,
                    points: JSON.parse(JSON.stringify(flashCurrentPoints)),
                    girth: girth,
                    legs: legs,
                    startTreatment: flashStartTreatment ? JSON.parse(JSON.stringify(flashStartTreatment)) : null,
                    endTreatment: flashEndTreatment ? JSON.parse(JSON.stringify(flashEndTreatment)) : null
                });
            }

            renderFlashJobTable();
            updateFlashSummary();
            // Reset for next
            flashClear();
            document.getElementById('flashName').value = '';
            document.getElementById('flashLength').value = '4500';
            document.getElementById('flashQty').value = '1';
        }

        function renderFlashJobTable() {
            var tbody = document.getElementById('flashJobBody');
            var totalRow = document.getElementById('flashTotalRow');
            var totalArea = document.getElementById('flashTotalArea');
            if (!tbody) return;

            if (flashingProfiles.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align:center;color:var(--sw-text-sec);padding:16px;font-size:12px">No flashings added yet. Click "Open Editor" to draw profiles.</td></tr>';
                if (totalRow) totalRow.style.display = 'none';
                return;
            }

            var totalSqm = 0;
            tbody.innerHTML = flashingProfiles.map(function(p, i) {
                var area = (p.girth / 1000) * (p.length / 1000) * p.qty;
                totalSqm += area;
                return '<tr class="' + (flashEditingId === p.id ? 'selected' : '') + '">' +
                    '<td class="mono">' + (i + 1) + '</td>' +
                    '<td>' + esc(p.name) + '</td>' +
                    '<td class="r mono">' + p.girth + 'mm</td>' +
                    '<td class="r mono">' + p.length + 'mm<br><span style="font-size:9px;color:var(--sw-text-sec)" title="Order length includes +500mm allowance">order: ' + (p.length + 500) + '</span></td>' +
                    '<td class="r mono">' + p.qty + '</td>' +
                    '<td>' + esc(p.colour) + '</td>' +
                    '<td class="mono">' + p.gauge + 'mm</td>' +
                    '<td style="font-size:10px">' + flashColourSideLabel(p.colourSide) + '</td>' +
                    '<td><div class="flash-row-actions">' +
                        '<button class="flash-row-btn" onclick="flashEditRow(' + i + ')" title="Edit">&#9998;</button>' +
                        '<button class="flash-row-btn" onclick="flashDupeRow(' + i + ')" title="Duplicate">&#10697;</button>' +
                        '<button class="flash-row-btn del" onclick="flashDeleteRow(' + i + ')" title="Delete">&times;</button>' +
                    '</div></td>' +
                '</tr>';
            }).join('');

            if (totalRow) {
                totalRow.style.display = '';
                if (totalArea) totalArea.textContent = totalSqm.toFixed(2);
            }
        }

        function esc(str) {
            var div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function flashEditRow(idx) {
            if (idx < 0 || idx >= flashingProfiles.length) return;
            var p = flashingProfiles[idx];
            flashEditingId = p.id;
            flashCurrentPoints = JSON.parse(JSON.stringify(p.points));
            flashColourSide = p.colourSide;
            setFlashMode('viewing');

            // Open modal first so elements are accessible
            openFlashModal();

            // Restore end treatments
            flashStartTreatment = p.startTreatment ? JSON.parse(JSON.stringify(p.startTreatment)) : null;
            flashEndTreatment = p.endTreatment ? JSON.parse(JSON.stringify(p.endTreatment)) : null;
            var stSel = document.getElementById('flashStartTreat');
            var enSel = document.getElementById('flashEndTreat');
            if (stSel) stSel.value = flashStartTreatment ? flashStartTreatment.type : 'none';
            if (enSel) enSel.value = flashEndTreatment ? flashEndTreatment.type : 'none';
            var hasMiniBrk = (flashStartTreatment && flashStartTreatment.type === 'miniBreak') || (flashEndTreatment && flashEndTreatment.type === 'miniBreak');
            var treatOpts = document.getElementById('flashTreatOpts');
            if (treatOpts) treatOpts.style.display = hasMiniBrk ? 'flex' : 'none';
            if (hasMiniBrk) {
                var mb = (flashStartTreatment && flashStartTreatment.type === 'miniBreak') ? flashStartTreatment : flashEndTreatment;
                document.getElementById('flashTreatSize').value = mb.size || 10;
                document.getElementById('flashTreatAngle').value = mb.angle || 45;
                document.getElementById('flashTreatDirOut').classList.toggle('active', mb.direction === 'out');
                document.getElementById('flashTreatDirIn').classList.toggle('active', mb.direction === 'in');
            }

            document.getElementById('flashName').value = p.name;
            document.getElementById('flashColour').value = p.colour;
            document.getElementById('flashGauge').value = p.gauge;
            document.getElementById('flashLength').value = p.length;
            document.getElementById('flashQty').value = p.qty;

            document.querySelectorAll('.flash-cs-btn').forEach(function(b) {
                b.classList.toggle('active', b.dataset.cs === flashColourSide);
            });

            setTimeout(function() {
                centerFlashView();
                drawFlashCanvas();
            }, 100);
            renderFlashJobTable();
        }

        function flashDupeRow(idx) {
            if (idx < 0 || idx >= flashingProfiles.length) return;
            var orig = flashingProfiles[idx];
            var dupe = JSON.parse(JSON.stringify(orig));
            dupe.id = 'flashing_' + String(flashNextId++).padStart(3, '0');
            dupe.name = orig.name + ' (copy)';
            flashingProfiles.splice(idx + 1, 0, dupe);
            renderFlashJobTable();
            updateFlashSummary();
        }

        function flashDeleteRow(idx) {
            if (idx < 0 || idx >= flashingProfiles.length) return;
            flashingProfiles.splice(idx, 1);
            if (flashEditingId && !flashingProfiles.find(function(p) { return p.id === flashEditingId; })) {
                flashEditingId = null;
            }
            renderFlashJobTable();
            updateFlashSummary();
        }

        // ==================== EXPORT / IMPORT JOB DATA ====================
        function gatherJobData() {
            const c = calc;
            return {
                _version: 'PatioDesignerPro_V18',
                _exported: new Date().toISOString(),
                client: {
                    jobRef: (document.getElementById('jobRef')?.value || '').trim(),
                    name: (document.getElementById('customerName')?.value || '').trim(),
                    address: (document.getElementById('customerAddress')?.value || '').trim(),
                    phone: (document.getElementById('customerPhone')?.value || '').trim(),
                    email: (document.getElementById('clientEmail')?.value || '').trim(),
                    salesperson: (document.getElementById('salesperson')?.value || '')
                },
                config: {
                    roofStyle: document.getElementById('inRoofStyle')?.value,
                    orientation: document.getElementById('inOrientation')?.value,
                    projection: document.getElementById('inWidth')?.value,
                    length: document.getElementById('inLength')?.value,
                    pitch: document.getElementById('inPitch')?.value,
                    postHeight: document.getElementById('inPostHeight')?.value,
                    posts: document.getElementById('inPosts')?.value,
                    postQtyOverride: document.getElementById('inPostQty')?.value,
                    trusses: document.getElementById('inTrusses')?.value,
                    rafters: document.getElementById('inRafters')?.value,
                    rafterSize: document.getElementById('inRafterSize')?.value,
                    rafterSpacing: document.getElementById('inRafterSpacing')?.value,
                    rafterQtyOverride: document.getElementById('inRafterQtyOverride')?.value,
                    purlinSize: document.getElementById('inPurlinSize')?.value,
                    gutterBeamSize: document.getElementById('inGutterBeamSize')?.value,
                    riserBeamSize: document.getElementById('inRiserBeamSize')?.value,
                    roofing: document.getElementById('inRoofing')?.value,
                    infill: document.getElementById('inInfill')?.value,
                    connection: document.getElementById('inConnection')?.value,
                    fasciaHeight: document.getElementById('inFasciaHeight')?.value,
                    riserHeight: document.getElementById('inRiserHeight')?.value,
                    riserOffset: document.getElementById('inRiserOffset')?.value,
                    riserQty: document.getElementById('inRiserQty')?.value,
                    houseGutter: document.getElementById('inHouseGutter')?.value,
                    riserGutter: document.getElementById('inRiserGutter')?.value,
                    fasciaBracketQty: document.getElementById('inFasciaBracketQty')?.value,
                    postFix: document.getElementById('inPostFix')?.value,
                    postSize: document.getElementById('inPostSize')?.value,
                    beamSize: document.getElementById('inBeamSize')?.value,
                    trussBase: document.getElementById('inTrussBase')?.value,
                    trussChord: document.getElementById('inTrussChord')?.value,
                    trussSteel: document.getElementById('inTrussSteel')?.value,
                    overhang: document.getElementById('inOverhang')?.value,
                    trussRiserLeft: {
                        enabled: document.getElementById('trussRiserOn')?.checked || false,
                        length: document.getElementById('riserLH')?.value || '200',
                        height: document.getElementById('riserLV')?.value || '150'
                    },
                    trussRiserRight: {
                        enabled: document.getElementById('trussRiserOn')?.checked || false,
                        length: document.getElementById('riserRH')?.value || '200',
                        height: document.getElementById('riserRV')?.value || '150'
                    },
                    trussRiserLocked: document.getElementById('trussRiserLock')?.checked || true,
                    riserType: document.getElementById('riserTypeSeparate')?.checked ? 'separate' : 'welded',
                    trussExtender: {
                        enabled: document.getElementById('trussExtOn')?.checked || false,
                        length: document.getElementById('trussExtLen')?.value || '300'
                    },
                    sheetColor: sheetColor.name,
                    steelColor: steelColor.name,
                    polycarbEnabled: isPolycarbEnabled(),
                    polycarbBrand: document.getElementById('inPolycarbBrand')?.value,
                    polycarbTint: document.getElementById('inPolycarbTint')?.value,
                    polycarbPattern: document.getElementById('inPolycarbPattern')?.value,
                    polycarbCustom: document.getElementById('inPolycarbCustom')?.value,
                    polycarbLevel: document.getElementById('inPolycarbLevel')?.value,
                    ceilingFinish: document.getElementById('inCeilingFinish')?.value,
                    sheetBMT: document.getElementById('inBMT')?.value || '042',
                    extraBattens: parseInt(document.getElementById('extraBattensVal')?.textContent) || 0,
                    bracketType: document.querySelector('input[name="bracketType"]:checked')?.value || 'internal'
                },
                existingSite: {
                    existing: document.getElementById('existingSite')?.value || 'clear',
                    demoNotes: document.getElementById('demoNotes')?.value || '',
                    electrical: document.getElementById('electrical')?.value || 'none'
                },
                pricing: {
                    addonRows: jobRows.filter(r => r.isAddon),
                    extrasRows: extrasRows,
                    additionalMaterials: additionalMaterials,
                    labour: {
                        trades: document.getElementById('labTrades')?.value,
                        days: document.getElementById('labDays')?.value,
                        dayRate: document.getElementById('labDayRate')?.value,
                        sell: document.getElementById('labSellInput')?.value
                    }
                },
                complexity: {
                    build: document.getElementById('cxBuild')?.value,
                    access: document.getElementById('cxAccess')?.value,
                    distance: document.getElementById('cxDistance')?.value,
                    footing: document.getElementById('cxFooting')?.value,
                    height: document.getElementById('cxHeight')?.value
                },
                notes: {
                    pricingNotes: (document.getElementById('pricingNotes')?.value || '').trim(),
                    noteQuote: (document.getElementById('noteQuote')?.value || '').trim(),
                    noteWorkOrder: (document.getElementById('noteWorkOrder')?.value || '').trim(),
                    noteMaterialOrder: (document.getElementById('noteMaterialOrder')?.value || '').trim(),
                    noteInternal: (document.getElementById('noteInternal')?.value || '').trim()
                },
                scope: {
                    elecDownlights: document.getElementById('elecDownlights')?.checked || false,
                    elecDownlightsQty: document.getElementById('elecDownlightsQty')?.value || '4',
                    elecFan: document.getElementById('elecFan')?.checked || false,
                    elecFanQty: document.getElementById('elecFanQty')?.value || '1',
                    elecGPO: document.getElementById('elecGPO')?.checked || false,
                    elecGPOQty: document.getElementById('elecGPOQty')?.value || '1',
                    scopeDemo: document.getElementById('scopeDemo')?.checked || false,
                    scopeSkip: document.getElementById('scopeSkip')?.checked || false,
                    scopePermit: document.getElementById('scopePermit')?.checked || false
                },
                flashings: flashingProfiles.map(function(p) {
                    return { id: p.id, name: p.name, colour: p.colour, gauge: p.gauge, length: p.length, qty: p.qty, colourSide: p.colourSide, points: p.points, girth: p.girth, legs: p.legs, startTreatment: p.startTreatment || null, endTreatment: p.endTreatment || null };
                })
            };
        }

        function exportJobData() {
            const data = gatherJobData();
            const json = JSON.stringify(data, null, 2);

            // Copy to clipboard
            navigator.clipboard.writeText(json).then(() => {
                alert('Job data copied to clipboard!\n\nPaste this into GHL notes, email, or save as a file to reload later.');
            }).catch(() => {
                // Fallback: download as file
                downloadJobJSON(json, data.client.jobRef);
            });
        }

        function saveJobData() {
            updateSiteDetails();
            var base = gatherJobData();
            var jobData = {
                version: '1.0',
                savedAt: new Date().toISOString(),
                customer: customer,
                siteDetails: siteDetails,
                client: base.client,
                config: base.config,
                pricing: base.pricing,
                complexity: base.complexity,
                notes: base.notes,
                specs: {
                    roofType: base.config.roofStyle,
                    width: base.config.length,
                    projection: base.config.projection,
                    height: base.config.postHeight,
                    pitch: base.config.pitch,
                    roofMaterial: base.config.roofing,
                    attachmentType: base.config.connection,
                    roofColour: base.config.sheetColor,
                    frameColour: base.config.steelColor
                },
                truss: {
                    base: base.config.trussBase,
                    chord: base.config.trussChord,
                    steel: base.config.trussSteel,
                    overhang: base.config.overhang,
                    riserLeft: base.config.trussRiserLeft,
                    riserRight: base.config.trussRiserRight,
                    riserLocked: base.config.trussRiserLocked,
                    riserType: base.config.riserType || 'welded',
                    extender: base.config.trussExtender
                },
                polycarb: {
                    enabled: base.config.polycarbEnabled,
                    brand: base.config.polycarbBrand,
                    tint: base.config.polycarbTint,
                    pattern: base.config.polycarbPattern,
                    custom: base.config.polycarbCustom,
                    level: base.config.polycarbLevel
                },
                flashings: flashingProfiles.map(function(p) {
                    return { id: p.id, name: p.name, colour: p.colour, gauge: p.gauge, length: p.length, qty: p.qty, colourSide: p.colourSide, points: p.points, girth: p.girth, legs: p.legs, startTreatment: p.startTreatment || null, endTreatment: p.endTreatment || null };
                })
            };
            var json = JSON.stringify(jobData, null, 2);

            navigator.clipboard.writeText(json).then(function() {
                localStorage.setItem('patio-job-' + Date.now(), json);
                alert('Job data copied to clipboard! Paste into GHL notes.');
            }).catch(function() {
                localStorage.setItem('patio-job-' + Date.now(), json);
                alert('Job data saved locally. Clipboard access was blocked.');
            });
        }

        function showLoadJobModal() {
            document.getElementById('loadJobTextarea').value = '';
            document.getElementById('loadJobStatus').textContent = '';
            document.getElementById('loadJobModal').style.display = '';
        }

        function closeLoadJobModal() {
            document.getElementById('loadJobModal').style.display = 'none';
        }

        function loadJobData() {
            var raw = document.getElementById('loadJobTextarea').value.trim();
            var statusEl = document.getElementById('loadJobStatus');
            if (!raw) { statusEl.textContent = 'Please paste JSON data first.'; statusEl.style.color = '#FF3B30'; return; }

            var data;
            try {
                data = JSON.parse(raw);
            } catch(e) {
                statusEl.textContent = 'Invalid JSON. Please check and try again.';
                statusEl.style.color = '#FF3B30';
                return;
            }

            // Restore customer state + DOM
            if (data.customer) {
                customer = { name: data.customer.name || '', address: data.customer.address || '', phone: data.customer.phone || '' };
                document.getElementById('customerName').value = customer.name;
                document.getElementById('customerAddress').value = customer.address;
                document.getElementById('customerPhone').value = customer.phone;
            }

            // Restore siteDetails state + DOM
            if (data.siteDetails) {
                var sd = data.siteDetails;
                siteDetails = {
                    existingSite: sd.existingSite || 'clear',
                    demoScope: sd.demoScope || 'na',
                    electrical: sd.electrical || 'none',
                    siteAccess: sd.siteAccess || 'easy',
                    groundSurface: sd.groundSurface || 'grass',
                    fasciaMaterial: sd.fasciaMaterial || 'timber',
                    wallType: sd.wallType || 'doublebrick',
                    existingRoof: sd.existingRoof || 'tiles'
                };
                // Restore toggle buttons
                var restoreToggle = function(fieldId, val) {
                    var el = document.getElementById(fieldId);
                    if (el) el.value = val;
                    var group = document.getElementById(fieldId + 'Group');
                    if (group) {
                        group.querySelectorAll('.toggle-btn').forEach(function(b) {
                            b.classList.toggle('active', b.getAttribute('data-value') === val);
                        });
                    }
                };
                restoreToggle('siteAccess', siteDetails.siteAccess);
                restoreToggle('groundSurface', siteDetails.groundSurface);
                restoreToggle('fasciaMaterial', siteDetails.fasciaMaterial);
                restoreToggle('wallType', siteDetails.wallType);
                restoreToggle('existingRoof', siteDetails.existingRoof);
                // Migrate old siteNotes â†’ noteWorkOrder
                if (siteDetails.notes && document.getElementById('noteWorkOrder') && !document.getElementById('noteWorkOrder').value) {
                    document.getElementById('noteWorkOrder').value = siteDetails.notes;
                }
            }
            // Restore existing site fields
            if (data.existingSite) {
                var es = data.existingSite;
                if (document.getElementById('existingSite')) document.getElementById('existingSite').value = es.existing || 'clear';
                if (document.getElementById('demoScope')) document.getElementById('demoScope').value = es.demoScope || 'na';
                if (document.getElementById('electrical')) {
                    document.getElementById('electrical').value = es.electrical || 'none';
                    var ev = es.electrical || 'none';
                    if (ev === 'downlights' || ev === 'both') document.getElementById('elecDownlights').checked = true;
                    if (ev === 'fan' || ev === 'both') document.getElementById('elecFan').checked = true;
                }
                updateExistingSite();
            }
            // Legacy: restore old extras format
            if (!data.existingSite && data.extras) {
                var ex = data.extras;
                if (ex.demo === 'yes' && document.getElementById('existingSite')) {
                    document.getElementById('existingSite').value = 'other';
                    updateExistingSite();
                }
            }

            // Restore client info (from existing format)
            if (data.client) {
                var cl = data.client;
                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                if (cl.name) document.getElementById('customerName').value = cl.name;
                if (cl.address) document.getElementById('customerAddress').value = cl.address;
                if (cl.phone) document.getElementById('customerPhone').value = cl.phone;
                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                if (cl.salesperson) document.getElementById('salesperson').value = cl.salesperson;
            }

            // Restore specs â†’ config inputs
            var cfg = data.config || {};
            var specs = data.specs || {};
            var setVal = function(id, val) { var el = document.getElementById(id); if (el && val != null) el.value = val; };
            setVal('inRoofStyle', specs.roofType || cfg.roofStyle);
            setVal('inOrientation', cfg.orientation);
            // Convert legacy mm values to m for dimension inputs
            var projVal = specs.projection || cfg.projection;
            var lenVal = specs.width || cfg.length;
            var heightVal = specs.height || cfg.postHeight;
            if (projVal && parseFloat(projVal) > 100) projVal = (parseFloat(projVal) / 1000).toFixed(1);
            if (lenVal && parseFloat(lenVal) > 100) lenVal = (parseFloat(lenVal) / 1000).toFixed(1);
            if (heightVal && parseFloat(heightVal) > 100) heightVal = (parseFloat(heightVal) / 1000).toFixed(1);
            setVal('inWidth', projVal);
            setVal('inLength', lenVal);
            setVal('inPitch', specs.pitch || cfg.pitch);
            setVal('inPostHeight', heightVal);
            setVal('inPosts', cfg.posts);
            if (cfg.postQtyOverride) { var pqo = document.getElementById('inPostQty'); if (pqo) pqo.value = cfg.postQtyOverride; }
            setVal('inTrusses', cfg.trusses);
            // Mark trusses as user-overridden if imported with a value
            if (cfg.trusses) { var tqf = document.getElementById('inTrusses'); if (tqf) tqf.dataset.userOverride = 'true'; }
            setVal('inRafters', cfg.rafters);
            if (cfg.rafterSize) setVal('inRafterSize', cfg.rafterSize);
            if (cfg.rafterSpacing) setVal('inRafterSpacing', cfg.rafterSpacing);
            if (cfg.rafterQtyOverride) { var rqo = document.getElementById('inRafterQtyOverride'); if (rqo) rqo.value = cfg.rafterQtyOverride; }
            if (cfg.purlinSize) setVal('inPurlinSize', cfg.purlinSize);
            if (cfg.gutterBeamSize) setVal('inGutterBeamSize', cfg.gutterBeamSize);
            if (cfg.riserBeamSize) setVal('inRiserBeamSize', cfg.riserBeamSize);
            // Convert legacy 'insulated' to 'solarspan75'
            var roofVal = specs.roofMaterial || cfg.roofing;
            if (roofVal === 'insulated') roofVal = 'solarspan75';
            setVal('inRoofing', roofVal);
            setVal('inInfill', cfg.infill);
            // Convert legacy 'fasciabeam' to 'riser'
            var connVal = specs.attachmentType || cfg.connection;
            if (connVal === 'fasciabeam') connVal = 'riser';
            // Legacy: old configs with gableAttachment='fascia' under riser â†’ use fascia connection
            if (connVal === 'riser' && cfg.gableAttachment === 'fascia') connVal = 'fascia';
            setVal('inConnection', connVal);
            setVal('inFasciaHeight', cfg.fasciaHeight);
            setVal('inRiserHeight', cfg.riserHeight);
            setVal('inRiserOffset', cfg.riserOffset);
            setVal('inRiserQty', cfg.riserQty);
            setVal('inHouseGutter', cfg.houseGutter);
            setVal('inRiserGutter', cfg.riserGutter);
            if (cfg.fasciaBracketQty) setVal('inFasciaBracketQty', cfg.fasciaBracketQty);
            setVal('inPostFix', cfg.postFix);
            setVal('inPostSize', cfg.postSize || '90x90');
            setVal('inBeamSize', cfg.beamSize || '100x50');
            setVal('inCeilingFinish', cfg.ceilingFinish);
            setVal('inBMT', cfg.sheetBMT || '042');
            if (cfg.extraBattens) { var ebEl = document.getElementById('extraBattensVal'); if (ebEl) ebEl.textContent = cfg.extraBattens; }
            if (cfg.bracketType) { var btRadio = document.querySelector('input[name="bracketType"][value="' + cfg.bracketType + '"]'); if (btRadio) btRadio.checked = true; }

            // Truss
            var truss = data.truss || {};
            // Legacy: map old trussStyle/trussBase values to new 3-option set
            const legacyStyleMap = {king:'kingpost', queen:'kingverticals', verticalwebs:'kingverticals', kingdiagonal:'web', kingfan:'kingverticals', queenpost:'kingverticals', kingstrut:'web', fink:'web', open:'web'};
            const rawBase = truss.base || cfg.trussBase || cfg.trussStyle || 'kingpost';
            const legacyBase = legacyStyleMap[rawBase] || rawBase;
            setVal('inTrussBase', legacyBase);
            setVal('inTrussChord', truss.chord || cfg.trussChord || 'bottom');
            setVal('inTrussSteel', truss.steel || cfg.trussSteel);
            setVal('inOverhang', truss.overhang || cfg.overhang);

            // Truss options: extender + risers (L/R)
            const tExtender = truss.extender || cfg.trussExtender || {};
            const tRiserL = truss.riserLeft || cfg.trussRiserLeft || {};
            const tRiserR = truss.riserRight || cfg.trussRiserRight || {};
            // Legacy: migrate old riser/dogleg data
            const legacyRiser = truss.riser || cfg.trussRiser || {};
            if (tExtender.enabled) {
                document.getElementById('trussExtOn').checked = true;
                setVal('trussExtLen', tExtender.length || '300');
            }
            if (tRiserL.enabled || tRiserR.enabled || legacyRiser.enabled) {
                document.getElementById('trussRiserOn').checked = true;
                setVal('riserLH', tRiserL.length || legacyRiser.rx || '200');
                setVal('riserLV', tRiserL.height || legacyRiser.ry || '150');
                setVal('riserRH', tRiserR.length || legacyRiser.rx || '200');
                setVal('riserRV', tRiserR.height || legacyRiser.ry || '150');
            }
            if (truss.riserLocked !== undefined || cfg.trussRiserLocked !== undefined) {
                document.getElementById('trussRiserLock').checked = truss.riserLocked !== false && cfg.trussRiserLocked !== false;
            }
            // Riser type (welded vs separate)
            const riserType = truss.riserType || cfg.riserType || 'welded';
            document.getElementById(riserType === 'separate' ? 'riserTypeSeparate' : 'riserTypeWelded').checked = true;
            toggleTrussOpt();

            // Existing Site (loaded above in siteDetails restore block)

            // Colours
            var roofColour = specs.roofColour || cfg.sheetColor;
            if (roofColour) {
                var sc = COLORS.find(function(c) { return c.name === roofColour; });
                if (sc) {
                    sheetColor = sc;
                    document.querySelectorAll('#sheetChips .color-chip').forEach(function(ch) { ch.classList.toggle('active', ch.title === sc.name); });
                    document.getElementById('sheetLabel').textContent = sc.name;
                }
            }
            var fColour = specs.frameColour || cfg.steelColor;
            if (fColour) {
                var sc2 = COLORS.find(function(c) { return c.name === fColour; });
                if (sc2) {
                    steelColor = sc2;
                    document.querySelectorAll('#steelChips .color-chip').forEach(function(ch) { ch.classList.toggle('active', ch.title === sc2.name); });
                    document.getElementById('steelLabel').textContent = sc2.name;
                }
            }

            // Polycarbonate
            var pc = data.polycarb || {};
            var pcEnabled = pc.enabled || cfg.polycarbEnabled;
            if (pcEnabled) {
                document.querySelector('input[name="polycarb"][value="yes"]').checked = true;
                document.getElementById('polycarbOptions').style.display = 'block';
                if (pc.brand || cfg.polycarbBrand) document.getElementById('inPolycarbBrand').value = pc.brand || cfg.polycarbBrand;
                updatePolycarbTints();
                if (pc.tint || cfg.polycarbTint) document.getElementById('inPolycarbTint').value = pc.tint || cfg.polycarbTint;
                if (pc.pattern || cfg.polycarbPattern) document.getElementById('inPolycarbPattern').value = pc.pattern || cfg.polycarbPattern;
                if (pc.custom || cfg.polycarbCustom) document.getElementById('inPolycarbCustom').value = pc.custom || cfg.polycarbCustom;
                var pcLevel = pc.level || cfg.polycarbLevel;
                if (pcLevel) document.getElementById('inPolycarbLevel').value = pcLevel;
                updatePolycarbLevels();
                updatePolycarbPreview();
            }

            // Pricing
            if (data.pricing) {
                var p = data.pricing;
                if (p.addonRows && Array.isArray(p.addonRows)) {
                    jobRows = jobRows.filter(function(r) { return !r.isAddon; });
                    p.addonRows.forEach(function(a) { a.isAddon = true; if (!a.unit) a.unit = 'each'; jobRows.push(a); });
                }
                if (p.extrasRows && Array.isArray(p.extrasRows)) extrasRows = p.extrasRows;
                if (p.additionalMaterials && Array.isArray(p.additionalMaterials)) additionalMaterials = p.additionalMaterials;
                if (p.labour) {
                    if (p.labour.trades != null) document.getElementById('labTrades').value = p.labour.trades;
                    if (p.labour.days != null) document.getElementById('labDays').value = p.labour.days;
                    if (p.labour.dayRate != null) document.getElementById('labDayRate').value = p.labour.dayRate;
                    if (p.labour.sell != null) document.getElementById('labSellInput').value = p.labour.sell;
                }
            }

            // Complexity
            if (data.complexity) {
                var cx = data.complexity;
                if (cx.build) document.getElementById('cxBuild').value = cx.build;
                if (cx.access) document.getElementById('cxAccess').value = cx.access;
                if (cx.distance) document.getElementById('cxDistance').value = cx.distance;
                if (cx.footing) document.getElementById('cxFooting').value = cx.footing;
                if (cx.height) document.getElementById('cxHeight').value = cx.height;
            }

            // Notes
            if (data.notes) {
                // Migrate old jobNotes â†’ noteInternal
                if (data.notes.jobNotes && !data.notes.noteInternal && document.getElementById('noteInternal')) document.getElementById('noteInternal').value = data.notes.jobNotes;
                if (data.notes.pricingNotes) document.getElementById('pricingNotes').value = data.notes.pricingNotes;
                if (data.notes.noteQuote && document.getElementById('noteQuote')) document.getElementById('noteQuote').value = data.notes.noteQuote;
                if (data.notes.noteWorkOrder && document.getElementById('noteWorkOrder')) document.getElementById('noteWorkOrder').value = data.notes.noteWorkOrder;
                if (data.notes.noteMaterialOrder && document.getElementById('noteMaterialOrder')) document.getElementById('noteMaterialOrder').value = data.notes.noteMaterialOrder;
                if (data.notes.noteInternal && document.getElementById('noteInternal')) document.getElementById('noteInternal').value = data.notes.noteInternal;
            }

            // Scope checkboxes
            if (data.scope) {
                if (data.scope.elecDownlights) { document.getElementById('elecDownlights').checked = true; document.getElementById('elecDownlightsQty').value = data.scope.elecDownlightsQty || '4'; }
                if (data.scope.elecFan) { document.getElementById('elecFan').checked = true; document.getElementById('elecFanQty').value = data.scope.elecFanQty || '1'; }
                if (data.scope.elecGPO) { document.getElementById('elecGPO').checked = true; document.getElementById('elecGPOQty').value = data.scope.elecGPOQty || '1'; }
                if (data.scope.scopeDemo) document.getElementById('scopeDemo').checked = true;
                if (data.scope.scopeSkip) document.getElementById('scopeSkip').checked = true;
                if (data.scope.scopePermit) document.getElementById('scopePermit').checked = true;
                syncElectricalCheckboxes();
            }

            // Flashings
            if (data.flashings && Array.isArray(data.flashings)) {
                flashingProfiles = data.flashings.map(function(f) {
                    return {
                        id: f.id || 'flashing_' + String(flashNextId++).padStart(3, '0'),
                        name: f.name || 'Unnamed',
                        colour: f.colour || 'Monument',
                        gauge: f.gauge || 0.42,
                        length: f.length || 3000,
                        qty: f.qty || 1,
                        colourSide: f.colourSide || 'inside',
                        points: f.points || [],
                        girth: f.girth || calcGirth(f.points || []),
                        legs: f.legs || calcLegs(f.points || [])
                    };
                });
                renderFlashJobTable();
                updateFlashSummary();
            }

            // Rebuild everything
            syncAllToggleButtons();
            updateUI();
            rebuildAll();
            renderExtras();
            updatePricing();
            updateHeaderBadge();

            closeLoadJobModal();
            var custName = (data.customer && data.customer.name) ? data.customer.name : (data.client && data.client.name) ? data.client.name : 'Unknown';
            var custAddr = (data.customer && data.customer.address) ? data.customer.address : (data.client && data.client.address) ? data.client.address : '';
            alert('Job loaded: ' + custName + (custAddr ? ', ' + custAddr : ''));
        }

        function downloadJobJSON(json, ref) {
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (ref || 'PatioJob') + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function showImportModal() {
            document.getElementById('importTextarea').value = '';
            document.getElementById('importStatus').textContent = '';
            document.getElementById('importModal').style.display = '';
        }

        function importJobData() {
            const raw = document.getElementById('importTextarea').value.trim();
            const statusEl = document.getElementById('importStatus');
            if (!raw) { statusEl.textContent = 'Please paste JSON data first.'; statusEl.style.color = '#FF3B30'; return; }
            let data;
            try {
                data = JSON.parse(raw);
            } catch(e) {
                statusEl.textContent = 'Invalid JSON. Check the data and try again.';
                statusEl.style.color = '#FF3B30';
                return;
            }

            // Populate client info
            if (data.client) {
                const cl = data.client;
                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                if (cl.name) document.getElementById('customerName').value = cl.name;
                if (cl.address) document.getElementById('customerAddress').value = cl.address;
                if (cl.phone) document.getElementById('customerPhone').value = cl.phone;
                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                if (cl.salesperson) document.getElementById('salesperson').value = cl.salesperson;
            }

            // Populate config
            if (data.config) {
                const cfg = data.config;
                const setVal = (id, val) => { const el = document.getElementById(id); if (el && val != null) el.value = val; };
                setVal('inRoofStyle', cfg.roofStyle);
                setVal('inOrientation', cfg.orientation);
                setVal('inWidth', cfg.projection);
                setVal('inLength', cfg.length);
                setVal('inPitch', cfg.pitch);
                setVal('inPostHeight', cfg.postHeight);
                setVal('inPosts', cfg.posts);
                if (cfg.postQtyOverride) { var pqo2 = document.getElementById('inPostQty'); if (pqo2) pqo2.value = cfg.postQtyOverride; }
                setVal('inTrusses', cfg.trusses);
                setVal('inRafters', cfg.rafters);
                if (cfg.rafterSize) setVal('inRafterSize', cfg.rafterSize);
                if (cfg.rafterSpacing) setVal('inRafterSpacing', cfg.rafterSpacing);
                if (cfg.rafterQtyOverride) { var rqo2 = document.getElementById('inRafterQtyOverride'); if (rqo2) rqo2.value = cfg.rafterQtyOverride; }
                if (cfg.purlinSize) setVal('inPurlinSize', cfg.purlinSize);
                if (cfg.gutterBeamSize) setVal('inGutterBeamSize', cfg.gutterBeamSize);
                if (cfg.riserBeamSize) setVal('inRiserBeamSize', cfg.riserBeamSize);
                setVal('inRoofing', cfg.roofing);
                setVal('inInfill', cfg.infill);
                setVal('inConnection', cfg.connection);
                setVal('inFasciaHeight', cfg.fasciaHeight);
                setVal('inRiserHeight', cfg.riserHeight);
                setVal('inRiserOffset', cfg.riserOffset);
                setVal('inRiserQty', cfg.riserQty);
                setVal('inHouseGutter', cfg.houseGutter);
                setVal('inRiserGutter', cfg.riserGutter);
                setVal('inPostFix', cfg.postFix);
                setVal('inPostSize', cfg.postSize || '90x90');
                setVal('inBeamSize', cfg.beamSize || '100x50');
                setVal('inBMT', cfg.sheetBMT || '042');
                if (cfg.extraBattens) { var ebEl2 = document.getElementById('extraBattensVal'); if (ebEl2) ebEl2.textContent = cfg.extraBattens; }
                if (cfg.bracketType) { var btR2 = document.querySelector('input[name="bracketType"][value="' + cfg.bracketType + '"]'); if (btR2) btR2.checked = true; }
                const legacyMap2 = {king:'kingpost', queen:'kingverticals', verticalwebs:'kingverticals', kingdiagonal:'web', kingfan:'kingverticals', queenpost:'kingverticals', kingstrut:'web', fink:'web', open:'web'};
                const rawBase2 = cfg.trussBase || cfg.trussStyle || 'kingpost';
                const lb = legacyMap2[rawBase2] || rawBase2;
                setVal('inTrussBase', lb);
                setVal('inTrussChord', cfg.trussChord || 'bottom');
                setVal('inTrussSteel', cfg.trussSteel);
                setVal('inOverhang', cfg.overhang);

                // Truss options (handles both legacy and new format)
                if (cfg.trussExtender && cfg.trussExtender.enabled) {
                    document.getElementById('trussExtOn').checked = true;
                    setVal('trussExtLen', cfg.trussExtender.length || '300');
                }
                // New riser L/R format
                if (cfg.trussRiserLeft && cfg.trussRiserLeft.enabled) {
                    document.getElementById('trussRiserOn').checked = true;
                    setVal('riserLH', cfg.trussRiserLeft.length || '200');
                    setVal('riserLV', cfg.trussRiserLeft.height || '150');
                    setVal('riserRH', (cfg.trussRiserRight || {}).length || '200');
                    setVal('riserRV', (cfg.trussRiserRight || {}).height || '150');
                }
                // Legacy riser format (migrate to both sides)
                else if (cfg.trussRiser && cfg.trussRiser.enabled) {
                    document.getElementById('trussRiserOn').checked = true;
                    setVal('riserLH', cfg.trussRiser.rx || '200');
                    setVal('riserLV', cfg.trussRiser.ry || '150');
                    setVal('riserRH', cfg.trussRiser.rx || '200');
                    setVal('riserRV', cfg.trussRiser.ry || '150');
                }
                if (cfg.trussRiserLocked !== undefined) {
                    document.getElementById('trussRiserLock').checked = cfg.trussRiserLocked !== false;
                }
                // Riser type (welded vs separate)
                if (cfg.riserType === 'separate') {
                    document.getElementById('riserTypeSeparate').checked = true;
                } else {
                    document.getElementById('riserTypeWelded').checked = true;
                }
                toggleTrussOpt();

                // Colours
                if (cfg.sheetColor) {
                    const sc = COLORS.find(c => c.name === cfg.sheetColor);
                    if (sc) {
                        sheetColor = sc;
                        const chips = document.querySelectorAll('#sheetChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('sheetLabel').textContent = sc.name;
                    }
                }
                if (cfg.steelColor) {
                    const sc = COLORS.find(c => c.name === cfg.steelColor);
                    if (sc) {
                        steelColor = sc;
                        const chips = document.querySelectorAll('#steelChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('steelLabel').textContent = sc.name;
                    }
                }
                // Polycarbonate
                if (cfg.polycarbEnabled) {
                    document.querySelector('input[name="polycarb"][value="yes"]').checked = true;
                    document.getElementById('polycarbOptions').style.display = 'block';
                    if (cfg.polycarbBrand) document.getElementById('inPolycarbBrand').value = cfg.polycarbBrand;
                    updatePolycarbTints();
                    if (cfg.polycarbTint) document.getElementById('inPolycarbTint').value = cfg.polycarbTint;
                    if (cfg.polycarbPattern) document.getElementById('inPolycarbPattern').value = cfg.polycarbPattern;
                    if (cfg.polycarbCustom) document.getElementById('inPolycarbCustom').value = cfg.polycarbCustom;
                    if (cfg.polycarbLevel) document.getElementById('inPolycarbLevel').value = cfg.polycarbLevel;
                    updatePolycarbLevels();
                    updatePolycarbPreview();
                }
            }

            // Populate existing site
            if (data.existingSite) {
                const es = data.existingSite;
                if (document.getElementById('existingSite')) document.getElementById('existingSite').value = es.existing || 'clear';
                if (document.getElementById('demoScope')) document.getElementById('demoScope').value = es.demoScope || 'na';
                if (document.getElementById('electrical')) {
                    document.getElementById('electrical').value = es.electrical || 'none';
                    var ev = es.electrical || 'none';
                    if (ev === 'downlights' || ev === 'both') document.getElementById('elecDownlights').checked = true;
                    if (ev === 'fan' || ev === 'both') document.getElementById('elecFan').checked = true;
                }
                updateExistingSite();
            }
            // Populate siteDetails toggle buttons
            if (data.siteDetails) {
                var sd2 = data.siteDetails;
                var restoreToggle2 = function(fieldId, val) {
                    var el = document.getElementById(fieldId);
                    if (el) el.value = val;
                    var group = document.getElementById(fieldId + 'Group');
                    if (group) {
                        group.querySelectorAll('.toggle-btn').forEach(function(b) {
                            b.classList.toggle('active', b.getAttribute('data-value') === val);
                        });
                    }
                };
                restoreToggle2('siteAccess', sd2.siteAccess || 'easy');
                restoreToggle2('groundSurface', sd2.groundSurface || 'grass');
                restoreToggle2('fasciaMaterial', sd2.fasciaMaterial || 'timber');
                restoreToggle2('wallType', sd2.wallType || 'doublebrick');
                restoreToggle2('existingRoof', sd2.existingRoof || 'tiles');
                // Migrate old siteNotes â†’ noteWorkOrder
                if (sd2.notes && document.getElementById('noteWorkOrder') && !document.getElementById('noteWorkOrder').value) {
                    document.getElementById('noteWorkOrder').value = sd2.notes;
                }
            }

            // Populate pricing
            if (data.pricing) {
                const p = data.pricing;
                if (p.addonRows && Array.isArray(p.addonRows)) {
                    jobRows = jobRows.filter(r => !r.isAddon);
                    p.addonRows.forEach(a => { a.isAddon = true; if (!a.unit) a.unit = 'each'; jobRows.push(a); });
                }
                // New extras format
                if (p.extrasRows && Array.isArray(p.extrasRows)) {
                    extrasRows = p.extrasRows;
                }
                if (p.additionalMaterials && Array.isArray(p.additionalMaterials)) {
                    additionalMaterials = p.additionalMaterials;
                }
                // New labour card format
                if (p.labour) {
                    const l = p.labour;
                    if (l.trades != null) document.getElementById('labTrades').value = l.trades;
                    if (l.days != null) document.getElementById('labDays').value = l.days;
                    if (l.dayRate != null) document.getElementById('labDayRate').value = l.dayRate;
                    if (l.sell != null) document.getElementById('labSellInput').value = l.sell;
                }
                // Legacy: old labourRows format (backward compat)
                if (p.labourRows && Array.isArray(p.labourRows) && p.labourRows.length > 0 && !p.labour) {
                    const first = p.labourRows[0];
                    document.getElementById('labTrades').value = first.trades || 2;
                    document.getElementById('labDays').value = first.days || 1.5;
                    document.getElementById('labDayRate').value = first.dayRate || 400;
                    document.getElementById('labSellInput').value = first.sell || 0;
                }
                // Legacy: delivery as extras (backward compat)
                if (p.deliveryCost != null && parseFloat(p.deliveryCost) > 0 && !p.extrasRows) {
                    extrasRows.push({ desc: 'Delivery', qty: 1, unitCost: parseFloat(p.deliveryCost) || 0, unitSell: parseFloat(p.deliverySell) || 0, type: 'delivery' });
                }
            }

            // Complexity scores (still stored in hidden inputs)
            if (data.complexity) {
                const cx = data.complexity;
                if (cx.build) document.getElementById('cxBuild').value = cx.build;
                if (cx.access) document.getElementById('cxAccess').value = cx.access;
                if (cx.distance) document.getElementById('cxDistance').value = cx.distance;
                if (cx.footing) document.getElementById('cxFooting').value = cx.footing;
                if (cx.height) document.getElementById('cxHeight').value = cx.height;
            }

            // Notes
            if (data.notes) {
                // Migrate old jobNotes â†’ noteInternal
                if (data.notes.jobNotes && !data.notes.noteInternal && document.getElementById('noteInternal')) document.getElementById('noteInternal').value = data.notes.jobNotes;
                if (data.notes.pricingNotes) document.getElementById('pricingNotes').value = data.notes.pricingNotes;
                if (data.notes.noteQuote && document.getElementById('noteQuote')) document.getElementById('noteQuote').value = data.notes.noteQuote;
                if (data.notes.noteWorkOrder && document.getElementById('noteWorkOrder')) document.getElementById('noteWorkOrder').value = data.notes.noteWorkOrder;
                if (data.notes.noteMaterialOrder && document.getElementById('noteMaterialOrder')) document.getElementById('noteMaterialOrder').value = data.notes.noteMaterialOrder;
                if (data.notes.noteInternal && document.getElementById('noteInternal')) document.getElementById('noteInternal').value = data.notes.noteInternal;
            }

            // Scope checkboxes
            if (data.scope) {
                if (data.scope.elecDownlights) { document.getElementById('elecDownlights').checked = true; document.getElementById('elecDownlightsQty').value = data.scope.elecDownlightsQty || '4'; }
                if (data.scope.elecFan) { document.getElementById('elecFan').checked = true; document.getElementById('elecFanQty').value = data.scope.elecFanQty || '1'; }
                if (data.scope.elecGPO) { document.getElementById('elecGPO').checked = true; document.getElementById('elecGPOQty').value = data.scope.elecGPOQty || '1'; }
                if (data.scope.scopeDemo) document.getElementById('scopeDemo').checked = true;
                if (data.scope.scopeSkip) document.getElementById('scopeSkip').checked = true;
                if (data.scope.scopePermit) document.getElementById('scopePermit').checked = true;
                syncElectricalCheckboxes();
            }

            // Flashings
            if (data.flashings && Array.isArray(data.flashings)) {
                flashingProfiles = data.flashings.map(function(f) {
                    return {
                        id: f.id || 'flashing_' + String(flashNextId++).padStart(3, '0'),
                        name: f.name || 'Unnamed',
                        colour: f.colour || 'Monument',
                        gauge: f.gauge || 0.42,
                        length: f.length || 3000,
                        qty: f.qty || 1,
                        colourSide: f.colourSide || 'inside',
                        points: f.points || [],
                        girth: f.girth || calcGirth(f.points || []),
                        legs: f.legs || calcLegs(f.points || [])
                    };
                });
                renderFlashJobTable();
                updateFlashSummary();
            }

            // Rebuild everything
            syncAllToggleButtons();
            updateUI();
            rebuildAll();
            renderExtras();
            updatePricing();
            updateHeaderBadge();

            statusEl.textContent = 'Job loaded successfully! All fields populated.';
            statusEl.style.color = '#34C759';
            setTimeout(() => { document.getElementById('importModal').style.display = 'none'; }, 1200);
        }

        // ==================== JOB REF AUTO-GENERATE ====================
        function generateJobRef() {
            const d = new Date();
            const yy = String(d.getFullYear()).slice(-2);
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const seq = String(Math.floor(Math.random() * 99) + 1).padStart(2, '0');
            return 'SW' + yy + mm + dd + '-' + seq;
        }

        function initJobDetails() {
            const refEl = document.getElementById('jobRef');
            if (!refEl.value.trim()) refEl.value = generateJobRef();
            // Sync header badge on any field change
            ['jobRef', 'customerName'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', updateHeaderBadge);
            });
            updateHeaderBadge();
        }

        function updateHeaderBadge() {
            const ref = (document.getElementById('jobRef')?.value || '').trim();
            const name = (document.getElementById('customerName')?.value || '').trim();
            const badge = document.getElementById('headerBadge');
            if (badge) badge.innerHTML = '<strong>' + (ref || 'SW\u2014') + '</strong>' + (name ? ' &nbsp;' + name : '');
        }

        // ==================== PDF SHARED HELPERS ====================
        function getJobRef() {
            const el = document.getElementById('jobRef');
            return (el && el.value.trim()) || generateJobRef();
        }
        function getClientName() { return (document.getElementById('customerName')?.value || '').trim() || 'Client'; }
        function getSiteAddress() { return (document.getElementById('customerAddress')?.value || '').trim(); }
        function getClientPhone() { return (document.getElementById('customerPhone')?.value || '').trim(); }
        function getClientEmail() { return (document.getElementById('clientEmail')?.value || '').trim(); }
        function getSalesperson() { return (document.getElementById('salesperson')?.value || '').trim(); }
        function safeName(s) { return s.replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_'); }
        function todayStr() {
            const d = new Date();
            return d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();
        }
        function fmtDollars(v) { return '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ','); }

        function connectionLabel(conn) {
            const map = {freestanding:'Freestanding',fascia:'Fascia / Receiving',wall:'Wall Mount',riser:'Riser Beam',flyover:'Flyover'};
            return map[conn] || conn;
        }
        function roofingLabel(r) {
            const map = {corrugated:'Corrugated Colorbond',trimdek:'Trimdek',spandek:'Spandek',solarspan75:'SolarSpan 75mm',solarspan100:'SolarSpan 100mm',spanplus330:'SpanPlus 330'};
            return map[r] || r;
        }

        function buildScopeText() {
            const c = calc;
            const style = c.isGable ? 'Gable' : 'Skillion';
            const Lm = (c.lenInput / 1000).toFixed(1);
            const Wm = (c.projInput / 1000).toFixed(1);
            const conn = connectionLabel(c.connection);
            const roof = roofingLabel(c.roofing);
            let roofDesc = 'Roof: ' + roof + ' (' + sheetColor.name + ')';
            const pc = hasPolycarbMatch(c.roofing) ? getPolycarbConfig() : null;
            if (pc) {
                const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
                roofDesc += ' with ' + brandLabel + ' ' + pc.tint + ' Lv' + pc.level + ' polycarbonate (every ' + pc.patternN + getSuffix(pc.patternN) + ' sheet)';
            }
            return 'Supply and install a ' + style + ' patio, ' + Lm + 'm x ' + Wm + 'm, attached via ' + conn + '. ' +
                   roofDesc + '. Steel: ' + steelColor.name + '. Including gutters, downpipes and flashings.';
        }
        function getSuffix(n) { return n === 2 ? 'nd' : n === 3 ? 'rd' : 'th'; }

        function capture3DImage() {
            try {
                if (asmRend && asmScene && asmCam) {
                    asmRend.render(asmScene, asmCam);
                    return asmRend.domElement.toDataURL('image/png');
                }
            } catch(e) { /* cross-origin or not ready */ }
            return null;
        }


        // Brand-correct colours from style guide
        const SW_ORANGE = [241, 90, 41];   // #F15A29  <- was #F26522
        const SW_DARK   = [41, 60, 70];    // #293C46
        const SW_MID    = [76, 106, 124];  // #4C6A7C

        // -- shared PDF helpers --

        function pdfHeader(doc, title, jobRef) {
            const pageW = doc.internal.pageSize.getWidth();
            // Orange header band - taller, more presence
            doc.setFillColor(...SW_ORANGE);
            doc.rect(0, 0, pageW, 32, 'F');

            // Company name - white, bold
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(20);
            doc.setTextColor(255, 255, 255);
            doc.text('SecureWorks WA', 14, 15);

            // Tagline
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(255, 255, 255);
            doc.text('Patios  \u2022  Carports  \u2022  Pergolas', 14, 23);

            // Job ref - right aligned
            doc.setFontSize(13);
            doc.setFont('helvetica', 'bold');
            doc.text(jobRef, pageW - 14, 14, { align: 'right' });
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.text(todayStr(), pageW - 14, 22, { align: 'right' });

            // Title below band - dark blue, with accent underline
            doc.setFontSize(15);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text(title, 14, 44);
            // Orange accent line under title
            doc.setDrawColor(...SW_ORANGE);
            doc.setLineWidth(0.8);
            doc.line(14, 47, 60, 47);
            doc.setLineWidth(0.2); // reset

            return 54;
        }

        function pdfFooter(doc) {
            const pageW = doc.internal.pageSize.getWidth();
            const pageH = doc.internal.pageSize.getHeight();
            // Thin line
            doc.setDrawColor(200, 200, 200);
            doc.setLineWidth(0.3);
            doc.line(14, pageH - 16, pageW - 14, pageH - 16);
            doc.setLineWidth(0.2);

            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(140, 140, 140);
            const sp = getSalesperson();
            const footerParts = ['SecureWorks WA'];
            var companyABN = 'XX XXX XXX XXX';
            var companyPhone = '(08) XXXX XXXX';
            if (companyABN && companyABN.indexOf('XX') === -1) footerParts.push('ABN: ' + companyABN);
            if (companyPhone && companyPhone.indexOf('XX') === -1) footerParts.push('Phone: ' + companyPhone);
            if (sp && sp !== 'Other') footerParts.push('Sales: ' + sp);
            doc.text(footerParts.join('  |  '), pageW / 2, pageH - 10, { align: 'center' });
        }

        function pdfClientBlock(doc, y) {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(80, 80, 80);
            const name = getClientName();
            const addr = getSiteAddress();
            const phone = getClientPhone();
            const email = getClientEmail();
            if (name) { doc.text('Client: ' + name, 14, y); y += 5; }
            if (addr) { doc.text('Site: ' + addr, 14, y); y += 5; }
            const contactParts = [phone ? 'Phone: ' + phone : '', email ? 'Email: ' + email : ''].filter(Boolean);
            if (contactParts.length) { doc.text(contactParts.join('    |    '), 14, y); y += 5; }
            return y + 3;
        }

        // Table helper (unchanged logic, cleaner styling)
        function pdfTable(doc, y, headers, rows, colWidths, opts) {
            opts = opts || {};
            const startX = opts.startX || 14;
            const rowH = opts.rowH || 6;
            const fontSize = opts.fontSize || 9;
            const headerBg = opts.headerBg || SW_DARK;
            const altBg = opts.altBg || [245, 245, 247];
            const totalW = colWidths.reduce((a, b) => a + b, 0);

            // Header row
            doc.setFillColor(...headerBg);
            doc.rect(startX, y, totalW, rowH + 1, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(fontSize - 1);
            doc.setTextColor(255, 255, 255);
            let cx = startX;
            headers.forEach((h, i) => {
                const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                doc.text(h, tx, y + rowH - 1, { align });
                cx += colWidths[i];
            });
            y += rowH + 1;

            // Data rows
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(fontSize);
            rows.forEach((row, ri) => {
                if (y + rowH > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                if (ri % 2 === 1) {
                    doc.setFillColor(...altBg);
                    doc.rect(startX, y, totalW, rowH, 'F');
                }
                const isBold = row._bold;
                doc.setFont('helvetica', isBold ? 'bold' : 'normal');
                doc.setTextColor(...(isBold ? SW_DARK : [60, 60, 60]));
                cx = startX;
                row.forEach((cell, i) => {
                    const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                    const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                    doc.text(String(cell), tx, y + rowH - 1.5, { align });
                    cx += colWidths[i];
                });
                y += rowH;
            });
            return y + 2;
        }

        function getMaterialRows() {
            const rows = [];
            const els = document.querySelectorAll('#matList .mat-row');
            els.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length >= 2) {
                    const desc = row.dataset.desc || spans[0].textContent.trim();
                    const qty = parseInt(spans[1].textContent.trim().replace('Ã—', '')) || 1;
                    const length = getItemLength(desc);
                    rows.push({ desc, qty, length });
                }
            });
            return rows;
        }


        // -- Improved render capture --

        function captureQuoteRenders() {
            if (!asmRend || !asmScene || !asmCam || !asmControls) return { hero: null, side: null, underside: null };
            var renders = {};
            var origPos = asmCam.position.clone();
            var origTarget = asmControls.target.clone();

            var box = new THREE.Box3();
            if (steelGrp) box.expandByObject(steelGrp);
            if (roofGrp) box.expandByObject(roofGrp);
            if (accGrp) box.expandByObject(accGrp);
            var center = new THREE.Vector3();
            var size = new THREE.Vector3();
            box.getCenter(center);
            box.getSize(size);
            if (size.length() === 0) { size.set(6, 3, 4); center.set(0, 1.5, 0); }

            var maxDim = Math.max(size.x, size.z);
            var houseVisible = houseGrp ? houseGrp.visible : false;

            function captureAngle(camPos, lookTarget) {
                asmCam.position.copy(camPos);
                asmControls.target.copy(lookTarget);
                asmControls.update();
                asmRend.render(asmScene, asmCam);
                return asmRend.domElement.toDataURL('image/png');
            }

            try {
                // Hero shot: front-right 3/4 angle, slightly elevated
                renders.hero = captureAngle(
                    new THREE.Vector3(center.x + maxDim * 1.3, center.y + size.y * 0.8, center.z + maxDim * 1.3),
                    center
                );

                // Side view: front elevation
                renders.side = captureAngle(
                    new THREE.Vector3(center.x, center.y + size.y * 0.3, center.z + maxDim * 2.2),
                    center
                );

                // FIXED: Rear 3/4 view instead of broken underside
                // Old code pointed camera upward from below -> often blank
                // New: rear-left angle showing back of structure
                renders.underside = captureAngle(
                    new THREE.Vector3(center.x - maxDim * 1.1, center.y + size.y * 0.6, center.z - maxDim * 1.1),
                    center
                );
            } catch(e) { /* render failed */ }

            // Restore camera
            asmCam.position.copy(origPos);
            asmControls.target.copy(origTarget);
            asmControls.update();
            asmRend.render(asmScene, asmCam);
            if (houseGrp) houseGrp.visible = houseVisible;

            return renders;
        }

        // ==================== PDF 1: QUOTE (Client) ====================
        function generateQuotePDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const ps = pricingState;
            const pFmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            const c = calc;
            const pageW = 210, pageH = 297;
            const margin = 14;
            const contentW = pageW - margin * 2;

            function ensureSpace(needed) {
                if (y + needed > pageH - 22) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
            }

            // PAGE 1 - HERO / VISUAL IMPACT PAGE

            let y = pdfHeader(doc, 'Quote', jobRef);

            // Client info - two column layout
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Prepared for:', margin, y);
            doc.text('Site Address:', 115, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);
            doc.setTextColor(70, 70, 70);

            const clientName = getClientName();
            const clientPhone = getClientPhone();
            const clientEmail = getClientEmail();
            const siteAddr = getSiteAddress();

            var leftY = y;
            doc.text(clientName, margin, leftY); leftY += 4.5;
            if (clientPhone) { doc.text(clientPhone, margin, leftY); leftY += 4.5; }
            if (clientEmail) { doc.text(clientEmail, margin, leftY); leftY += 4.5; }

            if (siteAddr) {
                var addrLines = doc.splitTextToSize(siteAddr, 75);
                doc.text(addrLines, 115, y);
            }
            y = Math.max(leftY, y + 9) + 2;

            // Date & validity - subtle
            doc.setFontSize(8);
            doc.setTextColor(130, 130, 130);
            doc.text('Date: ' + todayStr() + '   |   Valid for 30 days', margin, y);
            y += 10;

            // -- YOUR NEW PATIO --
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('YOUR NEW PATIO', margin, y);
            // Orange accent
            doc.setDrawColor(...SW_ORANGE);
            doc.setLineWidth(0.6);
            doc.line(margin, y + 2.5, margin + 48, y + 2.5);
            doc.setLineWidth(0.2);
            y += 8;

            // 3D Renders
            var renders = captureQuoteRenders();
            var heroImg = renders.hero || capture3DImage();

            if (heroImg) {
                try {
                    // Hero - fill width with subtle rounded-corner effect via clip
                    var heroW = contentW;
                    var heroH = heroW * 0.50;  // slightly less tall for better proportion
                    ensureSpace(heroH + 8);

                    // Light grey background behind image for a "card" feel
                    doc.setFillColor(245, 245, 247);
                    doc.roundedRect(margin - 1, y - 1, heroW + 2, heroH + 2, 2, 2, 'F');
                    doc.addImage(heroImg, 'PNG', margin, y, heroW, heroH);
                    y += heroH + 4;

                    // Two smaller views side by side
                    var smallW = (contentW - 6) / 2;
                    var smallH = smallW * 0.50;
                    ensureSpace(smallH + 4);

                    if (renders.side) {
                        doc.setFillColor(245, 245, 247);
                        doc.roundedRect(margin - 1, y - 1, smallW + 2, smallH + 2, 2, 2, 'F');
                        doc.addImage(renders.side, 'PNG', margin, y, smallW, smallH);
                    }
                    if (renders.underside) {
                        doc.setFillColor(245, 245, 247);
                        doc.roundedRect(margin + smallW + 4, y - 1, smallW + 2, smallH + 2, 2, 2, 'F');
                        doc.addImage(renders.underside, 'PNG', margin + smallW + 5, y, smallW, smallH);
                    }
                    if (renders.side || renders.underside) y += smallH + 4;
                } catch(e) { /* skip images on error */ }
            }

            // Page 1 footer
            pdfFooter(doc);

            // PAGE 2 - SPECS / INVESTMENT

            doc.addPage();
            y = pdfHeader(doc, 'Quote', jobRef);

            // -- SPECIFICATIONS --
            // Background panel for specs section
            var Lm = c.lenInput ? (c.lenInput / 1000).toFixed(1) : '?';
            var Wm = c.projInput ? (c.projInput / 1000).toFixed(1) : '?';
            var area = c.lenInput && c.projInput ? ((c.lenInput / 1000) * (c.projInput / 1000)).toFixed(0) : '?';
            var roofStyle = c.isGable ? 'Gable roof patio' : 'Skillion roof patio';
            var roofMat = roofingLabel(c.roofing || 'trimdek');
            var isSolarSpan = c.roofing && c.roofing.indexOf('solarspan') >= 0;

            var specs = [
                ['Dimensions', Lm + 'm \u00D7 ' + Wm + 'm (' + area + 'm\u00B2)'],
                ['Style', roofStyle],
                ['Roofing', roofMat + ' \u2013 ' + sheetColor.name],
            ];
            if (isSolarSpan) specs.push(['Ceiling Finish', 'Smooth white']);
            specs.push(['Frame Colour', steelColor.name + ' (powdercoated steel)']);
            specs.push(['Posts', (c.framePost ? c.framePost.name : '90\u00D790 SHS') + ' \u00D7 ' + (c.nPosts || '?')]);
            specs.push(['Attachment', connectionLabel(c.connection || 'fascia')]);
            specs.push(['Guttering', 'Quad gutter \u2013 ' + steelColor.name]);
            specs.push(['Downpipes', '95\u00D745mm \u2013 ' + steelColor.name]);
            specs.push(['Footings', 'Concrete in-ground (400\u00D7400\u00D7500mm)']);

            // Section heading
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('SPECIFICATIONS', margin, y);
            doc.setDrawColor(...SW_ORANGE);
            doc.setLineWidth(0.6);
            doc.line(margin, y + 2.5, margin + 42, y + 2.5);
            doc.setLineWidth(0.2);
            y += 8;

            // Specs in a subtle card
            var specCardH = specs.length * 6 + 4;
            doc.setFillColor(248, 248, 250);
            doc.roundedRect(margin, y - 2, contentW, specCardH, 1.5, 1.5, 'F');

            doc.setFontSize(9);
            specs.forEach(function(s) {
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_MID);
                doc.text(s[0], margin + 4, y + 2);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(50, 50, 50);
                doc.text(s[1], margin + 48, y + 2);
                y += 6;
            });
            y += 8;

            // -- WHAT'S INCLUDED --
            ensureSpace(55);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text("WHAT'S INCLUDED", margin, y);
            doc.setDrawColor(...SW_ORANGE);
            doc.setLineWidth(0.6);
            doc.line(margin, y + 2.5, margin + 48, y + 2.5);
            doc.setLineWidth(0.2);
            y += 8;

            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(50, 50, 50);

            var qc = calc;
            var qL = (qc.L / 1000).toFixed(1);
            var qW = (qc.W / 1000).toFixed(1);
            var qStyle = qc.isGable ? 'Gable' : (document.getElementById('inRoofStyle').value === 'hip' ? 'Hip' : 'Skillion');
            var qRoofLabel = roofingLabel(document.getElementById('inRoofing').value);
            var qSheetClr = sheetColor.name;
            var qSteelClr = steelColor.name;
            var qPostCount = qc.connection === 'freestanding' ? qc.nPosts * 2 : qc.nPosts;
            var qPostFix = (document.getElementById('inPostFix')?.value === 'concrete') ? 'concrete footings' : 'baseplate fixings';

            var inclusions = [
                qL + 'm \u00D7 ' + qW + 'm ' + qStyle + ' patio',
                qRoofLabel + ' roofing in ' + qSheetClr,
                qPostCount + ' powdercoated steel posts (' + qSteelClr + ') with ' + qPostFix,
                'Quad gutter and 2 downpipes in ' + qSteelClr,
                'All flashings colour-matched',
                'Professional installation',
                'Site cleanup on completion',
                '10-year structural warranty'
            ];
            var hasPermit = extrasRows.some(function(r) { return r.type === 'permit' || (r.desc && r.desc.toLowerCase().indexOf('permit') >= 0); });
            var hasDemo = extrasRows.some(function(r) { return r.type === 'demo' || (r.desc && r.desc.toLowerCase().indexOf('demo') >= 0); });
            var hasElectrical = extrasRows.some(function(r) { return r.type === 'electrical' || (r.desc && r.desc.toLowerCase().indexOf('electr') >= 0); });
            if (hasPermit) inclusions.push('Council permit application');
            if (hasElectrical) inclusions.push('Electrical work as specified');
            if (hasDemo) inclusions.push('Removal of existing structure');

            inclusions.forEach(function(item) {
                // Orange tick instead of plain check
                doc.setTextColor(...SW_ORANGE);
                doc.setFont('helvetica', 'bold');
                doc.text('\u2713', margin + 3, y);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(50, 50, 50);
                doc.text(item, margin + 10, y);
                y += 5;
            });

            // Quote note
            var quoteNote = (document.getElementById('noteQuote') || {}).value;
            if (quoteNote && quoteNote.trim()) {
                y += 3;
                doc.setFontSize(9);
                doc.setFont('helvetica', 'italic');
                doc.setTextColor(90, 90, 90);
                var noteLines = doc.splitTextToSize(quoteNote.trim(), contentW - 10);
                ensureSpace(noteLines.length * 4 + 4);
                doc.text(noteLines, margin + 4, y);
                y += noteLines.length * 4 + 2;
            }
            y += 8;

            // -- INVESTMENT --
            ensureSpace(60);

            // Dark blue panel for investment - high visual weight
            var investBoxY = y;
            doc.setFillColor(...SW_DARK);
            doc.roundedRect(margin, investBoxY, contentW, 28, 2, 2, 'F');

            var totalSell = ps.totalSell || 0;
            var gst = ps.gst || 0;
            var totalIncGST = ps.totalIncGST || 0;

            // "Your Investment" label - white on dark
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(255, 255, 255);
            doc.text('Your Investment', margin + 8, investBoxY + 12);

            // Price - large, orange on dark
            doc.setFontSize(22);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_ORANGE);
            doc.text(pFmt(totalIncGST), pageW - margin - 8, investBoxY + 14, { align: 'right' });

            // GST note
            doc.setFontSize(8);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(180, 190, 200);
            doc.text('(includes GST)', pageW - margin - 8, investBoxY + 22, { align: 'right' });

            y = investBoxY + 34;

            // -- PAYMENT SCHEDULE --
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('PAYMENT SCHEDULE', margin, y);
            y += 7;

            doc.setFontSize(9);
            var dep20 = totalIncGST * 0.20;
            var del50 = totalIncGST * 0.50;
            var bal30 = totalIncGST * 0.30;

            // Payment rows with alternating background
            var payRows = [
                ['20%', 'Deposit to confirm booking', pFmt(dep20)],
                ['50%', 'On material delivery', pFmt(del50)],
                ['30%', 'On completion', pFmt(bal30)]
            ];
            payRows.forEach(function(pr, i) {
                if (i % 2 === 0) {
                    doc.setFillColor(248, 248, 250);
                    doc.rect(margin, y - 3, contentW, 7, 'F');
                }
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_ORANGE);
                doc.text(pr[0], margin + 4, y);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(60, 60, 60);
                doc.text(pr[1], margin + 20, y);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text(pr[2], pageW - margin, y, { align: 'right' });
                y += 7;
            });
            y += 8;

            // -- ACCEPTANCE / SIGNATURE --
            ensureSpace(40);
            doc.setDrawColor(200, 200, 200);
            doc.line(margin, y, pageW - margin, y);
            y += 6;
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('ACCEPTANCE', margin, y);
            y += 6;
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(70, 70, 70);
            doc.text('I accept this quote and agree to the terms and conditions.', margin + 2, y);
            y += 12;

            // Signature lines
            doc.setDrawColor(160, 160, 160);
            doc.text('Signature:', margin + 2, y);
            doc.line(margin + 30, y + 1, margin + 95, y + 1);
            doc.text('Date:', margin + 105, y);
            doc.line(margin + 120, y + 1, pageW - margin, y + 1);
            y += 10;
            doc.text('Name:', margin + 2, y);
            doc.line(margin + 25, y + 1, margin + 95, y + 1);
            y += 12;

            // -- TERMS & CONDITIONS --
            ensureSpace(40);
            doc.setFontSize(8);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_MID);
            doc.text('TERMS & CONDITIONS', margin, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(7);
            doc.setTextColor(120, 120, 120);
            var terms = [
                'Quote valid for 30 days from date of issue.',
                '20% deposit required to confirm booking and schedule works.',
                '50% due on delivery of materials to site.',
                'Balance due on satisfactory completion.',
                'Council permits: included unless otherwise stated.',
                'Electrical/plumbing: excluded unless listed in scope.',
                'Variations: Any changes to scope will be quoted separately.',
                'All work to Australian Standards and NCC requirements.'
            ];
            terms.forEach(function(t) {
                ensureSpace(4);
                doc.setTextColor(180, 180, 180);
                doc.text('\u2022', margin + 2, y);
                doc.setTextColor(120, 120, 120);
                doc.text(t, margin + 6, y);
                y += 3.5;
            });

            // Footer
            pdfFooter(doc);
            doc.save('Quote_' + safeName(clientName) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Quote PDF: ' + e.message); console.error(e); }
        }

        // ==================== PDF 2: SUPPLIER ORDERS (Steel / Sheets & Flashings / Fabrication) ====================

        // Shared helper: delivery info block for supplier order PDFs
        function pdfDeliveryBlock(doc, y) {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(60, 60, 60);
            const addr = getSiteAddress();
            if (addr) { doc.text('Deliver to: ' + addr, 14, y); y += 5; }
            doc.text('Required by: ______________________', 14, y);
            y += 5;
            doc.text('Contact: ' + getClientName() + (getClientPhone() ? '  |  ' + getClientPhone() : ''), 14, y);
            y += 8;
            return y;
        }

        // Categorise a single material row into supplier groups
        function classifyMaterial(desc) {
            const d = desc.toLowerCase();
            if (/truss|dogleg|fabricat/.test(d)) return 'fabrication';
            if (/sheet|panel|gutter|downpipe|elbow|flashing|barge|ridge|channel|foam|infill|stop.?end|outlet/.test(d)) return 'sheets';
            if (/post|beam|rafter|purlin|batten|strut|bracket|joiner|cap/.test(d)) return 'steel';
            return 'steel'; // default structural items to steel
        }

        // Build categorised material rows for supplier orders
        function buildSupplierRows() {
            const mats = getMaterialRows();
            const c = calc;
            const trussName = c.steel ? c.steel.name : '76\u00D738\u00D71.6';
            const beamLabel = c.frameBeam ? c.frameBeam.name : '100Ã—50Ã—2 RHS';
            const postLabel = c.framePost ? c.framePost.name : '90Ã—90Ã—2 SHS';
            const colour = steelColor.name;
            const sheetColour = sheetColor.name;

            const groups = { steel: [], sheets: [], fabrication: [] };

            const nestPlan = c.steelNestingPlan || [];
            mats.forEach(m => {
                const d = m.desc.toLowerCase();
                const lengthM = (m.length).toFixed(2) + 'm';
                const isSheetItem = /sheet|panel|gutter|downpipe|flashing|barge|ridge/.test(d);
                const col = isSheetItem ? sheetColour : colour;
                const group = classifyMaterial(m.desc);

                let size = '';
                if (group === 'steel') {
                    if (d.includes('batten')) size = '76\u00D738\u00D71.6 RHS';
                    else if (d.includes('bracket')) size = '\u2014';
                    else if (d.includes('post') || d.includes('strut') || d.includes('elbow')) size = postLabel;
                    else if (d.includes('beam')) size = beamLabel;
                    else size = trussName;
                } else if (d.includes('sheet') || d.includes('panel')) {
                    size = roofingLabel(c.roofing);
                }

                // Add nesting note for steel items
                let note = '';
                if (group === 'steel') {
                    var entry = null;
                    if (d.includes('post')) entry = nestPlan.find(function(p){return p.label==='Posts';});
                    else if (d.includes('flyover beam')) entry = nestPlan.find(function(p){return p.label==='Flyover Beam';});
                    else if (d.includes('flyover strut')) entry = nestPlan.find(function(p){return p.label==='Flyover Struts';});
                    else if (d.includes('riser beam')) entry = nestPlan.find(function(p){return p.label==='Riser Beam';});
                    else if (d.includes('riser elbow')) entry = nestPlan.find(function(p){return p.label==='Riser Elbows';});
                    else if (d.includes('beam')) entry = nestPlan.find(function(p){return p.label==='Beams';});
                    else if (d.includes('truss')) entry = nestPlan.find(function(p){return p.label==='Trusses';});
                    else if (d.includes('rafter')) entry = nestPlan.find(function(p){return p.label==='Rafters';});
                    else if (d.includes('batten') || d.includes('purlin')) entry = nestPlan.find(function(p){return p.label==='Battens'||p.label==='Purlins';});
                    if (entry && entry.nesting) {
                        var n = entry.nesting;
                        if (n.specialOrder) {
                            note = 'SPECIAL ORDER';
                        } else {
                            note = 'ORDER: ' + n.totalSticks + '\u00D7 ' + (n.stockLength / 1000).toFixed(1) + 'm';
                        }
                    }
                }

                const row = [m.desc, size, lengthM, String(m.qty), col, note];
                groups[group].push(row);
            });

            return groups;
        }

        // â”€â”€ PDF 2a: STEEL & STRUCTURAL ORDER â”€â”€
        function generateSteelOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Steel & Structural Order', jobRef);

            // Supplier line
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(100, 100, 100);
            doc.text('Supplier: _________________', 14, y); y += 5;
            doc.setFont('helvetica', 'normal');

            y = pdfDeliveryBlock(doc, y);

            const groups = buildSupplierRows();
            const rows = groups.steel;
            const nestPlan = calc.steelNestingPlan || buildSteelNestingPlan();

            if (rows.length === 0) {
                doc.setFontSize(10);
                doc.setTextColor(120, 120, 120);
                doc.text('No steel / structural items for this job.', 14, y);
            } else {
                // Sub-categorise steel items
                const subCats = {
                    'Posts': [],
                    'Beams': [],
                    'Trusses': [],
                    'Battens & Purlins': [],
                    'Brackets & Fixings': []
                };
                rows.forEach(row => {
                    const d = row[0].toLowerCase();
                    if (d.includes('post')) subCats['Posts'].push(row);
                    else if (d.includes('beam') || d.includes('fascia')) subCats['Beams'].push(row);
                    else if (d.includes('truss')) subCats['Trusses'].push(row);
                    else if (d.includes('purlin') || d.includes('batten') || d.includes('rafter') || d.includes('strut')) subCats['Battens & Purlins'].push(row);
                    else subCats['Brackets & Fixings'].push(row);
                });

                const colWidths = [50, 36, 22, 16, 30, 28];
                const tableHeaders = ['Item', 'Size', 'Length', 'Qty', 'Colour', 'Notes'];
                let totalItems = 0;

                Object.entries(subCats).forEach(([cat, catRows]) => {
                    if (catRows.length === 0) return;
                    if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc);
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...SW_ORANGE);
                    doc.text(cat, 14, y);
                    y += 4;
                    y = pdfTable(doc, y, tableHeaders, catRows, colWidths, { leftAlignAll: true });
                    y += 2;
                    totalItems += catRows.length;
                });

                // Section subtotal
                y += 2;
                doc.setFontSize(9);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text('Total line items: ' + totalItems, 14, y);
                y += 6;

                // â”€â”€ STOCK ORDER SUMMARY â”€â”€
                if (nestPlan.length > 0) {
                    if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc); doc.addPage(); y = 20;
                    }
                    doc.setFillColor(245, 245, 247);
                    doc.rect(14, y, 182, 7, 'F');
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(10);
                    doc.setTextColor(...SW_DARK);
                    doc.text('STOCK ORDER SUMMARY', 17, y + 5);
                    y += 10;

                    // Column headers
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(120, 120, 120);
                    doc.text('ITEM', 14, y);
                    doc.text('SIZE', 44, y);
                    doc.text('CUT', 86, y);
                    doc.text('QTY', 106, y);
                    doc.text('ORDER', 120, y);
                    doc.text('NESTING', 150, y);
                    y += 4;
                    doc.setDrawColor(200, 200, 200);
                    doc.line(14, y - 1, 196, y - 1);

                    var grandTotalSticks = 0;
                    nestPlan.forEach(function(p) {
                        if (y + 6 > doc.internal.pageSize.getHeight() - 25) {
                            pdfFooter(doc); doc.addPage(); y = 20;
                        }
                        var n = p.nesting;
                        grandTotalSticks += n.totalSticks;
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(8);
                        doc.setTextColor(...SW_DARK);
                        doc.text(p.label, 14, y);
                        doc.setFont('helvetica', 'normal');
                        doc.text(p.sizeName, 44, y);
                        doc.text(p.cutMm + 'mm', 86, y);
                        doc.text(String(p.qty), 106, y);
                        if (n.specialOrder) {
                            doc.setTextColor(200, 0, 0);
                            doc.setFont('helvetica', 'bold');
                            doc.text('SPECIAL ORDER', 120, y);
                        } else {
                            doc.text(n.totalSticks + '\u00D7 ' + (n.stockLength / 1000).toFixed(1) + 'm', 120, y);
                            doc.setFontSize(7);
                            doc.setTextColor(100, 100, 100);
                            if (n.piecesPerStick > 1) {
                                doc.text(n.piecesPerStick + ' pcs/stick, ' + Math.round(n.totalWaste) + 'mm waste', 150, y);
                            } else {
                                doc.text(Math.round(n.totalWaste) + 'mm waste', 150, y);
                            }
                        }
                        y += 5;
                    });

                    // Total
                    doc.setDrawColor(60, 60, 60);
                    doc.line(14, y, 196, y);
                    y += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(9);
                    doc.setTextColor(...SW_DARK);
                    doc.text('TOTAL: ' + grandTotalSticks + ' sticks to order', 14, y);
                    y += 4;
                }
            }

            // Additional Materials (non-model items the salesman added) - skip placeholders
            var realAdditionalMats = additionalMaterials.filter(function(am) { return am.desc && am.desc.trim() && am.desc.trim() !== 'Item'; });
            if (realAdditionalMats.length > 0) {
                if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc); doc.addPage(); y = 20;
                }
                y += 4;
                doc.setFillColor(245, 245, 247);
                doc.rect(14, y, 182, 7, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(10);
                doc.setTextColor(41, 128, 185); // blue accent
                doc.text('ADDITIONAL MATERIALS', 17, y + 5);
                y += 10;
                realAdditionalMats.forEach(function(am) {
                    if (y + 5 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc); doc.addPage(); y = 20;
                    }
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(8);
                    doc.setTextColor(...SW_DARK);
                    doc.text(am.qty + '\u00D7  ' + am.desc, 14, y);
                    y += 5;
                });
            }

            // Material order note
            var matOrderNote = (document.getElementById('noteMaterialOrder') || {}).value;
            if (matOrderNote && matOrderNote.trim()) {
                if (y + 14 > 275) { pdfFooter(doc); doc.addPage(); y = 20; }
                y += 4;
                doc.setFontSize(9);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text('ORDER NOTES', 14, y);
                y += 5;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(60, 60, 60);
                var moLines = doc.splitTextToSize(matOrderNote.trim(), 170);
                doc.text(moLines, 14, y);
            }
            pdfFooter(doc);
            doc.save('SteelOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Steel Order PDF: ' + e.message); console.error(e); }
        }

        // â”€â”€ PDF 2b: SHEET METAL & FLASHINGS ORDER â”€â”€
        function generateSheetsOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Sheet Metal & Flashings Order', jobRef);

            // Supplier line
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(100, 100, 100);
            doc.text('Supplier: _________________', 14, y); y += 5;
            doc.setFont('helvetica', 'normal');

            y = pdfDeliveryBlock(doc, y);

            const groups = buildSupplierRows();
            const rows = groups.sheets;

            if (rows.length === 0) {
                doc.setFontSize(10);
                doc.setTextColor(120, 120, 120);
                doc.text('No sheet metal / flashing items for this job.', 14, y);
            } else {
                // Sub-categorise sheets items
                const subCats = {
                    'Roofing Sheets / Panels': [],
                    'Gutters & Downpipes': [],
                    'Flashings': [],
                    'Accessories': []
                };
                rows.forEach(row => {
                    const d = row[0].toLowerCase();
                    if (d.includes('sheet') || d.includes('panel')) subCats['Roofing Sheets / Panels'].push(row);
                    else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow')) subCats['Gutters & Downpipes'].push(row);
                    else if (d.includes('flashing') || d.includes('barge') || d.includes('ridge') || d.includes('channel')) subCats['Flashings'].push(row);
                    else subCats['Accessories'].push(row);
                });

                const colWidths = [50, 36, 22, 16, 30, 28];
                const tableHeaders = ['Item', 'Product', 'Length', 'Qty', 'Colour', 'Notes'];
                let totalItems = 0;

                Object.entries(subCats).forEach(([cat, catRows]) => {
                    if (catRows.length === 0) return;
                    if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc);
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...SW_ORANGE);
                    doc.text(cat, 14, y);
                    y += 4;
                    y = pdfTable(doc, y, tableHeaders, catRows, colWidths, { leftAlignAll: true });
                    y += 2;
                    totalItems += catRows.length;
                });

                // Flashing profiles section
                if (flashingProfiles.length > 0) {
                    if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc); doc.addPage(); y = 20;
                    }
                    y += 4;
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...SW_ORANGE);
                    doc.text('Flashing Profiles', 14, y);
                    y += 6;

                    flashingProfiles.forEach(function(fp) {
                        var blockH = 45;
                        if (y + blockH > doc.internal.pageSize.getHeight() - 25) {
                            pdfFooter(doc); doc.addPage(); y = 20;
                        }
                        // Name & specs
                        doc.setFontSize(9);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(...SW_DARK);
                        doc.text(fp.name, 14, y);
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(7);
                        doc.setTextColor(100, 100, 100);
                        var orderLen = fp.length + 500;
                        var profDims = flashProfileDimString(fp.points);
                        var csLabel = flashColourSideLabel(fp.colourSide);
                        doc.text('Profile: ' + profDims + '  |  Girth: ' + fp.girth + 'mm  |  Qty: ' + fp.qty, 14, y + 4);
                        doc.text('Colour: ' + fp.colour + ' \u2014 ' + csLabel.toUpperCase() + ' FACE  |  Gauge: ' + fp.gauge + 'mm  |  Length: ' + orderLen + 'mm (order)', 14, y + 8);
                        var non90 = flashNon90Angles(fp.points);
                        if (non90.length > 0) {
                            var angStr = non90.map(function(a) { return a.angle + '\u00B0 at point ' + a.point; }).join(', ');
                            doc.text('Non-90\u00B0 angles: ' + angStr, 14, y + 12);
                            y += 4;
                        }
                        y += 11;

                        // Draw profile in PDF
                        if (fp.points && fp.points.length >= 2) {
                            var pdfBoxW = 60, pdfBoxH = 28;
                            var bx = 14;
                            doc.setDrawColor(200, 200, 200);
                            doc.setLineWidth(0.2);
                            doc.rect(bx, y, pdfBoxW, pdfBoxH);

                            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                            fp.points.forEach(function(pt) { if(pt.x<minX)minX=pt.x;if(pt.x>maxX)maxX=pt.x;if(pt.y<minY)minY=pt.y;if(pt.y>maxY)maxY=pt.y; });
                            var rX = maxX - minX || 1, rY = maxY - minY || 1;
                            var sc = Math.min((pdfBoxW - 6) / rX, (pdfBoxH - 6) / rY);
                            var ox = bx + (pdfBoxW - rX * sc) / 2;
                            var oy = y + (pdfBoxH - rY * sc) / 2;

                            doc.setDrawColor(41, 60, 70);
                            doc.setLineWidth(0.5);
                            for (var pi = 0; pi < fp.points.length - 1; pi++) {
                                var pa = fp.points[pi], pb = fp.points[pi+1];
                                doc.line(ox + (pa.x - minX)*sc, oy + (maxY - pa.y)*sc, ox + (pb.x - minX)*sc, oy + (maxY - pb.y)*sc);
                            }

                            // Dimension labels on each leg
                            doc.setFontSize(5);
                            doc.setTextColor(80, 80, 80);
                            for (var li = 0; li < fp.points.length - 1; li++) {
                                var la = fp.points[li], lb = fp.points[li+1];
                                var ldx = lb.x - la.x, ldy = lb.y - la.y;
                                var llen = Math.round(Math.sqrt(ldx*ldx + ldy*ldy));
                                var lmx = ox + ((la.x + lb.x)/2 - minX)*sc;
                                var lmy = oy + (maxY - (la.y + lb.y)/2)*sc;
                                doc.text(llen + '', lmx + 1, lmy - 1);
                            }

                            y += pdfBoxH + 3;
                        }
                        y += 3;
                    });
                } else {
                    // Fallback: blank sketch boxes
                    if (y + 55 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc); doc.addPage(); y = 20;
                    }
                    y += 4;
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...SW_ORANGE);
                    doc.text('Flashing Sketches', 14, y);
                    y += 5;
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(130, 130, 130);
                    doc.text('Sketch flashing profiles below \u2014 hand draw dimensions and bends', 14, y);
                    y += 5;
                    var boxW = 42, boxH = 32, gap = 4;
                    var labels = ['Back Flashing', 'Barge Flashing L', 'Barge Flashing R', 'Other'];
                    labels.forEach(function(label, i) {
                        var bx2 = 14 + i * (boxW + gap);
                        doc.setDrawColor(180, 180, 180);
                        doc.setLineWidth(0.3);
                        doc.rect(bx2, y, boxW, boxH);
                        doc.setFontSize(7);
                        doc.setTextColor(130, 130, 130);
                        doc.text(label, bx2 + boxW / 2, y + boxH + 4, { align: 'center' });
                    });
                    y += boxH + 8;
                }

                // Section subtotal
                doc.setFontSize(9);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text('Total line items: ' + totalItems, 14, y);
            }

            // Material order note
            var matOrderNote2 = (document.getElementById('noteMaterialOrder') || {}).value;
            if (matOrderNote2 && matOrderNote2.trim()) {
                if (y + 14 > 275) { pdfFooter(doc); doc.addPage(); y = 20; }
                y += 4;
                doc.setFontSize(9);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text('ORDER NOTES', 14, y);
                y += 5;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(60, 60, 60);
                var moLines2 = doc.splitTextToSize(matOrderNote2.trim(), 170);
                doc.text(moLines2, 14, y);
            }
            pdfFooter(doc);
            doc.save('SheetsOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Sheets Order PDF: ' + e.message); console.error(e); }
        }

        // â”€â”€ PDF 2c: FABRICATION ORDER â”€â”€
        function generateFabricationOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const c = calc;
            let y = pdfHeader(doc, 'Fabrication Order', jobRef);

            // Supplier line
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(100, 100, 100);
            doc.text('Supplier: CMI / JBS Patios Malaga', 14, y); y += 5;
            doc.setFont('helvetica', 'normal');

            y = pdfDeliveryBlock(doc, y);

            const groups = buildSupplierRows();
            const fabMatRows = groups.fabrication;

            // If gable with truss data, show detailed truss info (reuse exportTrussPDF style)
            if (c.isGable && c.trussData) {
                const td = c.trussData;

                // Truss image
                const img = captureTrussImage();
                if (img) {
                    try {
                        doc.addImage(img, 'PNG', 14, y, 110, 55);
                        y += 58;
                    } catch(e) { /* skip */ }
                }

                const lx = 14;
                const rw = 178;
                const lh = 5.5;

                function fabSec(title) {
                    if (y + 10 > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc);
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFillColor(...SW_ORANGE);
                    doc.rect(lx, y, rw, 6, 'F');
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(9);
                    doc.setTextColor(255, 255, 255);
                    doc.text('  ' + title, lx + 2, y + 4.5);
                    y += 7;
                }
                function fabRow(label, value, bold) {
                    if (y + lh > doc.internal.pageSize.getHeight() - 25) {
                        pdfFooter(doc);
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFont('helvetica', bold ? 'bold' : 'normal');
                    doc.setFontSize(10);
                    doc.setTextColor(...SW_DARK);
                    doc.text(label, lx + 4, y);
                    doc.text(String(value), lx + rw - 4, y, { align: 'right' });
                    y += lh;
                }

                fabSec('TRUSS STEEL');
                fabRow('Profile', td.steelName + ' RHS');
                fabRow('Colour', td.clr);
                fabRow('BMT', td.bmt + 'mm');
                fabRow('Quantity', td.nTruss + ' trusses');
                y += 2;

                fabSec('TRUSS DIMENSIONS');
                fabRow('Span', td.trussSpan + 'mm');
                fabRow('Height', td.rise + 'mm');
                fabRow('Pitch', td.pitch.toFixed(1) + '\u00B0');
                if (td.overhang > 0) fabRow('Overhang', td.overhang + 'mm');
                if (td.extender && td.extender.enabled) {
                    fabRow('Extender', td.extender.length + 'mm (each end)');
                }
                y += 2;

                fabSec('CUT LIST (per truss)');
                fabRow('Chord', '1 \u00D7 ' + td.chordCut + 'mm', true);
                if (td.extender && td.extender.enabled) {
                    fabRow('Extender', '2 \u00D7 ' + Math.round(td.extender.length) + 'mm');
                }
                fabRow('Rafters', '2 \u00D7 ' + td.rafterCut + 'mm', true);
                if (td.webMembers && td.webMembers.length > 0) {
                    for (var wi = 0; wi < td.webMembers.length; wi++) {
                        var wm = td.webMembers[wi];
                        fabRow(wm.type, wm.count + ' \u00D7 ' + wm.length + 'mm');
                    }
                }
                y += 2;

                fabSec('CUT ANGLES');
                fabRow('Apex Mitre', td.apexAngle.toFixed(1) + '\u00B0 (both rafters)');
                fabRow('Heel Mitre', td.heelAngle.toFixed(1) + '\u00B0 (rafter to chord)');
                y += 2;

                fabSec('MATERIAL REQUIRED');
                fabRow('Truss LM (each)', td.totalLM.toFixed(3) + ' LM');
                fabRow('All ' + td.nTruss + ' trusses', td.totalAllLM.toFixed(2) + ' LM', true);
                fabRow('Order length', td.totalSticks + ' \u00D7 6m sticks', true);

                // Risers (separate steel)
                if (td.riserLeft && td.riserLeft.enabled) {
                    y += 2;
                    fabSec('RISERS (separate steel \u2013 bolted to truss ends)');
                    fabRow('Left Riser', Math.round(td.riserLeft.length) + 'mm horiz + ' + Math.round(td.riserLeft.height) + 'mm vert');
                    fabRow('Right Riser', Math.round(td.riserRight.length) + 'mm horiz + ' + Math.round(td.riserRight.height) + 'mm vert');
                    fabRow('Riser steel (per pair)', (td.riserLeft.lm + td.riserRight.lm).toFixed(2) + ' LM');
                    fabRow('Riser steel (all)', td.riserTotalLM.toFixed(2) + ' LM (' + td.nTruss + ' sets)', true);
                }
                y += 4;
            }

            // Any other fabrication material rows (custom items etc.)
            if (fabMatRows.length > 0) {
                if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_ORANGE);
                doc.text('Other Fabricated Items', 14, y);
                y += 4;
                const colWidths = [50, 36, 22, 16, 30, 28];
                const tableHeaders = ['Item', 'Size', 'Length', 'Qty', 'Colour', 'Notes'];
                y = pdfTable(doc, y, tableHeaders, fabMatRows, colWidths, { leftAlignAll: true });
            }

            if (!c.isGable && fabMatRows.length === 0) {
                doc.setFontSize(10);
                doc.setTextColor(120, 120, 120);
                doc.text('No fabrication items for this job (skillion roof \u2013 no trusses).', 14, y);
            }

            pdfFooter(doc);
            doc.save('FabOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Fabrication Order PDF: ' + e.message); console.error(e); }
        }

        // Legacy wrapper - keep for any external calls
        function generateMaterialsOrderPDF() {
            generateSteelOrderPDF();
        }

        // ==================== PDF 3: WORK ORDER (Crew) ====================
        async function generateWorkOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            if (!calc || !calc.W) { alert('Configure patio first before generating work order.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const c = calc;
            const pageW = 210, pageH = 297;
            const mx = 14, mr = 196; // margins
            const cw = mr - mx; // content width

            // â”€â”€ Helpers â”€â”€
            const mm = v => Math.round(v) + 'mm';
            const styleLabel = c.roofStyle === 'hip' ? 'HIP' : (c.isGable ? 'GABLE' : 'SKILLION');
            const connLabel = connectionLabel(c.connection).toUpperCase();
            const roofLabel = roofingLabel(c.roofing);
            const sheetClr = sheetColor.name;
            const steelClr = steelColor.name;
            const Lmm = c.lenInput, Wmm = c.projInput;
            const Lm = Lmm / 1000, Wm = Wmm / 1000;
            const postHmm = c.postH;
            const riseMm = Math.round(c.rise);
            const ridgeH = Math.round(c.frontBeamY + c.rise);
            const backBeamH = Math.round(c.backBeamY);
            const frontBeamH = Math.round(c.frontBeamY);
            const nPosts = c.nPosts;
            const nTruss = c.nTruss;
            const postFix = (document.getElementById('inPostFix')?.value || 'concrete');
            const isConc = postFix === 'concrete';
            const postCut = isConc ? postHmm + 300 : postHmm;
            const postSpacing = Math.round(Lmm / (nPosts - 1));
            const trussSpacing = c.nTruss > 1 ? Math.round(Lmm / (c.nTruss - 1)) : Lmm;
            const diagonal = Math.round(Math.sqrt(Lmm * Lmm + Wmm * Wmm));
            const cosP = Math.cos(c.pitchRad);
            const sheetLen = c.isGable ? Math.round((Wmm / 2) / cosP + 50) : Math.round(Wmm / cosP + 50);
            const infill = c.infill || 'none';
            const electricalVal = document.getElementById('electrical')?.value || 'none';
            const hasElectrical = electricalVal !== 'none';
            const downlights = (electricalVal === 'downlights' || electricalVal === 'both') ? 4 : 0;
            const steelName = (STEEL[c.trussSteel] || STEEL['76x38']).name;
            const beamName = c.frameBeam ? c.frameBeam.name : '100\u00D750\u00D72 RHS';
            const postName = c.framePost ? c.framePost.name : '90\u00D790\u00D72 SHS';
            const totalPosts = c.connection === 'freestanding' ? nPosts * 2 : nPosts;
            const sheetsPerSide = Math.ceil(Lmm / (c.sheetCoverage || 762));
            const totalSheets = c.isGable ? sheetsPerSide * 2 : sheetsPerSide;
            const purlinSpacing = isInsulated(c.roofing) ? 0 : 1000;
            const nPurlins = purlinSpacing > 0 ? Math.max(2, Math.ceil((Wmm / 2) / purlinSpacing)) : 0;
            const woNotes = (document.getElementById('noteWorkOrder')?.value || '').trim();
            const riserQty = c.riserQty || parseInt(document.getElementById('inRiserQty')?.value) || 0;
            const riserSpacing = riserQty > 1 ? Math.round(Lmm / (riserQty - 1)) : 0;

            function woSectionTitle(title, yp) {
                doc.setFillColor(245, 245, 247);
                doc.rect(mx, yp, cw, 7, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(10);
                doc.setTextColor(...SW_DARK);
                doc.text(title, mx + 3, yp + 5);
                return yp + 9;
            }
            function woKeyVal(label, val, yp, xOff) {
                xOff = xOff || mx;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(120, 120, 120);
                doc.text(label, xOff, yp);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text(String(val), xOff, yp + 4);
                return yp;
            }
            function woCheckRow(text, yp, indent) {
                var xi = indent || 0;
                doc.setDrawColor(180, 180, 180);
                doc.rect(mx + 1 + xi, yp - 2.5, 3, 3);
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(60, 60, 60);
                var maxW = cw - 10 - xi;
                var lines = doc.splitTextToSize(text, maxW);
                doc.text(lines, mx + 7 + xi, yp);
                return yp + lines.length * 4 + 1;
            }
            function ensureSpace(needed) {
                if (y + needed > pageH - 22) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
            }
            function addImageSafe(imgData, x, yi, w, h) {
                if (!imgData) return;
                try { doc.addImage(imgData, 'PNG', x, yi, w, h); } catch(e) { /* skip */ }
            }

            // â”€â”€ Capture 3D views â”€â”€
            var views = null;
            try { views = await exportWorkOrderViews(); } catch(e) { console.warn('Could not capture 3D views:', e); }
            if (!views) views = window._workOrderViews || {};

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 1: JOB SUMMARY
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let y = pdfHeader(doc, 'WORK ORDER', jobRef);

            // Customer + Site address side by side
            var cName = getClientName(), cAddr = getSiteAddress(), cPhone = getClientPhone(), cEmail = getClientEmail();
            doc.setFontSize(9); doc.setFont('helvetica', 'bold'); doc.setTextColor(...SW_DARK);
            doc.text('CUSTOMER', mx, y);
            doc.text('SITE ADDRESS', mx + 95, y);
            y += 4;
            doc.setFont('helvetica', 'normal'); doc.setFontSize(9); doc.setTextColor(60, 60, 60);
            doc.text(cName, mx, y);
            if (cAddr) { var addrLines = doc.splitTextToSize(cAddr, 80); doc.text(addrLines, mx + 95, y); }
            y += 5;
            if (cPhone) {
                doc.setFont('helvetica', 'bold'); doc.setFontSize(11); doc.setTextColor(...SW_DARK);
                doc.text('\u260E  ' + cPhone, mx, y);
                doc.setFont('helvetica', 'normal'); doc.setFontSize(9); doc.setTextColor(60, 60, 60);
                y += 5;
            }
            if (cEmail) { doc.text(cEmail, mx, y); y += 4; }
            y += 2;
            // Install date + crew blanks
            doc.setFontSize(8); doc.setTextColor(120, 120, 120);
            doc.text('Install Date: ______________________', mx, y);
            doc.text('Crew: ______________________', mx + 95, y);
            y += 7;

            // THE JOB box
            y = woSectionTitle('THE JOB', y);
            doc.setFont('helvetica', 'bold'); doc.setFontSize(11); doc.setTextColor(...SW_ORANGE);
            doc.text(styleLabel + ' PATIO', mx + 3, y + 1);
            y += 6;
            doc.setFont('helvetica', 'normal'); doc.setFontSize(9); doc.setTextColor(60, 60, 60);
            var jobLines = [
                Lm.toFixed(1) + 'm \u00D7 ' + Wm.toFixed(1) + 'm',
                roofLabel + ' \u2014 ' + sheetClr,
                'Steel \u2014 ' + steelClr,
                'Attached via ' + connectionLabel(c.connection),
                totalPosts + ' posts, ' + (isConc ? 'in-ground concrete footings' : 'baseplate fixings')
            ];
            if (c.isGable && infill !== 'none') jobLines.push('Gable infill: ' + infill.charAt(0).toUpperCase() + infill.slice(1));
            jobLines.forEach(function(l) { doc.text('\u2022  ' + l, mx + 5, y); y += 4.5; });
            y += 3;

            // SITE ACCESS & NOTES
            if (woNotes) {
                y = woSectionTitle('SITE ACCESS & NOTES', y);
                doc.setFont('helvetica', 'normal'); doc.setFontSize(8); doc.setTextColor(60, 60, 60);
                var noteLines = doc.splitTextToSize(woNotes, cw - 10);
                doc.text(noteLines, mx + 3, y);
                y += noteLines.length * 4 + 4;
            }

            // WHAT'S INCLUDED / NOT INCLUDED
            y = woSectionTitle("WHAT'S INCLUDED / NOT INCLUDED", y);
            var halfW = cw / 2 - 2;
            var included = ['Patio supply & install'];
            var excluded = [];
            if (isConc) included.push('Footings (' + totalPosts + '\u00D7 in-ground concrete)');
            else included.push('Baseplates (' + totalPosts + '\u00D7 dynabolt fixings)');
            var hasDemoScope = false, hasElecScope = false;
            extrasRows.forEach(function(er) {
                var d = (er.desc || '').toLowerCase();
                if (d.includes('demo')) { included.push('Demo existing structure'); hasDemoScope = true; }
                else if (d.includes('skip')) { included.push('Skip bin'); }
                else if (d.includes('electrical') || d.includes('downlight')) { included.push(er.desc); hasElecScope = true; }
                else if (d.includes('crane')) included.push('Crane hire');
                else if (d.includes('permit')) included.push('Council permit / engineering');
                else if (d.includes('soakwell')) included.push('Soakwell');
                else if (d.includes('deliver')) included.push('Delivery');
                else included.push(er.desc);
            });
            if (!hasElecScope) excluded.push('Electrical (by others)');
            if (!hasDemoScope) excluded.push('Demolition');
            excluded.push('Painting'); excluded.push('Stormwater connection');
            doc.setFont('helvetica', 'bold'); doc.setFontSize(7); doc.setTextColor(...SW_DARK);
            doc.text('INCLUDED', mx + 3, y); doc.text('NOT INCLUDED', mx + halfW + 6, y);
            y += 4;
            var maxItems = Math.max(included.length, excluded.length);
            for (var ii = 0; ii < maxItems; ii++) {
                if (ii < included.length) { doc.setFont('helvetica', 'normal'); doc.setFontSize(7); doc.setTextColor(34, 139, 34); doc.text('\u2713 ' + included[ii], mx + 3, y); }
                if (ii < excluded.length) { doc.setTextColor(180, 60, 60); doc.text('\u2717 ' + excluded[ii], mx + halfW + 6, y); }
                y += 4;
            }

            // ELECTRICAL & LIGHTING (SolarSpan)
            if (isInsulated(c.roofing)) {
                y += 1; doc.setFont('helvetica', 'bold'); doc.setFontSize(7); doc.setTextColor(...SW_ORANGE);
                doc.text('ELECTRICAL & LIGHTING', mx + 3, y); y += 4;
                doc.setFont('helvetica', 'normal'); doc.setFontSize(7); doc.setTextColor(60, 60, 60);
                doc.text('Cable chase in SolarSpan panels \u2014 install cabling for:', mx + 5, y); y += 4;
                if (downlights > 0) { doc.text('\u2022 ' + downlights + '\u00D7 LED downlights', mx + 8, y); y += 4; }
                if (electricalVal === 'both') { doc.text('\u2022 GPO outlets', mx + 8, y); y += 4; }
            }
            y += 3;

            // EQUIPMENT TO BRING
            ensureSpace(50);
            y = woSectionTitle('EQUIPMENT TO BRING', y);
            var equip = ['Laser level', 'Ladders', 'SDS drill + masonry bits', 'Grinder + cut-off discs', 'Rivet gun + rivets', 'Silicone gun', 'Safety gear (PPE)', 'Touch-up spray paint (' + steelClr + ')', 'Scaffolding / planks'];
            if (isConc) { equip.unshift('Post hole digger / auger'); equip.splice(2, 0, 'Concrete mixer OR premix bags'); }
            if (hasDemoScope) equip.push('Demo tools / pry bar / recipro saw');
            if (c.isGable) equip.push('Truss lifting equipment');
            equip.push('Rafter brackets');
            var eqCol = Math.ceil(equip.length / 2);
            for (var ei = 0; ei < eqCol; ei++) {
                if (y + 5 > pageH - 22) { pdfFooter(doc); doc.addPage(); y = 20; }
                y = woCheckRow(equip[ei], y);
                if (ei + eqCol < equip.length) { y -= 5; woCheckRow(equip[ei + eqCol], y, halfW); y += 5; }
            }
            y += 2;

            pdfFooter(doc);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 2: SITE PLAN (Top View)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Site Plan', jobRef);
            if (views.sitePlan) {
                var spW = cw * 0.95, spH = spW * 0.55;
                ensureSpace(spH + 8);
                addImageSafe(views.sitePlan, mx + (cw - spW) / 2, y, spW, spH);
                y += spH + 5;
            }
            // POST SCHEDULE
            ensureSpace(20 + totalPosts * 5);
            y = woSectionTitle('POST SCHEDULE', y);
            doc.setFont('helvetica', 'bold'); doc.setFontSize(7); doc.setTextColor(...SW_DARK);
            doc.text('Post', mx+3, y); doc.text('Size', mx+18, y); doc.text('Height', mx+55, y);
            doc.text('Footing', mx+80, y); doc.text('Location', mx+130, y);
            y += 2; doc.setDrawColor(180,180,180); doc.line(mx, y, mr, y); y += 3;
            doc.setFont('helvetica', 'normal'); doc.setFontSize(7); doc.setTextColor(60,60,60);
            var footStr = isConc ? '450\u00D7450\u00D7600 conc' : 'Baseplate';
            for (var pIdx = 0; pIdx < totalPosts; pIdx++) {
                var pRow = pIdx < nPosts ? 'Front' : 'Back';
                var pNum = pIdx < nPosts ? pIdx : pIdx - nPosts;
                var pSide = pNum === 0 ? 'left' : (pNum === (nPosts-1) ? 'right' : 'mid');
                doc.text('P'+(pIdx+1), mx+3, y); doc.text(postName, mx+18, y); doc.text(mm(postHmm), mx+55, y);
                doc.text(footStr, mx+80, y); doc.text(pRow+' '+pSide, mx+130, y);
                y += 4.5;
            }
            y += 3;
            doc.setFontSize(7); doc.setTextColor(80,80,80);
            doc.text('Post spacing: ' + mm(postSpacing) + ' centres    |    Set-out from house: ' + mm(Wmm), mx+3, y);
            y += 5;
            pdfFooter(doc);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 3: ELEVATIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Elevations', jobRef);
            y = woSectionTitle('FRONT ELEVATION', y);
            if (views.frontElevation) {
                var feW = cw * 0.92, feH = feW * 0.45;
                ensureSpace(feH + 5);
                addImageSafe(views.frontElevation, mx + (cw - feW)/2, y, feW, feH);
                y += feH + 5;
            }
            ensureSpace(60);
            y = woSectionTitle('SIDE ELEVATION', y);
            if (views.sideElevation) {
                var seW = cw * 0.92, seH = seW * 0.45;
                ensureSpace(seH + 5);
                addImageSafe(views.sideElevation, mx + (cw - seW)/2, y, seW, seH);
                y += seH + 5;
            }
            // KEY DIMENSIONS
            ensureSpace(60);
            y = woSectionTitle('KEY DIMENSIONS', y);
            var dimRows = [
                ['Overall length', mm(Lmm)], ['Projection', mm(Wmm)],
                ['Post height', mm(postHmm) + ' above FFL'],
                ['Post cut length', mm(postCut) + (isConc ? ' (inc. 300 in ground)' : '')],
                ['Fascia height', mm(Math.round(c.fasciaH || 0))],
                ['Roof pitch', c.pitch.toFixed(1) + '\u00B0']
            ];
            if (c.isGable) { dimRows.push(['Ridge height', mm(ridgeH) + ' above FFL']); dimRows.push(['Rise', mm(riseMm)]); }
            if (c.connection === 'riser') { dimRows.push(['Riser height', mm(Math.round(c.riserH || 0))]); dimRows.push(['Riser offset', mm(Math.round(c.riserOffset || 0))]); }
            dimRows.push(['Beam size', beamName], ['Post size', postName]);
            dimRows.push(['Front beam height', mm(frontBeamH) + ' above FFL'], ['Back beam height', mm(backBeamH) + ' above FFL']);
            dimRows.push(['Sheet length', mm(sheetLen)], ['Post spacing', mm(postSpacing) + ' centres']);
            if (c.isGable) dimRows.push(['Truss spacing', mm(trussSpacing) + ' centres']);
            dimRows.push(['Diagonal check', mm(diagonal) + ' (for square)']);
            dimRows.forEach(function(r) {
                doc.setFont('helvetica', 'bold'); doc.setFontSize(8); doc.setTextColor(100,100,100);
                doc.text(r[0] + ':', mx+3, y);
                doc.setFont('courier', 'bold'); doc.setTextColor(...SW_DARK);
                doc.text(r[1], mx+60, y); y += 4.5;
            });
            pdfFooter(doc);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 4: SECTION DETAILS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Construction Details', jobRef);

            function sectionDetail(title, imgKey, notes) {
                ensureSpace(45);
                y = woSectionTitle(title, y);
                if (views[imgKey]) {
                    var dw = cw * 0.38, dh = dw * 0.55;
                    addImageSafe(views[imgKey], mx + 2, y, dw, dh);
                    var nx = mx + dw + 8, ny = y + 3;
                    doc.setFont('helvetica', 'normal'); doc.setFontSize(7); doc.setTextColor(60,60,60);
                    notes.forEach(function(n) { doc.text('\u2022 ' + n, nx, ny); ny += 3.5; });
                    y += dh + 3;
                } else {
                    doc.setFont('helvetica', 'normal'); doc.setFontSize(7); doc.setTextColor(60,60,60);
                    notes.forEach(function(n) { doc.text('\u2022 ' + n, mx + 5, y); y += 3.5; });
                    y += 2;
                }
            }

            // DETAIL A: RISER BEAM
            if (c.connection === 'riser') {
                sectionDetail('DETAIL A: RISER BEAM ATTACHMENT', 'riserDetail', [
                    'Riser elbows: ' + postName + ' \u00D7 ' + mm(Math.round(c.riserH || 0)),
                    riserQty > 0 ? riserQty + ' elbows at ' + mm(riserSpacing) + ' centres' : 'Fix elbows per engineering',
                    'Fix to fascia: 4\u00D7 14g tek screws per elbow',
                    'Weld to beam: full fillet all round'
                ]);
            }
            // DETAIL B: POST TO BEAM
            sectionDetail('DETAIL B: POST TO BEAM CONNECTION', 'postDetail',
                isConc ? [
                    'Post: ' + postName + ' \u00D7 ' + mm(postHmm),
                    'Beam: ' + beamName,
                    'Connection: fillet weld all round',
                    'Footing: 450\u00D7450\u00D7600 concrete, N20 mix',
                    'Stirrup: N12 \u00D7 300\u00D7300 at 100mm from bottom',
                    'Post embedment: 100mm into concrete'
                ] : [
                    'Post: ' + postName + ' \u00D7 ' + mm(postHmm),
                    'Beam: ' + beamName,
                    'Connection: fillet weld all round',
                    'Baseplate: welded + 4\u00D7 dynabolts'
                ]);
            // DETAIL C: GUTTER & FASCIA
            var gutterLabel = (c.houseGutter === 'box') ? '150\u00D7100 Box Gutter' : '115mm Quad Gutter';
            sectionDetail('DETAIL C: GUTTER & FASCIA', 'gutterDetail', [
                'Gutter: ' + gutterLabel + ' \u2014 ' + steelClr,
                'Brackets at 600mm centres',
                'Fall: 1:500 toward downpipes',
                'Downpipes: 2\u00D7 95\u00D745mm \u00D7 1800mm (nested) + 1 strap each'
            ]);
            // DETAIL D: RIDGE (gable only)
            if (c.isGable) {
                sectionDetail('DETAIL D: RIDGE', 'ridgeDetail', [
                    'Ridge cap: ' + roofLabel + ' \u2014 ' + sheetClr,
                    'Foam closure strip under cap',
                    'Fix with dome head tek screws'
                ]);
            }
            pdfFooter(doc);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 5: MATERIALS CHECKLIST
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Materials Checklist', jobRef);
            doc.setFont('helvetica', 'bold'); doc.setFontSize(8); doc.setTextColor(...SW_ORANGE);
            doc.text('CHECK OFF ON ARRIVAL \u2014 Verify all materials present', mx + 3, y); y += 6;

            y = woSectionTitle('DELIVERED TO SITE', y);
            const mats = getMaterialRows();
            var matGroups = { 'STEEL': [], 'ROOFING': [], 'GUTTERS & DRAINAGE': [], 'FLASHINGS': [], 'OTHER': [] };
            mats.forEach(function(m) {
                var d = m.desc.toLowerCase();
                if (d.includes('post') || d.includes('beam') || d.includes('truss') || d.includes('purlin') || d.includes('rafter') || d.includes('riser') || d.includes('bracket'))
                    matGroups['STEEL'].push(m);
                else if (d.includes('sheet') || d.includes('ridge') || d.includes('solarspan') || d.includes('spanplus') || d.includes('trimdek') || d.includes('corrugat'))
                    matGroups['ROOFING'].push(m);
                else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow') || d.includes('dp '))
                    matGroups['GUTTERS & DRAINAGE'].push(m);
                else matGroups['OTHER'].push(m);
            });
            if (flashingProfiles.length > 0) {
                flashingProfiles.forEach(function(fp) {
                    matGroups['FLASHINGS'].push({ desc: fp.name + ' \u2014 ' + fp.girth + 'mm girth \u00D7 ' + mm(fp.length) + ' (' + fp.colour + ')', qty: fp.qty, length: fp.length / 1000 });
                });
            }
            var woNestPlan = c.steelNestingPlan || [];
            Object.entries(matGroups).forEach(function(entry) {
                var cat = entry[0], items = entry[1];
                if (!items.length) return;
                if (y + 8 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                doc.setFont('helvetica', 'bold'); doc.setFontSize(7); doc.setTextColor(...SW_ORANGE);
                doc.text(cat, mx + 6, y); y += 4;
                items.forEach(function(m) {
                    if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                    var lenStr = m.length >= 0.1 ? Math.round(m.length * 1000) + 'mm' : '';
                    var orderNote = '';
                    if (cat === 'STEEL' && woNestPlan.length > 0) {
                        var dl = m.desc.toLowerCase(); var ne = null;
                        if (dl.includes('post')) ne = woNestPlan.find(function(p){return p.label==='Posts';});
                        else if (dl.includes('flyover beam')) ne = woNestPlan.find(function(p){return p.label==='Flyover Beam';});
                        else if (dl.includes('beam') && !dl.includes('riser')) ne = woNestPlan.find(function(p){return p.label==='Beams';});
                        else if (dl.includes('riser beam')) ne = woNestPlan.find(function(p){return p.label==='Riser Beam';});
                        else if (dl.includes('truss')) ne = woNestPlan.find(function(p){return p.label==='Trusses';});
                        else if (dl.includes('rafter')) ne = woNestPlan.find(function(p){return p.label==='Rafters';});
                        else if (dl.includes('batten') || dl.includes('purlin')) ne = woNestPlan.find(function(p){return p.label==='Battens'||p.label==='Purlins';});
                        if (ne && ne.nesting && !ne.nesting.specialOrder) { orderNote = '  \u2192 ' + ne.nesting.totalSticks + '\u00D7 ' + (ne.nesting.stockLength / 1000).toFixed(1) + 'm sticks'; }
                    }
                    y = woCheckRow(m.qty + '\u00D7  ' + m.desc + (lenStr ? '  ' + lenStr : '') + orderNote, y);
                });
                y += 2;
            });
            y += 3;
            // BRING FROM STOCK
            ensureSpace(30);
            y = woSectionTitle('BRING FROM STOCK', y);
            ['Tek screws 14g \u00D7 50mm (1 box)', 'Dome head screws \u2014 ' + sheetClr, 'Rivets \u2014 ' + steelClr,
             'Silicone \u2014 clear + colour match', 'Foam closure strips', 'Rafter brackets'].forEach(function(si) {
                if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                y = woCheckRow(si, y);
            });
            if (isInsulated(c.roofing) && hasElectrical) y = woCheckRow('Electrical cable (as per lighting plan)', y);
            y += 3;
            var woRealAddMats = additionalMaterials.filter(function(am) { return am.desc && am.desc.trim() && am.desc.trim() !== 'Item'; });
            if (woRealAddMats.length > 0) {
                ensureSpace(10 + woRealAddMats.length * 5);
                y = woSectionTitle('ADDITIONAL MATERIALS', y);
                woRealAddMats.forEach(function(am) {
                    if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                    y = woCheckRow(am.qty + '\u00D7  ' + am.desc, y);
                });
            }
            pdfFooter(doc);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 6: FLASHING PROFILES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (flashingProfiles.length > 0) {
                doc.addPage();
                y = pdfHeader(doc, 'WORK ORDER \u2014 Flashing Profiles', jobRef);
                doc.setFont('helvetica', 'normal'); doc.setFontSize(8); doc.setTextColor(100,100,100);
                doc.text('Verify each flashing matches the profile shown before install.', mx + 3, y); y += 6;

                flashingProfiles.forEach(function(fp) {
                    var cardH = 50;
                    if (y + cardH > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                    doc.setDrawColor(200,200,200); doc.setLineWidth(0.3); doc.rect(mx, y, cw, cardH);
                    doc.setFont('helvetica', 'bold'); doc.setFontSize(9); doc.setTextColor(...SW_DARK);
                    doc.text(fp.name, mx + 3, y + 5);
                    doc.setDrawColor(230,230,230); doc.line(mx+1, y+7, mx+cw-1, y+7);

                    // Render profile to mini canvas
                    var profImg = null;
                    try {
                        var fCvs = document.createElement('canvas'); fCvs.width = 240; fCvs.height = 160;
                        var fCtx = fCvs.getContext('2d');
                        fCtx.fillStyle = '#ffffff'; fCtx.fillRect(0, 0, 240, 160);
                        if (fp.points && fp.points.length >= 2) {
                            var pts = fp.points;
                            var fmX = Infinity, fMX = -Infinity, fmY = Infinity, fMY = -Infinity;
                            pts.forEach(function(p) { if(p.x<fmX)fmX=p.x; if(p.x>fMX)fMX=p.x; if(p.y<fmY)fmY=p.y; if(p.y>fMY)fMY=p.y; });
                            var fRx = fMX-fmX||1, fRy = fMY-fmY||1, fPd = 20;
                            var fSc = Math.min((240-fPd*2)/fRx, (160-fPd*2)/fRy);
                            var ffOx = (240-fRx*fSc)/2, ffOy = (160-fRy*fSc)/2;
                            fCtx.strokeStyle = '#293C46'; fCtx.lineWidth = 3; fCtx.lineCap = 'round'; fCtx.lineJoin = 'round';
                            fCtx.beginPath();
                            pts.forEach(function(p, i) {
                                var px = ffOx + (p.x-fmX)*fSc, py = ffOy + (fMY-p.y)*fSc;
                                if (i===0) fCtx.moveTo(px,py); else fCtx.lineTo(px,py);
                            });
                            fCtx.stroke();
                            // Dimension labels on legs
                            var legs = calcLegs(pts);
                            fCtx.font = 'bold 11px Arial'; fCtx.fillStyle = '#1a365d'; fCtx.textAlign = 'center';
                            for (var li2 = 0; li2 < pts.length - 1; li2++) {
                                var p1x = ffOx+(pts[li2].x-fmX)*fSc, p1y = ffOy+(fMY-pts[li2].y)*fSc;
                                var p2x = ffOx+(pts[li2+1].x-fmX)*fSc, p2y = ffOy+(fMY-pts[li2+1].y)*fSc;
                                var mdx = (p1x+p2x)/2, mdy = (p1y+p2y)/2;
                                var ddx = p2x-p1x, ddy = p2y-p1y, dln = Math.sqrt(ddx*ddx+ddy*ddy)||1;
                                fCtx.fillText(legs[li2].length+'', mdx + (-ddy/dln*12), mdy + (ddx/dln*12) + 4);
                            }
                            fCtx.fillStyle = '#F26522';
                            pts.forEach(function(p) { var px = ffOx+(p.x-fmX)*fSc, py = ffOy+(fMY-p.y)*fSc; fCtx.beginPath(); fCtx.arc(px,py,3,0,Math.PI*2); fCtx.fill(); });
                        }
                        profImg = fCvs.toDataURL('image/png');
                    } catch(e) { /* skip */ }

                    if (profImg) addImageSafe(profImg, mx + 3, y + 9, 55, 38);
                    var dtX = mx + 62, dtY = y + 12;
                    doc.setFont('helvetica', 'normal'); doc.setFontSize(7); doc.setTextColor(60,60,60);
                    doc.text('Girth: ' + fp.girth + 'mm', dtX, dtY); dtY += 4;
                    doc.text('Colour: ' + fp.colour, dtX, dtY); dtY += 4;
                    doc.text('Gauge: ' + fp.gauge + 'mm', dtX, dtY); dtY += 4;
                    doc.text('Length: ' + mm(fp.length), dtX, dtY); dtY += 4;
                    doc.text('Qty: ' + fp.qty, dtX, dtY); dtY += 4;
                    doc.text('Colour face: ' + flashColourSideLabel(fp.colourSide).toUpperCase(), dtX, dtY);
                    // Legs
                    if (fp.points && fp.points.length >= 2) {
                        var fLegs = calcLegs(fp.points);
                        doc.setFont('helvetica', 'bold'); doc.setFontSize(6); doc.setTextColor(100,100,100);
                        doc.text('Legs:', dtX + 50, y + 12);
                        doc.setFont('helvetica', 'normal');
                        for (var lg = 0; lg < fLegs.length; lg++) {
                            doc.text((lg+1) + ': ' + fLegs[lg].length + 'mm' + (fLegs[lg].angle ? ' @ ' + fLegs[lg].angle + '\u00B0' : ''), dtX + 50, y + 16 + lg * 3.5);
                        }
                    }
                    y += cardH + 3;
                });
                pdfFooter(doc);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 7: INSTALLATION SEQUENCE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Installation Sequence', jobRef);
            var steps = [];

            if (hasDemoScope) {
                steps.push({ title: 'DEMOLITION', items: ['Remove existing structure as per scope', 'Check for asbestos before cutting', 'Dispose in skip bin provided', 'Clear site for new works'] });
            }
            // Steel cutting plan
            var woPlan = c.steelNestingPlan || buildSteelNestingPlan();
            if (woPlan.length > 0) {
                var cutItems = ['CUT ALL STEEL BEFORE INSTALL:'];
                woPlan.forEach(function(p) {
                    var n = p.nesting;
                    if (n.specialOrder) { cutItems.push(p.label + ': ' + p.qty + '\u00D7 ' + p.cutMm + 'mm ' + p.sizeName + ' \u2014 SPECIAL ORDER'); return; }
                    var line = p.label + ': ' + p.qty + '\u00D7 ' + p.cutMm + 'mm from ' + n.totalSticks + '\u00D7 ' + (n.stockLength/1000).toFixed(1) + 'm ' + p.sizeName;
                    if (n.piecesPerStick > 1) { line += ' \u2014 ' + n.piecesPerStick + ' pcs/stick'; if (n.sticks.length > 0 && n.sticks[n.sticks.length-1].cuts.length < n.piecesPerStick) line += ', last ' + n.sticks[n.sticks.length-1].cuts.length + ' pcs'; }
                    cutItems.push(line);
                });
                steps.push({ title: 'STEEL CUTTING PLAN', items: cutItems });
            }
            steps.push({ title: 'SET OUT', items: [
                'Mark post positions per site plan (Page 2)', 'Check for underground services',
                'Front row: ' + mm(Wmm) + ' out from house',
                'Spacing: ' + (function(){ var s=[]; for(var si2=0; si2<nPosts; si2++) s.push(mm(Math.round(si2*postSpacing))); return s.join(', '); })() + ' from left',
                'Check square: diagonal = ' + mm(diagonal), 'Confirm levels with laser'
            ]});
            if (isConc) {
                steps.push({ title: 'FOOTINGS & POSTS', items: [
                    'Dig ' + totalPosts + '\u00D7 holes: 450\u00D7450\u00D7600mm', 'Place stirrup at 100mm from bottom',
                    'Set posts plumb (check both ways)', 'Top of post: ' + mm(postHmm) + ' above FFL',
                    'Brace temporarily', 'Pour concrete, vibrate, finish top', 'See DETAIL B (Construction Details page)'
                ]});
            } else {
                steps.push({ title: 'BASEPLATES & POSTS', items: [
                    'Mark ' + totalPosts + '\u00D7 baseplate positions', 'Fix with dynabolts',
                    'Fix posts, plumb both ways', 'Top of post: ' + mm(postHmm) + ' above FFL'
                ]});
            }
            steps.push({ title: 'FRONT BEAM', items: [
                'Check post heights, trim if needed', 'Beam: ' + beamName + ' \u00D7 ' + mm(Lmm),
                'Weld connections \u2014 full fillet all round', 'Height: ' + mm(frontBeamH) + ' above FFL', 'Check level'
            ]});
            if (c.isAttached) {
                var backItems = [];
                if (c.connection === 'riser') backItems = ['Install riser elbows to house fascia', (riserQty > 0 ? riserQty + ' elbows at ' + mm(riserSpacing) + ' centres' : 'Fix per engineering'), 'Attach riser beam: ' + beamName, 'See DETAIL A (Construction Details page)'];
                else if (c.connection === 'flyover') backItems = ['Fix flyover brackets above house roof', 'Beam at ' + mm(backBeamH) + ' above FFL'];
                else backItems = ['Fix to house at ' + mm(backBeamH) + ' above FFL', 'Beam: ' + beamName + ' \u00D7 ' + mm(Lmm)];
                backItems.push('Check level across full length');
                steps.push({ title: 'BACK BEAM (house connection)', items: backItems });
            }
            if (c.isGable) {
                steps.push({ title: 'TRUSSES', items: [nTruss + '\u00D7 trusses at ' + mm(trussSpacing) + ' centres', 'Install per fabrication drawing', 'Check plumb, apex aligned', 'Ridge height: ' + mm(ridgeH) + ' above FFL'] });
            }
            if (isConc) {
                steps.push({ title: 'CURE TIME', items: ['\u26A0 MINIMUM 24 HOURS before loading structure', 'Do not sheet until concrete cured'] });
            }
            var bc = c.battenCalc;
            if (!c.isGable && bc && bc.battensNeeded > 0) {
                var batItems = [bc.battensNeeded + '\u00D7 battens at ' + mm(bc.spanDistance) + ' centres', 'Cut to ' + mm(Math.round(bc.battenLength))];
                batItems.push('Positions: ' + bc.battenPositions.map(function(p){return mm(p);}).join(', '));
                var bk = c.bracketCalc;
                if (bk && bk.bracketsNeeded > 0) batItems.push('Brackets: ' + bk.bracketsNeeded + '\u00D7 ' + c.bracketType);
                steps.push({ title: 'BATTEN LAYOUT', items: batItems });
            } else if (nPurlins > 0) {
                steps.push({ title: 'PURLINS', items: [nPurlins + '\u00D7 purlins at ' + mm(purlinSpacing) + ' centres', 'Fix with tek screws'] });
            }
            steps.push({ title: 'GUTTERS', items: ['Brackets at 600mm centres', 'Fall 1:500 toward downpipes', 'Install downpipes (2\u00D71800mm nested + strap)', 'See DETAIL C (Construction Details page)'] });
            var sheetItems = [totalSheets + '\u00D7 ' + roofLabel + ' @ ' + mm(sheetLen), 'Install from LOW side first', 'Fix through pan with tek screws', '50mm gutter overhang'];
            if (isInsulated(c.roofing)) { sheetItems.push('Run electrical cables in chase first'); sheetItems.push('Colour side faces DOWN (ceiling visible)'); }
            if (c.isGable) { sheetItems.push('Install ridge cap with foam closure \u2014 See DETAIL D'); }
            steps.push({ title: 'SHEETING', items: sheetItems });
            if (c.isGable && infill !== 'none') {
                steps.push({ title: 'GABLE INFILL', items: [infill.charAt(0).toUpperCase() + infill.slice(1) + ' infill', 'Cut to match pitch', 'Fix to end trusses', 'Seal with silicone'] });
            }
            var fSteps = ['Install apron flashing to house first', 'Install barge flashings (silicone joints)', 'Install fascia flashings'];
            if (flashingProfiles.length > 0) flashingProfiles.forEach(function(fp) { fSteps.push(fp.name + ' \u2014 ' + fp.girth + 'mm girth \u00D7 ' + fp.qty); });
            fSteps.push('Lap away from prevailing weather', 'Verify profiles match drawings (Flashings page)', 'Seal all junctions');
            steps.push({ title: 'FLASHINGS', items: fSteps });
            if (hasElectrical && downlights > 0) {
                steps.push({ title: 'ELECTRICAL', items: [downlights + '\u00D7 downlights as marked', 'Electrician to connect'] });
            }
            steps.push({ title: 'COMPLETION', items: ['Touch up scratches with spray paint', 'Clean all surfaces', 'Remove rubbish and offcuts', 'Take completion photos', 'Customer walkthrough'] });

            // Render steps with numbered badges
            steps.forEach(function(step, si) {
                var needed = 10 + step.items.length * 4;
                if (y + needed > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                doc.setFillColor(...SW_ORANGE); doc.roundedRect(mx, y, 8, 6, 1, 1, 'F');
                doc.setFont('helvetica', 'bold'); doc.setFontSize(8); doc.setTextColor(255,255,255);
                doc.text(String(si+1), mx+4, y+4.2, {align:'center'});
                doc.setFont('helvetica', 'bold'); doc.setFontSize(9); doc.setTextColor(...SW_DARK);
                doc.text(step.title, mx+11, y+4.2);
                doc.setDrawColor(200,200,200); doc.setLineWidth(0.2); doc.line(mx+11, y+6, mr, y+6);
                doc.setDrawColor(180,180,180); doc.rect(mr-12, y+1, 3, 3);
                doc.setFontSize(5); doc.setFont('helvetica', 'normal'); doc.setTextColor(150,150,150);
                doc.text('Done', mr-8, y+3.5);
                y += 9;
                doc.setFont('helvetica', 'normal'); doc.setFontSize(7.5); doc.setTextColor(60,60,60);
                step.items.forEach(function(item) {
                    if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                    var wrapped = doc.splitTextToSize('\u2022 ' + item, cw - 12);
                    doc.text(wrapped, mx+11, y); y += wrapped.length * 3.8;
                });
                y += 3;
            });
            pdfFooter(doc);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 8: SIGN-OFF
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 Sign-Off', jobRef);
            if (views.hero) {
                var hW = cw * 0.7, hH = hW * 0.52;
                ensureSpace(hH + 5);
                addImageSafe(views.hero, mx + (cw - hW)/2, y, hW, hH);
                y += hH + 6;
            }
            y = woSectionTitle('COMPLETION CHECKLIST', y);
            ['Structure plumb and level', 'All fixings secure', 'Roof sheets correctly lapped',
             c.isGable ? 'Ridge cap sealed' : 'Roof sealed at house junction',
             'Gutters fall to downpipe', 'No visible gaps or defects', 'Flashings sealed',
             'Site clean, rubbish removed', 'Before photos taken', 'After photos taken', 'Customer walkthrough completed'
            ].forEach(function(item) { y = woCheckRow(item, y); });
            y += 6;

            y = woSectionTitle('NOTES / ISSUES', y);
            doc.setDrawColor(200,200,200);
            for (var nli = 0; nli < 6; nli++) { doc.line(mx+3, y+1, mr-3, y+1); y += 7; }
            y += 4;

            y = woSectionTitle('SIGN-OFF', y); y += 4;
            doc.setFont('helvetica', 'normal'); doc.setFontSize(9); doc.setTextColor(80,80,80);
            doc.text('Installer: ___________________________   Sign: _______________   Date: __________', mx+3, y); y += 12;
            doc.text('Customer: ___________________________   Sign: _______________   Date: __________', mx+3, y); y += 8;
            doc.setFontSize(8); doc.setTextColor(120,120,120); doc.setFont('helvetica', 'italic');
            doc.text('"I confirm the work has been completed to my satisfaction"', mx+3, y);
            pdfFooter(doc);

            // â”€â”€ Page numbers on all pages â”€â”€
            var totalPages = doc.internal.getNumberOfPages();
            for (var pgi = 1; pgi <= totalPages; pgi++) {
                doc.setPage(pgi);
                doc.setFontSize(7); doc.setFont('helvetica', 'normal'); doc.setTextColor(150,150,150);
                doc.text('Page ' + pgi + ' of ' + totalPages + '  |  ' + jobRef, pageW/2, pageH - 4, {align:'center'});
            }

            doc.save('WorkOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Work Order PDF: ' + e.message); console.error(e); }
        }

        // ==================== PDF: TRUSS ORDER ====================
        function exportTrussPDF() {
            if (!calc.isGable || !calc.trussData) {
                alert('Truss data only available for Gable roofs. Switch to Gable first.');
                return;
            }
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const td = calc.trussData;
            let y = pdfHeader(doc, 'Truss Fabrication Order', jobRef);
            y = pdfClientBlock(doc, y);

            // Truss image capture
            const img = captureTrussImage();
            if (img) {
                try {
                    doc.addImage(img, 'PNG', 14, y, 110, 55);
                    y += 58;
                } catch(e) { /* skip */ }
            }

            const lx = 14;
            const rw = 178;
            const lh = 5.5;

            function fabSection(title) {
                doc.setFillColor(...SW_ORANGE);
                doc.rect(lx, y, rw, 6, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                doc.setTextColor(255, 255, 255);
                doc.text('  ' + title, lx + 2, y + 4.5);
                y += 7;
            }
            function fabRow(label, value, bold) {
                doc.setFont('helvetica', bold ? 'bold' : 'normal');
                doc.setFontSize(10);
                doc.setTextColor(...SW_DARK);
                doc.text(label, lx + 4, y);
                doc.text(String(value), lx + rw - 4, y, { align: 'right' });
                y += lh;
            }

            fabSection('STEEL');
            fabRow('Profile', td.steelName + ' RHS');
            fabRow('Colour', td.clr);
            fabRow('BMT', td.bmt + 'mm');
            fabRow('Quantity', td.nTruss + ' trusses');
            y += 2;

            fabSection('DIMENSIONS');
            fabRow('SP (Span)', td.trussSpan + 'mm');
            fabRow('HT (Height)', td.rise + 'mm');
            fabRow('Pitch', td.pitch.toFixed(1) + '\u00B0');
            if (td.overhang > 0) fabRow('Overhang', td.overhang + 'mm');
            if (td.extender && td.extender.enabled) {
                fabRow('Extender', td.extender.length + 'mm (each end)');
            }
            y += 2;

            fabSection('CUT LIST (per truss)');
            fabRow('Chord', '1 \u00D7 ' + td.chordCut + 'mm', true);
            if (td.extender && td.extender.enabled) {
                fabRow('Extender', '2 \u00D7 ' + Math.round(td.extender.length) + 'mm');
            }
            fabRow('Rafters', '2 \u00D7 ' + td.rafterCut + 'mm', true);
            if (td.webMembers && td.webMembers.length > 0) {
                for (var wi = 0; wi < td.webMembers.length; wi++) {
                    var wm = td.webMembers[wi];
                    fabRow(wm.type, wm.count + ' \u00D7 ' + wm.length + 'mm');
                }
            }
            y += 2;

            fabSection('CUT ANGLES');
            fabRow('Apex Mitre', td.apexAngle.toFixed(1) + '\u00B0 (both rafters)');
            fabRow('Heel Mitre', td.heelAngle.toFixed(1) + '\u00B0 (rafter to chord)');
            y += 2;

            fabSection('MATERIAL REQUIRED');
            fabRow('Truss LM (each)', td.totalLM.toFixed(3) + ' LM');
            fabRow('All ' + td.nTruss + ' trusses', td.totalAllLM.toFixed(2) + ' LM', true);
            fabRow('Order length', td.totalSticks + ' \u00D7 6m sticks', true);

            // Risers (separate steel, bolted to truss ends)
            if (td.riserLeft && td.riserLeft.enabled) {
                y += 2;
                fabSection('RISERS (separate steel \u2013 bolted to truss ends)');
                fabRow('Left Riser', Math.round(td.riserLeft.length) + 'mm horiz + ' + Math.round(td.riserLeft.height) + 'mm vert');
                fabRow('Right Riser', Math.round(td.riserRight.length) + 'mm horiz + ' + Math.round(td.riserRight.height) + 'mm vert');
                fabRow('Riser steel (per pair)', (td.riserLeft.lm + td.riserRight.lm).toFixed(2) + ' LM');
                fabRow('Riser steel (all)', td.riserTotalLM.toFixed(2) + ' LM (' + td.nTruss + ' sets)', true);
            }

            pdfFooter(doc);
            doc.save('TrussOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Truss Order PDF: ' + e.message); console.error(e); }
        }

        function captureTrussImage() {
            try {
                if (trussRend && trussScene && trussCam) {
                    trussRend.render(trussScene, trussCam);
                    return trussRend.domElement.toDataURL('image/png');
                }
            } catch(e) {}
            return null;
        }

        function initPricing() {
            loadRates();
            renderRatesPanel();
            buildJobRows();
            // Set default labour day rate from stored rates
            const drEl = document.getElementById('labDayRate');
            if (drEl && storedRates['Skilled Trade']) drEl.value = storedRates['Skilled Trade'];
            updatePricing();
        }

        // ==================== POST UI ====================
        function adjustPostQty(delta) {
            var el = document.getElementById('inPostQty');
            var cur = parseInt(el.value);
            if (isNaN(cur) || cur < 2) {
                cur = parseInt(document.getElementById('inPosts').value) || 3;
            }
            var next = Math.max(2, cur + delta);
            el.value = next;
            rebuildAll();
        }
        function onPostQtyChange() {
            rebuildAll();
        }
        function clearPostQtyOverride() {
            document.getElementById('inPostQty').value = '';
            rebuildAll();
        }
        function updatePostUI() {
            var c = calc;
            if (!c || !c.L) return;

            // Post size display
            document.getElementById('postSizeDisplay').textContent = c.framePost.name;

            // Calculate values
            var totalPosts = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
            var spacing = c.postSpacing;
            var postFix = document.getElementById('inPostFix')?.value || 'concrete';
            var isConc = postFix === 'concrete';
            var cutLen = isConc ? c.postH + 300 : c.postH;
            var totalLineal = (totalPosts * cutLen / 1000).toFixed(1);

            // Result display
            var sideLabel = c.connection === 'freestanding' ? ' (' + c.nPosts + ' front + ' + c.nPosts + ' back)' : ' (front beam)';
            document.getElementById('postResultTitle').textContent = totalPosts + ' post' + (totalPosts !== 1 ? 's' : '') + ' required' + sideLabel + (c.postQtyOverride ? ' (manual)' : '');
            document.getElementById('postResultSpacing').textContent = 'Spacing: ' + spacing + 'mm centres (span: ' + Math.round(c.L) + 'mm)';
            document.getElementById('postResultLineal').textContent = 'Total lineal: ' + totalLineal + 'm of ' + c.framePost.name + ' (' + cutLen + 'mm cut length' + (isConc ? ', incl. 300mm footing' : '') + ')';
            document.getElementById('postResultFootings').textContent = 'Footings: ' + totalPosts + ' Ã— ' + (isConc ? 'concrete footing' : 'baseplate');

            // Warnings
            var warnEl = document.getElementById('postWarnings');
            var warnings = [];
            if (spacing > 3000) warnings.push('Spacing exceeds 3000mm \u2014 check beam size can span this distance');
            if (spacing < 1500 && c.nPosts > 2) warnings.push('Spacing under 1500mm \u2014 consider reducing posts for a cleaner look');
            if (warnings.length > 0) {
                warnEl.innerHTML = warnings.map(function(w) {
                    return '<div style="background:#FEF9E7;border:1px solid #F39C12;border-radius:6px;padding:6px 10px;font-size:11px;color:#7D6608;margin-bottom:4px">\u26A0 ' + w + '</div>';
                }).join('');
                warnEl.style.display = 'block';
            } else {
                warnEl.style.display = 'none';
            }
        }

        // ==================== RAFTER UI ====================
        function setRafterSpacing(val) {
            document.getElementById('inRafterSpacing').value = val;
            document.getElementById('inRafterQtyOverride').value = '';
            rebuildAll();
        }
        function onRafterSpacingChange() {
            document.getElementById('inRafterQtyOverride').value = '';
            rebuildAll();
        }
        function onRafterQtyChange() {
            rebuildAll();
        }
        function adjustRafterQty(delta) {
            var el = document.getElementById('inRafterQtyOverride');
            var cur = parseInt(el.value);
            if (isNaN(cur) || cur < 2) {
                // Read the current calculated value from the hidden field
                cur = parseInt(document.getElementById('inRafters').value) || 5;
            }
            var next = Math.max(2, cur + delta);
            el.value = next;
            rebuildAll();
        }
        function clearRafterQtyOverride() {
            document.getElementById('inRafterQtyOverride').value = '';
            rebuildAll();
        }
        function updateRafterUI() {
            var c = calc;
            if (!c || c.isGable) return;
            var rc = c.rafterCalc;
            if (!rc) return;

            var rafterLen = Math.round(c.rafter);
            var totalLineal = (rc.rafterCount * rafterLen / 1000).toFixed(1);

            document.getElementById('rafterResultTitle').textContent = rc.rafterCount + ' rafter' + (rc.rafterCount !== 1 ? 's' : '') + ' required' + (rc.isOverride ? ' (manual)' : '');
            document.getElementById('rafterResultSpacing').textContent = 'Actual spacing: ' + rc.spacing + 'mm centres (span: ' + Math.round(c.L) + 'mm)';
            document.getElementById('rafterResultLineal').textContent = 'Total lineal: ' + totalLineal + 'm of ' + c.rafterSize.name + ' (' + rafterLen + 'mm each)';
        }

        // ==================== STRUCTURAL SIZING UI ====================
        var _structBeamQtys = { fascia: 1, gutter: 1, riser: 1 };

        function adjustStructPurlinQty(delta) {
            // Purlins use the existing extra battens mechanism
            var c = calc;
            if (!c) return;
            if (c.isGable) {
                var el = document.getElementById('gableExtraBattensVal');
                var cur = parseInt(el.textContent) || 0;
                el.textContent = Math.max(0, cur + delta);
            } else {
                var el = document.getElementById('extraBattensVal');
                var cur = parseInt(el.textContent) || 0;
                el.textContent = Math.max(0, cur + delta);
            }
            rebuildAll();
        }

        function adjustStructBeamQty(type, delta) {
            var cur = _structBeamQtys[type] || 1;
            _structBeamQtys[type] = Math.max(1, Math.min(4, cur + delta));
            var el = document.getElementById('struct' + type.charAt(0).toUpperCase() + type.slice(1) + 'BeamQty');
            if (el) el.textContent = _structBeamQtys[type];
            rebuildAll();
        }

        function adjustStructTrussQty(delta) {
            var el = document.getElementById('inTrussesOverride');
            var cur = parseInt(el.value);
            if (isNaN(cur) || cur < 2) {
                cur = parseInt(document.getElementById('inTrusses').value) || 3;
            }
            var next = Math.max(2, cur + delta);
            el.value = next;
            onTrussQtyOverride();
        }

        function onTrussQtyOverride() {
            var el = document.getElementById('inTrussesOverride');
            var trussField = document.getElementById('inTrusses');
            var val = parseInt(el.value);
            if (val >= 2) {
                trussField.value = val;
                trussField.dataset.userOverride = 'true';
            }
            rebuildAll();
        }

        function scrollToTrussSection() {
            var sec = document.getElementById('sec-truss');
            if (!sec) return;
            // Expand it if collapsed
            var body = sec.querySelector('.collapse-body');
            if (body && body.classList.contains('shut')) {
                toggleSection('sec-truss');
            }
            sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function updateStructSizing() {
            var c = calc;
            if (!c || !c.L) return;
            var isGable = c.isGable;
            var conn = c.connection || 'riser';
            var isFlyover = conn === 'flyover';
            var isRiser = conn === 'riser';
            var isFreestanding = conn === 'freestanding';

            // Row visibility
            document.getElementById('structRowFasciaBeam').style.display = isFreestanding ? 'none' : '';
            document.getElementById('structRowGutterBeam').style.display = isFlyover ? 'none' : '';
            document.getElementById('structRowRiserBeam').style.display = (isRiser && !isGable) ? '' : 'none';
            document.getElementById('structRowRafters').style.display = isGable ? 'none' : '';
            document.getElementById('structRowTrusses').style.display = isGable ? '' : 'none';

            // Update purlin qty display
            var purlinQty = 0;
            if (isGable && c.gableBattenCalc) {
                purlinQty = c.gableBattenCalc.totalBattens || 0;
            } else if (c.battenCalc) {
                purlinQty = c.battenCalc.battensNeeded || 0;
            }
            document.getElementById('structPurlinQty').textContent = purlinQty || '--';

            // Update post qty display (show auto-calculated value if no override)
            var postQtyEl = document.getElementById('inPostQty');
            if (!postQtyEl.value) {
                postQtyEl.placeholder = c.nPosts;
            }

            // Update rafter qty display (show auto-calculated value if no override)
            var rafterQtyEl = document.getElementById('inRafterQtyOverride');
            if (rafterQtyEl && !rafterQtyEl.value) {
                rafterQtyEl.placeholder = c.nRafters || parseInt(document.getElementById('inRafters').value) || 5;
            }

            // Update truss qty display
            var trussOverrideEl = document.getElementById('inTrussesOverride');
            if (trussOverrideEl) {
                var trussField = document.getElementById('inTrusses');
                if (!trussOverrideEl.value && trussField) {
                    trussOverrideEl.placeholder = trussField.value;
                }
            }

            // Beam qty display
            var beamLen = Math.round(c.L);
            var fasciaQtyEl = document.getElementById('structFasciaBeamQty');
            var gutterQtyEl = document.getElementById('structGutterBeamQty');
            var riserQtyEl = document.getElementById('structRiserBeamQty');
            // Auto-set beam qty: need 2 if span > 6000mm (typical max beam length)
            var autoBeamQty = beamLen > 6000 ? 2 : 1;
            if (fasciaQtyEl && _structBeamQtys.fascia === 1 && autoBeamQty > 1) {
                _structBeamQtys.fascia = autoBeamQty;
                fasciaQtyEl.textContent = autoBeamQty;
            }
            if (gutterQtyEl && _structBeamQtys.gutter === 1 && autoBeamQty > 1) {
                _structBeamQtys.gutter = autoBeamQty;
                gutterQtyEl.textContent = autoBeamQty;
            }

            // Validation warnings
            updateStructSizingWarnings();
        }

        function updateStructSizingWarnings() {
            var c = calc;
            if (!c) return;
            var warnEl = document.getElementById('structSizingWarnings');
            var warnings = [];
            var spanMm = Math.round(c.W * 1000); // rafter/truss span in mm

            // Post spacing check
            var postSpacing = c.postSpacing;
            if (postSpacing > 3000) {
                warnings.push('Post spacing ' + postSpacing + 'mm exceeds 3000mm \u2014 check beam can span');
                document.getElementById('structRowPosts').classList.add('warn');
            } else {
                document.getElementById('structRowPosts').classList.remove('warn');
            }

            // Beam span check (post spacing = beam span between posts)
            var beamKey = document.getElementById('inBeamSize').value;
            var beam = FRAME_BEAMS[beamKey];
            if (beam && postSpacing > 3000) {
                var beamH = beam.h * 1000;
                if (beamH < 100 && postSpacing > 2400) {
                    warnings.push('Beam ' + beam.label + ' may be undersized for ' + (postSpacing/1000).toFixed(1) + 'm post span');
                }
            }

            if (warnings.length > 0) {
                warnEl.innerHTML = warnings.map(function(w) {
                    return '<div style="background:#FEF9E7;border:1px solid #F39C12;border-radius:6px;padding:6px 10px;font-size:10px;color:#7D6608;margin-bottom:4px">\u26A0 ' + w + '</div>';
                }).join('');
            } else {
                warnEl.innerHTML = '';
            }
        }

        // ==================== BATTEN UI ====================
        function adjustExtraBattens(delta) {
            var el = document.getElementById('extraBattensVal');
            var cur = parseInt(el.textContent) || 0;
            el.textContent = Math.max(0, cur + delta);
            rebuildAll();
        }

        function adjustGableExtraBattens(delta) {
            var el = document.getElementById('gableExtraBattensVal');
            var cur = parseInt(el.textContent) || 0;
            el.textContent = Math.max(0, cur + delta);
            rebuildAll();
        }

        function updateGableBattenUI() {
            var c = calc;
            if (!c || !c.isGable) return;
            var gb = c.gableBattenCalc;
            if (!gb) return;

            var spanTable = SPAN_TABLES[c.roofing];
            var sheetLabel = (ROOFING_TYPES[c.roofing] || {}).name || c.roofing;
            document.getElementById('gableBattenSheet').textContent = sheetLabel;
            document.getElementById('gableBattenMaxSpan').textContent = spanTable ? spanTable.maxSpan + 'mm' : 'N/A';
            document.getElementById('gableBattenRafter').textContent = Math.round(c.rafter) + 'mm';
            document.getElementById('gableBattenPitch').textContent = c.pitch.toFixed(1) + '\u00B0';

            if (gb.totalBattens === 0) {
                document.getElementById('gableBattenResultTitle').textContent = '\u2713 ' + gb.message;
                document.getElementById('gableBattenResultBreakdown').textContent = '';
                document.getElementById('gableBattenResultSpacing').textContent = '';
                document.getElementById('gableBattenResultLineal').textContent = '';
                document.getElementById('gableBattenDiagram').textContent = '';
                return;
            }

            document.getElementById('gableBattenResultTitle').textContent = gb.totalBattens + ' purlins required (' + gb.battensPerSide + ' per side)';
            document.getElementById('gableBattenResultBreakdown').textContent = 'Apex pair: 2 (straddling ridge, ' + gb.apexGap + 'mm gap)  |  End battens: 2 (at eaves)  |  Intermediate: ' + Math.max(0, gb.totalBattens - 4);
            document.getElementById('gableBattenResultSpacing').textContent = 'Spacing: ' + gb.spacing + 'mm centres along rafter (max span: ' + gb.maxSpan + 'mm)';
            var totalLineal = (gb.totalBattens * gb.battenLength / 1000).toFixed(1);
            document.getElementById('gableBattenResultLineal').textContent = 'Total lineal: ' + totalLineal + 'm of ' + c.steel.name + ' (' + gb.battenLength + 'mm each)';

            // Cross-section diagram
            var diag = '';
            var rLen = gb.rafterLength;
            var positions = gb.positionsPerSide;
            diag += '              RIDGE\n';
            diag += '               /\\\n';
            // Build left + right side indicators
            var maxW = 30;
            for (var i = positions.length - 1; i >= 0; i--) {
                var frac = positions[i] / rLen;
                var indent = Math.round((1 - frac) * maxW / 2);
                var width = maxW - indent * 2;
                var spaces = '';
                for (var s = 0; s < indent; s++) spaces += ' ';
                var label = '';
                if (i === positions.length - 1) label = '  \u2190 Apex purlins (\u00D72)';
                else if (i === 0) label = '  \u2190 End purlins (\u00D72)';
                else label = '  \u2190 ' + positions[i] + 'mm';
                diag += '  ' + spaces + '\u2550';
                for (var w = 0; w < width - 2; w++) diag += (i === positions.length - 1 || i === 0) ? '\u2550' : '\u2500';
                diag += '\u2550' + label + '\n';
                if (i > 0) {
                    diag += '  ' + spaces + '/';
                    for (var w = 0; w < width - 2; w++) diag += ' ';
                    diag += '\\\n';
                }
            }
            diag += '  ';
            for (var w = 0; w < maxW; w++) diag += '\u2501';
            diag += '  BOTTOM CHORD';
            diag += '\n\n  ' + c.steel.name + ' \u00D7 ' + gb.totalBattens + ' purlins';
            diag += '\n  Cut to: ' + gb.battenLength + 'mm (patio length)';
            document.getElementById('gableBattenDiagram').textContent = diag;
        }

        function updateBattenUI() {
            var c = calc;
            if (!c) return;
            if (c.isGable) { updateGableBattenUI(); return; }

            // For insulated roofs, show simple no-battens message
            if (isInsulated(c.roofing)) {
                document.getElementById('battenSheetLabel').textContent = c.roofing === 'solarspan75' ? 'SolarSpan 75mm' : 'SolarSpan 100mm';
                document.getElementById('battenMaxSpan').textContent = 'Self-spanning';
                document.getElementById('battenProjection').textContent = Math.round(c.W) + 'mm';
                document.getElementById('battenPitch').textContent = c.pitch.toFixed(1) + '\u00B0';
                document.getElementById('battenResultTitle').textContent = '\u2713 Self-spanning \u2014 no battens required';
                document.getElementById('battenResultSpacing').textContent = '';
                document.getElementById('battenResultPositions').textContent = '';
                document.getElementById('battenResultBrackets').textContent = '';
                document.getElementById('battenBracketType').style.display = 'none';
                document.getElementById('battenWarnings').style.display = 'none';
                document.getElementById('battenDiagram').textContent = '';
                return;
            }

            var bc = c.battenCalc;
            var bk = c.bracketCalc;
            var bv = c.battenValidation;
            var sheet = SHEET_SPANS[c.sheetSpanKey];
            if (!sheet) return;

            // Summary
            document.getElementById('battenSheetLabel').textContent = sheet.label;
            document.getElementById('battenMaxSpan').textContent = sheet.maxSpan + 'mm';
            document.getElementById('battenProjection').textContent = Math.round(c.W) + 'mm';
            document.getElementById('battenPitch').textContent = c.pitch.toFixed(1) + '\u00B0';

            // Warnings
            var warnEl = document.getElementById('battenWarnings');
            if (bv.errors.length > 0 || bv.warnings.length > 0) {
                var html = '';
                bv.errors.forEach(function(e) { html += '<div style="background:#FDEDEC;border:1px solid #E74C3C;border-radius:6px;padding:6px 10px;font-size:11px;color:#C0392B;margin-bottom:4px">\u2716 ' + e + '</div>'; });
                bv.warnings.forEach(function(w) { html += '<div style="background:#FEF9E7;border:1px solid #F39C12;border-radius:6px;padding:6px 10px;font-size:11px;color:#7D6608;margin-bottom:4px">\u26A0 ' + w + '</div>'; });
                warnEl.innerHTML = html;
                warnEl.style.display = 'block';
            } else {
                warnEl.style.display = 'none';
            }

            // Result
            if (bc.battensNeeded === 0) {
                var noBattenMsg = bc.message;
                if (c.roofing === 'spanplus330') noBattenMsg = 'SpanPlus spans full projection \u2014 no battens required';
                document.getElementById('battenResultTitle').textContent = '\u2713 ' + noBattenMsg;
                document.getElementById('battenResultSpacing').textContent = '';
                document.getElementById('battenResultPositions').textContent = '';
                document.getElementById('battenResultBrackets').textContent = '';
                document.getElementById('battenBracketType').style.display = 'none';
            } else {
                document.getElementById('battenResultTitle').textContent = bc.battensNeeded + ' batten row' + (bc.battensNeeded > 1 ? 's' : '') + ' required';
                document.getElementById('battenResultSpacing').textContent = 'Spacing: ' + bc.spanDistance + 'mm centres';
                document.getElementById('battenResultPositions').textContent = 'Positions from back beam: ' + bc.battenPositions.join('mm, ') + 'mm';
                document.getElementById('battenResultBrackets').textContent = 'Brackets: ' + bk.bracketsNeeded + ' total (' + bk.perBatten + ' per batten)';
                document.getElementById('battenBracketType').style.display = 'block';
            }

            // Bracket powdercoat warning
            var extRadio = document.querySelector('input[name="bracketType"][value="external"]');
            document.getElementById('battenPowdercoatWarn').style.display = (extRadio && extRadio.checked && bc.battensNeeded > 0) ? 'block' : 'none';

            // Diagram
            var diag = '';
            var projMm = Math.round(c.W);
            diag += '  HOUSE\n';
            diag += '    \u2502\n';
            diag += '  Back \u2502';
            var items = [{pos: 0, label: 'Back Beam'}];
            bc.battenPositions.forEach(function(p, i) { items.push({pos: p, label: 'Batten ' + (i + 1)}); });
            items.push({pos: projMm, label: 'Front Beam'});

            // Build horizontal layout
            var line1 = '  ';
            var line2 = '  ';
            var line3 = '  ';
            for (var i = 0; i < items.length; i++) {
                if (i === 0) {
                    line1 += items[i].pos + 'mm';
                    line2 += '\u2550\u2550\u2550\u2550';
                    line3 += items[i].label;
                } else {
                    var gap = items[i].pos - items[i-1].pos;
                    var pad = Math.max(2, Math.round(gap / 300));
                    var spacer = '';
                    for (var s = 0; s < pad; s++) spacer += '\u2500';
                    line1 += spacer + items[i].pos + 'mm';
                    line2 += spacer + '\u2550\u2550\u2550\u2550';
                    line3 += spacer + items[i].label;
                }
            }
            diag += '\n' + line1 + '\n' + line2 + '\n' + line3;
            if (bc.battensNeeded > 0) {
                diag += '\n\n  76\u00D738\u00D71.6 RHS patio tubing \u00D7 ' + bc.battensNeeded;
                diag += '\n  Cut to: ' + Math.round(bc.battenLength) + 'mm';
            }
            document.getElementById('battenDiagram').textContent = diag;
        }

        function rebuildAll() {
            autoCalculatePostsAndTrusses();
            getInputs();
            draw2DPlan();
            buildTruss3D();
            updateCutListPanel();
            buildAsm3D();
            updateBattenUI();
            updateRafterUI();
            updatePostUI();
            buildJobRows();
            updatePricing();
            updateEstimate();
            updateRightPanelSummary();
            updateEngGroupSummary();
            updatePatioCatchment();
            updatePurlinValidation();
            updateStructSizing();
        }

        function exportOrder() {
            exportAllOutputs();
        }

        // ==================== CONSOLIDATED OUTPUT FUNCTIONS ====================

        function showToast(message, type) {
            type = type || 'success';
            var toast = document.createElement('div');
            toast.className = 'toast toast-' + type;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(function() { toast.classList.add('show'); }, 10);
            setTimeout(function() {
                toast.classList.remove('show');
                setTimeout(function() { toast.remove(); }, 300);
            }, 2500);
        }

        function formatDateStr(date) {
            return date.toISOString().split('T')[0];
        }

        async function exportAllOutputs() {
            if (!window.jspdf) {
                showToast('PDF library not loaded. Check internet connection and reload.', 'error');
                return;
            }
            var c = calc;
            if (!c.roofStyle) {
                showToast('No design loaded. Configure a patio design first.', 'error');
                return;
            }
            generateQuotePDF();
            downloadMaterialOrderPDF();
            await generateWorkOrderPDF();
            showToast('All documents generated');
        }

        function generateMaterialOrder() {
            var optionsEl = document.getElementById('materialOrderOptions');
            optionsEl.style.display = optionsEl.style.display === 'none' ? 'flex' : 'none';

            // Hide fab button if no fab items
            var groups = buildSupplierRows();
            var hasFab = groups.fabrication && groups.fabrication.length > 0;
            var fabBtn = document.getElementById('copyFabBtn');
            if (fabBtn) fabBtn.style.display = hasFab ? 'inline-block' : 'none';

            showToast('Material order ready - copy sections or download PDF');
        }

        function copySectionToClipboard(section) {
            var groups = buildSupplierRows();
            var rows = [];
            if (section === 'steel') rows = groups.steel || [];
            else if (section === 'sheets') rows = groups.sheets || [];
            else if (section === 'fab') rows = groups.fabrication || [];

            if (rows.length === 0) {
                showToast('No items in ' + section + ' section', 'error');
                return;
            }

            var text = section.toUpperCase() + ' ORDER - ' + getJobRef() + ' - ' + getClientName() + '\n';
            text += 'Date: ' + formatDateStr(new Date()) + '\n';
            text += 'Deliver to: ' + getSiteAddress() + '\n\n';
            text += 'Item | Size | Length | Qty | Colour | Notes\n';
            text += '---|---|---|---|---|---\n';
            rows.forEach(function(r) {
                text += r.join(' | ') + '\n';
            });
            // Append additional materials for steel section
            if (section === 'steel' && additionalMaterials.length > 0) {
                text += '\nADDITIONAL MATERIALS\n';
                additionalMaterials.forEach(function(am) {
                    text += (am.desc || 'Item') + ' | - | - | ' + am.qty + ' | - | -\n';
                });
            }

            navigator.clipboard.writeText(text).then(function() {
                showToast(section.charAt(0).toUpperCase() + section.slice(1) + ' order copied to clipboard');
            }).catch(function() {
                showToast('Failed to copy to clipboard', 'error');
            });
        }

        function downloadMaterialOrderPDF() {
            if (!window.jspdf) { showToast('PDF library not loaded', 'error'); return; }
            try {
                var jobRef = getJobRef();

                // Generate Steel Order PDF
                generateSteelOrderPDF();

                // Generate Sheets & Flashings PDF
                generateSheetsOrderPDF();

                // Generate Fabrication PDF if applicable
                var groups = buildSupplierRows();
                if (groups.fabrication && groups.fabrication.length > 0) {
                    generateFabricationOrderPDF();
                }

                showToast('Material Order PDFs downloaded');
            } catch(e) {
                showToast('Error generating Material Order: ' + e.message, 'error');
                console.error(e);
            }
        }

        function exportRawData() {
            var base = gatherJobData();
            var data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                customer: typeof customer !== 'undefined' ? customer : {},
                siteDetails: typeof siteDetails !== 'undefined' ? siteDetails : {},
                client: base.client,
                config: base.config,
                pricing: base.pricing,
                complexity: base.complexity,
                notes: base.notes,
                truss: {
                    base: base.config.trussBase,
                    chord: base.config.trussChord,
                    steel: base.config.trussSteel,
                    overhang: base.config.overhang,
                    riserLeft: base.config.trussRiserLeft,
                    riserRight: base.config.trussRiserRight,
                    riserLocked: base.config.trussRiserLocked,
                    riserType: base.config.riserType || 'welded',
                    extender: base.config.trussExtender
                },
                flashings: flashingProfiles.map(function(p) {
                    return { id: p.id, name: p.name, colour: p.colour, gauge: p.gauge, length: p.length, qty: p.qty, colourSide: p.colourSide, points: p.points, girth: p.girth, legs: p.legs, startTreatment: p.startTreatment || null, endTreatment: p.endTreatment || null };
                })
            };

            var json = JSON.stringify(data, null, 2);
            var blob = new Blob([json], { type: 'application/json' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'PatioData_' + safeName(getClientName()) + '_' + formatDateStr(new Date()) + '.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Raw data exported');
        }

        function loadRawData(file) {
            if (!file) return;
            var reader = new FileReader();
            reader.onload = function(e) {
                try {
                    var data = JSON.parse(e.target.result);
                    // Use existing import logic
                    if (data.client || data.config) {
                        // Populate via the import system
                        var textarea = document.getElementById('importTextarea');
                        if (textarea) {
                            textarea.value = e.target.result;
                            importJobData();
                            document.getElementById('importModal').style.display = 'none';
                        } else {
                            // Direct population
                            if (data.client) {
                                var cl = data.client;
                                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                                if (cl.name) document.getElementById('customerName').value = cl.name;
                                if (cl.address) document.getElementById('customerAddress').value = cl.address;
                                if (cl.phone) document.getElementById('customerPhone').value = cl.phone;
                                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                            }
                        }
                        showToast('Job data loaded successfully');
                    } else {
                        showToast('Invalid job data file', 'error');
                    }
                } catch(err) {
                    showToast('Error loading file: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // ==================== INIT ====================
        function resizeAsm() {
            const ac = document.getElementById('asmViewport');
            if (asmRend && ac && !ac.classList.contains('fullscreen') && !ac.classList.contains('fullscreen-mode')) {
                var w = ac.clientWidth, h = ac.clientHeight;
                if (w > 0 && h > 0) {
                    if (asmCam) {
                        asmCam.aspect = w / h;
                        asmCam.updateProjectionMatrix();
                    }
                    if (asmOrthoCamera) {
                        var aspect = w / h;
                        var halfH = (asmOrthoCamera.top - asmOrthoCamera.bottom) / 2;
                        asmOrthoCamera.left = -halfH * aspect;
                        asmOrthoCamera.right = halfH * aspect;
                        asmOrthoCamera.updateProjectionMatrix();
                    }
                    asmRend.setSize(w, h);
                }
            }
        }
        function resizeTruss() {
            const tc = document.getElementById('trussViewport');
            if (trussCam && trussRend && tc) {
                var w = tc.clientWidth, h = tc.clientHeight;
                if (w > 0 && h > 0) {
                    trussCam.aspect = w / h;
                    trussCam.updateProjectionMatrix();
                    trussRend.setSize(w, h);
                }
            }
        }
        window.addEventListener('resize', () => {
            resizeTruss();
            resizeAsm();
            draw2DPlan();
            if (flashModalOpen) { resizeFlashCanvas(); drawFlashCanvas(); }
        });
        document.addEventListener('fullscreenchange', () => { setTimeout(resizeTruss, 100); });
        // ResizeObserver for container-specific resize (layout changes, panel toggle)
        if (typeof ResizeObserver !== 'undefined') {
            var ro = new ResizeObserver(function() {
                resizeAsm();
                resizeTruss();
                draw2DPlan();
                if (flashModalOpen) { resizeFlashCanvas(); drawFlashCanvas(); }
            });
            var asmEl = document.getElementById('asmViewport');
            var trussEl = document.getElementById('trussViewport');
            var rpEl = document.getElementById('panelRight');
            if (asmEl) ro.observe(asmEl);
            if (trussEl) ro.observe(trussEl);
            if (rpEl) ro.observe(rpEl);
        }

        // ==================== LAYOUT TOGGLE ====================
        function toggleLayout() {
            var main = document.getElementById('mainLayout');
            var btn = document.getElementById('layoutToggle');
            var isFullWidth = main.classList.toggle('full-width');
            btn.innerHTML = isFullWidth ? '&#9704; Show Preview' : '&#9703; Full Width';
            localStorage.setItem('patioLayout', isFullWidth ? 'full' : 'split');
            // Resize canvases after layout change â€” multiple delays for CSS transition
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 50);
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 200);
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 500);
        }

        function initLayout() {
            var pref = localStorage.getItem('patioLayout');
            if (pref === 'full') {
                document.getElementById('mainLayout').classList.add('full-width');
                document.getElementById('layoutToggle').innerHTML = '&#9704; Show Preview';
            }
        }

        // initRightPanel3D removed â€” single renderer now in right panel via initAsm3D

        function updateRightPanelSummary() {
            var c = calc;
            if (!c || !c.L) return;
            var rpDims = document.getElementById('rpDims');
            var rpRoof = document.getElementById('rpRoofType');
            var rpMat = document.getElementById('rpMaterial');
            var rpClr = document.getElementById('rpColour');
            if (rpDims) rpDims.textContent = (c.lenInput / 1000).toFixed(1) + 'm Ã— ' + (c.projInput / 1000).toFixed(1) + 'm';
            if (rpRoof) rpRoof.textContent = c.roofStyle === 'hip' ? 'Hip' : (c.isGable ? 'Gable' : 'Skillion');
            if (rpMat) rpMat.textContent = (ROOFING_TYPES[c.roofing] || ROOFING_TYPES.corrugated).name;
            if (rpClr) rpClr.textContent = sheetColor.name;

            // Estimate now writes directly to rpEstSqm/rpEstRange via updateEstimate()
        }

        function updateEngGroupSummary() {
            var c = calc;
            var parts = [];
            if (c && c.rafterQty) parts.push(c.rafterQty + ' rafters');
            if (c && c.battenQty) parts.push(c.battenQty + ' battens');
            var flashCount = document.querySelectorAll('#flashJobBody tr').length;
            if (flashCount > 0) parts.push(flashCount + ' flashing' + (flashCount > 1 ? 's' : ''));
            if (c && c.isGable && c.trussQty) parts.push(c.trussQty + ' truss' + (c.trussQty > 1 ? 'es' : ''));
            var el = document.getElementById('sgEngSummary');
            if (el) el.textContent = parts.length ? parts.join(' \u00B7 ') : '';
        }

        // ==================== CUSTOMER PREVIEW (AI IMAGE GENERATION) ====================

        // Capture screenshot of 3D viewer
        function capture3DScreenshot() {
            var canvas = document.getElementById('asmCanvas');
            if (!canvas) {
                alert('Could not find 3D canvas');
                return;
            }

            // Force a render to ensure current state is captured
            if (asmRend && asmScene && asmCam) {
                asmRend.render(asmScene, asmCam);
            }

            var dataUrl = canvas.toDataURL('image/png');

            // Show preview
            var preview = document.getElementById('screenshotPreview');
            var img = document.getElementById('screenshotImg');
            img.src = dataUrl;
            preview.style.display = 'block';

            // Also copy to clipboard if supported
            canvas.toBlob(function(blob) {
                if (navigator.clipboard && navigator.clipboard.write) {
                    navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': blob })
                    ]).then(function() {
                        console.log('Screenshot copied to clipboard');
                    }).catch(function(err) {
                        console.log('Could not copy to clipboard:', err);
                    });
                }
            });

            alert('Screenshot captured!\n\nRight-click the image to save it, or it may be copied to your clipboard.');
        }

        // Generate prompt and open Gemini
        function generateGeminiPrompt() {
            // Get form values using actual field IDs
            var length = parseFloat(document.getElementById('inLength').value) || 6;
            var projection = parseFloat(document.getElementById('inWidth').value) || 4;
            var height = parseFloat(document.getElementById('inPostHeight').value) || 2.7;
            var roofStyle = document.getElementById('inRoofStyle').value || 'skillion';
            var attachment = document.getElementById('inConnection').value || 'fascia';
            var roofMaterial = document.getElementById('inRoofing').value || 'solarspan75';
            var pitch = parseFloat(document.getElementById('inPitch').value) || 3;

            // Get colour names from global picker state
            var roofColourName = sheetColor ? sheetColor.name : 'Surfmist';
            var steelColourName = steelColor ? steelColor.name : 'Monument';

            // Build descriptive text
            var roofStyleText = {
                skillion: 'single-slope skillion (flat angled)',
                gable: 'peaked gable with central ridge',
                hip: 'hip roof',
                flat: 'flat roof'
            }[roofStyle] || roofStyle;

            var attachmentText = {
                fascia: 'attached directly to the house fascia board',
                riser: 'attached via riser brackets sitting above the existing house roof',
                flyover: 'flyover attachment sitting above the existing house roof',
                freestanding: 'freestanding structure with posts on all four corners',
                wall: 'wall-mounted to the house'
            }[attachment] || attachment;

            var materialText = roofMaterial.indexOf('solarspan') === 0
                ? 'insulated SolarSpan panels (smooth flat white/cream ceiling visible from underneath, coloured Colorbond on top)'
                : 'Colorbond ' + roofMaterial + ' profile steel sheets';

            // Build the prompt
            var prompt = 'I\'m attaching:\n' +
                '1. A 3D model screenshot showing the patio structure and dimensions\n' +
                '2. A photo of the actual house/site (if provided)\n\n' +
                'Please generate a PHOTOREALISTIC image that combines these - showing this exact patio design built at this house.\n\n' +
                'PATIO SPECIFICATIONS (match the 3D model):\n' +
                '- Dimensions: ' + length + 'm wide Ã— ' + projection + 'm deep Ã— ' + height + 'm ceiling height\n' +
                '- Roof style: ' + roofStyleText + '\n' +
                '- Roof pitch: ' + pitch + ' degrees\n' +
                '- Roofing material: ' + materialText + '\n' +
                '- Roof colour: ' + roofColourName + ' - this is a Colorbond colour, get it accurate\n' +
                '- Steel frame (posts, beams, fascia): ' + steelColourName + ' Colorbond powder-coated steel\n' +
                '- ' + attachmentText + '\n' +
                '- Matching ' + steelColourName + ' gutters and downpipes\n\n' +
                'HOUSE:\n' +
                '- Typical Perth suburban home\n' +
                '- Match the site photo if provided\n\n' +
                'IMPORTANT RENDERING INSTRUCTIONS:\n' +
                '- Make it look like a REAL PHOTO, not CGI or a render\n' +
                '- Late afternoon lighting (golden hour, Perth summer ~5pm)\n' +
                '- Camera position: standing in the backyard, looking back toward the house at a slight angle\n' +
                '- Show the full patio structure clearly - posts, beams, roof\n' +
                '- The underside of the roof (ceiling) should be visible and is smooth white/cream (SolarSpan)\n' +
                '- Colorbond steel has a subtle satin sheen, not mirror-shiny\n' +
                '- Include realistic shadows on the ground\n' +
                '- Green lawn, blue sky with light clouds\n' +
                '- Style: architectural photography, like a home renovation magazine\n\n' +
                'CRITICAL: Match the EXACT colours:\n' +
                '- Roof: ' + roofColourName + '\n' +
                '- Steel frame: ' + steelColourName + '\n' +
                'These are specific Australian Colorbond colours - they must be accurate.';

            // Copy to clipboard
            navigator.clipboard.writeText(prompt).then(function() {
                // Show instructions
                document.getElementById('promptInstructions').style.display = 'block';

                // Open Gemini
                window.open('https://gemini.google.com/app', '_blank');
            }).catch(function(err) {
                console.log('Prompt:', prompt);
                alert('Could not copy automatically. The prompt has been logged to console (F12).');
            });
        }

        // Initialize
        initLayout();
        initCollapseSections();
        initJobDetails();
        updateUI();
        initTruss3D();
        initAsm3D();
        initPricing();
        initFlashingEditor();
        rebuildAll();
        // Deferred resize to ensure renderers sync after DOM settles
        function deferredResize() {
            resizeAsm(); resizeTruss(); draw2DPlan();
        }
        requestAnimationFrame(deferredResize);
        setTimeout(deferredResize, 200);
        setTimeout(deferredResize, 500);
    </script>
</body>
</html>
