
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureWorks WA - Patio Designer Pro V18</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/3.0.3/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js"></script>
    <style>
        :root {
            --sw-orange: #F15A29;
            --sw-blue-dark: #293C46;
            --sw-white: #FFFFFF;
            --sw-bg: #F5F5F7;
            --sw-border: #E5E5E5;
            --sw-text: #1D1D1F;
            --sw-text-sec: #86868B;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: var(--sw-bg);
            color: var(--sw-text);
        }
        .header {
            background: var(--sw-white);
            border-bottom: 1px solid var(--sw-border);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo { display: flex; align-items: center; gap: 10px; }
        .header-logo { height: 32px; width: auto; }
        .job-badge { background: var(--sw-bg); padding: 6px 14px; border-radius: 16px; font-size: 13px; }
        .job-badge strong { color: var(--sw-orange); }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }
        .btn-primary { background: var(--sw-orange); color: white; }
        .btn-secondary { background: var(--sw-bg); color: var(--sw-text); border: 1px solid var(--sw-border); }
        .main { max-width: 1400px; margin: 0 auto; padding: 24px; display: flex; gap: 24px; align-items: flex-start; }
        .panel-left { flex: 0 0 45%; min-width: 0; overflow-y: auto; max-height: calc(100vh - 80px); }
        .panel-right { flex: 0 0 calc(55% - 24px); position: sticky; top: 80px; max-height: calc(100vh - 100px); overflow-y: auto; height: fit-content; }
        .main.full-width .panel-left { flex: 0 0 100%; max-height: none; }
        .main.full-width .panel-right { display: none; }
        /* Right panel cards */
        .rp-card { background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); overflow: hidden; margin-bottom: 16px; }
        .rp-card-hdr { padding: 12px 16px; border-bottom: 1px solid var(--sw-border); font-size: 14px; font-weight: 600; }
        .rp-card-body { padding: 16px; }
        .rp-summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .rp-summary-item { background: var(--sw-bg); border-radius: 8px; padding: 8px 10px; }
        .rp-summary-label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); }
        .rp-summary-value { font-size: 14px; font-weight: 600; font-family: 'SF Mono', monospace; }
        .rp-est-range { font-size: 20px; font-weight: 700; font-family: 'SF Mono', monospace; text-align: center; padding: 8px 0; }
        .rp-est-label { font-size: 11px; color: var(--sw-text-sec); text-align: center; }
        .rp-est-btn { margin-top: 12px; }
        .rp-est-btn .btn { width: 100%; text-align: center; }
        .section {
            background: #fff;
            border-radius: 0;
            margin-bottom: 0;
            overflow: hidden;
        }
        .section-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--sw-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .section-title { font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; color: #333; }
        .section-subtitle { display: none; }
        .section-body { padding: 16px 20px; }

        /* Basics layout helpers */
        .basics-group { margin-bottom: 0; }
        .basics-group-title { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
        .basics-group-title .bg-num { display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: var(--sw-border); color: var(--sw-text-sec); font-size: 9px; font-weight: 700; flex-shrink: 0; }
        .basics-divider { height: 1px; background: var(--sw-border); margin: 14px 0; }
        .basics-grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
        .basics-grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .basics-grid-4 { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 8px; }
        .basics-field label { font-size: 11px; font-weight: 500; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .basics-field input, .basics-field select, .basics-field textarea { width: 100%; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 12px; }
        .basics-field input:focus, .basics-field select:focus { outline: none; border-color: var(--sw-orange); }
        .basics-colours { display: flex; gap: 24px; align-items: flex-start; }
        .basics-colour-block { flex: 1; }
        .basics-colour-label { font-size: 10px; color: var(--sw-text-sec); margin-bottom: 4px; }
        .extras-cost { margin-top: 6px; }
        .extras-cost label { font-size: 10px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .extras-cost input { width: 100%; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 12px; }
        .readonly-field { background: #f5f5f5 !important; color: #666 !important; cursor: not-allowed; }
        .helper-text { font-size: 11px; color: var(--sw-text-sec); margin-top: 5px; }

        .setup-grid { display: grid; grid-template-columns: 320px 1fr 280px; gap: 20px; }
        .options-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 16px; }
        .setup-card { background: var(--sw-bg); border-radius: 10px; padding: 14px; }
        .setup-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 10px; }
        .field { margin-bottom: 10px; }
        .field-label { display: flex; justify-content: space-between; font-size: 12px; font-weight: 500; margin-bottom: 3px; }
        .field-unit { font-size: 10px; color: var(--sw-text-sec); }
        .field-input { width: 100%; padding: 7px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; }
        .field-input:focus { outline: none; border-color: var(--sw-orange); }
        .field-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .plan-2d { background: #EEF1F4; border-radius: 8px; height: 220px; }
        .plan-2d canvas { width: 100%; height: 100%; }
        .color-chips { display: flex; flex-wrap: wrap; gap: 5px; }
        .color-chip { width: 24px; height: 24px; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
        .color-chip.active { border-color: var(--sw-text); }
        .color-label { font-size: 11px; color: var(--sw-text-sec); margin-top: 6px; }
        .calc-display { background: var(--sw-blue-dark); border-radius: 8px; padding: 10px; margin-top: 10px; color: white; }
        .calc-row { display: flex; justify-content: space-between; font-size: 11px; padding: 3px 0; }
        .calc-label { opacity: 0.7; }
        .calc-value { font-weight: 600; font-family: 'SF Mono', monospace; color: var(--sw-orange); }

        /* Structural Sizing Component */
        .struct-sizing { border: 1px solid var(--sw-border); border-radius: 8px; overflow: hidden; }
        .struct-row { display: grid; grid-template-columns: 100px 1fr 1fr; align-items: center; gap: 8px; padding: 7px 12px; border-bottom: 1px solid var(--sw-border); }
        .struct-row:last-child { border-bottom: none; }
        .struct-label { font-size: 11px; font-weight: 600; color: var(--sw-text); white-space: nowrap; }
        .struct-qty { display: flex; align-items: center; gap: 0; }
        .struct-qty button { width: 26px; height: 26px; border: 1px solid var(--sw-border); background: #fff; cursor: pointer; font-size: 14px; line-height: 1; color: var(--sw-text); }
        .struct-qty button:first-child { border-radius: 4px 0 0 4px; }
        .struct-qty button:last-child { border-radius: 0 4px 4px 0; }
        .struct-qty button:hover { background: var(--sw-bg); }
        .struct-qty input, .struct-qty span { width: 40px; height: 26px; border: 1px solid var(--sw-border); border-left: none; border-right: none; text-align: center; font-size: 12px; font-weight: 600; font-family: 'SF Mono', monospace; background: #fff; line-height: 26px; }
        .struct-qty input { padding: 0; }
        .struct-size select { width: 100%; padding: 4px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 11px; background: #fff; }
        .struct-size select:focus { outline: none; border-color: var(--sw-orange); }
        .struct-configure-btn { padding: 4px 12px; border: 1px solid var(--sw-accent); border-radius: 4px; background: #fff; color: var(--sw-accent); font-size: 11px; font-weight: 600; cursor: pointer; }
        .struct-configure-btn:hover { background: var(--sw-accent); color: #fff; }
        .struct-row.warn { background: #FEF9E7; }
        .struct-row.warn .struct-label { color: #7D6608; }
        .struct-warn-tip { grid-column: 1 / -1; font-size: 10px; color: #7D6608; padding: 0 0 2px 0; }

        .truss-viewport { background: linear-gradient(180deg, #E8ECF0 0%, #D5DAE0 100%); border-radius: 10px; min-height: 500px; height: 60vh; max-height: 800px; position: relative; overflow: hidden; }
        .truss-viewport:fullscreen { max-height: none; height: 100vh; border-radius: 0; }
        .truss-viewport:fullscreen canvas { border-radius: 0; }
        .truss-fullscreen-btn { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); border: none; border-radius: 6px; padding: 5px 10px; font-size: 13px; cursor: pointer; z-index: 50; color: var(--sw-text-sec); }
        .truss-fullscreen-btn:hover { background: white; color: var(--sw-text); }
        .truss-dim-toggle { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); border-radius: 6px; padding: 5px 10px; font-size: 11px; z-index: 50; display: flex; align-items: center; gap: 4px; cursor: pointer; color: var(--sw-text-sec); user-select: none; }
        .truss-dim-toggle input { accent-color: var(--sw-orange); }
        .truss-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .truss-viewport canvas:active { cursor: grabbing; }
        .truss-view-btns { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.9); padding: 3px; border-radius: 6px; }
        .truss-view-btn { padding: 5px 10px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .truss-view-btn.active { background: var(--sw-blue-dark); color: white; }
        .truss-panel-vertical { display: flex; flex-direction: column; gap: 12px; margin-top: 12px; }
        .truss-cards-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        .truss-card { background: var(--sw-bg); border-radius: 10px; padding: 12px; }
        .truss-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .spec-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .spec-item { background: white; border-radius: 6px; padding: 8px; text-align: center; }
        .spec-label { font-size: 9px; color: var(--sw-text-sec); }
        .spec-value { font-size: 15px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .spec-value.hl { color: var(--sw-orange); }
        .fab-box { background: var(--sw-blue-dark); border-radius: 10px; padding: 12px; color: white; }
        .fab-box h4 { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; margin-bottom: 8px; }
        .fab-line { font-family: 'SF Mono', monospace; font-size: 11px; padding: 4px 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-bottom: 2px; }
        .truss-config { display: flex; gap: 12px; padding: 8px 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; }
        .truss-config-item { display: flex; align-items: center; gap: 6px; }
        .truss-config-item > label { font-size: 11px; font-weight: 600; color: var(--sw-text); display: flex; align-items: center; gap: 4px; cursor: pointer; white-space: nowrap; }
        .truss-config-item input[type="checkbox"] { accent-color: var(--sw-orange); }
        .truss-opt-fields { display: flex; gap: 6px; align-items: center; }
        .truss-opt-fields label { font-size: 10px; color: var(--sw-text-sec); display: flex; align-items: center; gap: 3px; white-space: nowrap; }
        .truss-opt-fields input[type="number"] { width: 52px; font-size: 11px; padding: 2px 4px; border: 1px solid var(--sw-border); border-radius: 4px; }
        .truss-opt-fields span { font-size: 9px; color: var(--sw-text-sec); }

        .gutter-inputs { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        .gutter-inputs label { font-size: 10px; color: var(--sw-text-sec); display: flex; flex-direction: column; gap: 2px; }
        .gutter-inputs input, .gutter-inputs select { font-size: 11px; padding: 4px 6px; border: 1px solid var(--sw-border); border-radius: 4px; }
        .gutter-inputs small { font-size: 8px; color: #aaa; }
        .gutter-results { margin-top: 10px; }
        .gutter-results h5 { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin: 10px 0 6px; }
        .gutter-result-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; }
        .gutter-result-item { background: white; border-radius: 6px; padding: 6px 8px; text-align: center; }
        .gutter-result-item .r-label { font-size: 8px; color: var(--sw-text-sec); text-transform: uppercase; }
        .gutter-result-item .r-value { font-size: 14px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .gutter-status { margin: 8px 0; }
        .gutter-badge { display: inline-block; padding: 3px 10px; border-radius: 4px; font-size: 11px; font-weight: 700; }
        .gutter-badge.ok { background: #e8f5e9; color: #2e7d32; }
        .gutter-badge.warn { background: #fff3e0; color: #ef6c00; }
        .gutter-badge.fail { background: #ffebee; color: #c62828; }
        .gutter-issues { font-size: 10px; color: #c62828; margin-top: 4px; }

        .gutter-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .gutter-modal { background: white; border-radius: 12px; max-width: 1000px; width: 95%; max-height: 90vh; box-shadow: 0 20px 60px rgba(0,0,0,0.3); display: flex; flex-direction: column; overflow: hidden; }
        .gutter-modal-header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--sw-border); }
        .gutter-modal-header h3 { font-size: 16px; font-weight: 600; margin: 0; }
        .gutter-modal-header .close-btn { width: 28px; height: 28px; border: none; background: none; font-size: 18px; cursor: pointer; border-radius: 6px; color: var(--sw-text-sec); }
        .gutter-modal-header .close-btn:hover { background: #f0f0f0; }
        .gutter-modal-body { display: grid; grid-template-columns: 1fr 1fr; gap: 0; flex: 1; overflow: hidden; min-height: 0; }
        .gutter-modal-left { padding: 16px 20px; overflow-y: auto; border-right: 1px solid var(--sw-border); }
        .gutter-modal-right { position: relative; background: #f8f9fa; min-height: 400px; }
        .gutter-modal-right canvas { width: 100%; height: 100%; }
        .gutter-modal-footer { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; border-top: 1px solid var(--sw-border); }
        .gutter-modal-footer .btn-save { padding: 8px 20px; border-radius: 6px; border: none; background: var(--sw-orange); color: white; font-size: 13px; font-weight: 500; cursor: pointer; }
        .gutter-modal-footer .btn-save:hover { background: #e05a1a; }
        .gutter-modal-footer .btn-remove { padding: 8px 16px; border-radius: 6px; border: 1px solid var(--sw-border); background: none; font-size: 12px; color: var(--sw-text-sec); cursor: pointer; }
        .gutter-modal-footer .btn-remove:hover { border-color: #c62828; color: #c62828; }
        .truss-box-gutter-btn { padding: 4px 12px; border: 1px solid var(--sw-border); border-radius: 4px; background: white; font-size: 10px; cursor: pointer; font-weight: 600; }
        .truss-box-gutter-btn.active { background: var(--sw-orange); color: white; border-color: var(--sw-orange); }

        .asm-viewport { height: 520px; background: linear-gradient(180deg, #D4D9E0 0%, #BCC4CC 100%); border-radius: 10px; position: relative; }
        .asm-viewport canvas { display: block; width: 100%; height: 100%; cursor: grab; }
        .asm-viewport canvas:active { cursor: grabbing; }
        .asm-viewport.fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100vw; height: 100vh; z-index: 1000; border-radius: 0; }
        .asm-viewport.fullscreen-mode { width: 100vw !important; height: 100vh !important; border-radius: 0; background: #1a1a1a; }
        .asm-viewport.fullscreen-mode:fullscreen { width: 100vw; height: 100vh; }
        .layer-panel { position: absolute; top: 12px; left: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; min-width: 140px; }
        .layer-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .layer-item { display: flex; align-items: center; gap: 6px; padding: 4px 0; cursor: pointer; font-size: 11px; }
        .layer-check { width: 14px; height: 14px; border: 2px solid var(--sw-border); border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 9px; color: white; }
        .layer-item.active .layer-check { background: var(--sw-orange); border-color: var(--sw-orange); }
        .layer-item.active .layer-check::after { content: 'âœ“'; }
        .mat-panel { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; width: 200px; }
        .mat-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .mat-row { display: flex; justify-content: space-between; font-size: 10px; padding: 3px 0; border-bottom: 1px solid var(--sw-border); }
        .mat-row:last-child { border-bottom: none; }
        .mat-qty { font-weight: 600; color: var(--sw-orange); }
        .view-panel { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.95); padding: 3px; border-radius: 6px; }
        .view-btn { padding: 5px 12px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .view-btn.active { background: var(--sw-blue-dark); color: white; }
        .zoom-panel { position: absolute; bottom: 12px; right: 12px; display: flex; gap: 2px; background: rgba(255,255,255,0.95); padding: 3px; border-radius: 6px; }
        .zoom-btn { width: 32px; height: 32px; border: none; background: transparent; border-radius: 4px; font-size: 16px; font-weight: 700; cursor: pointer; color: var(--sw-text-sec); display: flex; align-items: center; justify-content: center; line-height: 1; }
        .zoom-btn:hover { background: var(--sw-blue-dark); color: white; }
        .fullscreen-btn { position: absolute; top: 12px; right: 230px; background: rgba(255,255,255,0.95); border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; font-size: 11px; }
        .fullscreen-btn:hover { background:#e0e0e0; }
        /* Toolbar strip at top of viewport */
        .asm-toolbar { position:absolute; top:12px; right:12px; display:flex; gap:6px; align-items:center; z-index:40; }
        .asm-tool-btn { padding:5px 10px; border:1px solid rgba(0,0,0,0.15); background:rgba(255,255,255,0.95); border-radius:5px; cursor:pointer; font-size:11px; color:var(--sw-text-sec); transition:all 0.15s; white-space:nowrap; }
        .asm-tool-btn:hover { background:#e0e0e0; border-color:rgba(0,0,0,0.25); }
        .asm-tool-btn.active { background:var(--sw-blue-dark); color:white; border-color:var(--sw-blue-dark); }
        .asm-tool-btn.primary { background:var(--sw-orange); color:white; border-color:var(--sw-orange); }
        .asm-tool-btn.primary:hover { background:#d14d12; }
        .asm-tool-sep { width:1px; height:20px; background:rgba(0,0,0,0.12); }
        #asmSectionSelect { padding:4px 8px; border:1px solid rgba(0,0,0,0.15); border-radius:5px; font-size:11px; background:rgba(255,255,255,0.95); cursor:pointer; }
        /* Dimension label overlay (CSS2DRenderer-style, but using sprites for export) */
        .dim-label-overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; overflow:hidden; }
        .tooltip { position: absolute; background: rgba(41,60,70,0.95); color: white; padding: 10px 14px; border-radius: 8px; font-size: 11px; pointer-events: none; opacity: 0; transition: opacity 0.15s; z-index: 50; max-width: 240px; }
        .tooltip.visible { opacity: 1; }
        .tooltip-title { font-weight: 600; font-size: 12px; color: var(--sw-orange); margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .tooltip-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .tooltip-label { opacity: 0.7; }
        .tooltip-value { font-weight: 500; font-family: 'SF Mono', monospace; }

        /* Polycarb preview blocks */
        .pc-block { width: 16px; height: 20px; border-radius: 2px; border: 1px solid #ccc; }
        .pc-block.steel { background: #6B7B8D; border-color: #5A6A7C; }
        .pc-block.polycarb { border-color: #8ECAE6; }

        /* Pricing Section - Card Layout */
        .pricing-cards-container { display: flex; flex-direction: column; gap: 24px; }
        .q-card { background: #fff; border-radius: 8px; padding: 20px 24px; box-shadow: 0 1px 4px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04); }
        .q-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .q-card-title { font-size: 15px; font-weight: 600; color: var(--sw-text); display: flex; align-items: center; gap: 8px; }
        .q-card-title .status-ok { color: #34C759; }
        .q-card-title .status-warn { color: #FF9500; }
        .q-card-amount { font-size: 22px; font-weight: 700; font-family: 'SF Mono', monospace; color: var(--sw-text); }
        .q-card-sub { font-size: 13px; color: var(--sw-text-sec); margin-bottom: 0; }
        .q-card-edit { font-size: 13px; color: var(--sw-orange); cursor: pointer; font-weight: 500; background: none; border: none; padding: 0; }
        .q-card-edit:hover { text-decoration: underline; }
        /* Labour inline */
        .labour-inline { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
        .labour-inline .li-input { width: 60px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: center; }
        .labour-inline .li-input:focus { outline: none; border-color: var(--sw-orange); }
        .labour-inline .li-input.wide { width: 80px; }
        .labour-inline .li-label { font-size: 13px; color: var(--sw-text-sec); }
        .labour-inline .li-equals { font-size: 14px; font-weight: 600; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .labour-sell-row { display: flex; align-items: center; gap: 10px; margin-top: 10px; padding-top: 10px; border-top: 1px solid #f0f0f0; }
        .labour-sell-row label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .labour-sell-row input { width: 120px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: right; }
        .labour-sell-row input:focus { outline: none; border-color: var(--sw-orange); }
        /* Extras pills & rows */
        .extras-pills { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
        .extras-pill { padding: 7px 14px; border-radius: 20px; border: 1px solid var(--sw-border); background: #fff; font-size: 13px; cursor: pointer; color: var(--sw-text); transition: all 0.15s; }
        .extras-pill:hover { border-color: var(--sw-orange); color: var(--sw-orange); background: #FFF5F0; }
        .extras-rows { margin-top: 16px; display: flex; flex-direction: column; gap: 8px; }
        .extras-row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #f9f9f9; border-radius: 6px; border: 1px solid #f0f0f0; }
        .extras-row .ex-desc { flex: 1; font-size: 13px; font-weight: 500; color: var(--sw-text); }
        .extras-row .ex-field { display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--sw-text-sec); }
        .extras-row .ex-input { width: 80px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: right; }
        .extras-row .ex-input:focus { outline: none; border-color: var(--sw-orange); }
        .extras-row .ex-input.desc-input { width: 160px; text-align: left; font-family: inherit; }
        .extras-row .ex-remove { background: none; border: none; color: #ccc; cursor: pointer; font-size: 18px; padding: 0 4px; line-height: 1; transition: color 0.15s; }
        .extras-row .ex-remove:hover { color: #FF3B30; }
        /* Pricing sub-sections */
        .pricing-subsection { background: #fff; border-radius: 8px; margin-bottom: 12px; box-shadow: 0 1px 4px rgba(0,0,0,0.06); overflow: hidden; }
        .pricing-sub-hdr { padding: 10px 16px; font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; border-left: 4px solid transparent; background: var(--sw-bg); display: flex; justify-content: space-between; align-items: center; }
        .pricing-sub-body { padding: 12px 16px; }
        .pricing-subtotal { display: flex; align-items: center; gap: 8px; padding: 10px 0 2px; border-top: 2px solid var(--sw-border); margin-top: 8px; font-size: 13px; font-weight: 600; }
        .pricing-subtotal span:nth-child(2) { font-family: 'SF Mono', monospace; }
        /* Patio materials table */
        .pm-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .pm-table th { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 4px 6px; border-bottom: 1px solid var(--sw-border); text-align: left; white-space: nowrap; }
        .pm-table th.r { text-align: right; }
        .pm-table td { padding: 5px 6px; border-bottom: 1px solid #f0f0f0; vertical-align: middle; }
        .pm-table td.r { text-align: right; font-family: 'SF Mono', monospace; font-size: 10px; }
        .pm-table td.cost-cell { color: var(--sw-text-sec); }
        .pm-table td .pm-sell-input { width: 70px; padding: 2px 4px; border: none; border-bottom: 1px dashed var(--sw-border); font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; background: transparent; }
        .pm-table td .pm-sell-input:focus { outline: none; border-bottom-color: var(--sw-orange); background: #FFF5F0; }
        .pm-table .pm-cat-hdr td { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding-top: 10px; border-bottom: 1px solid var(--sw-border); background: var(--sw-bg); }
        .pm-table .markup-badge { display: inline-block; font-size: 9px; padding: 1px 5px; border-radius: 8px; background: #f0f0f0; color: var(--sw-text-sec); font-weight: 600; }
        .pm-table .markup-badge.high { background: #E8F5E9; color: #2E7D32; }
        .pm-table .markup-badge.low { background: #FFF3E0; color: #E65100; }
        .pm-table .pm-dupe-btn { background: none; border: 1px solid transparent; color: #ccc; cursor: pointer; font-size: 14px; padding: 0 2px; line-height: 1; transition: all 0.15s; border-radius: 3px; }
        .pm-table tr:hover .pm-dupe-btn { color: var(--sw-orange); border-color: var(--sw-border); }
        .pm-table .pm-dupe-btn:hover { color: #fff; background: var(--sw-orange); border-color: var(--sw-orange); }
        /* Additional materials table */
        .am-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .am-table th { font-size: 10px; font-weight: 600; text-transform: uppercase; color: var(--sw-text-sec); padding: 4px 6px; border-bottom: 1px solid var(--sw-border); text-align: left; }
        .am-table th.r { text-align: right; }
        .am-table td { padding: 4px 6px; border-bottom: 1px solid #f0f0f0; }
        .am-table input[type="text"] { width: 100%; padding: 3px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 11px; }
        .am-table input[type="number"] { width: 65px; padding: 3px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; }
        .am-table .am-del { background: none; border: none; color: transparent; cursor: pointer; font-size: 14px; padding: 0 4px; transition: color 0.15s; }
        .am-table tr:hover .am-del { color: #ccc; }
        .am-table .am-del:hover { color: #FF3B30; }
        .am-quick-add { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; margin-top: 10px; padding-top: 8px; border-top: 1px dashed #e8e8e8; }
        .am-table .am-empty-row td { opacity: 0.5; }
        .am-table .am-empty-row:focus-within td { opacity: 1; }
        .am-table input:focus { outline: none; border-color: var(--sw-orange) !important; }
        /* Hidden compat elements */
        .hidden-compat { display: none; }
        /* Total card */
        .total-card { background: #fff; border-radius: 8px 8px 0 0; padding: 16px 20px; box-shadow: 0 -2px 8px rgba(0,0,0,0.08); text-align: center; position: sticky; bottom: 0; z-index: 10; border-top: 2px solid var(--sw-border); }
        .total-breakdown { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; margin-top: 6px; font-size: 11px; color: var(--sw-text-sec); font-family: 'SF Mono', monospace; }
        .total-breakdown span { white-space: nowrap; }
        .total-breakdown .bd-label { color: #999; }
        .total-breakdown .bd-val { font-weight: 600; color: var(--sw-text); }
        .total-amount { font-size: 32px; font-weight: 800; font-family: 'SF Mono', monospace; color: var(--sw-text); letter-spacing: -0.5px; }
        .total-label { font-size: 13px; color: var(--sw-text-sec); margin-top: 2px; }
        .total-margin { font-size: 14px; font-weight: 600; margin-top: 10px; font-family: 'SF Mono', monospace; }
        .total-margin.margin-green { color: #34C759; }
        .total-margin.margin-orange { color: #FF9500; }
        .total-margin.margin-red { color: #FF3B30; }
        /* Notes fields */
        .notes-field { margin-bottom: 10px; }
        .notes-field:last-child { margin-bottom: 0; }
        .notes-label { display: block; font-size: 11px; font-weight: 600; margin-bottom: 4px; color: var(--sw-text); }
        .notes-field textarea { width: 100%; font-size: 11px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 6px; resize: vertical; font-family: inherit; }
        .notes-field textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Totals table */
        .totals-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .totals-table th { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 4px 8px; border-bottom: 1px solid var(--sw-border); text-align: left; }
        .totals-table th.r { text-align: right; }
        .totals-table td { padding: 6px 8px; border-bottom: 1px solid #f0f0f0; }
        .totals-table td.r { text-align: right; }
        .totals-table td.mono { font-family: 'SF Mono', monospace; font-size: 11px; }
        .totals-table .tt-subtotal td { border-top: 2px solid var(--sw-border); font-weight: 600; padding-top: 8px; }
        .totals-table .tt-gst td { color: var(--sw-text-sec); font-size: 11px; }
        .totals-table .tt-total td { font-weight: 800; font-size: 14px; background: var(--sw-bg); border-top: 2px solid var(--sw-text); }
        .totals-table .tt-margin td { font-weight: 600; font-family: 'SF Mono', monospace; font-size: 11px; border-bottom: none; }
        /* Client mode: hide costs, margins, markups */
        body.client-mode .scoper-only { display: none !important; }
        body.client-mode .tt-margin { display: none !important; }
        body.client-mode .total-margin { display: none !important; }
        body.client-mode #clientModeBtn { background: var(--sw-orange); color: white; border-color: var(--sw-orange); }
        .btn-generate-quote { display: block; width: 100%; padding: 14px; border: none; border-radius: 8px; background: #F26522; color: white; font-size: 15px; font-weight: 600; cursor: pointer; margin-top: 20px; letter-spacing: 0.3px; transition: background 0.15s; }
        .btn-generate-quote:hover { background: #e05a1a; }
        .total-links { display: flex; justify-content: center; gap: 24px; margin-top: 14px; }
        .total-links a { font-size: 13px; color: var(--sw-text-sec); cursor: pointer; text-decoration: none; }
        .total-links a:hover { color: var(--sw-orange); }
        /* Settings gear */
        .settings-gear { background: none; border: none; cursor: pointer; font-size: 16px; color: var(--sw-text-sec); padding: 4px; transition: color 0.15s; }
        .settings-gear:hover { color: var(--sw-orange); }
        /* Materials modal */
        .mat-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .mat-modal { background: white; border-radius: 12px; padding: 24px; max-width: 800px; width: 95%; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .mat-modal h3 { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
        .mat-modal-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; }
        .mat-modal-controls label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .mat-modal-controls input { width: 60px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: center; }
        .mat-modal-controls input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-controls .btn-apply { padding: 6px 14px; border-radius: 6px; border: 1px solid var(--sw-orange); background: #FFF5F0; color: var(--sw-orange); font-size: 12px; font-weight: 500; cursor: pointer; }
        .mat-modal-controls .btn-apply:hover { background: var(--sw-orange); color: white; }
        .mat-modal-controls .toggle-wrap { display: flex; align-items: center; gap: 6px; margin-left: auto; }
        .mat-modal-controls .toggle-wrap input[type="checkbox"] { accent-color: var(--sw-orange); }
        .mat-modal-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .mat-modal-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 8px 8px; border-bottom: 2px solid var(--sw-border); }
        .mat-modal-table th.r { text-align: right; }
        .mat-modal-table td { padding: 6px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; vertical-align: middle; }
        .mat-modal-table td.r { text-align: right; }
        .mat-modal-table td.mono { font-family: 'SF Mono', monospace; font-size: 12px; }
        .mat-modal-table tr:last-child td { border-bottom: none; }
        .mat-modal-table input { width: 80px; padding: 5px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .mat-modal-table input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-table .markup-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 500; background: #E8F5E9; color: #2E7D32; }
        .mat-modal-table .markup-badge.custom { background: #FFF3E0; color: #E65100; }
        .mat-modal-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--sw-border); }
        .mat-modal-footer .mat-total { font-size: 16px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .mat-modal-footer .btn-done { padding: 10px 28px; border-radius: 6px; border: none; background: var(--sw-orange); color: white; font-size: 14px; font-weight: 500; cursor: pointer; }
        .mat-modal-footer .btn-done:hover { background: #e05a1a; }
        .mat-modal-footer .btn-add-custom { padding: 8px 16px; border-radius: 6px; border: 1px dashed var(--sw-border); background: none; font-size: 12px; color: var(--sw-text-sec); cursor: pointer; }
        .mat-modal-footer .btn-add-custom:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        /* Rates modal */
        .rates-modal { background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .rates-modal h3 { font-size: 16px; font-weight: 600; margin-bottom: 16px; }
        .rate-input { width: 80px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .rate-input:focus { outline: none; border-color: var(--sw-orange); }
        .pricing-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .pricing-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 6px 8px; border-bottom: 2px solid var(--sw-border); }
        .pricing-table td { padding: 5px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; }
        .pricing-table th.r, .pricing-table td.r { text-align: right; }
        .pricing-table tr:last-child td { border-bottom: none; }
        /* Hidden elements for PDF compatibility */
        .pdf-data { display: none; }
        /* Collapsible sections */
        .collapse-header {
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background 0.15s ease;
        }
        .collapse-header:hover { background: #fafafa; }
        .collapse-header .section-title { font-size: 13px; font-weight: 600; }
        .collapse-arrow {
            font-size: 12px;
            color: #999;
            transition: transform 0.2s ease;
            flex-shrink: 0;
            margin-left: 12px;
        }
        .collapse-header:not(.collapsed) .collapse-arrow { transform: rotate(90deg); }
        .collapse-header.collapsed { border-bottom: none; }
        .collapse-body { overflow: hidden; transition: max-height 0.3s ease, opacity 0.2s ease; max-height: 2000px; opacity: 1; }
        .collapse-body.shut { max-height: 0; opacity: 0; }
        /* Warning dot indicator on section header */
        .section-warn-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: #FF9500; display: none; flex-shrink: 0; margin-left: 8px;
        }
        .section-warn-dot.active { display: inline-block; }

        /* Section Groups */
        .section-group {
            margin-bottom: 12px;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            overflow: hidden;
            background: #fff;
        }
        .section-group .section {
            margin-bottom: 0;
            border-radius: 0;
            border: none;
            border-bottom: 1px solid #f0f0f0;
        }
        .section-group .section:last-child { border-bottom: none; }
        .section-group-header {
            padding: 10px 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #F97316;
            border-left: 4px solid #F97316;
            background: rgba(249,115,22,0.04);
            border-bottom: 1px solid #f0f0f0;
        }
        #group-build > .section-group-header {
            color: #3B82F6;
            border-left-color: #3B82F6;
            background: rgba(59,130,246,0.04);
        }
        #group-sale > .section-group-header {
            color: #22C55E;
            border-left-color: #22C55E;
            background: rgba(34,197,94,0.04);
        }
        /* Sticky Price Card (right panel) */
        .rp-price-card {
            background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            overflow: hidden; margin-bottom: 16px;
            border-left: 4px solid #28A745;
        }
        .rp-price-card .rp-price-body { padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; gap: 12px; }
        .rp-price-total { font-size: 20px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .rp-price-sqm { font-size: 11px; color: var(--sw-text-sec); }
        .rp-price-link { font-size: 11px; color: #2980B9; cursor: pointer; text-decoration: underline; }
        .rp-price-margin { font-size: 11px; font-weight: 600; font-family: 'SF Mono', monospace; margin-top: 2px; }
        .rp-breakdown { padding: 0 16px 6px; border-top: 1px solid #f0f0f0; }
        .rp-bd-row { display: flex; justify-content: space-between; font-size: 11px; color: var(--sw-text-sec); padding: 2px 0; }
        .rp-bd-row span:last-child { font-family: 'SF Mono', monospace; font-size: 10px; }
        .rp-bd-total { font-weight: 600; color: var(--sw-text); border-top: 1px solid var(--sw-border); padding-top: 4px; margin-top: 2px; }
        /* Import/Export modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .modal-box { background: white; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .modal-box h3 { font-size: 16px; margin-bottom: 12px; }
        .modal-box textarea { width: 100%; height: 200px; font-family: 'SF Mono', monospace; font-size: 11px; border: 1px solid var(--sw-border); border-radius: 6px; padding: 10px; resize: vertical; }
        .modal-box textarea:focus { outline: none; border-color: var(--sw-orange); }
        .modal-btns { display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end; }
        .modal-status { font-size: 12px; color: #34C759; margin-top: 8px; min-height: 18px; }
        .job-details-grid { display: grid; grid-template-columns: 140px 1fr 1fr 150px 150px 140px; gap: 10px; align-items: end; }
        .job-details-grid label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .job-details-grid input, .job-details-grid select { width: 100%; font-size: 12px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-family: inherit; }
        .job-details-grid input:focus, .job-details-grid select:focus { outline: none; border-color: var(--sw-orange); }
        .job-ref-input { font-family: 'SF Mono', monospace !important; font-weight: 600; color: var(--sw-orange); }
        /* Notes card */
        .notes-inline { margin-top: 12px; }
        .notes-inline textarea { width: 100%; padding: 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; min-height: 60px; }
        .notes-inline textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Customer details section */
        .customer-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
        .customer-grid label { font-size: 12px; font-weight: 500; margin-bottom: 4px; display: block; }
        .customer-grid input { width: 100%; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; }
        .customer-grid input:focus { outline: none; border-color: var(--sw-orange); }
        /* Site details subsection */
        .site-details { background: var(--sw-bg); border-radius: 10px; padding: 16px 20px; margin-top: 16px; }
        .site-details-label { font-size: 13px; font-weight: 600; margin-bottom: 4px; }
        .site-details-hint { font-size: 11px; color: var(--sw-text-sec); margin-bottom: 14px; }
        .site-details-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 14px; }
        .radio-group-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .radio-options { display: flex; flex-wrap: wrap; gap: 4px; }
        .radio-pill input[type="radio"] { display: none; }
        .radio-pill span { display: inline-block; padding: 4px 10px; font-size: 12px; border: 1px solid var(--sw-border); border-radius: 16px; cursor: pointer; background: var(--sw-white); transition: all 0.15s; }
        .radio-pill input[type="radio"]:checked + span { background: var(--sw-orange); color: white; border-color: var(--sw-orange); }
        .site-notes-wrap { grid-column: 1 / -1; }
        .site-notes-wrap textarea { width: 100%; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; }
        .site-notes-wrap textarea:focus { outline: none; border-color: var(--sw-orange); }
        /* Estimate Options section */
        .estimate-cards { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .est-card { border-radius: 10px; padding: 20px; display: flex; flex-direction: column; }
        .est-card--quick { background: var(--sw-bg); }
        .est-card--full { background: var(--sw-white); border: 1px solid var(--sw-border); }
        .est-card-icon { font-size: 20px; margin-bottom: 4px; }
        .est-card-title { font-size: 15px; font-weight: 700; margin-bottom: 2px; }
        .est-card-desc { font-size: 12px; color: var(--sw-text-sec); line-height: 1.4; }
        .est-card-divider { border: none; border-top: 1px solid var(--sw-border); margin: 14px 0; }
        .est-card-stat { font-size: 13px; color: var(--sw-text-sec); margin-bottom: 2px; }
        .est-card-range { font-size: 22px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .est-card-gst { font-size: 11px; color: var(--sw-text-sec); }
        .est-card-btn { margin-top: auto; padding-top: 16px; }
        .est-card-btn .btn { width: 100%; text-align: center; }
        .est-hint { font-size: 12px; color: var(--sw-text-sec); margin-top: 16px; }
        /* Detailed Configuration groups */
        .cfg-group { border: 1px solid var(--sw-border); border-radius: 8px; margin-bottom: 8px; overflow: hidden; }
        .cfg-group:last-child { margin-bottom: 0; }
        .cfg-group-hdr { display: flex; align-items: center; gap: 8px; padding: 10px 14px; cursor: pointer; user-select: none; background: var(--sw-bg); font-size: 13px; font-weight: 600; }
        .cfg-group-hdr:hover { background: #ECECEE; }
        .cfg-group-arrow { font-size: 10px; color: var(--sw-text-sec); transition: transform 0.2s; }
        .cfg-group-arrow.open { transform: rotate(90deg); }
        .cfg-group-num { color: var(--sw-text-sec); font-size: 11px; font-weight: 500; }
        .cfg-group-body { display: none; }
        .cfg-group-body.open { display: block; }
        .cfg-group-body .mat-hdr { display: grid; grid-template-columns: 1fr 50px 130px 60px 120px; gap: 4px; padding: 5px 14px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); border-bottom: 1px solid var(--sw-border); }
        .cfg-group-body .mat-row { display: grid; grid-template-columns: 1fr 50px 130px 60px 120px; gap: 4px; font-size: 12px; padding: 6px 14px; border-bottom: 1px solid #f0f0f0; align-items: baseline; }
        .cfg-group-body .mat-row:last-child { border-bottom: none; }
        .cfg-group-body .mat-qty { font-weight: 600; color: var(--sw-orange); font-family: 'SF Mono', monospace; font-size: 11px; text-align: right; }
        .cfg-group-body .mat-size { font-size: 11px; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .cfg-group-body .mat-len { font-size: 11px; font-family: 'SF Mono', monospace; text-align: right; }
        .cfg-group-body .mat-clr { font-size: 11px; color: var(--sw-text-sec); }
        .cfg-group-empty { padding: 10px 14px; font-size: 12px; color: var(--sw-text-sec); font-style: italic; }
        /* Pre-order checks */
        .preorder-box { display: none; }
        .preorder-title { display: none; }
        .preorder-item { display: none; }
        .preorder-ok { color: #2e7d32; }
        .preorder-warn { color: #e65100; }

        /* ==================== FLASHING EDITOR ==================== */
        /* Fullscreen modal */
        .flash-modal-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:9999; }
        .flash-modal-overlay.open { display:flex; }
        .flash-modal { display:flex; flex-direction:column; width:100%; height:100%; background:#fff; }
        .flash-modal-header { display:flex; align-items:center; justify-content:space-between; padding:10px 16px; border-bottom:2px solid var(--sw-border); background:var(--sw-bg); flex-shrink:0; }
        .flash-modal-header h2 { margin:0; font-size:15px; font-weight:700; letter-spacing:0.5px; color:var(--sw-text); }
        .flash-modal-close { background:none; border:none; font-size:22px; cursor:pointer; color:var(--sw-text-sec); padding:4px 8px; border-radius:4px; line-height:1; }
        .flash-modal-close:hover { background:#eee; color:#333; }
        .flash-modal-body { display:flex; flex:1; overflow:hidden; }
        /* Left sidebar - templates */
        .flash-sidebar { width:260px; min-width:220px; border-right:1px solid var(--sw-border); display:flex; flex-direction:column; overflow:hidden; flex-shrink:0; background:#FAFBFC; }
        .flash-sidebar-title { padding:10px 12px 6px; font-size:11px; font-weight:700; text-transform:uppercase; letter-spacing:0.4px; color:var(--sw-text-sec); flex-shrink:0; }
        .flash-sidebar-scroll { flex:1; overflow-y:auto; padding:0 8px 8px; }
        /* Right - canvas area */
        .flash-canvas-area { flex:1; display:flex; flex-direction:column; overflow:hidden; }
        .flash-viewport { background:#fff; position:relative; overflow:hidden; flex:1; }
        .flash-viewport canvas { display:block; width:100%; height:100%; cursor:default; touch-action:none; }
        .flash-viewport canvas.mode-drawing { cursor:crosshair; }
        .flash-toolbar { display:flex; gap:4px; padding:8px 12px; border-top:1px solid var(--sw-border); flex-wrap:wrap; align-items:center; flex-shrink:0; }
        .flash-tool-btn { padding:5px 10px; border:1px solid var(--sw-border); background:var(--sw-white); border-radius:4px; font-size:11px; cursor:pointer; color:var(--sw-text-sec); transition:all 0.15s; }
        .flash-tool-btn:hover { border-color:var(--sw-orange); color:var(--sw-orange); }
        .flash-tool-btn.active { background:var(--sw-blue-dark); color:white; border-color:var(--sw-blue-dark); }
        .flash-tool-sep { width:1px; height:20px; background:var(--sw-border); margin:0 4px; }
        .flash-info { display:flex; gap:16px; padding:4px 12px; border-top:1px solid var(--sw-border); font-size:10px; color:var(--sw-text-sec); align-items:center; flex-shrink:0; background:#FAFBFC; }
        .flash-info-val { font-weight:600; color:var(--sw-text); font-family:'SF Mono',monospace; }
        .flash-zoom-ctrl { display:flex; align-items:center; gap:4px; }
        .flash-zoom-btn { width:22px; height:22px; border:1px solid var(--sw-border); border-radius:4px; background:#fff; cursor:pointer; font-size:14px; line-height:1; display:flex; align-items:center; justify-content:center; color:var(--sw-text); padding:0; }
        .flash-zoom-btn:hover { background:var(--sw-blue-dark); color:#fff; border-color:var(--sw-blue-dark); }
        .flash-status-bar { display:flex; gap:8px; padding:6px 12px; border-top:1px solid var(--sw-border); font-size:11px; color:var(--sw-text-sec); align-items:center; flex-shrink:0; background:#f0f2f5; }
        .flash-status-mode { font-weight:700; font-size:10px; text-transform:uppercase; letter-spacing:0.5px; padding:2px 8px; border-radius:3px; background:#293C46; color:#fff; }
        .flash-status-mode.extending { background:#2563eb; }
        .flash-status-mode.selected { background:#F15A29; }
        .flash-status-sep { width:1px; height:14px; background:var(--sw-border); }
        .flash-status-btn { padding:3px 12px; border:1px solid var(--sw-border); border-radius:4px; background:#fff; font-size:11px; cursor:pointer; color:var(--sw-text-sec); }
        .flash-status-btn:hover { border-color:#e74c3c; color:#e74c3c; }
        .flash-zoom-panel { position:absolute; bottom:12px; right:12px; display:flex; flex-direction:column; gap:4px; z-index:15; }
        .flash-zpanel-btn { width:32px; height:32px; border:1px solid var(--sw-border); border-radius:6px; background:rgba(255,255,255,0.92); cursor:pointer; font-size:18px; line-height:1; display:flex; align-items:center; justify-content:center; color:var(--sw-text); padding:0; box-shadow:0 1px 4px rgba(0,0,0,0.12); backdrop-filter:blur(4px); }
        .flash-zpanel-btn:hover { background:var(--sw-blue-dark); color:#fff; border-color:var(--sw-blue-dark); }
        .flash-inspector { position:absolute; top:12px; right:12px; width:200px; background:#fff; border:1px solid var(--sw-border); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:20; font-size:11px; }
        .flash-inspector-header { display:flex; justify-content:space-between; align-items:center; padding:8px 10px; border-bottom:1px solid var(--sw-border); font-weight:700; font-size:12px; color:var(--sw-text); }
        .flash-inspector-close { border:none; background:none; font-size:16px; cursor:pointer; color:var(--sw-text-sec); padding:0 2px; line-height:1; }
        .flash-inspector-close:hover { color:#e74c3c; }
        .flash-inspector-body { padding:10px; }
        .flash-insp-row { display:flex; align-items:center; gap:6px; margin-bottom:8px; }
        .flash-insp-row label { font-size:10px; color:var(--sw-text-sec); min-width:24px; font-weight:600; }
        .flash-insp-row input { flex:1; padding:3px 6px; border:1px solid var(--sw-border); border-radius:4px; font-size:11px; font-family:'SF Mono',monospace; }
        .flash-insp-row input:focus { outline:none; border-color:var(--sw-orange); }
        .flash-insp-unit { font-size:10px; color:var(--sw-text-sec); }
        .flash-insp-info { font-size:10px; color:var(--sw-text-sec); margin-bottom:8px; padding:4px 0; border-top:1px solid var(--sw-border); }
        .flash-insp-btn { width:100%; padding:5px; border:1px solid var(--sw-border); border-radius:4px; background:#fff; font-size:10px; cursor:pointer; color:var(--sw-text-sec); margin-top:4px; }
        .flash-insp-btn:hover { border-color:#e74c3c; color:#e74c3c; }
        .flash-insp-btn.danger:hover { background:#FDEDEC; }
        .flash-modal-tabs { display:flex; gap:2px; }
        .flash-tab { padding:6px 16px; border:none; background:transparent; font-size:12px; font-weight:600; cursor:pointer; color:var(--sw-text-sec); border-bottom:2px solid transparent; }
        .flash-tab.active { color:var(--sw-orange); border-bottom-color:var(--sw-orange); }
        .flash-tab:hover { color:var(--sw-text); }
        /* Add to job bar */
        .flash-add-bar { display:grid; grid-template-columns:1fr 120px 80px 80px 60px auto; gap:8px; padding:10px 14px; border-top:2px solid var(--sw-border); align-items:end; flex-shrink:0; background:var(--sw-bg); }
        .flash-add-bar label { font-size:10px; font-weight:600; text-transform:uppercase; letter-spacing:0.3px; color:var(--sw-text-sec); margin-bottom:2px; display:block; }
        .flash-add-bar input, .flash-add-bar select { width:100%; font-size:12px; padding:5px 8px; border:1px solid var(--sw-border); border-radius:4px; font-family:inherit; }
        .flash-add-bar input:focus, .flash-add-bar select:focus { outline:none; border-color:var(--sw-orange); }
        /* Template items and folders */
        .flash-tpl { min-width:70px; padding:6px; border:1px solid var(--sw-border); border-radius:6px; cursor:pointer; text-align:center; transition:all 0.15s; flex-shrink:0; }
        .flash-tpl:hover { border-color:var(--sw-orange); }
        .flash-tpl.active { border-color:var(--sw-orange); background:#FFF5F0; }
        .flash-tpl canvas { display:block; margin:0 auto 4px; width:56px; height:34px; }
        .flash-tpl-name { font-size:9px; color:var(--sw-text-sec); white-space:nowrap; }
        .template-folder { margin-bottom:4px; border:1px solid var(--sw-border); border-radius:6px; overflow:hidden; }
        .folder-header { display:flex; align-items:center; gap:6px; padding:6px 10px; cursor:pointer; user-select:none; font-size:11px; font-weight:600; color:var(--sw-text); background:var(--sw-bg); transition:background 0.15s; }
        .folder-header:hover { background:#E8EAED; }
        .folder-icon { font-size:13px; }
        .folder-contents { display:flex; flex-wrap:wrap; gap:6px; padding:8px 10px; }
        .folder-contents.collapsed { display:none; }
        /* Colour side & treatment controls */
        .flash-colour-side { display:flex; gap:4px; align-items:center; }
        .flash-cs-btn { padding:3px 8px; border:1px solid var(--sw-border); background:var(--sw-white); border-radius:3px; font-size:10px; cursor:pointer; }
        .flash-cs-btn.active { background:var(--sw-orange); color:white; border-color:var(--sw-orange); }
        /* Job flashings table (inline section) */
        .flash-table { width:100%; border-collapse:collapse; font-size:12px; }
        .flash-table th { text-align:left; font-size:10px; font-weight:600; text-transform:uppercase; letter-spacing:0.3px; color:var(--sw-text-sec); padding:6px 10px; border-bottom:2px solid var(--sw-border); }
        .flash-table th.r { text-align:right; }
        .flash-table td { padding:6px 10px; border-bottom:1px solid #f0f0f0; vertical-align:middle; }
        .flash-table td.r { text-align:right; }
        .flash-table td.mono { font-family:'SF Mono',monospace; font-size:11px; }
        .flash-table tr:last-child td { border-bottom:none; }
        .flash-table tr:hover { background:#FAFAFA; }
        .flash-table tr.selected { background:#FFF5F0; }
        .flash-table .flash-row-actions { display:flex; gap:4px; }
        .flash-table .flash-row-btn { background:none; border:none; cursor:pointer; font-size:14px; color:#ccc; padding:0 4px; transition:color 0.15s; }
        .flash-table .flash-row-btn:hover { color:var(--sw-orange); }
        .flash-table .flash-row-btn.del:hover { color:#FF3B30; }
        .flash-total-row { display:flex; justify-content:flex-end; padding:8px 12px; font-size:12px; font-weight:600; color:var(--sw-text); border-top:1px solid var(--sw-border); }
        .flash-total-row span { font-family:'SF Mono',monospace; margin-left:8px; color:var(--sw-orange); }
        .flash-header-row { display:flex; justify-content:space-between; align-items:center; padding:0 0 8px 0; }
        /* Summary line in collapsed section */
        .flash-summary { display:flex; align-items:center; gap:12px; padding:10px 14px; }
        .flash-summary-text { font-size:12px; color:var(--sw-text-sec); }
        .flash-summary-count { font-weight:700; color:var(--sw-text); font-family:'SF Mono',monospace; }

        /* Properties Panel (3D selection) */
        .properties-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 0;
            min-width: 200px;
            max-width: 280px;
            color: #fff;
            font-size: 13px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .props-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #2a2a2a;
            border-bottom: 1px solid #444;
            font-weight: bold;
            border-radius: 6px 6px 0 0;
        }
        .props-header button {
            background: none;
            border: none;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            padding: 0 4px;
        }
        .props-header button:hover { color: #fff; }
        .props-content { padding: 10px 12px; }
        .props-content div { margin-bottom: 6px; }
        .props-content div:last-child { margin-bottom: 0; }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: #fff;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 10000;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        .toast-success { background: #2e7d32; }
        .toast-error { background: #c62828; }

        /* Output Buttons */
        .output-buttons { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
        .output-buttons .btn { flex: 1; min-width: 120px; text-align: center; padding: 10px 14px; font-size: 13px; }
        .material-order-options { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 10px; align-items: center; }
        .material-order-options .btn-small { padding: 5px 10px; border-radius: 4px; font-size: 11px; cursor: pointer; border: 1px solid var(--sw-border); background: var(--sw-bg); color: var(--sw-text); }
        .material-order-options .btn-small:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        .load-section { margin-top: 12px; text-align: center; }
        .load-section .btn-secondary { display: inline-block; }
        .button-group { display: flex; gap: 4px; flex-wrap: wrap; }
        .toggle-btn-group { display: flex; gap: 4px; flex-wrap: wrap; }
        .toggle-btn { padding: 6px 12px; border: 1px solid var(--sw-border); background: #fff; border-radius: 4px; cursor: pointer; font-size: 13px; transition: all 0.15s; }
        .toggle-btn:hover { border-color: #999; }
        .toggle-btn.active { background: var(--sw-blue-dark); color: #fff; border-color: var(--sw-blue-dark); }
        .toggle-btn.disabled { opacity: 0.35; pointer-events: none; cursor: not-allowed; }

        /* Customer Preview Generator */
        #aiPreviewSection button {
            background: #4285f4;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            font-size: 13px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        #aiPreviewSection button:hover {
            background: #3367d6;
        }
        #generatePromptBtn {
            background: linear-gradient(135deg, #4285f4, #34a853) !important;
        }

        /* Fabrication Cut List Panel */
        .cut-list-panel {
            background: #fff;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
            font-size: 13px;
        }
        .cut-list-panel .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #333;
        }
        .cut-list-panel h4 {
            margin: 0;
            flex: 1;
            font-size: 16px;
            letter-spacing: 1px;
        }
        .cut-list-panel .btn-small {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            border: 1px solid var(--sw-border);
            background: var(--sw-bg);
            color: var(--sw-text);
        }
        .cut-list-panel .btn-small:hover {
            border-color: var(--sw-orange);
            color: var(--sw-orange);
        }
        .tubing-summary {
            margin-bottom: 12px;
            font-size: 12px;
        }
        .tubing-summary .label {
            color: #666;
            text-transform: uppercase;
            font-size: 10px;
            margin-right: 6px;
        }
        .tubing-summary .value {
            font-weight: 700;
        }
        .cut-list-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'SF Mono', 'Courier New', monospace;
        }
        .cut-list-table th {
            background: #333;
            color: #fff;
            padding: 8px 12px;
            text-align: left;
            font-size: 11px;
            text-transform: uppercase;
        }
        .cut-list-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
            vertical-align: top;
        }
        .cut-list-table tr:hover {
            background: #f5f5f5;
        }
        .cut-list-table .cut-length {
            font-size: 18px;
            font-weight: bold;
            color: #d32f2f;
        }
        .cut-list-table .angle-info {
            font-size: 11px;
            color: #666;
            display: block;
        }
        .cut-list-table .mitre {
            color: #1976d2;
            font-weight: 600;
        }
        .cut-list-table .square {
            color: #388e3c;
        }
        .cut-list-totals {
            display: flex;
            gap: 24px;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 2px solid #333;
            flex-wrap: wrap;
        }
        .total-item {
            display: flex;
            flex-direction: column;
        }
        .total-item span:first-child {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
        }
        .total-item span:last-child {
            font-size: 20px;
            font-weight: bold;
        }
        @media print {
            .cut-list-panel .btn-small { display: none; }
            .cut-list-panel { border-color: #000; break-inside: avoid; }
            .cut-list-table th { background: #000; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
        }

        /* â”€â”€ Site Media (Photos & Video) â”€â”€ */
        .media-capture-bar {
            display: flex; gap: 6px; margin-bottom: 10px; flex-wrap: wrap;
        }
        .media-capture-bar .btn-capture {
            display: inline-flex; align-items: center; gap: 5px;
            padding: 8px 14px; border-radius: 6px; font-size: 12px; font-weight: 600;
            cursor: pointer; border: 1px solid var(--sw-border); background: var(--sw-bg); color: var(--sw-text);
            transition: background 0.15s;
        }
        .media-capture-bar .btn-capture:active { background: #e8e8e8; }
        .media-capture-bar .btn-capture.primary { background: var(--sw-orange); color: white; border-color: var(--sw-orange); }
        .media-capture-bar .btn-capture.primary:active { background: #d94d1f; }
        .photo-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;
        }
        .photo-card {
            position: relative; border-radius: 8px; overflow: hidden; border: 1px solid var(--sw-border);
            background: var(--sw-bg); transition: box-shadow 0.15s;
        }
        .photo-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.12); }
        .photo-card img {
            width: 100%; aspect-ratio: 4/3; object-fit: cover; display: block; cursor: pointer;
        }
        .photo-card .photo-delete {
            position: absolute; top: 4px; right: 4px; width: 22px; height: 22px;
            border-radius: 50%; background: rgba(0,0,0,0.55); color: white;
            border: none; cursor: pointer; font-size: 13px; line-height: 22px; text-align: center;
            opacity: 0; transition: opacity 0.15s;
        }
        .photo-card:hover .photo-delete { opacity: 1; }
        .photo-card .photo-label-sel {
            width: 100%; padding: 4px 6px; border: none; border-top: 1px solid var(--sw-border);
            font-size: 10px; background: white; color: var(--sw-text);
        }
        .photo-card .photo-label-sel:focus { outline: none; border-top-color: var(--sw-orange); }
        .photo-card .photo-compress-badge {
            position: absolute; top: 4px; left: 4px; padding: 1px 5px; border-radius: 3px;
            background: rgba(0,0,0,0.5); color: #fff; font-size: 8px; font-weight: 600;
        }
        .media-count {
            font-size: 11px; color: var(--sw-text-sec); font-weight: 500; margin-bottom: 8px;
        }
        .media-count strong { color: var(--sw-text); }
        .compress-progress {
            display: flex; align-items: center; gap: 8px; padding: 8px 12px; margin-bottom: 8px;
            background: rgba(59,130,246,0.06); border-radius: 6px; border-left: 3px solid #3B82F6;
            font-size: 11px; color: #3B82F6; font-weight: 500;
        }
        .compress-progress .spinner {
            width: 14px; height: 14px; border: 2px solid #3B82F6; border-top-color: transparent;
            border-radius: 50%; animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .video-preview-card {
            position: relative; border-radius: 8px; overflow: hidden; border: 1px solid var(--sw-border);
            background: #000; margin-bottom: 8px;
        }
        .video-preview-card video {
            width: 100%; max-height: 200px; display: block;
        }
        .video-preview-card .video-info {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 10px; background: var(--sw-bg); border-top: 1px solid var(--sw-border);
            font-size: 10px; color: var(--sw-text-sec);
        }
        .video-preview-card .photo-delete {
            position: absolute; top: 6px; right: 6px; width: 24px; height: 24px;
            border-radius: 50%; background: rgba(0,0,0,0.6); color: white;
            border: none; cursor: pointer; font-size: 14px; line-height: 24px; text-align: center;
        }
        /* Lightbox for full-size photo view */
        .photo-lightbox {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 10000; justify-content: center; align-items: center;
            cursor: pointer;
        }
        .photo-lightbox.active { display: flex; }
        .photo-lightbox img { max-width: 95%; max-height: 90%; object-fit: contain; border-radius: 4px; }
        .photo-lightbox .lb-close {
            position: absolute; top: 16px; right: 20px; font-size: 28px; color: white;
            cursor: pointer; background: none; border: none; line-height: 1;
        }
        .photo-lightbox .lb-nav {
            position: absolute; top: 50%; transform: translateY(-50%); font-size: 36px; color: white;
            cursor: pointer; background: none; border: none; padding: 12px; line-height: 1;
        }
        .photo-lightbox .lb-nav.prev { left: 8px; }
        .photo-lightbox .lb-nav.next { right: 8px; }
        .photo-lightbox .lb-caption {
            position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
            color: white; font-size: 12px; background: rgba(0,0,0,0.5); padding: 4px 12px; border-radius: 4px;
        }

        /* â”€â”€ Save & Submit Overlay â”€â”€ */
        .save-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 10001; justify-content: center; align-items: center;
        }
        .save-overlay.active { display: flex; }
        .save-overlay-card {
            background: white; border-radius: 12px; width: 90%; max-width: 480px; max-height: 85vh;
            overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .save-overlay-hdr {
            padding: 16px 20px; border-bottom: 1px solid var(--sw-border);
            display: flex; justify-content: space-between; align-items: center;
        }
        .save-overlay-hdr h3 { margin: 0; font-size: 16px; color: var(--sw-blue-dark); }
        .save-overlay-body { padding: 16px 20px; }
        .save-summary-row {
            display: flex; justify-content: space-between; padding: 6px 0;
            font-size: 12px; border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        .save-summary-row .label { color: var(--sw-text-sec); }
        .save-summary-row .value { font-weight: 600; color: var(--sw-text); }
        .save-overlay-actions {
            padding: 12px 20px; border-top: 1px solid var(--sw-border);
            display: flex; gap: 8px; justify-content: flex-end;
        }
        .save-progress-step {
            display: flex; align-items: center; gap: 8px; padding: 6px 0; font-size: 12px;
        }
        .save-progress-step .step-icon { width: 18px; text-align: center; }
        .save-progress-step.done .step-icon { color: #22C55E; }
        .save-progress-step.pending .step-icon { color: #ccc; }
        .save-progress-step.active .step-icon { color: #3B82F6; }
        .save-progress-step.error .step-icon { color: #EF4444; }
        .pending-badge {
            position: fixed; bottom: 16px; left: 16px; padding: 8px 14px;
            background: #FEF3C7; border: 1px solid #F59E0B; border-radius: 8px;
            font-size: 11px; font-weight: 600; color: #92400E; z-index: 9999;
            display: none; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .pending-badge:hover { background: #FDE68A; }

        /* â”€â”€ QA Verification Overlay â”€â”€ */
        .qa-body-locked { overflow:hidden !important; }
        .qa-overlay { position:fixed; inset:0; z-index:10000; background:rgba(0,0,0,0.7); display:none; flex-direction:column; }
        .qa-overlay.active { display:flex; }
        .qa-overlay-inner { flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch; background:#F5F5F7; }
        .qa-header { position:sticky; top:0; z-index:10; background:var(--sw-blue-dark); color:#fff; padding:14px 20px; padding-top:calc(14px + env(safe-area-inset-top, 0px)); display:flex; justify-content:space-between; align-items:center; }
        .qa-header h2 { margin:0; font-size:16px; font-weight:700; }
        .qa-header-summary { font-size:12px; opacity:0.85; }
        .qa-header-summary .qa-count-red { color:#FCA5A5; font-weight:700; }
        .qa-header-summary .qa-count-amber { color:#FCD34D; font-weight:700; }
        .qa-header-summary .qa-count-green { color:#86EFAC; font-weight:700; }
        .qa-header-close { background:none; border:none; color:#fff; font-size:24px; cursor:pointer; padding:4px 8px; min-width:44px; min-height:44px; display:flex; align-items:center; justify-content:center; }
        .qa-cards { padding:16px; max-width:720px; margin:0 auto; }
        .qa-card { background:#fff; border-radius:8px; margin-bottom:12px; box-shadow:0 1px 4px rgba(0,0,0,0.08); border-left:4px solid #22C55E; overflow:hidden; }
        .qa-card.severity-red { border-left-color:#EF4444; }
        .qa-card.severity-amber { border-left-color:#F59E0B; }
        .qa-card.severity-blue { border-left-color:#3B82F6; }
        .qa-card-header { padding:12px 16px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #F0F0F0; }
        .qa-card-title { font-size:13px; font-weight:700; color:var(--sw-blue-dark); text-transform:uppercase; letter-spacing:0.5px; }
        .qa-card-badge { font-size:11px; font-weight:700; padding:2px 8px; border-radius:10px; }
        .qa-card-badge.pass { background:#DCFCE7; color:#166534; }
        .qa-card-badge.warn { background:#FEF3C7; color:#92400E; }
        .qa-card-badge.fail { background:#FEE2E2; color:#991B1B; }
        .qa-card-badge.info { background:#DBEAFE; color:#1E40AF; }
        .qa-card-body { padding:12px 16px; }
        .qa-kv { display:flex; justify-content:space-between; align-items:center; padding:5px 0; border-bottom:1px solid rgba(0,0,0,0.04); }
        .qa-kv:last-child { border-bottom:none; }
        .qa-kv-label { font-size:10px; text-transform:uppercase; letter-spacing:0.5px; color:var(--sw-text-sec); font-weight:600; }
        .qa-kv-value { font-size:13px; font-weight:600; color:var(--sw-text); text-align:right; max-width:60%; }
        .qa-kv-value .qa-swatch { display:inline-block; width:14px; height:14px; border-radius:50%; border:1px solid rgba(0,0,0,0.15); vertical-align:middle; margin-right:6px; }
        .qa-flag { padding:8px 12px; border-radius:6px; margin-top:8px; font-size:12px; display:flex; align-items:flex-start; gap:8px; }
        .qa-flag.red { background:#FEF2F2; color:#991B1B; border:1px solid #FECACA; }
        .qa-flag.amber { background:#FFFBEB; color:#92400E; border:1px solid #FDE68A; }
        .qa-flag.blue { background:#EFF6FF; color:#1E40AF; border:1px solid #BFDBFE; }
        .qa-flag-text { flex:1; line-height:1.4; }
        .qa-flag .qa-fix-btn { background:#EF4444; color:#fff; border:none; border-radius:4px; padding:8px 12px; font-size:11px; font-weight:700; cursor:pointer; white-space:nowrap; min-height:44px; }
        .qa-flag .qa-fix-btn:hover { background:#DC2626; }
        .qa-flag .qa-ack-label { display:flex; align-items:center; gap:6px; cursor:pointer; white-space:nowrap; font-weight:600; font-size:11px; min-height:44px; padding:4px 0; }
        .qa-flag .qa-ack-label input[type="checkbox"] { width:22px; height:22px; min-width:22px; cursor:pointer; }
        .qa-photo-strip { display:flex; gap:6px; overflow-x:auto; padding:8px 0; -webkit-overflow-scrolling:touch; }
        .qa-photo-strip img { width:64px; height:64px; object-fit:cover; border-radius:4px; border:1px solid var(--sw-border); flex-shrink:0; }
        .qa-footer { position:sticky; bottom:0; z-index:10; background:#fff; border-top:1px solid var(--sw-border); padding:12px 20px; padding-bottom:calc(12px + env(safe-area-inset-bottom, 0px)); display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; }
        .qa-footer-info { font-size:11px; color:var(--sw-text-sec); }
        .qa-signoff-btn { padding:12px 24px; border:none; border-radius:6px; font-size:14px; font-weight:700; cursor:pointer; transition:opacity 0.2s; min-height:44px; }
        .qa-signoff-btn.enabled { background:#22C55E; color:#fff; }
        .qa-signoff-btn.enabled:hover { background:#16A34A; }
        .qa-signoff-btn.disabled { background:#D1D5DB; color:#9CA3AF; cursor:not-allowed; }
        .qa-cancel-btn { background:none; border:1px solid #D1D5DB; border-radius:6px; padding:10px 16px; font-size:13px; color:#4B5563; cursor:pointer; min-height:44px; }
        .qa-cancel-btn:hover { background:#F3F4F6; }
        .qa-locked-btn { opacity:0.4; cursor:not-allowed !important; }
        .qa-draft-watermark { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%) rotate(-35deg); font-size:48px; font-weight:900; color:rgba(239,68,68,0.12); pointer-events:none; z-index:9999; white-space:nowrap; letter-spacing:4px; }
        .qa-review-banner { background:#FEF3C7; border:1px solid #F59E0B; border-radius:6px; padding:10px 14px; margin:8px 0; font-size:12px; color:#92400E; display:flex; align-items:center; gap:8px; }
        .qa-review-banner .qa-banner-icon { font-size:16px; }
        .qa-review-banner .qa-banner-text { flex:1; }
        .qa-review-banner .qa-banner-btn { background:#F59E0B; color:#fff; border:none; border-radius:4px; padding:6px 12px; font-size:11px; font-weight:700; cursor:pointer; white-space:nowrap; min-height:44px; }
        .qa-review-banner .qa-banner-btn:hover { background:#D97706; }
        .qa-approved-banner { background:#DCFCE7; border:1px solid #22C55E; border-radius:6px; padding:10px 14px; margin:8px 0; font-size:12px; color:#166534; }
        .qa-order-preview { background:#F9FAFB; border:1px solid var(--sw-border); border-radius:6px; padding:12px; margin-top:8px; font-family:monospace; font-size:11px; white-space:pre-wrap; line-height:1.5; max-height:300px; overflow-y:auto; }
        .qa-order-actions { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
        .qa-order-actions button { padding:8px 14px; border-radius:4px; font-size:12px; font-weight:600; cursor:pointer; border:none; min-height:44px; }
        .qa-order-actions .qa-copy-btn { background:var(--sw-blue-dark); color:#fff; }
        .qa-order-actions .qa-copy-btn:hover { background:#4C6A7C; }
        .qa-order-actions .qa-pdf-btn { background:#fff; color:var(--sw-blue-dark); border:1px solid var(--sw-blue-dark); }
        .qa-order-actions .qa-pdf-btn:hover { background:#F3F4F6; }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <svg class="header-logo" viewBox="0 0 490 79.55" xmlns="http://www.w3.org/2000/svg" style="height:36px;width:auto">
                <defs><style>.cls-1{fill:#f15a29;}.cls-2{fill:#293c46;}.cls-3{fill:#4C6A7C;}</style></defs>
                <path class="cls-2" d="M85.25,46.94c.24,1.73,.73,3.02,1.44,3.88,1.31,1.56,3.56,2.34,6.74,2.34,1.91,0,3.45-.21,4.64-.62,2.26-.79,3.38-2.25,3.38-4.39,0-1.25-.55-2.22-1.66-2.9-1.11-.67-2.86-1.26-5.26-1.77l-4.1-.9c-4.03-.89-6.8-1.86-8.3-2.9-2.55-1.75-3.83-4.48-3.83-8.19,0-3.39,1.25-6.21,3.74-8.45s6.16-3.36,11-3.36c4.04,0,7.48,1.06,10.33,3.17,2.85,2.11,4.35,5.18,4.48,9.21h-7.6c-.14-2.28-1.16-3.89-3.05-4.85-1.26-.63-2.83-.95-4.71-.95-2.09,0-3.76,.41-5,1.23-1.25,.82-1.87,1.97-1.87,3.44,0,1.35,.61,2.36,1.84,3.03,.79,.45,2.47,.97,5.03,1.57l6.64,1.57c2.91,.69,5.09,1.6,6.55,2.75,2.26,1.78,3.38,4.36,3.38,7.73s-1.34,6.33-4.01,8.62c-2.67,2.29-6.45,3.43-11.33,3.43s-8.9-1.13-11.76-3.38c-2.86-2.25-4.28-5.35-4.28-9.28h7.55Z"/>
                <path class="cls-2" d="M131.12,31.2c1.95,.87,3.57,2.26,4.84,4.14,1.15,1.66,1.89,3.59,2.23,5.79,.2,1.29,.28,3.14,.24,5.56h-20.39c.11,2.81,1.09,4.78,2.93,5.91,1.12,.7,2.46,1.05,4.04,1.05,1.67,0,3.02-.43,4.06-1.28,.57-.46,1.07-1.1,1.51-1.93h7.47c-.2,1.66-1.1,3.35-2.71,5.06-2.51,2.72-6.02,4.08-10.53,4.08-3.73,0-7.01-1.15-9.86-3.44-2.85-2.3-4.27-6.03-4.27-11.21,0-4.85,1.28-8.57,3.86-11.16,2.57-2.59,5.91-3.88,10.01-3.88,2.44,0,4.63,.44,6.58,1.31Zm-10.95,6.32c-1.03,1.07-1.68,2.51-1.95,4.33h12.61c-.13-1.94-.78-3.42-1.95-4.42s-2.61-1.51-4.34-1.51c-1.88,0-3.34,.53-4.37,1.6Z"/>
                <path class="cls-2" d="M157.72,40.68c-.14-1.04-.49-1.99-1.06-2.82-.82-1.13-2.1-1.7-3.84-1.7-2.47,0-4.16,1.22-5.07,3.67-.48,1.3-.72,3.02-.72,5.17s.24,3.7,.72,4.94c.87,2.33,2.52,3.49,4.94,3.49,1.72,0,2.94-.46,3.66-1.39,.72-.92,1.16-2.12,1.31-3.6h7.47c-.17,2.23-.98,4.33-2.42,6.32-2.3,3.2-5.7,4.8-10.21,4.8s-7.82-1.34-9.95-4.01c-2.12-2.67-3.19-6.13-3.19-10.39,0-4.8,1.17-8.54,3.52-11.21,2.35-2.67,5.59-4.01,9.72-4.01,3.51,0,6.39,.79,8.63,2.36,2.24,1.58,3.56,4.36,3.97,8.35h-7.5Z"/>
                <path class="cls-2" d="M176.36,30.63v16.87c0,1.59,.19,2.79,.56,3.6,.66,1.42,1.97,2.13,3.91,2.13,2.49,0,4.19-1.01,5.11-3.03,.48-1.1,.72-2.54,.72-4.34v-15.23h7.42v27.99h-7.11v-3.96c-.07,.09-.24,.34-.51,.77s-.6,.8-.97,1.13c-1.14,1.03-2.25,1.73-3.32,2.11-1.07,.38-2.32,.57-3.75,.57-4.13,0-6.92-1.49-8.35-4.47-.8-1.64-1.2-4.07-1.2-7.27V30.63h7.5Z"/>
                <path class="cls-2" d="M215.59,29.98c.09,0,.3,.02,.63,.04v7.5c-.46-.05-.87-.09-1.23-.1-.36-.02-.65-.03-.87-.03-2.95,0-4.92,.96-5.93,2.88-.57,1.08-.85,2.74-.85,4.98v13.38h-7.37V30.63h6.99v4.88c1.13-1.87,2.11-3.14,2.95-3.83,1.37-1.15,3.15-1.72,5.34-1.72,.14,0,.25,0,.35,.01Z"/>
                <path class="cls-2" d="M237.6,31.2c1.95,.87,3.57,2.26,4.84,4.14,1.15,1.66,1.89,3.59,2.23,5.79,.2,1.29,.28,3.14,.24,5.56h-20.39c.11,2.81,1.09,4.78,2.93,5.91,1.12,.7,2.46,1.05,4.04,1.05,1.67,0,3.02-.43,4.06-1.28,.57-.46,1.07-1.1,1.51-1.93h7.47c-.2,1.66-1.1,3.35-2.71,5.06-2.51,2.72-6.02,4.08-10.53,4.08-3.73,0-7.01-1.15-9.86-3.44-2.85-2.3-4.27-6.03-4.27-11.21,0-4.85,1.28-8.57,3.86-11.16,2.57-2.59,5.91-3.88,10.01-3.88,2.44,0,4.63,.44,6.58,1.31Zm-10.95,6.32c-1.03,1.07-1.68,2.51-1.95,4.33h12.61c-.13-1.94-.78-3.42-1.95-4.42s-2.61-1.51-4.34-1.51c-1.88,0-3.34,.53-4.37,1.6Z"/>
                <path class="cls-2" d="M257.32,20.77l.39,21.68-.21,6.04,2.36-5.91,8.91-21.8h8.35l-.13,21.68-.13,6.04,2.39-5.8,9.73-21.91h8.04l-18.7,37.86h-7.55l.13-22.14,.21-7.32-2.88,7.32-9.27,22.14h-7.34l-2.7-37.86h8.4Z"/>
                <path class="cls-2" d="M303.45,59.6c-4.81,0-8.09-1.46-9.82-4.38-1.74-2.92-2.17-6.43-1.3-10.54,.86-4.04,2.78-7.54,5.78-10.5,3-2.96,6.9-4.44,11.71-4.44s8.08,1.48,9.81,4.44c1.73,2.96,2.17,6.46,1.31,10.5-.87,4.11-2.8,7.62-5.79,10.54-2.99,2.92-6.89,4.38-11.7,4.38Zm9.81-14.92c.6-2.81,.48-4.97-.35-6.49-.83-1.52-2.32-2.27-4.46-2.27s-3.95,.76-5.42,2.27c-1.47,1.52-2.51,3.68-3.11,6.49-.6,2.81-.48,4.97,.35,6.5,.83,1.52,2.32,2.29,4.46,2.29s3.95-.76,5.42-2.29,2.51-3.69,3.11-6.5Z"/>
                <path class="cls-2" d="M344.31,30.02l-1.59,7.5c-.45-.05-.85-.09-1.21-.1-.36-.02-.65-.03-.87-.03-2.94,0-5.13,.96-6.55,2.88-.79,1.08-1.42,2.74-1.9,4.98l-2.83,13.38h-7.37l5.93-27.99h6.99l-1.03,4.88c1.52-1.87,2.77-3.14,3.75-3.83,1.63-1.15,3.54-1.72,5.73-1.72,.14,0,.25,0,.35,.01,.09,0,.3,.02,.6,.04Z"/>
                <path class="cls-2" d="M349.31,20.9h7.19l-4.34,20.39,11.35-10.53h9.07l-12.07,10.71,6.55,17.16h-8.83l-4.16-11.97-3.72,3.16-1.85,8.81h-7.19l8.01-37.73Z"/>
                <path class="cls-2" d="M377.05,49.69c-.12,1.3,.03,2.23,.44,2.77,.68,.98,2.25,1.46,4.7,1.46,1.44,0,2.63-.21,3.57-.64,.94-.43,1.51-1.07,1.7-1.93,.17-.82-.04-1.45-.64-1.87-.6-.43-2.99-1.16-7.17-2.21-3-.79-5.02-1.77-6.06-2.95-1.06-1.16-1.35-2.84-.87-5.03,.55-2.59,2.03-4.81,4.46-6.66,2.42-1.86,5.47-2.79,9.16-2.79s6.19,.7,8.09,2.09c1.9,1.4,2.65,3.81,2.26,7.23h-7.32c.09-.94-.02-1.69-.33-2.23-.6-.99-1.87-1.49-3.8-1.49-1.59,0-2.78,.25-3.56,.74-.78,.5-1.24,1.08-1.37,1.75-.19,.84,.04,1.45,.69,1.82,.63,.39,3.03,1.07,7.19,2.03,2.76,.69,4.72,1.72,5.88,3.11,1.15,1.4,1.5,3.16,1.05,5.26-.6,2.77-2.11,5.04-4.55,6.79-2.43,1.76-5.8,2.63-10.12,2.63s-7.45-.93-9.16-2.79c-1.7-1.86-2.26-4.22-1.66-7.1h7.42Z"/>
                <text class="cls-3" x="406" y="52" font-family="'Helvetica Neue', Helvetica, Arial, sans-serif" font-size="21" font-weight="400" letter-spacing="0.5">Group</text>
                <polygon class="cls-2" points="53.54 30.35 53.54 22.29 31.54 8.51 9 22.26 9 34.53 45.72 42.34 45.72 52.83 38.68 52.83 31.53 45.47 24.29 52.83 16.81 52.83 16.81 39 9 37.4 9 60.64 27.56 60.64 31.5 56.65 35.38 60.64 53.54 60.64 53.54 36.01 16.81 28.21 16.81 26.65 31.49 17.69 45.72 26.61 45.72 31.95 53.54 33.41 53.54 30.35"/>
                <rect class="cls-1" x="9.09" y="62.99" width="44.53" height="7.77"/>
            </svg>
        </div>
        <div class="job-badge" id="headerBadge"><strong>SWâ€”</strong></div>
        <div style="display:flex;gap:8px">
            <button class="btn btn-secondary" id="layoutToggle" onclick="toggleLayout()">&#9703; Full Width</button>
            <button class="btn btn-secondary" onclick="showLoadJobModal()">Load Job</button>
            <button class="btn btn-primary" onclick="exportAllOutputs()">Export All</button>
        </div>
    </header>

    <main class="main" id="mainLayout">
        <div class="panel-left">

        <!-- ======== GROUP: JOB ======== -->
        <div class="section-group" id="group-job">
        <div class="section-group-header">Job</div>

        <!-- ============ SECTION: JOB DETAILS ============ -->
        <div class="section" id="sec-job">
            <div class="collapse-header" onclick="toggleSection('sec-job')">
                <div>
                    <div class="section-title">Job Details</div>
                </div>
                <div style="display:flex;align-items:center;gap:6px">
                    <button class="btn btn-primary" style="font-size:10px;padding:4px 10px" onclick="event.stopPropagation();showSaveSubmit()">Save Scope</button>
                    <button class="btn btn-secondary" style="font-size:10px;padding:3px 8px" onclick="event.stopPropagation();exportJobData()">Export</button>
                    <button class="btn btn-secondary" style="font-size:10px;padding:3px 8px" onclick="event.stopPropagation();showImportModal()">Import</button>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body">
                <div class="section-body">
                <div class="basics-group">
                    <div class="basics-grid-3">
                        <div class="basics-field">
                            <label>Job Ref</label>
                            <input type="text" id="jobRef" placeholder="SW250208-01">
                        </div>
                        <div class="basics-field">
                            <label>Salesperson</label>
                            <select id="salesperson">
                                <option value="Nithin">Nithin</option>
                                <option value="Marnin">Marnin</option>
                                <option value="Other">Other</option>
                            </select>
                        </div>
                        <div class="basics-field">
                            <label>Email</label>
                            <input type="text" id="clientEmail" placeholder="client@email.com">
                        </div>
                    </div>
                    <div class="basics-grid-4" style="margin-top:6px">
                        <div class="basics-field">
                            <label>Customer Name</label>
                            <input type="text" id="customerName" placeholder="Full name" oninput="updateCustomer()">
                        </div>
                        <div class="basics-field" style="grid-column:span 2">
                            <label>Address</label>
                            <input type="text" id="customerAddress" placeholder="Street, suburb, postcode" oninput="updateCustomer()">
                        </div>
                        <div class="basics-field">
                            <label>Phone</label>
                            <input type="text" id="customerPhone" placeholder="0412 345 678" oninput="updateCustomer()">
                        </div>
                    </div>
                </div>
                </div>
            </div>
        </div>

        </div><!-- end group-job -->

        <!-- ======== GROUP: SCOPE (Site Media) ======== -->
        <div class="section-group" id="group-scope">
        <div class="section-group-header" style="color:#8B5CF6;border-left-color:#8B5CF6;background:rgba(139,92,246,0.04)">Scope</div>

        <!-- ============ SECTION: SITE PHOTOS ============ -->
        <div class="section" id="sec-photos">
            <div class="collapse-header" onclick="toggleSection('sec-photos')">
                <div>
                    <div class="section-title">Site Photos</div>
                </div>
                <div style="display:flex;align-items:center;gap:6px">
                    <span class="media-count" id="photoCountBadge" style="margin:0"></span>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body">
                <div class="section-body">
                    <div class="media-capture-bar">
                        <label class="btn-capture primary">
                            &#128247; Take Photo
                            <input type="file" accept="image/*" capture="environment" multiple style="display:none" onchange="handlePhotoCapture(this.files)">
                        </label>
                        <label class="btn-capture">
                            &#128193; From Library
                            <input type="file" accept="image/*" multiple style="display:none" onchange="handlePhotoCapture(this.files)">
                        </label>
                    </div>
                    <div id="photoCompressProgress" style="display:none" class="compress-progress">
                        <div class="spinner"></div>
                        <span id="compressProgressText">Compressing photos...</span>
                    </div>
                    <div id="photoGrid" class="photo-grid"></div>
                    <div id="photoCountInfo" class="media-count" style="display:none"></div>
                </div>
            </div>
        </div>

        <!-- ============ SECTION: SITE VIDEO ============ -->
        <div class="section" id="sec-video">
            <div class="collapse-header" onclick="toggleSection('sec-video')">
                <div>
                    <div class="section-title">Site Walkthrough</div>
                </div>
                <div style="display:flex;align-items:center;gap:6px">
                    <span id="videoBadge" class="media-count" style="margin:0"></span>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body shut">
                <div class="section-body">
                    <p style="font-size:10px;color:var(--sw-text-sec);margin:0 0 8px">Record a walkthrough in the Camera app first, then upload from your Photo Library. iOS auto-compresses to 720p. Keep under 2 minutes.</p>
                    <div class="media-capture-bar">
                        <label class="btn-capture primary">
                            &#127909; Upload Video
                            <input type="file" accept="video/*" style="display:none" onchange="handleVideoUpload(this.files)">
                        </label>
                    </div>
                    <div id="videoPreviewArea"></div>
                </div>
            </div>
        </div>

        </div><!-- end group-scope -->

        <!-- ======== GROUP: BUILD ======== -->
        <div class="section-group" id="group-build">
        <div class="section-group-header">Build</div>

        <!-- ============ SECTION: DESIGN ============ -->
        <div class="section" id="sec-design">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-design')">
                <div><div class="section-title">Design</div></div>
                <div style="display:flex;align-items:center;gap:4px">
                    <span class="section-warn-dot" id="buildWarnDot"></span>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">
                <div class="basics-group">
                    <!-- Roof Style toggle buttons -->
                    <div class="basics-field" style="margin-bottom:10px">
                        <label>Roof Style</label>
                        <input type="hidden" id="inRoofStyle" value="skillion">
                        <div class="toggle-btn-group" id="roofStyleGroup">
                            <button type="button" class="toggle-btn" data-value="gable" onclick="setDesignToggle('inRoofStyle','gable',this)">Gable</button>
                            <button type="button" class="toggle-btn active" data-value="skillion" onclick="setDesignToggle('inRoofStyle','skillion',this)">Skillion</button>
                        </div>
                    </div>
                    <!-- Attachment toggle buttons -->
                    <div class="basics-field" style="margin-bottom:10px">
                        <label>Attachment</label>
                        <input type="hidden" id="inConnection" value="riser">
                        <div class="toggle-btn-group" id="connectionGroup">
                            <button type="button" class="toggle-btn active" data-value="riser" onclick="setDesignToggle('inConnection','riser',this)">Riser</button>
                            <button type="button" class="toggle-btn" data-value="flyover" onclick="setDesignToggle('inConnection','flyover',this)">Flyover</button>
                            <button type="button" class="toggle-btn" data-value="fascia" onclick="setDesignToggle('inConnection','fascia',this)">Fascia</button>
                            <button type="button" class="toggle-btn" data-value="wall" onclick="setDesignToggle('inConnection','wall',this)">Wall</button>
                            <button type="button" class="toggle-btn" data-value="freestanding" onclick="setDesignToggle('inConnection','freestanding',this)">Free</button>
                        </div>
                    </div>
                    <div class="basics-field" id="lshapeField" style="margin-bottom:10px;display:none">
                        <label>House Shape</label>
                        <input type="hidden" id="inLShape" value="none">
                        <div class="toggle-btn-group" id="lshapeGroup">
                            <button type="button" class="toggle-btn active" data-value="none" onclick="setDesignToggle('inLShape','none',this)">Straight</button>
                            <button type="button" class="toggle-btn" data-value="left" onclick="setDesignToggle('inLShape','left',this)">L-Shape Left</button>
                            <button type="button" class="toggle-btn" data-value="right" onclick="setDesignToggle('inLShape','right',this)">L-Shape Right</button>
                        </div>
                    </div>
                    <div class="basics-field" id="wraparoundField" style="margin-bottom:10px;display:none">
                        <label>Wraparound</label>
                        <input type="hidden" id="inWraparound" value="none">
                        <div class="toggle-btn-group" id="wraparoundGroup">
                            <button type="button" class="toggle-btn active" data-value="none" onclick="setDesignToggle('inWraparound','none',this)">None</button>
                            <button type="button" class="toggle-btn" data-value="left" onclick="setDesignToggle('inWraparound','left',this)">Left</button>
                            <button type="button" class="toggle-btn" data-value="right" onclick="setDesignToggle('inWraparound','right',this)">Right</button>
                        </div>
                    </div>
                    <div class="basics-field" id="existingRoofDesignField" style="margin-bottom:10px;display:none">
                        <label>House Roof</label>
                        <div class="toggle-btn-group" id="existingRoofDesignGroup">
                            <button type="button" class="toggle-btn active" data-value="tiles" onclick="setExistingRoofFromDesign('tiles',this)">Tiles</button>
                            <button type="button" class="toggle-btn" data-value="colorbond" onclick="setExistingRoofFromDesign('colorbond',this)">Colorbond</button>
                            <button type="button" class="toggle-btn" data-value="flat" onclick="setExistingRoofFromDesign('flat',this)">Flat</button>
                        </div>
                    </div>
                    <div id="wraparoundDimsField" style="display:none">
                        <div style="display:flex;align-items:center;gap:6px;margin-bottom:6px;padding:6px 8px;background:rgba(76,106,124,0.06);border-radius:6px;border-left:3px solid #F15A29">
                            <span style="font-size:10px;font-weight:700;color:#4C6A7C;letter-spacing:0.5px;text-transform:uppercase">Return Patio</span>
                            <span id="wrapReturnInfo" style="font-size:10px;color:#999;margin-left:auto"></span>
                        </div>
                        <div class="basics-grid-2">
                            <div class="basics-field">
                                <label>Return Length <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inReturnLength" value="3000" step="100" min="1000" max="10000" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field">
                                <label>Return Posts</label>
                                <input type="number" id="inReturnPosts" value="2" step="1" min="1" max="6" oninput="rebuildAll()">
                            </div>
                        </div>
                    </div>
                    <div class="basics-grid-3">
                        <div class="basics-field">
                            <label>Material</label>
                            <select id="inRoofing" onchange="updateUI(); rebuildAll()">
                                <option value="solarspan75">SolarSpan 75mm</option>
                                <option value="solarspan100">SolarSpan 100mm</option>
                                <option value="trimdek">Trimdek</option>
                                <option value="spanplus330">SpanPlus 330</option>
                                <option value="corrugated">Corrugated</option>
                                <option value="spandek">Spandek</option>
                            </select>
                        </div>
                        <div class="basics-field" id="pitchField">
                            <label>Pitch <span style="color:var(--sw-text-sec);font-size:9px">&deg;</span></label>
                            <input type="number" id="inPitch" value="10" step="0.5" oninput="rebuildAll()">
                        </div>
                    </div>
                </div>
                <div class="basics-divider"></div>
                <!-- Colours -->
                <div class="basics-group">
                    <div class="basics-group-title">Colours</div>
                    <div class="basics-colours">
                        <div class="basics-colour-block">
                            <div class="basics-colour-label">Sheets</div>
                            <div class="color-chips" id="sheetChips"></div>
                            <div class="color-label" id="sheetLabel">Monument</div>
                        </div>
                        <div class="basics-colour-block">
                            <div class="basics-colour-label">Steel</div>
                            <div class="color-chips" id="steelChips"></div>
                            <div class="color-label" id="steelLabel">Monument</div>
                        </div>
                        <div class="basics-colour-block">
                            <div class="basics-colour-label">Flashings</div>
                            <div class="color-chips" id="flashingChips"></div>
                            <div class="color-label" id="flashingLabel">Monument</div>
                        </div>
                        <div class="basics-colour-block" id="ceilingFinishColorBlock" style="display:none">
                            <div class="basics-colour-label">Ceiling</div>
                            <div class="toggle-btn-group" style="gap:2px">
                                <button type="button" class="toggle-btn active" data-value="plain" onclick="setDesignToggle('inCeilingFinish','plain',this);syncCeilingToggles('plain')">Plain</button>
                                <button type="button" class="toggle-btn" data-value="vj" onclick="setDesignToggle('inCeilingFinish','vj',this);syncCeilingToggles('vj')">VJ</button>
                                <button type="button" class="toggle-btn" data-value="cedar" onclick="setDesignToggle('inCeilingFinish','cedar',this);syncCeilingToggles('cedar')">Cedar</button>
                            </div>
                        </div>
                    </div>
                </div>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: STRUCTURE ============ -->
        <div class="section" id="sec-structure">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-structure')">
                <div><div class="section-title">Structure</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">

                    <!-- 1. DIMENSIONS subsection -->
                    <div class="basics-group">
                        <div class="basics-group-title"><span class="bg-num">1</span>Dimensions</div>
                        <div class="basics-grid-3">
                            <div class="basics-field">
                                <label>Length <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                                <input type="number" id="inLength" value="6" step="0.1" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field">
                                <label>Projection <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                                <input type="number" id="inWidth" value="3" step="0.1" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field">
                                <label>Post Height <span style="color:var(--sw-text-sec);font-size:9px">m</span></label>
                                <input type="number" id="inPostHeight" value="2.4" step="0.1" oninput="rebuildAll()">
                            </div>
                        </div>
                    </div>

                    <!-- Purlin validation (subtle inline note) -->
                    <div id="purlinValidation" style="margin:4px 0 0;padding:4px 10px;border-radius:4px;font-size:10px;background:transparent">
                        <div id="purlinValidationText" style="color:var(--sw-text-sec)">--</div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 3. CONNECTION subsection -->
                    <div class="basics-group">
                        <div class="basics-group-title"><span class="bg-num">2</span>Connection</div>
                        <div class="basics-grid-3">
                            <div class="basics-field" id="fasciaHeightField" style="display:none">
                                <label>Fascia Height <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inFasciaHeight" value="2700" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="fasciaBracketQtyField" style="display:none">
                                <label>Fascia Brackets</label>
                                <input type="number" id="inFasciaBracketQty" value="4" min="2" step="1" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="basics-grid-4" style="margin-top:6px">
                            <div class="basics-field" id="riserHeightField" style="display:none">
                                <label>Riser Height <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inRiserHeight" value="400" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserOffsetField" style="display:none">
                                <label>Riser Offset <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inRiserOffset" value="150" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="riserQtyField" style="display:none">
                                <label>Riser Brackets</label>
                                <input type="number" id="inRiserQty" value="" min="2" oninput="rebuildAll()">
                            </div>
                        </div>
                        <!-- Flyover Options (show if Attachment = Flyover) -->
                        <div id="flyoverOptionsField" style="display:none;margin-top:8px">
                            <label style="font-size:11px;color:var(--sw-text-sec);margin-bottom:4px;display:block">Flyover Configuration</label>
                            <div class="basics-grid-4">
                                <div class="basics-field">
                                    <label>House Roof Pitch <span style="color:var(--sw-text-sec);font-size:9px">&deg;</span></label>
                                    <input type="number" id="inHouseRoofPitch" value="15" min="2" max="45" step="0.5" oninput="rebuildAll()">
                                </div>
                                <div class="basics-field">
                                    <label>House Roof Depth <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                    <input type="number" id="inHouseRoofDepth" value="1500" min="500" max="5000" step="100" oninput="rebuildAll()">
                                </div>
                                <div class="basics-field">
                                    <label>Post Setback <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                    <input type="number" id="inFlyoverSetback" value="200" min="0" max="3000" step="50" oninput="rebuildAll()">
                                </div>
                                <div class="basics-field">
                                    <label>Clearance <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                    <input type="number" id="inFlyoverClearance" value="150" min="50" max="500" step="10" oninput="rebuildAll()">
                                </div>
                            </div>
                        </div>
                        <!-- House Gutter (show if Attachment = Riser) -->
                        <div id="houseGutterImpactField" style="display:none;margin-top:8px">
                            <label style="font-size:11px;color:var(--sw-text-sec);margin-bottom:4px;display:block">Gutter at House</label>
                            <input type="hidden" id="inHouseGutter" value="quad">
                            <div class="toggle-btn-group">
                                <button type="button" class="toggle-btn active" data-value="quad" onclick="setDesignToggle('inHouseGutter','quad',this)">Keep Existing</button>
                                <button type="button" class="toggle-btn" data-value="box" onclick="setDesignToggle('inHouseGutter','box',this)">Replace with Box Gutter</button>
                            </div>
                            <div id="boxGutterConfig" style="display:none;margin-top:8px;padding:10px;background:#f0f7ff;border:1px solid #ccddef;border-radius:8px">
                                <div style="font-size:11px;font-weight:600;color:#2c5282;margin-bottom:6px">Box Gutter Sizing</div>
                                <div style="display:flex;gap:10px;align-items:flex-end;margin-bottom:6px">
                                    <div class="basics-field" style="flex:1;margin-bottom:0">
                                        <label>Width <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                        <input type="number" id="inBoxGutterWidth" value="300" min="150" max="600" step="10" oninput="updateBoxGutterSummary()">
                                    </div>
                                    <div class="basics-field" style="flex:1;margin-bottom:0">
                                        <label>Catchment <span style="color:var(--sw-text-sec);font-size:9px">m&sup2;</span></label>
                                        <input type="number" id="inBoxGutterCatchment" value="85" min="10" max="500" step="5" oninput="updateBoxGutterSummary()">
                                    </div>
                                </div>
                                <div id="boxGutterSummary" style="font-size:10px;color:var(--sw-text-sec);margin-bottom:4px">
                                    <div id="boxGutterWidthRec" style="font-weight:500">Recommended: 300mm width</div>
                                    <div id="boxGutterProfileRec" style="margin-top:2px">Profile: 100mm deep &times; 70mm back &times; 130mm front</div>
                                </div>
                                <div id="boxGutterWarn" style="display:none;font-size:10px;color:#7D6608;background:#FEF9E7;border:1px solid #F39C12;border-radius:4px;padding:4px 8px;margin-bottom:4px"></div>
                                <div style="font-size:9px;color:#999;margin-top:4px">Width auto-syncs with riser horizontal length</div>
                            </div>
                        </div>
                    </div>
                    <!-- Downpipes -->
                    <div id="downpipeField" style="margin-top:10px">
                        <label style="font-size:11px;color:var(--sw-text-sec);margin-bottom:4px;display:block">Downpipes <span id="dpCountBadge" style="background:var(--sw-accent);color:#fff;font-size:9px;font-weight:700;border-radius:8px;padding:1px 6px;margin-left:4px">2</span></label>
                        <div id="dpPostMap" style="display:flex;align-items:center;gap:0;padding:4px 0"></div>
                        <div id="dpSummary" style="font-size:9px;color:var(--sw-text-sec);margin-top:2px">Tap a post to add/remove downpipe</div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 4. STRUCTURAL SIZING -->
                    <div class="basics-group">
                        <div class="basics-group-title"><span class="bg-num">3</span>Structural Sizing</div>
                        <div class="struct-sizing" id="structSizing">
                            <!-- Posts -->
                            <div class="struct-row" id="structRowPosts">
                                <span class="struct-label">Posts</span>
                                <div class="struct-qty">
                                    <button onclick="adjustPostQty(-1)">&#8722;</button>
                                    <input type="number" id="inPostQty" value="" min="2" max="20" step="1" placeholder="auto" oninput="onPostQtyChange()">
                                    <button onclick="adjustPostQty(1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <select id="inPostSize" onchange="rebuildAll()">
                                        <option value="65x65">65&times;65 SHS</option>
                                        <option value="75x75">75&times;75 SHS</option>
                                        <option value="90x90" selected>90&times;90 SHS</option>
                                        <option value="100x100">100&times;100 SHS</option>
                                        <option value="125x125">125&times;125 SHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Purlins -->
                            <div class="struct-row" id="structRowPurlins">
                                <span class="struct-label">Purlins</span>
                                <div class="struct-qty">
                                    <button onclick="adjustStructPurlinQty(-1)">&#8722;</button>
                                    <span id="structPurlinQty">--</span>
                                    <button onclick="adjustStructPurlinQty(1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <select id="inPurlinSize" onchange="rebuildAll()">
                                        <option value="76x38" selected>76Ã—38 RHS</option>
                                        <option value="100x50">100Ã—50 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Fascia Beam -->
                            <div class="struct-row" id="structRowFasciaBeam">
                                <span class="struct-label">Fascia Beam</span>
                                <div class="struct-qty">
                                    <span id="structFasciaBeamQty" style="min-width:28px;text-align:center">1</span>
                                </div>
                                <div class="struct-size">
                                    <select id="inBeamSize" onchange="rebuildAll()">
                                        <option value="75x50">75&times;50 RHS</option>
                                        <option value="100x50" selected>100&times;50 RHS</option>
                                        <option value="125x50">125&times;50 RHS</option>
                                        <option value="150x50">150&times;50 RHS</option>
                                        <option value="200x50">200&times;50 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Gutter Beam -->
                            <div class="struct-row" id="structRowGutterBeam">
                                <span class="struct-label">Gutter Beam</span>
                                <div class="struct-qty">
                                    <span id="structGutterBeamQty" style="min-width:28px;text-align:center">1</span>
                                </div>
                                <div class="struct-size">
                                    <select id="inGutterBeamSize" onchange="rebuildAll()">
                                        <option value="75x50">75&times;50 RHS</option>
                                        <option value="100x50" selected>100&times;50 RHS</option>
                                        <option value="125x50">125&times;50 RHS</option>
                                        <option value="150x50">150&times;50 RHS</option>
                                        <option value="200x50">200&times;50 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Riser Beam (skillion + riser only) -->
                            <div class="struct-row" id="structRowRiserBeam" style="display:none">
                                <span class="struct-label">Riser Beam</span>
                                <div class="struct-qty">
                                    <span id="structRiserBeamQty" style="min-width:28px;text-align:center">1</span>
                                </div>
                                <div class="struct-size">
                                    <select id="inRiserBeamSize" onchange="rebuildAll()">
                                        <option value="75x50">75&times;50 RHS</option>
                                        <option value="100x50" selected>100&times;50 RHS</option>
                                        <option value="125x50">125&times;50 RHS</option>
                                        <option value="150x50">150&times;50 RHS</option>
                                        <option value="200x50">200&times;50 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Riser Steel (skillion + riser only) -->
                            <div class="struct-row" id="structRowRiserSteel" style="display:none">
                                <span class="struct-label">Riser Steel</span>
                                <div class="struct-qty">
                                    <span id="structRiserSteelQty" style="min-width:28px;text-align:center;font-size:10px;color:var(--sw-text-sec)">per riser</span>
                                </div>
                                <div class="struct-size">
                                    <select id="inRiserSteel" onchange="rebuildAll()">
                                        <option value="76x38" selected>76&times;38 RHS</option>
                                        <option value="75x50">75&times;50 RHS</option>
                                        <option value="100x50">100&times;50 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Rafters (skillion only) -->
                            <div class="struct-row" id="structRowRafters">
                                <span class="struct-label">Rafters</span>
                                <div class="struct-qty">
                                    <button onclick="adjustRafterQty(-1)">&#8722;</button>
                                    <input type="number" id="inRafterQtyOverride" value="" min="2" max="30" step="1" placeholder="auto" oninput="onRafterQtyChange()">
                                    <button onclick="adjustRafterQty(1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <select id="inRafterSize" onchange="rebuildAll()">
                                        <option value="50x25">50&times;25 RHS</option>
                                        <option value="65x35">65&times;35 RHS</option>
                                        <option value="75x35" selected>75&times;35 RHS</option>
                                        <option value="75x50">75&times;50 RHS</option>
                                        <option value="100x50">100&times;50 RHS</option>
                                        <option value="125x50">125&times;50 RHS</option>
                                        <option value="150x50x2">150&times;50&times;2 RHS</option>
                                        <option value="150x50x3">150&times;50&times;3 RHS</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Trusses (gable only) -->
                            <div class="struct-row" id="structRowTrusses" style="display:none">
                                <span class="struct-label">Trusses</span>
                                <div class="struct-qty">
                                    <button onclick="adjustStructTrussQty(-1)">&#8722;</button>
                                    <input type="number" id="inTrussesOverride" value="" min="2" max="20" step="1" placeholder="auto" oninput="onTrussQtyOverride()">
                                    <button onclick="adjustStructTrussQty(1)">+</button>
                                </div>
                                <div class="struct-size">
                                    <button class="struct-configure-btn" onclick="scrollToTrussSection()">Configure</button>
                                </div>
                            </div>
                        </div>
                        <div id="structSizingWarnings" style="margin-top:6px"></div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 5. POST OPTIONS -->
                    <div class="basics-group">
                        <div class="basics-group-title"><span class="bg-num">4</span>Post Options</div>
                        <div class="basics-field" style="margin-bottom:10px">
                            <label>Ground Surface</label>
                            <div class="toggle-btn-group" id="groundSurfaceGroup">
                                <button type="button" class="toggle-btn" data-value="slab" onclick="setToggle('groundSurface', 'slab', this); smartPostFixDefault()">Slab</button>
                                <button type="button" class="toggle-btn" data-value="paving" onclick="setToggle('groundSurface', 'paving', this); smartPostFixDefault()">Paving</button>
                                <button type="button" class="toggle-btn active" data-value="grass" onclick="setToggle('groundSurface', 'grass', this); smartPostFixDefault()">Grass</button>
                                <button type="button" class="toggle-btn" data-value="deck" onclick="setToggle('groundSurface', 'deck', this); smartPostFixDefault()">Deck</button>
                            </div>
                            <input type="hidden" id="groundSurface" value="grass">
                        </div>
                        <div class="basics-field">
                            <label>Post Fixing</label>
                            <input type="hidden" id="inPostFix" value="concrete">
                            <div class="toggle-btn-group" id="postFixGroup">
                                <button type="button" class="toggle-btn active" data-value="concrete" onclick="setDesignToggle('inPostFix','concrete',this)">In-ground</button>
                                <button type="button" class="toggle-btn" data-value="baseplate" onclick="setDesignToggle('inPostFix','baseplate',this)">Bolt-down</button>
                            </div>
                        </div>
                        <div id="postWarnings" style="display:none;margin-top:8px"></div>
                        <span id="postSizeDisplay" style="display:none">90Ã—90Ã—2 SHS</span>
                        <!-- Post calculation summary (hidden, populated for export) -->
                        <div id="postResult" style="display:none">
                            <div id="postResultTitle">--</div>
                            <div id="postResultSpacing">--</div>
                            <div id="postResultLineal">--</div>
                            <div id="postResultFootings">--</div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 6. SHEET BMT (single-skin only) -->
                    <div class="basics-group" id="bmtField" style="display:none">
                        <div class="basics-field">
                            <label>Sheet BMT</label>
                            <select id="inBMT" onchange="rebuildAll()">
                                <option value="042">0.42mm</option>
                                <option value="048">0.48mm</option>
                            </select>
                        </div>
                    </div>

                    <!-- Rise/Rafter calc display (hidden, moved to visualiser in Phase 11) -->
                    <div class="calc-display" id="calcDisplay" style="display:none">
                        <div class="calc-row"><span class="calc-label">Rise:</span><span class="calc-value" id="calcRise">--</span></div>
                        <div class="calc-row"><span class="calc-label">Rafter TRUE:</span><span class="calc-value" id="calcRafter">--</span></div>
                        <div class="calc-row" id="calcPitchRow" style="display:none"><span class="calc-label">Actual Pitch:</span><span class="calc-value" id="calcPitch">--</span></div>
                    </div>

                </div>
            </div>
        </div>


        <!-- ============ SECTION: GABLE TRUSS (conditional) ============ -->
        <div class="section" id="sec-truss" style="display:none">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-truss')">
                <div><div class="section-title">Gable Truss Calculator</div></div>
                <div style="display:flex;align-items:center;gap:8px">
                    <button class="btn btn-secondary" style="padding:3px 8px;font-size:10px" onclick="event.stopPropagation();exportTrussPDF()">PDF</button>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="padding:0">
                    <!-- Truss configuration inputs (moved from Site Details) -->
                    <div style="padding:12px 16px;border-bottom:1px solid var(--sw-border)">
                        <div class="basics-grid-4">
                            <div class="basics-field">
                                <label>Span <span style="color:var(--sw-text-sec);font-size:9px">from projection</span></label>
                                <input type="text" id="trussSpanDisplay" readonly class="readonly-field" value="3m">
                            </div>
                            <div class="basics-field">
                                <label>Pitch <span style="color:var(--sw-text-sec);font-size:9px">from roof pitch</span></label>
                                <input type="text" id="trussPitchDisplay" readonly class="readonly-field" value="10&deg;">
                            </div>
                            <div class="basics-field">
                                <label>Qty <span style="color:var(--sw-text-sec);font-size:9px">auto or override</span></label>
                                <input type="number" id="inTrusses" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="basics-field" id="orientationField">
                                <label>Ridge Direction</label>
                                <select id="inOrientation" onchange="rebuildAll()">
                                    <option value="lengthways">Along House</option>
                                    <option value="perpendicular">Away from House</option>
                                </select>
                            </div>
                        </div>
                        <div class="basics-grid-4" style="margin-top:6px">
                            <div class="basics-field">
                                <label>Steel Size</label>
                                <select id="inTrussSteel" onchange="rebuildAll()">
                                    <option value="76x38">76 &times; 38 &times; 1.6mm RHS</option>
                                    <option value="75x50">75 &times; 50 &times; 2.0mm RHS</option>
                                    <option value="100x50">100 &times; 50 &times; 2.0mm RHS</option>
                                </select>
                            </div>
                            <div class="basics-field" id="trussBaseField">
                                <label>Web Style</label>
                                <select id="inTrussBase" onchange="rebuildAll()">
                                    <option value="kingpost" selected>King Post</option>
                                    <option value="kingverticals">King Post + Verticals</option>
                                    <option value="web">Web</option>
                                </select>
                            </div>
                            <div class="basics-field" id="trussChordField">
                                <label>Chord</label>
                                <select id="inTrussChord" onchange="rebuildAll()">
                                    <option value="bottom">Bottom</option>
                                    <option value="mid">Mid</option>
                                    <option value="none">None</option>
                                </select>
                            </div>
                            <div class="basics-field">
                                <label>Overhang <span style="color:var(--sw-text-sec);font-size:9px">mm</span></label>
                                <input type="number" id="inOverhang" value="0" min="0" step="10" oninput="rebuildAll()">
                            </div>
                        </div>
                        <!-- Auto-calculated posts (hidden, used by getInputs) -->
                        <input type="hidden" id="inPosts" value="3">
                        <!-- Rafters field for skillion (hidden here, used by getInputs) -->
                        <input type="hidden" id="inRafters" value="5">
                    </div>
                    <div class="truss-config">
                        <div class="truss-config-item">
                            <label><input type="checkbox" id="trussExtOn" onchange="toggleTrussOpt();rebuildAll()"> Extender</label>
                            <div class="truss-opt-fields" id="trussExtInputs" style="display:none">
                                <label>Length <input type="number" id="trussExtLen" value="300" min="0" step="10" oninput="rebuildAll()"><span>mm</span></label>
                            </div>
                        </div>
                        <div class="truss-config-item">
                            <label><input type="checkbox" id="trussRiserOn" onchange="toggleTrussOpt();rebuildAll()"> Risers</label>
                            <div class="truss-opt-fields" id="trussRiserInputs" style="display:none">
                                <label><input type="checkbox" id="trussRiserLock" checked onchange="syncRiserLock();rebuildAll()"> Lock L/R</label>
                                <input type="hidden" id="trussBoxGutterOn" value="0">
                                <button type="button" class="truss-box-gutter-btn" id="trussBoxGutterBtn" onclick="openGutterDesigner()">Box Gutter</button>
                            </div>
                            <div class="truss-opt-fields" id="trussRiserTypePanel" style="display:none;gap:6px;margin-top:2px">
                                <label style="font-weight:600;font-size:10px;color:var(--sw-text-sec)">Riser Type</label>
                                <label style="font-size:10px;cursor:pointer"><input type="radio" name="riserType" id="riserTypeWelded" value="welded" checked onchange="rebuildAll()"> Welded to Truss</label>
                                <label style="font-size:10px;cursor:pointer"><input type="radio" name="riserType" id="riserTypeSeparate" value="separate" onchange="rebuildAll()"> Separate Piece</label>
                            </div>
                        </div>
                        <div class="truss-config-item" id="trussRiserLPanel" style="display:none">
                            <span class="truss-opt-fields" style="display:flex">
                                <label style="font-weight:600;font-size:10px;color:var(--sw-text-sec)">Left Riser</label>
                                <label>Horiz <input type="number" id="riserLH" value="200" min="0" max="800" step="10" oninput="syncRiserInputs('L');if(document.getElementById('trussBoxGutterOn').value==='1')syncRiserToBoxGutter();rebuildAll()"><span>mm</span></label>
                                <label>Vert <input type="number" id="riserLV" value="150" min="0" max="600" step="10" oninput="syncRiserInputs('L');if(document.getElementById('trussBoxGutterOn').value==='1')syncRiserToBoxGutter();rebuildAll()"><span>mm</span></label>
                            </span>
                        </div>
                        <div class="truss-config-item" id="trussRiserRPanel" style="display:none">
                            <span class="truss-opt-fields" style="display:flex">
                                <label style="font-weight:600;font-size:10px;color:var(--sw-text-sec)">Right Riser</label>
                                <label>Horiz <input type="number" id="riserRH" value="200" min="0" max="800" step="10" oninput="syncRiserInputs('R');if(document.getElementById('trussBoxGutterOn').value==='1')syncRiserToBoxGutter();rebuildAll()"><span>mm</span></label>
                                <label>Vert <input type="number" id="riserRV" value="150" min="0" max="600" step="10" oninput="syncRiserInputs('R');if(document.getElementById('trussBoxGutterOn').value==='1')syncRiserToBoxGutter();rebuildAll()"><span>mm</span></label>
                            </span>
                        </div>
                    </div>
                    <div style="padding:12px">
                        <div class="truss-viewport" id="trussViewport">
                            <canvas id="trussCanvas"></canvas>
                            <div id="trussPropertiesPanel" class="properties-panel" style="display: none;"></div>
                            <button class="truss-fullscreen-btn" onclick="toggleTrussFullscreen()" title="Fullscreen">&#x26F6;</button>
                            <label class="truss-dim-toggle"><input type="checkbox" id="showTrussDims" checked onchange="toggleTrussDimensions()"> Dims</label>
                            <div class="truss-view-btns">
                                <button class="truss-view-btn active" onclick="setTrussView('front',this)">Front</button>
                                <button class="truss-view-btn" onclick="setTrussView('front',document.querySelector('.truss-view-btn:nth-child(1)'))" title="Reset view" style="font-size:13px;padding:3px 8px">&#x21BA;</button>
                            </div>
                        </div>
                        <div class="truss-panel-vertical">
                            <div class="truss-cards-row">
                                <div class="truss-card">
                                    <h4>Truss Dimensions</h4>
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-label">SP: Span</div><div class="spec-value" id="specA">3000</div></div>
                                        <div class="spec-item"><div class="spec-label">HT: Height</div><div class="spec-value" id="specB">264</div></div>
                                        <div class="spec-item"><div class="spec-label">Rafter</div><div class="spec-value hl" id="specC">1523</div></div>
                                        <div class="spec-item"><div class="spec-label">Pitch</div><div class="spec-value" id="specD">10&deg;</div></div>
                                        <div class="spec-item" id="specExtItem" style="display:none"><div class="spec-label">Extender</div><div class="spec-value" id="specExt">300</div></div>
                                        <div class="spec-item" id="specRiserLItem" style="display:none"><div class="spec-label">Riser L</div><div class="spec-value" id="specRiserL">200Ã—150</div></div>
                                        <div class="spec-item" id="specRiserRItem" style="display:none"><div class="spec-label">Riser R</div><div class="spec-value" id="specRiserR">200Ã—150</div></div>
                                    </div>
                                </div>
                                <!-- Cut lengths/angles hidden â€” data still calculated for PDF -->
                                <div class="truss-card" style="display:none">
                                    <div class="spec-grid">
                                        <div class="spec-item"><div class="spec-value hl" id="specChordCut">--</div></div>
                                        <div class="spec-item"><div class="spec-value hl" id="specRafterCut">--</div></div>
                                        <div class="spec-item" id="specRiserLMitem"><div class="spec-value" id="specRiserLM">--</div></div>
                                        <div class="spec-item"><div class="spec-value" id="specLMper">--</div></div>
                                        <div class="spec-item"><div class="spec-value" id="specLMall">--</div></div>
                                        <div class="spec-item"><div class="spec-value" id="angleApex">--</div></div>
                                        <div class="spec-item"><div class="spec-value" id="angleBase">--</div></div>
                                    </div>
                                </div>
                            </div>
                            <div class="truss-card" id="webCard" style="display:none">
                                <h4>Web Members</h4>
                                <div class="spec-grid">
                                    <div class="spec-item"><div class="spec-label">Style</div><div class="spec-value" id="webStyle">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Count</div><div class="spec-value" id="webCount">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Cut Lengths</div><div class="spec-value" id="webCuts">--</div></div>
                                    <div class="spec-item"><div class="spec-label">Web LM</div><div class="spec-value" id="webLM">--</div></div>
                                </div>
                            </div>
                            <div class="fab-box" id="fabOrder" style="display:none;white-space:pre;font-family:'SF Mono',monospace;font-size:10px;line-height:1.5;padding:12px;overflow-x:auto"></div>
                            <!-- Fabrication Cut List Panel (hidden from scoper) -->
                            <div id="cutListPanel" class="cut-list-panel" style="display:none">
                                <div class="panel-header">
                                    <h4>FABRICATION CUT LIST</h4>
                                    <button onclick="printCutList()" class="btn-small">Print</button>
                                    <button onclick="copyCutList()" class="btn-small">Copy</button>
                                </div>
                                <div class="tubing-summary">
                                    <span class="label">Tubing:</span>
                                    <span class="value" id="cutListTubing">76x38 RHS</span>
                                </div>
                                <table class="cut-list-table">
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Part</th>
                                            <th>Qty</th>
                                            <th>Cut Length</th>
                                            <th>End 1</th>
                                            <th>End 2</th>
                                            <th>Notes</th>
                                        </tr>
                                    </thead>
                                    <tbody id="cutListBody"></tbody>
                                </table>
                                <div class="cut-list-totals">
                                    <div class="total-item">
                                        <span>Total Pieces:</span>
                                        <span id="totalPieces">-</span>
                                    </div>
                                    <div class="total-item">
                                        <span>Total Linear:</span>
                                        <span id="totalLinear">-</span>
                                    </div>
                                    <div class="total-item">
                                        <span>Stock Lengths (6.5m):</span>
                                        <span id="stockLengths">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============ SECTION: BATTEN / PURLIN CALCULATOR ============ -->
        <div class="section" id="sec-battens" style="display:none">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-battens')">
                <div><div class="section-title" id="battenSectionTitle">Purlin &amp; Batten Calculator</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="padding:14px 16px">

                    <!-- ===== RAFTERS SUBSECTION (skillion only â€” spacing detail) ===== -->
                    <div id="rafterSubsection" style="margin-bottom:16px">
                        <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px;border-bottom:1px solid var(--sw-border);padding-bottom:4px">Rafter Spacing</div>

                        <!-- Rafter spacing -->
                        <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">
                            <label style="font-size:11px;color:var(--sw-text-sec);white-space:nowrap;min-width:80px">Spacing (mm):</label>
                            <input type="number" id="inRafterSpacing" value="900" min="300" max="2400" step="50" oninput="onRafterSpacingChange()" style="font-size:11px;padding:4px 8px;border:1px solid var(--sw-border);border-radius:4px;width:80px">
                            <div style="display:flex;gap:4px">
                                <button onclick="setRafterSpacing(900)" style="font-size:10px;padding:2px 6px;border:1px solid var(--sw-border);border-radius:3px;background:#fff;cursor:pointer">900</button>
                                <button onclick="setRafterSpacing(1000)" style="font-size:10px;padding:2px 6px;border:1px solid var(--sw-border);border-radius:3px;background:#fff;cursor:pointer">1000</button>
                                <button onclick="setRafterSpacing(1200)" style="font-size:10px;padding:2px 6px;border:1px solid var(--sw-border);border-radius:3px;background:#fff;cursor:pointer">1200</button>
                            </div>
                        </div>

                        <!-- Rafter result -->
                        <div id="rafterResult" style="background:var(--sw-bg);border-radius:8px;padding:10px;margin-bottom:4px">
                            <div style="font-size:13px;font-weight:600;margin-bottom:4px" id="rafterResultTitle">--</div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="rafterResultSpacing">--</div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="rafterResultLineal">--</div>
                        </div>
                    </div>

                    <!-- ===== BATTENS SUBSECTION (skillion) ===== -->
                    <div id="skillionBattenSubsection">
                        <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px;border-bottom:1px solid var(--sw-border);padding-bottom:4px">Battens</div>

                        <!-- Validation warnings -->
                        <div id="battenWarnings" style="display:none;margin-bottom:10px"></div>

                        <!-- Summary row -->
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px">
                            <div style="font-size:11px;color:var(--sw-text-sec)">Sheet: <strong id="battenSheetLabel" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Max span: <strong id="battenMaxSpan" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Projection: <strong id="battenProjection" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Pitch: <strong id="battenPitch" style="color:var(--sw-text)">--</strong></div>
                        </div>

                        <!-- Result -->
                        <div id="battenResult" style="background:var(--sw-bg);border-radius:8px;padding:12px;margin-bottom:12px">
                            <div style="font-size:13px;font-weight:600;margin-bottom:6px" id="battenResultTitle">--</div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="battenResultSpacing"></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="battenResultPositions"></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="battenResultBrackets"></div>
                        </div>

                        <!-- Extra battens override -->
                        <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
                            <label style="font-size:11px;color:var(--sw-text-sec);white-space:nowrap">Extra battens for rigidity:</label>
                            <button onclick="adjustExtraBattens(-1)" style="width:24px;height:24px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer;font-size:14px;line-height:1">-</button>
                            <span id="extraBattensVal" style="font-size:13px;font-weight:600;min-width:16px;text-align:center">0</span>
                            <button onclick="adjustExtraBattens(1)" style="width:24px;height:24px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer;font-size:14px;line-height:1">+</button>
                        </div>

                        <!-- Bracket type -->
                        <div id="battenBracketType" style="display:none;margin-bottom:12px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:6px">Bracket Type</div>
                            <div style="display:flex;gap:12px">
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="bracketType" value="internal" checked onchange="rebuildAll()"> Internal (hidden, slower)
                                </label>
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="bracketType" value="external" onchange="rebuildAll()"> External (visible, faster)
                                </label>
                            </div>
                            <div id="battenPowdercoatWarn" style="display:none;font-size:10px;color:#E67E22;margin-top:4px">External brackets need powdercoating to match roof colour</div>
                        </div>

                        <!-- Side-view diagram -->
                        <div style="background:#f8f9fa;border:1px solid var(--sw-border);border-radius:6px;padding:10px;overflow-x:auto">
                            <div style="font-size:9px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:6px">Side View (battens run left-to-right across patio)</div>
                            <pre id="battenDiagram" style="font-family:'SF Mono',monospace;font-size:10px;line-height:1.4;color:var(--sw-text);margin:0;white-space:pre"></pre>
                        </div>
                    </div>

                    <!-- ===== GABLE PURLINS SUBSECTION ===== -->
                    <div id="gableBattenSubsection" style="display:none">
                        <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px;border-bottom:1px solid var(--sw-border);padding-bottom:4px">Gable Purlins</div>

                        <!-- Summary row -->
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px">
                            <div style="font-size:11px;color:var(--sw-text-sec)">Sheet: <strong id="gableBattenSheet" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Max span: <strong id="gableBattenMaxSpan" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Rafter length: <strong id="gableBattenRafter" style="color:var(--sw-text)">--</strong></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)">Pitch: <strong id="gableBattenPitch" style="color:var(--sw-text)">--</strong></div>
                        </div>

                        <!-- Extra purlins override -->
                        <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">
                            <label style="font-size:11px;color:var(--sw-text-sec);white-space:nowrap">Extra purlins per side:</label>
                            <button onclick="adjustGableExtraBattens(-1)" style="width:24px;height:24px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer;font-size:14px;line-height:1">-</button>
                            <span id="gableExtraBattensVal" style="font-size:13px;font-weight:600;min-width:16px;text-align:center">0</span>
                            <button onclick="adjustGableExtraBattens(1)" style="width:24px;height:24px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer;font-size:14px;line-height:1">+</button>
                        </div>

                        <!-- Result -->
                        <div id="gableBattenResult" style="background:var(--sw-bg);border-radius:8px;padding:12px;margin-bottom:12px">
                            <div style="font-size:13px;font-weight:600;margin-bottom:6px" id="gableBattenResultTitle">--</div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="gableBattenResultBreakdown"></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="gableBattenResultSpacing"></div>
                            <div style="font-size:11px;color:var(--sw-text-sec)" id="gableBattenResultLineal"></div>
                        </div>

                        <!-- Gable cross-section diagram -->
                        <div style="background:#f8f9fa;border:1px solid var(--sw-border);border-radius:6px;padding:10px;overflow-x:auto">
                            <div style="font-size:9px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:6px">Cross Section (purlins run along patio length)</div>
                            <pre id="gableBattenDiagram" style="font-family:'SF Mono',monospace;font-size:10px;line-height:1.4;color:var(--sw-text);margin:0;white-space:pre"></pre>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: FINISHING ============ -->
        <div class="section" id="sec-finishing">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-finishing')">
                <div><div class="section-title">Finishing</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">

                    <!-- Ceiling Finish (SolarSpan only) -->
                    <div class="basics-group" id="ceilingFinishField" style="display:none">
                        <div class="basics-field" style="margin-bottom:10px">
                            <label>Ceiling Finish</label>
                            <input type="hidden" id="inCeilingFinish" value="plain">
                            <div class="toggle-btn-group">
                                <button type="button" class="toggle-btn active" data-value="plain" onclick="setDesignToggle('inCeilingFinish','plain',this);syncCeilingToggles('plain')">Plain</button>
                                <button type="button" class="toggle-btn" data-value="vj" onclick="setDesignToggle('inCeilingFinish','vj',this);syncCeilingToggles('vj')">VJ Groove</button>
                                <button type="button" class="toggle-btn" data-value="cedar" onclick="setDesignToggle('inCeilingFinish','cedar',this);syncCeilingToggles('cedar')">Cedar Look</button>
                            </div>
                        </div>
                        <div class="basics-divider"></div>
                    </div>

                    <!-- Gable Infill (gable only) -->
                    <div class="basics-group" id="gableInfillField" style="display:none">
                        <div class="basics-field" style="margin-bottom:10px">
                            <label>Gable Infill</label>
                            <select id="inInfill" onchange="rebuildAll()">
                                <option value="colorbond">Colorbond</option>
                                <option value="polycarbonate">Polycarbonate</option>
                                <option value="louvre">Louvre</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                        <div class="basics-divider"></div>
                    </div>

                    <!-- Polycarbonate -->
                    <div id="polycarbField" style="display:none">
                        <div class="basics-group">
                            <div class="basics-group-title">Polycarbonate</div>
                            <div style="display:flex;align-items:center;gap:12px;margin-bottom:6px">
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="no" checked onchange="updatePolycarbUI();rebuildAll()"> No
                                </label>
                                <label style="font-size:11px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="yes" onchange="updatePolycarbUI();rebuildAll()"> Yes
                                </label>
                            </div>
                            <div id="polycarbOptions" style="display:none">
                                <div class="basics-grid-3" style="gap:6px">
                                    <div class="basics-field">
                                        <label>Brand</label>
                                        <select id="inPolycarbBrand" onchange="updatePolycarbTints();rebuildAll()">
                                            <option value="ampelite">Ampelite Solasafe</option>
                                            <option value="laserlite">Laserlite 2000</option>
                                        </select>
                                    </div>
                                    <div class="basics-field">
                                        <label>Tint</label>
                                        <select id="inPolycarbTint" onchange="rebuildAll()"></select>
                                    </div>
                                    <div class="basics-field">
                                        <label>Pattern</label>
                                        <select id="inPolycarbPattern" onchange="updatePolycarbPreview();rebuildAll()">
                                            <option value="2">Every 2nd (1:1)</option>
                                            <option value="3" selected>Every 3rd (2:1)</option>
                                            <option value="4">Every 4th (3:1)</option>
                                            <option value="custom">Custom</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="basics-grid-3" style="gap:6px;margin-top:4px">
                                    <div class="basics-field">
                                        <label>Level</label>
                                        <select id="inPolycarbLevel" onchange="rebuildAll()">
                                            <option value="1">Level 1 - Max Light</option>
                                            <option value="2">Level 2 - Medium</option>
                                        </select>
                                    </div>
                                    <div class="basics-field" id="polycarbProfileNote" style="display:flex;align-items:flex-end">
                                        <span style="font-size:10px;color:var(--sw-text-sec)" id="polycarbProfileLabel"></span>
                                    </div>
                                </div>
                                <div id="polycarbCustomField" style="display:none;margin-top:4px">
                                    <div class="basics-field" style="max-width:140px">
                                        <label>Colorbond per 1 polycarb</label>
                                        <input type="number" id="inPolycarbCustom" value="3" min="1" max="20" step="1" oninput="updatePolycarbPreview();rebuildAll()">
                                    </div>
                                </div>
                                <div style="margin-top:6px">
                                    <div style="font-size:10px;color:var(--sw-text-sec);margin-bottom:3px">Preview</div>
                                    <div id="polycarbPreview" style="display:flex;gap:2px;flex-wrap:wrap"></div>
                                    <div style="font-size:9px;color:var(--sw-text-sec);margin-top:3px">&#9632;=steel &#9633;=polycarb</div>
                                </div>
                            </div>
                        </div>
                        <div class="basics-divider"></div>
                    </div>

                    <!-- Box Gutter Designer -->
                    <div class="basics-group">
                        <button type="button" class="btn btn-secondary" style="font-size:11px;padding:6px 12px" onclick="openGutterDesigner()">Open Box Gutter Designer</button>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- Flashings Editor (moved from standalone section) -->
                    <div class="basics-group">
                        <div class="basics-group-title">Flashings</div>
                        <div class="flash-summary" style="padding:0;border:none;margin-bottom:8px">
                            <span class="flash-summary-text"><span class="flash-summary-count" id="flashSummaryCount">0</span> flashings defined</span>
                            <button class="flash-tool-btn" style="background:var(--sw-orange);color:white;border-color:var(--sw-orange)" onclick="openFlashModal()">Open Editor</button>
                        </div>
                        <table class="flash-table" id="flashJobTable">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Name</th>
                                    <th class="r">Girth</th>
                                    <th class="r">Length</th>
                                    <th class="r">Qty</th>
                                    <th>Colour</th>
                                    <th>Gauge</th>
                                    <th>Side</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody id="flashJobBody"></tbody>
                        </table>
                        <div class="flash-total-row" id="flashTotalRow" style="display:none">
                            Total area: <span id="flashTotalArea">0</span> m&sup2;
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: EXTRAS ============ -->
        <div class="section" id="sec-extras">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-extras')">
                <div><div class="section-title">Extras</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">

                    <!-- 1. EXISTING STRUCTURE -->
                    <div class="basics-group">
                        <div class="basics-group-title">Existing Structure</div>
                        <div class="basics-field" style="margin-bottom:8px">
                            <label>What's There Now?</label>
                            <select id="existingSite" onchange="updateExistingSite()">
                                <option value="clear" selected>Clear site</option>
                                <option value="patio">Old patio</option>
                                <option value="pergola">Pergola</option>
                                <option value="shadesail">Shadesail</option>
                                <option value="deck">Deck</option>
                                <option value="other">Other</option>
                            </select>
                        </div>
                        <div class="basics-field" id="demoNotesField" style="display:none;margin-bottom:8px">
                            <label>Demo Notes</label>
                            <textarea id="demoNotes" rows="2" placeholder="Describe what needs removing and any special requirements..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                            <div style="font-size:10px;color:var(--sw-text-sec);margin-top:2px">Add demo pricing to Additional Items below</div>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 2. SITE ACCESS -->
                    <div class="basics-group">
                        <div class="basics-field">
                            <label>Site Access</label>
                            <div class="toggle-btn-group" id="siteAccessGroup">
                                <button type="button" class="toggle-btn active" data-value="easy" onclick="setToggle('siteAccess', 'easy', this)">Easy</button>
                                <button type="button" class="toggle-btn" data-value="moderate" onclick="setToggle('siteAccess', 'moderate', this)">Moderate</button>
                                <button type="button" class="toggle-btn" data-value="difficult" onclick="setToggle('siteAccess', 'difficult', this)">Difficult</button>
                            </div>
                            <input type="hidden" id="siteAccess" value="easy">
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 3. ELECTRICAL -->
                    <div class="basics-group">
                        <div class="basics-group-title">Electrical</div>
                        <div style="display:flex;flex-wrap:wrap;gap:16px;margin-bottom:8px">
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="elecDownlights" onchange="syncElectricalCheckboxes()"> Downlights
                                <input type="number" id="elecDownlightsQty" value="4" min="1" max="20" style="width:45px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:4px;font-size:11px;text-align:center">
                            </label>
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="elecFan" onchange="syncElectricalCheckboxes()"> Ceiling Fan
                                <input type="number" id="elecFanQty" value="1" min="1" max="5" style="width:45px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:4px;font-size:11px;text-align:center">
                            </label>
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="elecGPO" onchange="syncElectricalCheckboxes()"> GPO
                                <input type="number" id="elecGPOQty" value="1" min="1" max="5" style="width:45px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:4px;font-size:11px;text-align:center">
                            </label>
                        </div>
                        <div id="elecSolarSpanNote" style="display:none;font-size:10px;color:#E67E22;margin-top:4px">Crew runs cable in panel chase. Electrician does final connections.</div>
                        <!-- Hidden dropdown for backward compatibility -->
                        <select id="electrical" style="display:none" onchange="updateUI()">
                            <option value="none" selected>None</option>
                            <option value="downlights">Downlights</option>
                            <option value="fan">Fan point</option>
                            <option value="both">Both</option>
                        </select>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 4. ADDITIONAL CHECKBOXES -->
                    <div class="basics-group">
                        <div style="display:flex;flex-wrap:wrap;gap:16px">
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="scopeSkip"> Skip bin
                            </label>
                            <label style="font-size:11px;display:flex;align-items:center;gap:6px;cursor:pointer">
                                <input type="checkbox" id="scopePermit"> Council permit required
                            </label>
                        </div>
                    </div>

                    <div class="basics-divider"></div>

                    <!-- 5. SITE REFERENCE (collapsible, for work order info) -->
                    <div class="basics-group">
                        <div class="basics-group-title" style="cursor:pointer" onclick="var b=this.nextElementSibling;b.style.display=b.style.display==='none'?'block':'none'">
                            Site Reference <span style="font-size:9px;color:var(--sw-text-sec)">(appears on work order) &#9656;</span>
                        </div>
                        <div id="siteReferenceBody" style="display:none">
                            <div class="basics-grid-3" style="gap:8px">
                                <div class="basics-field">
                                    <label>Existing Roof</label>
                                    <div class="toggle-btn-group" id="existingRoofGroup">
                                        <button type="button" class="toggle-btn active" data-value="tiles" onclick="setToggle('existingRoof', 'tiles', this); rebuildAll()">Tiles</button>
                                        <button type="button" class="toggle-btn" data-value="colorbond" onclick="setToggle('existingRoof', 'colorbond', this); rebuildAll()">Colorbond</button>
                                        <button type="button" class="toggle-btn" data-value="flat" onclick="setToggle('existingRoof', 'flat', this); rebuildAll()">Flat</button>
                                    </div>
                                    <input type="hidden" id="existingRoof" value="tiles">
                                </div>
                                <div class="basics-field">
                                    <label>Fascia Material</label>
                                    <div class="toggle-btn-group" id="fasciaMaterialGroup">
                                        <button type="button" class="toggle-btn active" data-value="timber" onclick="setToggle('fasciaMaterial', 'timber', this)">Timber</button>
                                        <button type="button" class="toggle-btn" data-value="metal" onclick="setToggle('fasciaMaterial', 'metal', this)">Metal</button>
                                        <button type="button" class="toggle-btn" data-value="fc" onclick="setToggle('fasciaMaterial', 'fc', this)">Fibre Cement</button>
                                    </div>
                                    <input type="hidden" id="fasciaMaterial" value="timber">
                                </div>
                                <div class="basics-field">
                                    <label>Wall Type</label>
                                    <div class="toggle-btn-group" id="wallTypeGroup">
                                        <button type="button" class="toggle-btn active" data-value="doublebrick" onclick="setToggle('wallType', 'doublebrick', this)">Double Brick</button>
                                        <button type="button" class="toggle-btn" data-value="veneer" onclick="setToggle('wallType', 'veneer', this)">Brick Veneer</button>
                                        <button type="button" class="toggle-btn" data-value="rendered" onclick="setToggle('wallType', 'rendered', this)">Rendered</button>
                                    </div>
                                    <input type="hidden" id="wallType" value="doublebrick">
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- Fullscreen flashing editor modal (outside section flow) -->
        <div class="flash-modal-overlay" id="flashModalOverlay">
            <div class="flash-modal">
                <!-- Header with tabs -->
                <div class="flash-modal-header">
                    <div class="flash-modal-tabs">
                        <button class="flash-tab active" id="flashTabStandard" onclick="switchFlashTab('standard')">Standard Flashings</button>
                        <button class="flash-tab" id="flashTabBoxGutter" onclick="switchFlashTab('boxgutter')">Box Gutter</button>
                    </div>
                    <button class="flash-modal-close" onclick="closeFlashModal()" title="Close">&times;</button>
                </div>
                <!-- Standard flashing body: sidebar + canvas -->
                <div class="flash-modal-body" id="flashBodyStandard">
                    <!-- Left sidebar: templates -->
                    <div class="flash-sidebar">
                        <div class="flash-sidebar-title">Templates</div>
                        <div class="flash-sidebar-scroll" id="flashTemplates"></div>
                        <div style="padding:6px 8px;border-top:1px solid var(--sw-border)">
                            <div class="flash-tpl" style="border-style:dashed;cursor:pointer;display:inline-block" onclick="saveFlashTemplate()">
                                <div style="font-size:16px;color:var(--sw-text-sec)">+</div>
                                <div class="flash-tpl-name">Save Current</div>
                            </div>
                        </div>
                    </div>
                    <!-- Right: canvas area -->
                    <div class="flash-canvas-area">
                        <div class="flash-viewport" id="flashViewport">
                            <canvas id="flashCanvas"></canvas>
                            <!-- Inspector panel (floating) -->
                            <div class="flash-inspector" id="flashInspector" style="display:none">
                                <div class="flash-inspector-header">
                                    <span id="flashInspTitle">Point 1</span>
                                    <button class="flash-inspector-close" onclick="closeFlashInspector()">&times;</button>
                                </div>
                                <div class="flash-inspector-body" id="flashInspBody"></div>
                            </div>
                            <!-- Floating zoom panel -->
                            <div class="flash-zoom-panel">
                                <button class="flash-zpanel-btn" onclick="flashZoomIn()" title="Zoom in">+</button>
                                <button class="flash-zpanel-btn" onclick="flashZoomOut()" title="Zoom out">&minus;</button>
                                <button class="flash-zpanel-btn" onclick="flashZoomFit()" title="Fit to view">&#8865;</button>
                            </div>
                        </div>
                        <!-- Info bar -->
                        <div class="flash-info" id="flashInfoBar">
                            <span>Girth: <span class="flash-info-val" id="flashGirth">0</span> mm</span>
                            <span>Legs: <span class="flash-info-val" id="flashLegs">0</span></span>
                            <span style="margin-left:auto"></span>
                            <div class="flash-zoom-ctrl">
                                <button class="flash-zoom-btn" onclick="flashZoomIn()" title="Zoom in">+</button>
                                <span class="flash-info-val" id="flashZoom">10</span>
                                <span style="font-size:9px;color:var(--sw-text-sec)">mm/grid</span>
                                <button class="flash-zoom-btn" onclick="flashZoomOut()" title="Zoom out">&minus;</button>
                                <button class="flash-zoom-btn" onclick="flashZoomFit()" title="Fit profile to view" style="font-size:9px;width:auto;padding:0 6px">Fit</button>
                            </div>
                        </div>
                        <!-- Status bar (mode-aware) -->
                        <div class="flash-status-bar" id="flashStatusBar">
                            <span id="flashStatusMode" class="flash-status-mode">VIEWING</span>
                            <span class="flash-status-sep"></span>
                            <span id="flashStatusHints">Double-click to start drawing &bull; Click point to select &bull; Scroll to zoom</span>
                            <span style="flex:1"></span>
                            <button id="flashStatusBtn" class="flash-status-btn" style="display:none" onclick="flashStatusAction()">Cancel</button>
                        </div>
                        <!-- Toolbar -->
                        <div class="flash-toolbar">
                            <button class="flash-tool-btn" onclick="flashUndo()" title="Undo (Ctrl+Z)">Undo</button>
                            <button class="flash-tool-btn" onclick="flashRedo()" title="Redo (Ctrl+Y)">Redo</button>
                            <div class="flash-tool-sep"></div>
                            <button class="flash-tool-btn" onclick="flashClearConfirm()" title="Clear entire profile">Clear All</button>
                            <div class="flash-tool-sep"></div>
                            <button class="flash-tool-btn" id="flashDrawToggle" onclick="toggleFlashDraw()" title="Draw mode (D)">&#9998; Draw</button>
                            <div class="flash-tool-sep"></div>
                            <button class="flash-tool-btn" id="flashSnapToggle" onclick="toggleFlashSnap()" title="Toggle 45Â° angle snapping">Snap: OFF</button>
                            <div class="flash-tool-sep"></div>
                            <button class="flash-tool-btn" onclick="flashFlipH()" title="Flip horizontal (H)">Flip H</button>
                            <button class="flash-tool-btn" onclick="flashFlipV()" title="Flip vertical (V)">Flip V</button>
                            <div class="flash-tool-sep"></div>
                            <div class="flash-colour-side" style="display:flex;align-items:center;gap:4px">
                                <button class="flash-tool-btn" id="flashColourFlipBtn" onclick="flipColourSide()" title="Flip colour face" style="min-width:auto;padding:3px 8px;font-size:10px;font-weight:600">
                                    &#x21C5; Colour: <span id="flashColourSideLabel">Inside</span>
                                </button>
                            </div>
                            <div class="flash-tool-sep"></div>
                            <div style="display:flex;align-items:center;gap:4px">
                                <span style="font-size:10px;color:var(--sw-text-sec)">Start:</span>
                                <select id="flashStartTreat" onchange="updateFlashTreatment('start')" style="font-size:10px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:3px">
                                    <option value="none">None</option>
                                    <option value="miniBreak">Mini Break</option>
                                    <option value="hem">Hem</option>
                                </select>
                                <span style="font-size:10px;color:var(--sw-text-sec)">End:</span>
                                <select id="flashEndTreat" onchange="updateFlashTreatment('end')" style="font-size:10px;padding:2px 4px;border:1px solid var(--sw-border);border-radius:3px">
                                    <option value="none">None</option>
                                    <option value="miniBreak">Mini Break</option>
                                    <option value="hem">Hem</option>
                                </select>
                            </div>
                            <div id="flashTreatOpts" style="display:none;align-items:center;gap:4px">
                                <span style="font-size:9px;color:var(--sw-text-sec)">Size:</span>
                                <input type="number" id="flashTreatSize" value="10" min="3" max="30" style="width:36px;font-size:10px;padding:1px 3px;border:1px solid var(--sw-border);border-radius:3px">
                                <span style="font-size:9px;color:var(--sw-text-sec)">Angle:</span>
                                <input type="number" id="flashTreatAngle" value="45" min="10" max="90" step="5" style="width:36px;font-size:10px;padding:1px 3px;border:1px solid var(--sw-border);border-radius:3px">
                                <button class="flash-cs-btn active" id="flashTreatDirOut" onclick="setTreatDir('out')" style="font-size:9px;padding:1px 5px">Out</button>
                                <button class="flash-cs-btn" id="flashTreatDirIn" onclick="setTreatDir('in')" style="font-size:9px;padding:1px 5px">In</button>
                            </div>
                            <div style="flex:1"></div>
                            <button class="flash-tool-btn" style="background:var(--sw-orange);color:white;border-color:var(--sw-orange)" onclick="flashAddToJob()">+ Add to Job</button>
                        </div>
                        <!-- Add to job fields -->
                        <div class="flash-add-bar">
                            <div><label>Name</label><input type="text" id="flashName" placeholder="Apron - Back Wall" value=""></div>
                            <div><label>Colour</label>
                                <select id="flashColour">
                                    <option>Monument</option><option>Woodland Grey</option><option>Paperbark</option><option>Surfmist</option>
                                    <option>Basalt</option><option>Manor Red</option><option selected>Deep Ocean</option><option>Windspray</option>
                                </select>
                            </div>
                            <div><label>Gauge</label>
                                <select id="flashGauge">
                                    <option value="0.42" selected>0.42</option><option value="0.48">0.48</option><option value="0.55">0.55</option>
                                </select>
                            </div>
                            <div><label>Length <span style="font-size:9px;color:var(--sw-text-sec)">mm</span></label><input type="number" id="flashLength" value="4500" step="100"></div>
                            <div><label>Qty</label><input type="number" id="flashQty" value="1" min="1" step="1"></div>
                        </div>
                    </div>
                </div>
                <!-- Box Gutter body -->
                <div class="flash-modal-body" id="flashBodyBoxGutter" style="display:none;flex-direction:column;padding:20px;overflow-y:auto">
                    <div style="max-width:600px;margin:0 auto;width:100%">
                        <h3 style="font-size:14px;font-weight:700;margin-bottom:16px;color:var(--sw-text)">BOX GUTTER DESIGNER</h3>
                        <!-- Catchment -->
                        <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Catchment &amp; Sizing</div>
                            <div class="basics-grid-2" style="gap:8px;margin-bottom:8px">
                                <div class="basics-field">
                                    <label>House roof catchment (m&sup2;)</label>
                                    <input type="number" id="bgCatchment" value="85" min="10" max="500" step="5" oninput="updateBGDesigner()">
                                </div>
                                <div class="basics-field">
                                    <label>Patio adds to catchment?</label>
                                    <div class="toggle-btn-group" id="bgPatioCatchGroup">
                                        <button type="button" class="toggle-btn" data-value="no" onclick="setToggle('bgPatioCatch','no',this);updateBGDesigner()">No</button>
                                        <button type="button" class="toggle-btn active" data-value="yes" onclick="setToggle('bgPatioCatch','yes',this);updateBGDesigner()">Yes</button>
                                    </div>
                                    <input type="hidden" id="bgPatioCatch" value="yes">
                                </div>
                            </div>
                            <div id="bgCatchSummary" style="font-size:11px;color:var(--sw-text-sec);margin-bottom:4px">Total catchment: -- m&sup2;</div>
                            <div id="bgWidthRec" style="font-size:12px;font-weight:600;color:var(--sw-text)">Minimum width required: --</div>
                            <div id="bgCatchWarn" style="display:none;font-size:10px;color:#7D6608;background:#FEF9E7;border:1px solid #F39C12;border-radius:4px;padding:4px 8px;margin-top:6px"></div>
                        </div>
                        <!-- Dimensions -->
                        <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Dimensions</div>
                            <div class="basics-grid-2" style="gap:8px">
                                <div class="basics-field"><label>Width (mm)</label><input type="number" id="bgWidth" value="300" min="200" max="600" step="10" oninput="updateBGDesigner()"></div>
                                <div class="basics-field"><label>Depth (mm)</label><input type="number" id="bgDepth" value="100" min="50" max="200" step="10" oninput="updateBGDesigner()"></div>
                                <div class="basics-field"><label>Back Height (mm)</label><input type="number" id="bgBackH" value="70" min="30" max="200" step="5" oninput="updateBGDesigner()"></div>
                                <div class="basics-field"><label>Front Height (mm)</label><input type="number" id="bgFrontH" value="130" min="50" max="300" step="5" oninput="updateBGDesigner()"></div>
                                <div class="basics-field"><label>Length (mm)</label><input type="number" id="bgLength" value="6200" min="1000" max="12000" step="100" oninput="updateBGDesigner()"></div>
                            </div>
                            <div id="bgDimWarn" style="display:none;font-size:10px;color:#7D6608;background:#FEF9E7;border:1px solid #F39C12;border-radius:4px;padding:4px 8px;margin-top:6px"></div>
                        </div>
                        <!-- Material -->
                        <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Material</div>
                            <div class="basics-grid-2" style="gap:8px">
                                <div class="basics-field">
                                    <label>Gauge</label>
                                    <select id="bgGauge" onchange="updateBGDesigner()"><option value="0.42">0.42 BMT</option><option value="0.48">0.48 BMT</option><option value="0.55" selected>0.55 BMT</option></select>
                                </div>
                                <div class="basics-field">
                                    <label>Colour</label>
                                    <select id="bgColour"><option>Monument</option><option>Woodland Grey</option><option>Paperbark</option><option>Surfmist</option><option>Basalt</option><option selected>Deep Ocean</option><option>Windspray</option></select>
                                </div>
                            </div>
                            <div style="margin-top:6px">
                                <label style="font-size:10px;color:var(--sw-text-sec)">Colour side:</label>
                                <span style="font-size:11px;font-weight:600"> Inside (channel)</span>
                            </div>
                        </div>
                        <!-- Outlet -->
                        <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Outlet</div>
                            <div class="basics-grid-2" style="gap:8px">
                                <div class="basics-field">
                                    <label>Position</label>
                                    <select id="bgOutletPos"><option value="left">Left end</option><option value="right" selected>Right end</option><option value="centre">Centre</option><option value="both">Both ends</option></select>
                                </div>
                                <div class="basics-field">
                                    <label>Size</label>
                                    <select id="bgOutletSize"><option value="90round">90mm round</option><option value="100round" selected>100mm round</option></select>
                                </div>
                            </div>
                        </div>
                        <!-- Profile Preview -->
                        <div style="margin-bottom:16px;padding:12px;background:#fff;border:1px solid var(--sw-border);border-radius:8px">
                            <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-accent);margin-bottom:8px">Profile Preview</div>
                            <canvas id="bgPreviewCanvas" width="560" height="200" style="width:100%;height:200px;border:1px solid #eee;border-radius:4px"></canvas>
                        </div>
                        <!-- Validation -->
                        <div id="bgValidation" style="margin-bottom:16px"></div>
                        <!-- Add button -->
                        <button class="flash-tool-btn" style="background:var(--sw-orange);color:white;border-color:var(--sw-orange);width:100%;padding:10px;font-size:13px" onclick="bgAddToJob()">+ Add Box Gutter to Job</button>
                    </div>
                </div>
            </div>
        </div>

        </div><!-- end group-build -->

        <!-- Hidden elements (JS targets, not visible) -->
        <div id="preOrderChecks" style="display:none"></div>
        <div style="display:none"><div id="matList"></div></div>

        <!-- ======== GROUP: SALE ======== -->
        <div class="section-group" id="group-sale">
        <div class="section-group-header">Sale</div>

        <!-- ============ SECTION: PRICING & COSTS ============ -->
        <div class="section" id="sec-pricing">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-pricing')">
                <div><div class="section-title">Pricing &amp; Costs</div></div>
                <div style="display:flex;align-items:center;gap:8px">
                    <button class="settings-gear" onclick="event.stopPropagation();openRatesModal()" title="Stored Rates">&#9881;</button>
                    <span class="collapse-arrow">&#9656;</span>
                </div>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body" style="background:#f5f5f5;padding:16px">

                    <!-- ===== SUB-SECTION 1: PATIO MATERIALS ===== -->
                    <div class="pricing-subsection">
                        <div class="pricing-sub-hdr" style="border-left-color:#E8552A">
                            <span>Patio Materials</span>
                            <span style="font-size:10px;font-weight:400;color:var(--sw-text-sec)">Auto-calculated from design</span>
                        </div>
                        <div class="pricing-sub-body">
                            <div class="scoper-only" style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
                                <label style="font-size:11px;color:var(--sw-text-sec)">Markup:</label>
                                <input type="number" id="globalMarkupPct" value="35" min="0" max="200" step="1" style="width:55px;padding:3px 6px;border:1px solid var(--sw-border);border-radius:4px;font-size:11px;text-align:center" onchange="applyMarkupAll()">
                                <span style="font-size:11px;color:var(--sw-text-sec)">%</span>
                                <button style="font-size:10px;padding:3px 8px;border:1px solid var(--sw-border);border-radius:4px;background:#fff;cursor:pointer" onclick="applyMarkupAll()">Apply All</button>
                            </div>
                            <div id="patioMaterialsTable"></div>
                            <div class="pricing-subtotal" id="matSubtotal">
                                <span>Patio Materials Subtotal:</span>
                                <span id="matSellDisplay">$0</span>
                                <span class="scoper-only" style="font-size:10px;color:var(--sw-text-sec)">(cost: <span id="matCostDisplay">$0</span> | markup: <span id="matMarkupPct">0%</span>)</span>
                            </div>
                        </div>
                    </div>

                    <!-- ===== SUB-SECTION 2: ADDITIONAL MATERIALS ===== -->
                    <div class="pricing-subsection">
                        <div class="pricing-sub-hdr" style="border-left-color:#2980B9">
                            <span>Additional Materials</span>
                        </div>
                        <div class="pricing-sub-body">
                            <div id="additionalMaterialsTable"></div>
                            <div class="am-quick-add">
                                <span style="font-size:10px;color:var(--sw-text-sec);font-weight:600">Quick add:</span>
                                <button class="extras-pill" onclick="quickAddMaterial('post')">+ Extra Post</button>
                                <button class="extras-pill" onclick="quickAddMaterial('other')">+ Other</button>
                                <button class="extras-pill" onclick="addExtra('footings')">+ Footings</button>
                                <button class="extras-pill" onclick="addExtra('electrical')">+ Electrical</button>
                                <button class="extras-pill" onclick="addExtra('downlights')">+ Downlights</button>
                                <button class="extras-pill" onclick="addExtra('demo')">+ Demo</button>
                                <button class="extras-pill" onclick="addExtra('delivery')">+ Delivery</button>
                                <button class="extras-pill" onclick="addExtra('crane')">+ Crane Hire</button>
                                <button class="extras-pill" onclick="addExtra('permit')">+ Council/Permit</button>
                                <button class="extras-pill" onclick="addExtra('soakwell')">+ Soakwell</button>
                                <button class="extras-pill" onclick="addExtra('skip')">+ Skip Bin</button>
                                <button class="extras-pill" onclick="addExtra('other')">+ Custom</button>
                            </div>
                            <div class="pricing-subtotal" id="addMatSubtotal" style="display:none">
                                <span>Additional Subtotal:</span>
                                <span class="scoper-only" style="font-size:10px;color:var(--sw-text-sec)">(cost: <span id="addMatCostDisplay">$0</span>)</span>
                                <span id="addMatSellDisplay">$0</span>
                            </div>
                        </div>
                    </div>

                    <!-- Scope items merged into quick-add above. Keep container for added rows -->
                    <div id="extrasRowsContainer" style="margin-top:6px"></div>
                    <div class="pricing-subtotal" id="scopeSubtotal" style="display:none">
                        <span>Scope Subtotal:</span>
                        <span id="scopeSellDisplay">$0</span>
                    </div>

                    <!-- ===== SUB-SECTION 4: LABOUR ===== -->
                    <div class="pricing-subsection">
                        <div class="pricing-sub-hdr" style="border-left-color:#666">
                            <span>Labour</span>
                        </div>
                        <div class="pricing-sub-body">
                            <div class="labour-inline scoper-only">
                                <input type="number" class="li-input" id="labTrades" value="2" min="0" step="1" oninput="updateLabour()">
                                <span class="li-label">trades</span>
                                <input type="number" class="li-input" id="labLabourers" value="0" min="0" step="1" oninput="updateLabour()">
                                <span class="li-label">labourers</span>
                                <span class="li-label">&times;</span>
                                <input type="number" class="li-input" id="labDays" value="1.5" min="0.5" step="0.5" oninput="updateLabour()">
                                <span class="li-label">days</span>
                            </div>
                            <div style="display:flex;gap:16px;margin-top:8px;font-size:12px">
                                <span class="scoper-only">Cost: <strong id="labCostDisplay">$0</strong></span>
                                <span>Sell: <strong id="labSellDisplay">$0</strong></span>
                            </div>
                            <!-- Hidden fields for backward compat with export/import -->
                            <input type="hidden" id="labDayRate" value="400">
                            <input type="hidden" id="labSellInput" value="2000">
                        </div>
                    </div>

                    <!-- ===== TOTAL + OUTPUTS ===== -->
                    <!-- Output buttons (non-sticky, stay in flow) -->
                    <div style="background:#fff;border-radius:8px;padding:14px 16px;box-shadow:0 1px 4px rgba(0,0,0,0.06);text-align:center;margin-bottom:8px">
                        <!-- QA verification action -->
                        <div style="margin-bottom:10px">
                            <button class="btn" onclick="patioQA.showScopeVerification()" style="background:#22C55E;color:#fff;width:100%;padding:12px 16px;font-size:14px;font-weight:700;border-radius:6px;border:none;cursor:pointer">Review &amp; Sign Off</button>
                        </div>
                        <div id="patioQABanner" style="display:none"></div>
                        <!-- Quote exports (locked until scope signed off) -->
                        <div class="output-buttons" style="margin-bottom:8px">
                            <button class="btn btn-primary qa-locked-btn" id="btnPatioQuotePDF" onclick="generateQuotePDF()">Quote PDF</button>
                            <button class="btn btn-primary qa-locked-btn" id="btnPatioEmailQuote" onclick="emailQuotePDF()" style="background:#293C46">Email Quote</button>
                        </div>
                        <!-- Material gated exports -->
                        <div class="output-buttons" style="margin-bottom:8px">
                            <button class="btn btn-primary qa-locked-btn" id="btnPatioWorkOrder" data-tooltip="Pending material review" onclick="showToast('Work order locked â€” pending material review sign-off')">Work Order</button>
                            <button class="btn btn-primary qa-locked-btn" id="btnPatioMaterialOrder" data-tooltip="Pending material review" onclick="patioQA.showDraftPreview()">Material Order</button>
                            <button class="btn btn-primary" id="btnPatioReviewMaterials" onclick="patioQA.showMaterialReview()" style="display:none;background:#F59E0B;color:#fff">Review Materials</button>
                        </div>
                        <div id="materialOrderOptions" class="material-order-options" style="display: none;">
                            <span style="color: #888; font-size: 12px; margin-right: 6px;">Copy section:</span>
                            <button onclick="copySectionToClipboard('steel')" class="btn-small">Copy Steel</button>
                            <button onclick="copySectionToClipboard('sheets')" class="btn-small">Copy Sheets</button>
                            <button onclick="copySectionToClipboard('fab')" class="btn-small" id="copyFabBtn">Copy Fab</button>
                            <button onclick="downloadMaterialOrderPDF()" class="btn-small" style="border-color:var(--sw-orange);color:var(--sw-orange)">Download PDF</button>
                        </div>
                        <!-- Save/Load -->
                        <div style="display:flex;justify-content:center;gap:8px;margin-top:6px">
                            <button class="btn btn-secondary" onclick="exportRawData()">Save Job</button>
                            <label class="btn btn-secondary" style="cursor: pointer;">
                                Load Job
                                <input type="file" accept=".json" onchange="loadRawData(this.files[0])" style="display: none;">
                            </label>
                        </div>
                    </div>

                    <!-- Hidden field for backward compatibility -->
                    <textarea id="noteMaterialOrder" style="display:none"></textarea>

                    <!-- ===== TOTALS TABLE ===== -->
                    <div class="pricing-subsection">
                        <div class="pricing-sub-hdr" style="border-left-color:#293C46">
                            <span>Totals</span>
                            <button id="clientModeBtn" onclick="toggleClientMode()" style="margin-left:auto;font-size:9px;padding:2px 8px;border:1px solid var(--sw-border);border-radius:4px;background:white;cursor:pointer;font-weight:600;color:var(--sw-text-sec)" title="Toggle client-safe view (hides costs and margins)">Client View</button>
                        </div>
                        <div class="pricing-sub-body">
                            <table class="totals-table" id="totalsTable">
                                <thead><tr><th></th><th class="r scoper-only">Cost</th><th class="r">Price</th></tr></thead>
                                <tbody>
                                    <tr><td>Patio Materials</td><td class="r mono scoper-only" id="ttMatCost">$0</td><td class="r mono" id="ttMatSell">$0</td></tr>
                                    <tr id="ttAddRow"><td>Additional Materials</td><td class="r mono scoper-only" id="ttAddCost">$0</td><td class="r mono" id="ttAddSell">$0</td></tr>
                                    <tr id="ttScopeRow"><td>Scope Items</td><td class="r mono scoper-only" id="ttScopeCost">$0</td><td class="r mono" id="ttScopeSell">$0</td></tr>
                                    <tr><td>Labour</td><td class="r mono scoper-only" id="ttLabCost">$0</td><td class="r mono" id="ttLabSell">$0</td></tr>
                                </tbody>
                                <tfoot>
                                    <tr class="tt-subtotal"><td>Subtotal (ex GST)</td><td class="r mono scoper-only" id="ttSubCost">$0</td><td class="r mono" id="ttSubSell">$0</td></tr>
                                    <tr class="tt-gst"><td>GST (10%)</td><td class="r mono"></td><td class="r mono" id="ttGst">$0</td></tr>
                                    <tr class="tt-total"><td>TOTAL (inc GST)</td><td class="r mono"></td><td class="r mono" id="ttTotal">$0</td></tr>
                                    <tr class="tt-margin"><td>Margin</td><td class="r mono" colspan="2" id="ttMargin">$0 (0%)</td></tr>
                                </tfoot>
                            </table>
                        </div>
                    </div>

                    <!-- Sticky total bar -->
                    <div class="total-card" id="totalCard">
                        <div class="total-amount" id="totalAmountDisplay" style="font-size:24px">TOTAL $0 inc GST</div>
                        <div class="total-breakdown" id="totalBreakdown">
                            <span><span class="bd-label">Materials:</span> <span class="bd-val" id="bdMatVal">$0</span></span>
                            <span><span class="bd-label">Additional:</span> <span class="bd-val" id="bdAddVal">$0</span></span>
                            <span><span class="bd-label">Scope:</span> <span class="bd-val" id="bdScopeVal">$0</span></span>
                            <span><span class="bd-label">Labour:</span> <span class="bd-val" id="bdLabVal">$0</span></span>
                        </div>
                        <div class="total-margin" id="totalMarginDisplay" style="font-size:12px;margin-top:4px">Margin: $0 (0%)</div>
                    </div>

                    <!-- Keep legacy textarea hidden for compat -->
                    <textarea id="pricingNotes" style="display:none"></textarea>

                </div>
            </div>
        </div>

        <!-- ============ SECTION: NOTES ============ -->
        <div class="section" id="sec-notes">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-notes')">
                <div><div class="section-title">Notes</div></div>
                <span class="collapse-arrow">&#9656;</span>
            </div>
            <div class="collapse-body shut" style="max-height:0">
                <div class="section-body">
                    <div class="basics-group">
                        <div class="basics-field" style="margin-bottom:12px">
                            <label style="font-weight:600;font-size:11px">Quote Note <span style="font-weight:400;color:var(--sw-text-sec)">(appears on customer quote)</span></label>
                            <textarea id="noteQuote" rows="2" placeholder="e.g. Price includes removal of existing pergola..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                        </div>
                        <div class="basics-field" style="margin-bottom:12px">
                            <label style="font-weight:600;font-size:11px">Work Order Note <span style="font-weight:400;color:var(--sw-text-sec)">(for install crew)</span></label>
                            <textarea id="noteWorkOrder" rows="2" placeholder="e.g. Access via side gate, dog on property..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                        </div>
                        <div class="basics-field">
                            <label style="font-weight:600;font-size:11px">Internal Note <span style="font-weight:400;color:var(--sw-text-sec)">(office only &mdash; doesn't print)</span></label>
                            <textarea id="noteInternal" rows="2" placeholder="e.g. Margin notes, follow-up reminders..." style="width:100%;font-size:11px;padding:6px 8px;border:1px solid var(--sw-border);border-radius:6px"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        </div><!-- end group-sale -->

        </div><!-- end panel-left -->

        <div class="panel-right" id="panelRight">

            <!-- Top row: Price Summary + Site Plan side-by-side -->
            <div style="display:flex;gap:12px;margin-bottom:16px;align-items:stretch">

                <!-- Price Summary (60%) -->
                <div class="rp-price-card" id="rpPriceCard" style="flex:3;margin-bottom:0;position:relative">
                    <button id="clientModeBtnTop" onclick="toggleClientMode()" style="position:absolute;top:6px;right:8px;font-size:8px;padding:2px 6px;border:1px solid var(--sw-border);border-radius:3px;background:white;cursor:pointer;font-weight:600;color:var(--sw-text-sec);z-index:1" title="Toggle client-safe view">Client View</button>
                    <div class="rp-price-body">
                        <div>
                            <div class="rp-price-total" id="rpPriceTotal">$0 inc GST</div>
                            <div class="rp-price-margin scoper-only" id="rpPriceMargin"></div>
                        </div>
                        <div style="text-align:right">
                            <div class="rp-price-sqm"><span id="rpDims">6.0m &times; 3.0m</span> &bull; <span id="rpRoofType">Skillion</span></div>
                            <div class="rp-price-sqm"><span id="rpMaterial">Corrugated</span> &bull; <span id="rpColour">Monument</span></div>
                            <div class="rp-price-sqm" style="font-size:10px;color:var(--sw-text-sec)">Rise: <span id="rpRise">--</span> &bull; Rafter: <span id="rpRafter">--</span></div>
                        </div>
                    </div>
                    <!-- Mini breakdown -->
                    <div class="rp-breakdown" id="rpBreakdown">
                        <div class="rp-bd-row"><span>Materials</span><span id="rpBdMat">$0</span></div>
                        <div class="rp-bd-row"><span>Labour</span><span id="rpBdLab">$0</span></div>
                        <div class="rp-bd-row" id="rpBdScopeRow" style="display:none"><span>Scope Items</span><span id="rpBdScope">$0</span></div>
                        <div class="rp-bd-row rp-bd-total"><span>Subtotal (ex GST)</span><span id="rpBdSubtotal">$0</span></div>
                        <div class="rp-bd-row"><span>GST 10%</span><span id="rpBdGst">$0</span></div>
                    </div>
                    <div style="display:flex;justify-content:center;padding:4px 16px 10px;gap:8px">
                        <div class="rp-est-range" id="rpEstRange" style="font-size:13px;padding:0">&mdash;</div>
                        <button class="btn btn-secondary" style="font-size:10px;padding:3px 8px" onclick="copyEstimate()">Copy</button>
                    </div>
                </div>

                <!-- Site Plan (40%) -->
                <div class="rp-card" style="flex:2;margin-bottom:0;display:flex;flex-direction:column">
                    <div class="rp-card-hdr" style="padding:8px 12px;font-size:12px">Site Plan</div>
                    <div class="rp-card-body" style="padding:6px;flex:1;display:flex">
                        <div class="plan-2d" style="flex:1;min-height:140px"><canvas id="plan2d"></canvas></div>
                    </div>
                </div>

            </div>

            <!-- 3D Assembly Preview -->
            <div class="rp-card">
                <div class="rp-card-hdr">3D Preview</div>
                <div class="asm-viewport" id="asmViewport" style="height:360px;border-radius:0">
                    <canvas id="asmCanvas"></canvas>
                    <!-- Top-right toolbar -->
                    <div class="asm-toolbar">
                        <select id="scenePresetSelect" onchange="switchScenePreset(this.value)" style="font-size:12px;padding:4px 8px;border-radius:4px;border:1px solid #ccc;background:#fff;cursor:pointer">
                            <option value="backyard">Backyard</option>
                            <option value="carport">Carport</option>
                        </select>
                        <div class="asm-tool-sep"></div>
                        <button class="asm-tool-btn" id="dimToggleBtn" onclick="toggleAsmDimensions()">&#x1F4D0; Dimensions</button>
                        <div class="asm-tool-sep"></div>
                        <select id="asmSectionSelect" onchange="handleAsmSectionChange(this.value)">
                            <option value="">Section Views...</option>
                            <option value="riser">Riser Detail</option>
                            <option value="post">Post Detail</option>
                            <option value="gutter">Gutter Detail</option>
                            <option value="ridge">Ridge Detail</option>
                        </select>
                        <div class="asm-tool-sep"></div>
                        <button class="asm-tool-btn" onclick="toggleFullscreen()">&#x26F6; Fullscreen</button>
                        <button class="asm-tool-btn primary" onclick="exportWorkOrderViews()">&#x1F4F7; Export Views</button>
                    </div>
                    <div class="layer-panel">
                        <div class="layer-title">Layers</div>
                        <div class="layer-item active" data-layer="steel" onclick="toggleLayer('steel',this)"><span class="layer-check"></span>Steel</div>
                        <div class="layer-item active" data-layer="roof" onclick="toggleLayer('roof',this)"><span class="layer-check"></span>Roofing</div>
                        <div class="layer-item active" data-layer="acc" onclick="toggleLayer('acc',this)"><span class="layer-check"></span>Gutters/DP</div>
                        <div class="layer-item active" data-layer="house" onclick="toggleLayer('house',this)"><span class="layer-check"></span>House</div>
                    </div>
                    <div class="tooltip" id="tooltip"><div class="tooltip-title" id="ttTitle"></div><div id="ttContent"></div></div>
                    <div id="asmPropertiesPanel" class="properties-panel" style="display: none;"></div>
                    <div class="view-panel">
                        <button class="view-btn active" data-view="3d" onclick="setAsmView('3d',this)">3D</button>
                        <button class="view-btn" data-view="front" onclick="setAsmView('front',this)">Front</button>
                        <button class="view-btn" data-view="side" onclick="setAsmView('side',this)">Side</button>
                        <button class="view-btn" data-view="top" onclick="setAsmView('top',this)">Top</button>
                    </div>
                    <div class="zoom-panel">
                        <button class="zoom-btn" onclick="zoomStep(1)" title="Zoom in">+</button>
                        <button class="zoom-btn" onclick="zoomStep(-1)" title="Zoom out">&minus;</button>
                        <button class="zoom-btn" onclick="setAsmView('3d',document.querySelector('.view-btn[data-view=\'3d\']'))" title="Reset view" style="font-size:14px;margin-top:4px">&#8634;</button>
                    </div>
                </div>
            </div>

            <!-- Customer Preview Generator (collapsible) -->
            <div class="rp-card" id="aiPreviewSection">
                <div class="rp-card-hdr" style="cursor:pointer" onclick="var t=document.getElementById('aiPreviewBody');t.style.display=t.style.display==='none'?'':'none'">Customer Preview Generator <span style="float:right;font-size:11px;color:var(--sw-text-sec)">&#9662;</span></div>
                <div id="aiPreviewBody" class="rp-card-body">
                    <p style="margin: 0 0 12px 0; font-size: 13px; color: #666;">
                        Generate a photorealistic image for your customer using AI.
                    </p>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button id="screenshot3DBtn" onclick="capture3DScreenshot()">
                            1. Screenshot 3D
                        </button>
                        <button id="generatePromptBtn" onclick="generateGeminiPrompt()">
                            2. Copy Prompt &amp; Open Gemini
                        </button>
                    </div>
                    <div id="screenshotPreview" style="display: none; margin-top: 12px;">
                        <p style="font-size: 12px; color: #666; margin-bottom: 8px;">3D Screenshot (right-click to save):</p>
                        <img id="screenshotImg" style="max-width: 300px; border: 1px solid #ddd; border-radius: 4px;">
                    </div>
                    <div id="promptInstructions" style="display: none; margin-top: 12px; padding: 12px; background: #e8f5e9; border-radius: 4px;">
                        <p style="margin: 0; font-size: 13px; color: #2e7d32; line-height: 1.5;">
                            &#10004; Prompt copied to clipboard!<br><br>
                            In Gemini:<br>
                            1. Upload the 3D screenshot (saved above)<br>
                            2. Optionally upload a site photo for realistic compositing<br>
                            3. Paste the prompt (Ctrl+V / Cmd+V)<br>
                            4. Hit Generate<br><br>
                            <em>Tip: Without a site photo, Gemini will generate a typical Perth suburban house as backdrop.</em>
                        </p>
                    </div>
                </div>
            </div>

            <!-- Hidden: rpEstSqm for updateEstimate() compatibility -->
            <div style="display:none"><span id="rpEstSqm"></span></div>

        </div><!-- end panel-right -->

        <!-- Hidden: Complexity scores preserved for export/import -->
        <div style="display:none">
            <input type="number" id="cxBuild" value="3"><input type="number" id="cxAccess" value="3">
            <input type="number" id="cxDistance" value="2"><input type="number" id="cxFooting" value="3"><input type="number" id="cxHeight" value="2">
        </div>

        <!-- Materials Edit Modal -->
        <div id="materialsModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)closeMaterialsModal()">
            <div class="mat-modal">
                <h3>Materials &amp; Pricing</h3>
                <div class="mat-modal-controls">
                    <label>Markup:</label>
                    <input type="number" id="modalMarkupPct" value="35" min="0" max="200" step="1">
                    <span style="font-size:13px;color:var(--sw-text-sec)">%</span>
                    <button class="btn-apply" onclick="applyMarkupAll(true)">Apply to All</button>
                    <div class="toggle-wrap">
                        <input type="checkbox" id="showCostToggle" onchange="renderMaterialsModal()">
                        <label for="showCostToggle" style="font-size:12px;color:var(--sw-text-sec);cursor:pointer">Show cost prices</label>
                    </div>
                </div>
                <table class="mat-modal-table">
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Qty</th>
                            <th class="r cost-col" style="display:none">Cost</th>
                            <th class="r">Sell Price</th>
                            <th class="r">Markup</th>
                            <th style="width:24px"></th>
                        </tr>
                    </thead>
                    <tbody id="matModalBody"></tbody>
                </table>
                <div class="mat-modal-footer">
                    <div>
                        <button class="btn-add-custom" onclick="addCustomMaterialRow()">+ Add Custom Item</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:16px">
                        <span>Total: <span class="mat-total" id="matModalTotal">$0.00</span></span>
                        <button class="btn-done" onclick="closeMaterialsModal()">Done</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Modal (expanded from Rates) -->
        <div id="ratesModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
            <div class="rates-modal" style="max-width:520px">
                <h3>Settings</h3>

                <!-- Defaults tab -->
                <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                    <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:8px">Defaults</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Default Markup %</label>
                            <input type="number" id="settingsDefaultMarkup" value="35" min="0" max="200" step="1" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                    </div>
                </div>

                <!-- Labour Rates -->
                <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                    <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:8px">Labour Rates</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Trade Cost $/hr</label>
                            <input type="number" id="settingsTradesCostHr" value="45" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Trade Sell $/hr</label>
                            <input type="number" id="settingsTradesSellHr" value="110" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Labourer Cost $/hr</label>
                            <input type="number" id="settingsLabourerCostHr" value="35" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Labourer Sell $/hr</label>
                            <input type="number" id="settingsLabourerSellHr" value="90" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Hours Per Day</label>
                            <input type="number" id="settingsHoursPerDay" value="8" min="1" max="12" step="1" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults();updateLabour()">
                        </div>
                    </div>
                </div>

                <!-- Scope item default costs -->
                <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                    <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:8px">Scope Item Defaults (cost per unit)</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Footings ($/each)</label>
                            <input type="number" id="settingsScopeFootings" value="85" min="0" step="5" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Demo (flat rate)</label>
                            <input type="number" id="settingsScopeDemo" value="500" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Crane Hire</label>
                            <input type="number" id="settingsScopeCrane" value="600" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Council/Permit</label>
                            <input type="number" id="settingsScopePermit" value="350" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Soakwell</label>
                            <input type="number" id="settingsScopeSoakwell" value="800" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Skip Bin</label>
                            <input type="number" id="settingsScopeSkip" value="350" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Delivery</label>
                            <input type="number" id="settingsScopeDelivery" value="200" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                        <div>
                            <label style="font-size:11px;color:var(--sw-text-sec);display:block;margin-bottom:2px">Electrical</label>
                            <input type="number" id="settingsScopeElectrical" value="0" min="0" step="50" style="width:80px;padding:5px 8px;border:1px solid var(--sw-border);border-radius:4px;font-size:13px" onchange="saveSettingsDefaults()">
                        </div>
                    </div>
                </div>

                <!-- Work order options -->
                <div style="margin-bottom:16px;padding:12px;background:var(--sw-bg);border-radius:8px">
                    <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:8px">Output Options</div>
                    <label style="display:flex;align-items:center;gap:8px;font-size:12px;color:var(--sw-text);cursor:pointer">
                        <input type="checkbox" id="settingsShowWoCosts" onchange="saveSettingsDefaults()">
                        Show cost prices on Work Order
                    </label>
                    <label style="display:flex;align-items:center;gap:8px;font-size:12px;color:var(--sw-text);cursor:pointer;margin-top:6px">
                        <input type="checkbox" id="settingsItemisedQuote" onchange="saveSettingsDefaults()">
                        Itemised quote (show individual scope items)
                    </label>
                </div>

                <!-- Material rates -->
                <div style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--sw-text-sec);margin-bottom:6px">Material &amp; Labour Rates</div>
                <p style="font-size:11px;color:var(--sw-text-sec);margin-bottom:8px">$/LM, $/ea, $/day. Saved to browser.</p>
                <div style="max-height:300px;overflow-y:auto;border:1px solid var(--sw-border);border-radius:6px">
                <table class="pricing-table">
                    <thead><tr><th>Material / Role</th><th class="r">Rate $</th></tr></thead>
                    <tbody id="ratesBody"></tbody>
                </table>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:16px">
                    <button style="font-size:11px;padding:5px 12px;border:1px solid #ccc;border-radius:4px;background:#fff;cursor:pointer;color:#FF3B30" onclick="if(confirm('Reset all rates to defaults?')){storedRates={...DEFAULT_RATES};saveRates();renderRatesPanel();buildJobRows();updatePricing()}">Reset to Defaults</button>
                    <button class="btn-done" style="padding:8px 20px;border-radius:6px;border:none;background:var(--sw-orange);color:white;font-size:13px;cursor:pointer" onclick="document.getElementById('ratesModal').style.display='none'">Done</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Import Modal -->
    <div id="importModal" class="modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
        <div class="modal-box">
            <h3>Import Job Data</h3>
            <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:8px">Paste previously exported JSON data below, then click Load Job.</p>
            <textarea id="importTextarea" placeholder="Paste job JSON here..."></textarea>
            <div class="modal-status" id="importStatus"></div>
            <div class="modal-btns">
                <button class="btn btn-secondary" onclick="document.getElementById('importModal').style.display='none'">Cancel</button>
                <button class="btn btn-primary" onclick="importJobData()">Load Job</button>
            </div>
        </div>
    </div>

    <div id="loadJobModal" class="modal-overlay" style="display:none" onclick="if(event.target===this)closeLoadJobModal()">
        <div class="modal-box" style="max-width:500px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
                <h3 style="margin:0">Load Job</h3>
                <span style="cursor:pointer;font-size:18px;color:var(--sw-text-sec);padding:4px" onclick="closeLoadJobModal()">&times;</span>
            </div>
            <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:8px">Paste job data JSON:</p>
            <textarea id="loadJobTextarea" rows="6" placeholder="Paste job JSON here..." style="height:auto"></textarea>
            <div class="modal-status" id="loadJobStatus"></div>
            <div class="modal-btns">
                <button class="btn btn-secondary" onclick="closeLoadJobModal()">Cancel</button>
                <button class="btn btn-primary" onclick="loadJobData()">Load Job</button>
            </div>
        </div>
    </div>

    <!-- Box Gutter Designer Modal -->
    <div id="gutterDesignerModal" class="gutter-modal-overlay" style="display:none" onclick="if(event.target===this)closeGutterDesigner()">
        <div class="gutter-modal" onclick="event.stopPropagation()">
            <div class="gutter-modal-header">
                <h3>Box Gutter Designer</h3>
                <button class="close-btn" onclick="closeGutterDesigner()">&times;</button>
            </div>
            <div class="gutter-modal-body">
                <div class="gutter-modal-left">
                    <div class="gutter-inputs">
                        <label>House Catchment (m&sup2;)
                            <input type="number" id="bgHouseCatch" value="30" min="0" step="1" oninput="calcBoxGutter()">
                            <small>House roof area to gutter</small>
                        </label>
                        <label>Patio Catchment (m&sup2;)
                            <input type="number" id="bgPatioCatch" value="0" min="0" step="0.1" readonly>
                            <small>Auto from patio dims</small>
                        </label>
                        <label>Gutter Run (mm)
                            <input type="number" id="bgRunLength" value="6000" min="1000" max="15000" step="100" oninput="calcBoxGutter()">
                            <small>Length to nearest downpipe</small>
                        </label>
                    </div>
                    <div class="gutter-inputs" style="margin-top:8px">
                        <label>Available Width (mm)
                            <input type="number" id="bgAvailWidth" value="300" min="150" max="600" step="10" oninput="calcBoxGutter()">
                            <small>Riser gap</small>
                        </label>
                        <label>Available Depth (mm)
                            <input type="number" id="bgAvailDepth" value="150" min="75" max="300" step="10" oninput="calcBoxGutter()">
                            <small>Step-down house to patio</small>
                        </label>
                        <label>Fall Ratio
                            <select id="bgFallRatio" onchange="calcBoxGutter()">
                                <option value="100">1:100 (minimum)</option>
                                <option value="80">1:80 (standard)</option>
                                <option value="60" selected>1:60 (recommended)</option>
                                <option value="40">1:40 (steep)</option>
                            </select>
                        </label>
                    </div>
                    <div class="gutter-inputs" style="margin-top:8px">
                        <label>Downpipe Size
                            <select id="bgDownpipe" onchange="calcBoxGutter()">
                                <option value="100x75">100x75 rectangular</option>
                                <option value="100x100">100x100 square</option>
                                <option value="90round">90mm round</option>
                            </select>
                        </label>
                    </div>
                    <div class="gutter-results" id="bgResults" style="margin-top:12px">
                        <div class="gutter-status" id="bgStatus"></div>
                        <h5>Calculated Profile</h5>
                        <div class="gutter-result-grid">
                            <div class="gutter-result-item"><div class="r-label">Total Catchment</div><div class="r-value" id="bgResCatch">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Flow Rate</div><div class="r-value" id="bgResFlow">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Downpipes</div><div class="r-value" id="bgResDP">-</div></div>
                        </div>
                        <h5>Fabrication Dimensions</h5>
                        <div class="gutter-result-grid">
                            <div class="gutter-result-item"><div class="r-label">Back Upstand</div><div class="r-value" id="bgResBack">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Sole Width</div><div class="r-value" id="bgResSoleW">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Sole Depth</div><div class="r-value" id="bgResSoleD">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Front Upstand</div><div class="r-value" id="bgResFront">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Front Turn-in</div><div class="r-value" id="bgResTurnIn">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Total Girth</div><div class="r-value" id="bgResGirth">-</div></div>
                        </div>
                        <div class="gutter-result-grid" style="margin-top:6px">
                            <div class="gutter-result-item"><div class="r-label">Freeboard</div><div class="r-value" id="bgResFB">-</div></div>
                            <div class="gutter-result-item"><div class="r-label">Fall Total</div><div class="r-value" id="bgResFall">-</div></div>
                        </div>
                    </div>
                </div>
                <div class="gutter-modal-right" id="bgCrossSectionBox">
                    <canvas id="bgCanvas"></canvas>
                </div>
            </div>
            <div class="gutter-modal-footer">
                <button class="btn-remove" onclick="removeGutterFromTruss()">Remove Gutter</button>
                <button class="btn-save" onclick="saveGutterToTruss()">Save to Truss</button>
            </div>
        </div>
    </div>

    <script>
        /*
         * V18 FIXES:
         * 1. Downpipes - now extend from ground to actual gutter height (not postH)
         * 2. Gable sheets perpendicular - complete rotation rewrite for proper roof alignment
         * 3. Carry beam condition - removed for gable+fascia (trusses sit on fascia beam directly)
         * 4. Gable+riser beam stacking - riser beam now sits ON TOP of risers correctly
         */

        // ==================== CONFIG ====================
        // Official BlueScope Colorbond colour hex values
        const COLORBOND_COLOURS = {
            // Light tones
            'Surfmist':       '#E4E2D5',
            'Classic Cream':  '#D8CDB2',
            'Paperbark':      '#CABFA4',
            'Evening Haze':   '#C5C2AA',
            'Dune':           '#B1ADA3',
            // Mid tones
            'Shale Grey':     '#BDBFBA',
            'Windspray':      '#888B8A',
            'Pale Eucalypt':  '#7C846A',
            'Gully':          '#857E73',
            'Jasper':         '#6C6153',
            'Wallaby':        '#7F7C78',
            // Dark tones
            'Basalt':         '#6D6C6E',
            'Woodland Grey':  '#4B4C46',
            'Monument':       '#323233',
            'Ironstone':      '#3E434C',
            // Feature colours
            'Manor Red':      '#6B3D3A',
            'Cottage Green':  '#3D5246',
            'Deep Ocean':     '#2B3E4A',
            'Cove':           '#3F4C54',
            'Night Sky':      '#2D3033',
            // Special
            'Zincalume':      '#C0C0C0'
        };

        // CamelCase keyed Colorbond dictionary for AI prompt generation
        const COLORBOND_COLORS = {
            surfmist:       { hex: '#E4E2D5', name: 'Surfmist (off-white)' },
            classicCream:   { hex: '#D8CDB2', name: 'Classic Cream' },
            paperbark:      { hex: '#CABFA4', name: 'Paperbark (light tan)' },
            eveningHaze:    { hex: '#C5C2AA', name: 'Evening Haze' },
            dune:           { hex: '#B1ADA3', name: 'Dune (warm beige-grey)' },
            shaleGrey:      { hex: '#BDBFBA', name: 'Shale Grey (light grey)' },
            windspray:      { hex: '#888B8A', name: 'Windspray (mid grey)' },
            paleEucalypt:   { hex: '#7C846A', name: 'Pale Eucalypt (grey-green)' },
            gully:          { hex: '#857E73', name: 'Gully (brown-grey)' },
            jasper:         { hex: '#6C6153', name: 'Jasper (brown-grey)' },
            wallaby:        { hex: '#7F7C78', name: 'Wallaby (warm grey)' },
            basalt:         { hex: '#6D6C6E', name: 'Basalt (mid grey)' },
            woodlandGrey:   { hex: '#4B4C46', name: 'Woodland Grey (dark charcoal)' },
            monument:       { hex: '#323233', name: 'Monument (near black)' },
            ironstone:      { hex: '#3E434C', name: 'Ironstone (dark blue-grey)' },
            manorRed:       { hex: '#6B3D3A', name: 'Manor Red' },
            cottageGreen:   { hex: '#3D5246', name: 'Cottage Green' },
            deepOcean:      { hex: '#2B3E4A', name: 'Deep Ocean' }
        };

        function getColorbond(key) {
            return COLORBOND_COLORS[key] || COLORBOND_COLORS.surfmist;
        }

        // Common Perth patio Colorbond colours for picker (most popular first)
        const COLORS = [
            {name:'Surfmist',hex:'#E4E2D5'},{name:'Paperbark',hex:'#CABFA4'},{name:'Classic Cream',hex:'#E9DCB8'},
            {name:'Dune',hex:'#B1ADA3'},{name:'Shale Grey',hex:'#BDBFBA'},{name:'Evening Haze',hex:'#C5C2AA'},
            {name:'Windspray',hex:'#888B8A'},{name:'Pale Eucalypt',hex:'#7C846A'},
            {name:'Jasper',hex:'#6C6153'},{name:'Gully',hex:'#857E73'},{name:'Wallaby',hex:'#7F7C78'},
            {name:'Basalt',hex:'#6D6C6E'},{name:'Woodland Grey',hex:'#4B4C46'},{name:'Monument',hex:'#323233'},
            {name:'Ironstone',hex:'#3E434C'},{name:'Manor Red',hex:'#6B3D3A'},
            {name:'Cottage Green',hex:'#3D5246'},{name:'Deep Ocean',hex:'#2B3E4A'},
            {name:'Cove',hex:'#3F4C54'},{name:'Night Sky',hex:'#2D3033'}
        ];
        const STEEL = {'76x38':{w:0.076,h:0.038,name:'76Ã—38Ã—1.6',bmt:1.6},'75x50':{w:0.075,h:0.05,name:'75Ã—50Ã—2',bmt:2.0},'100x50':{w:0.1,h:0.05,name:'100Ã—50Ã—2',bmt:2.0}};
        const FRAME_POSTS = {
            '65x65': {w:0.065, name:'65Ã—65Ã—2 SHS', label:'65Ã—65Ã—2'},
            '75x75': {w:0.075, name:'75Ã—75Ã—2 SHS', label:'75Ã—75Ã—2'},
            '90x90': {w:0.09,  name:'90Ã—90Ã—2 SHS', label:'90Ã—90Ã—2'},
            '100x100':{w:0.1,  name:'100Ã—100Ã—2 SHS',label:'100Ã—100Ã—2'},
            '125x125':{w:0.125,name:'125Ã—125Ã—3 SHS',label:'125Ã—125Ã—3'},
            '150x150':{w:0.15, name:'150Ã—150Ã—3 SHS',label:'150Ã—150Ã—3'}
        };
        const FRAME_BEAMS = {
            '75x50':  {w:0.075, h:0.05, name:'75Ã—50Ã—2 RHS', label:'75Ã—50Ã—2'},
            '100x50': {w:0.1,   h:0.05, name:'100Ã—50Ã—2 RHS', label:'100Ã—50Ã—2'},
            '125x50': {w:0.125, h:0.05, name:'125Ã—50Ã—2 RHS', label:'125Ã—50Ã—2'},
            '150x50': {w:0.15,  h:0.05, name:'150Ã—50Ã—2 RHS', label:'150Ã—50Ã—2'},
            '200x50': {w:0.2,   h:0.05, name:'200Ã—50Ã—2 RHS', label:'200Ã—50Ã—2'}
        };

        const RAFTER_SIZES = {
            '50x25':    {w:0.05,  h:0.025, name:'50Ã—25Ã—1.6 RHS', label:'50Ã—25 RHS'},
            '65x35':    {w:0.065, h:0.035, name:'65Ã—35Ã—2 RHS',   label:'65Ã—35 RHS'},
            '75x35':    {w:0.075, h:0.035, name:'75Ã—35Ã—2 RHS',   label:'75Ã—35 RHS'},
            '75x50':    {w:0.075, h:0.05,  name:'75Ã—50Ã—2 RHS',   label:'75Ã—50 RHS'},
            '100x50':   {w:0.1,   h:0.05,  name:'100Ã—50Ã—2 RHS',  label:'100Ã—50 RHS'},
            '125x50':   {w:0.125, h:0.05,  name:'125Ã—50Ã—2 RHS',  label:'125Ã—50 RHS'},
            '150x50x2': {w:0.15,  h:0.05,  name:'150Ã—50Ã—2 RHS',  label:'150Ã—50Ã—2 RHS'},
            '150x50x3': {w:0.15,  h:0.05,  name:'150Ã—50Ã—3 RHS',  label:'150Ã—50Ã—3 RHS'},
            '76x38x16':{w:0.076, h:0.038, name:'76Ã—38Ã—1.6 RHS',  label:'76Ã—38 Tubing'},
            '100x50x2':{w:0.100, h:0.05, name:'100Ã—50Ã—2 RHS',   label:'100Ã—50 Tubing'}
        };

        const PURLIN_SIZES = {
            '76x38':  {w:0.076, h:0.038, name:'76Ã—38Ã—1.6 RHS',  label:'76Ã—38'},
            '100x50': {w:0.100, h:0.050, name:'100Ã—50Ã—2 RHS',    label:'100Ã—50'}
        };

        const SHEET_COVERAGE = {
            corrugated: 762,
            trimdek: 762,
            spandek: 760,
            solarspan75: 1000,
            solarspan100: 1000,
            spanplus330: 330
        };

        // Detailed sheet profile data for steel and polycarbonate roofing
        const SHEET_PROFILES = {
            trimdek:    { name: 'Trimdek (5-rib)',         coverWidth: 762, overallWidth: 840, ribDepth: 29, minPitch: 2, material: 'colorbond', polycarbMatch: 'trimdek' },
            corrugated: { name: 'Custom Orb (Corrugated)', coverWidth: 762, overallWidth: 838, ribDepth: 16, minPitch: 5, material: 'colorbond', polycarbMatch: 'corrugated' },
            spandek:    { name: 'Spandek',                 coverWidth: 760, overallWidth: 835, ribDepth: 28, minPitch: 2, material: 'colorbond', polycarbMatch: null },
            solarspan75:  { name: 'SolarSpan 75mm',  coverWidth: 1000, material: 'insulated', polycarbMatch: null },
            solarspan100: { name: 'SolarSpan 100mm', coverWidth: 1000, material: 'insulated', polycarbMatch: null },
            spanplus330:  { name: 'SpanPlus 330',    coverWidth: 330,  material: 'colorbond',  polycarbMatch: null }
        };

        // Polycarbonate profile compatibility (which polycarb matches which steel profile)
        const POLYCARB_PROFILES = {
            trimdek:    { name: 'Solasafe 5-Rib',    coverWidth: 760, thickness: 0.8, maxLength: 8100, manufacturer: 'Ampelite', levels: [1, 2] },
            corrugated: { name: 'Solasafe Corrugated', coverWidth: 760, thickness: 0.8, maxLength: 8100, manufacturer: 'Ampelite', levels: [1, 2, 3] }
        };

        const SPAN_TABLES = {
            corrugated: { maxSpan: 1100, endSpan: 900, needsPurlins: true },
            trimdek: { maxSpan: 2100, endSpan: 1500, needsPurlins: true },
            spandek: { maxSpan: 2400, endSpan: 1800, needsPurlins: true },
            solarspan75: { maxSpan: 6000, endSpan: 6000, needsPurlins: false },
            solarspan100: { maxSpan: 6000, endSpan: 6000, needsPurlins: false },
            spanplus330: { maxSpan: 1800, endSpan: 1200, needsPurlins: true }
        };

        // Sheet span lookup for batten calculator (max spans in mm at standard load)
        const SHEET_SPANS = {
            solarspan75:       { maxSpan: 4500, minPitch: 2, battensRequired: false, label: 'SolarSpan 75mm' },
            solarspan100:      { maxSpan: 5500, minPitch: 2, battensRequired: false, label: 'SolarSpan 100mm' },
            trimdek_048:       { maxSpan: 2600, minPitch: 2, battensRequired: true,  label: 'Trimdek (0.48 BMT)' },
            trimdek_042:       { maxSpan: 1900, minPitch: 2, battensRequired: true,  label: 'Trimdek (0.42 BMT)' },
            corrugated_048:    { maxSpan: 1700, minPitch: 5, battensRequired: true,  label: 'Corrugated (0.48 BMT)' },
            corrugated_042:    { maxSpan: 1200, minPitch: 5, battensRequired: true,  label: 'Corrugated (0.42 BMT)' },
            spanplus330_042:   { maxSpan: 4500, minPitch: 1, battensRequired: true,  label: 'SpanPlus 330 (0.42 BMT)' }
        };

        // Map roofing dropdown value + BMT to SHEET_SPANS key
        function getSheetSpanKey(roofing, bmt) {
            if (roofing === 'solarspan75' || roofing === 'solarspan100') return roofing;
            if (roofing === 'trimdek') return 'trimdek_' + (bmt || '042');
            if (roofing === 'corrugated') return 'corrugated_' + (bmt || '042');
            if (roofing === 'spanplus330') return 'spanplus330_042';
            return null;
        }

        function calculateBattens(sheetSpanKey, projectionMm, patioLengthMm, extraBattens) {
            const sheet = SHEET_SPANS[sheetSpanKey];
            if (!sheet) return { battensNeeded: 0, spanDistance: projectionMm, battenPositions: [], battenLength: patioLengthMm, message: 'Unknown sheet type' };

            if (!sheet.battensRequired) {
                return {
                    battensNeeded: 0, spanDistance: projectionMm, battenPositions: [],
                    battenLength: patioLengthMm, maxSpan: sheet.maxSpan,
                    message: sheet.label + ' is self-spanning \u2014 no battens required'
                };
            }

            const spansNeeded = Math.ceil(projectionMm / sheet.maxSpan);
            const baseBattens = Math.max(0, spansNeeded - 1);
            const battensNeeded = baseBattens + (extraBattens || 0);

            if (battensNeeded === 0) {
                return {
                    battensNeeded: 0, spanDistance: projectionMm, battenPositions: [],
                    battenLength: patioLengthMm, maxSpan: sheet.maxSpan, baseBattens: 0,
                    message: sheet.label + ' can span ' + projectionMm + 'mm without battens'
                };
            }

            const totalSpans = battensNeeded + 1;
            const spanDistance = Math.round(projectionMm / totalSpans);
            const battenPositions = [];
            for (var i = 1; i <= battensNeeded; i++) battenPositions.push(spanDistance * i);

            return {
                battensNeeded, spanDistance, battenPositions, battenLength: patioLengthMm,
                maxSpan: sheet.maxSpan, baseBattens,
                message: battensNeeded + ' batten row' + (battensNeeded > 1 ? 's' : '') + ' at ' + spanDistance + 'mm centres'
            };
        }

        function calculateBrackets(battensNeeded, patioLengthMm) {
            if (battensNeeded === 0) return { bracketsNeeded: 0, perBatten: 0 };
            const perBatten = 2 + Math.floor(Math.max(0, patioLengthMm - 200) / 1200);
            return { bracketsNeeded: perBatten * battensNeeded, perBatten };
        }

        function validateBattenSetup(sheetSpanKey, projectionMm, pitchDeg) {
            const sheet = SHEET_SPANS[sheetSpanKey];
            if (!sheet) return { errors: [], warnings: [], isValid: true };
            var errors = [], warnings = [];
            if (pitchDeg < sheet.minPitch) {
                errors.push(sheet.label + ' requires min ' + sheet.minPitch + '\u00B0 pitch. Current: ' + pitchDeg.toFixed(1) + '\u00B0');
            }
            if (sheet.battensRequired) {
                var bn = Math.ceil(projectionMm / sheet.maxSpan) - 1;
                if (bn >= 3) warnings.push(bn + ' batten rows needed \u2014 consider a longer-spanning sheet');
            }
            if (projectionMm > 6000) warnings.push('Projection exceeds 6m \u2014 verify structural design');
            return { errors, warnings, isValid: errors.length === 0 };
        }

        function calculateRafters(spanMm, spacingMm, overrideQty) {
            if (overrideQty && overrideQty > 0) {
                var qty = overrideQty;
                var actualSpacing = qty > 1 ? Math.round(spanMm / (qty - 1)) : spanMm;
                return { rafterCount: qty, spacing: actualSpacing, isOverride: true };
            }
            var sp = Math.max(300, spacingMm || 900);
            var qty = Math.floor(spanMm / sp) + 1;
            if (qty < 2) qty = 2;
            var actualSpacing = qty > 1 ? Math.round(spanMm / (qty - 1)) : spanMm;
            return { rafterCount: qty, spacing: actualSpacing, isOverride: false };
        }

        function calculateGableBattens(roofing, rafterMm, patioLengthMm, extraBattens) {
            var spanTable = SPAN_TABLES[roofing];
            if (!spanTable || !spanTable.needsPurlins) {
                return {
                    totalBattens: 0, battensPerSide: 0, spacing: 0,
                    positionsPerSide: [], apexGap: 0,
                    battenLength: patioLengthMm,
                    message: (spanTable ? 'Self-spanning â€” no purlins required' : 'Unknown sheet type')
                };
            }
            var maxSpan = spanTable.maxSpan;
            var apexOffset = 75; // mm from ridge centre to each apex batten
            var effectiveLen = rafterMm - apexOffset;
            if (effectiveLen < 100) effectiveLen = rafterMm;
            var spansNeeded = Math.ceil(effectiveLen / maxSpan);
            if (spansNeeded < 1) spansNeeded = 1;
            var battensPerSide = spansNeeded + 1 + (extraBattens || 0);
            var spacing = Math.round(effectiveLen / (battensPerSide - 1));
            var positions = [];
            for (var i = 0; i < battensPerSide; i++) {
                positions.push(Math.round(spacing * i));
            }
            // Last position is at the apex batten
            positions[positions.length - 1] = Math.round(effectiveLen);
            var totalBattens = battensPerSide * 2;
            return {
                totalBattens: totalBattens,
                battensPerSide: battensPerSide,
                spacing: spacing,
                positionsPerSide: positions,
                apexGap: apexOffset * 2,
                battenLength: patioLengthMm,
                maxSpan: maxSpan,
                rafterLength: rafterMm,
                message: totalBattens + ' purlins total (' + battensPerSide + ' per side) at ' + spacing + 'mm centres'
            };
        }

        function isInsulated(roofing) {
            return roofing === 'solarspan75' || roofing === 'solarspan100';
        }

        const ROOFING_TYPES = {
            solarspan75:  { name: 'SolarSpan 75mm',  coverWidth: 1000, costPerLm: 110.00, sqmRate: 620 },
            solarspan100: { name: 'SolarSpan 100mm', coverWidth: 1000, costPerLm: 130.00, sqmRate: 680 },
            trimdek:      { name: 'Trimdek',         coverWidth: 762,  costPerLm: 15.00,  sqmRate: 480 },
            corrugated:   { name: 'Corrugated',      coverWidth: 762,  costPerLm: 12.04,  sqmRate: 440 },
            spandek:      { name: 'Spandek',         coverWidth: 760,  costPerLm: 14.50,  sqmRate: 480 },
            spanplus330:  { name: 'SpanPlus 330',    coverWidth: 330,  costPerLm: 12.04,  sqmRate: 460 }
        };

        const SPANPLUS_COLOURS = [
            'Basalt','Classic Cream','Cottage Green','Deep Ocean','Domain','Dune',
            'Evening Haze','Ironstone','Jasper','Manor Red','Monument',
            'Pale Eucalypt','Paperbark','Shale Grey','Surfmist','Woodland Grey'
        ];

        // Polycarbonate tint options per brand
        const POLYCARB_TINTS = {
            ampelite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Light Bronze',color:'rgba(180,150,100,0.4)'},
                {name:'Grey',       color:'rgba(160,160,165,0.45)'},
                {name:'Dark Tint',  color:'rgba(80,80,85,0.55)'},
                {name:'Smooth Cream',color:'rgba(245,235,210,0.5)'}
            ],
            laserlite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Cream',      color:'rgba(245,235,210,0.5)'},
                {name:'Bronze Tint',color:'rgba(170,140,90,0.45)'},
                {name:'Grey Tint',  color:'rgba(150,150,155,0.45)'}
            ]
        };

        // Three.js tint colours for polycarb 3D rendering
        const POLYCARB_3D_TINTS = {
            'Clear':        {color: 0x88CCEE, opacity: 0.5},
            'Opal':         {color: 0xE8E8F0, opacity: 0.6},
            'Light Bronze': {color: 0xB49664, opacity: 0.55},
            'Grey':         {color: 0x909098, opacity: 0.55},
            'Dark Tint':    {color: 0x505055, opacity: 0.65},
            'Smooth Cream': {color: 0xF0E4C8, opacity: 0.55},
            'Cream':        {color: 0xF0E4C8, opacity: 0.55},
            'Bronze Tint':  {color: 0xAA8C5A, opacity: 0.55},
            'Grey Tint':    {color: 0x868690, opacity: 0.55}
        };

        let sheetColor = COLORS[0]; // Surfmist default
        let steelColor = COLORS.find(c => c.name === 'Monument') || COLORS[9];
        let flashingColor = COLORS.find(c => c.name === 'Monument') || COLORS[9];
        let calc = {};

        // ==================== CUSTOMER STATE ====================
        let customer = { name: '', address: '', phone: '' };
        function updateCustomer() {
            customer = {
                name: document.getElementById('customerName').value,
                address: document.getElementById('customerAddress').value,
                phone: document.getElementById('customerPhone').value
            };
            // customer object updated from visible fields above
        }

        // ==================== SITE DETAILS STATE ====================
        let siteDetails = {
            existingSite: 'clear',
            demoNotes: '',
            electrical: 'none',
            siteAccess: 'easy',
            groundSurface: 'grass',
            fasciaMaterial: 'timber',
            wallType: 'doublebrick',
            existingRoof: 'tiles'
        };
        function updateSiteDetails() {
            siteDetails = {
                existingSite: document.getElementById('existingSite')?.value || 'clear',
                demoNotes: document.getElementById('demoNotes')?.value || '',
                electrical: document.getElementById('electrical')?.value || 'none',
                siteAccess: document.getElementById('siteAccess')?.value || 'easy',
                groundSurface: document.getElementById('groundSurface')?.value || 'grass',
                fasciaMaterial: document.getElementById('fasciaMaterial')?.value || 'timber',
                wallType: document.getElementById('wallType')?.value || 'doublebrick',
                existingRoof: document.getElementById('existingRoof')?.value || 'tiles'
            };
        }

        // ==================== EXISTING SITE ====================
        function updateExistingSite() {
            var existing = document.getElementById('existingSite').value;
            var demoNotesField = document.getElementById('demoNotesField');
            if (demoNotesField) {
                demoNotesField.style.display = (existing === 'clear') ? 'none' : 'block';
            }
            // Legacy compat: also update demoScopeGroup if it exists
            var demoGroup = document.getElementById('demoScopeGroup');
            if (demoGroup) {
                if (existing === 'clear') {
                    demoGroup.style.display = 'none';
                } else {
                    demoGroup.style.display = 'block';
                }
            }
            updateSiteDetails();
            updateUI();
        }

        function calculateDemoCost() {
            var existing = document.getElementById('existingSite')?.value || 'clear';
            if (existing === 'clear') return 0;
            // Demo cost now added via Additional Items â€” this returns 0
            // Old auto-cost removed; user adds demo pricing manually
            return 0;
        }

        // ==================== TOGGLE BUTTONS ====================
        function setToggle(fieldId, value, btn) {
            document.getElementById(fieldId).value = value;
            var group = btn.parentElement;
            group.querySelectorAll('.toggle-btn').forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            updateSiteDetails();
            updateUI();
        }

        function setDesignToggle(fieldId, value, btn) {
            document.getElementById(fieldId).value = value;
            var group = btn.parentElement;
            group.querySelectorAll('.toggle-btn').forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            updateUI();
            rebuildAll();
        }

        // Sync both ceiling finish toggle groups (finishing section + colour section)
        function syncCeilingToggles(val) {
            document.querySelectorAll('[data-value="plain"], [data-value="vj"], [data-value="cedar"]').forEach(function(btn) {
                // Only sync ceiling finish buttons (check parent context)
                var parentBlock = btn.closest('#ceilingFinishField, #ceilingFinishColorBlock');
                if (!parentBlock) return;
                btn.classList.toggle('active', btn.getAttribute('data-value') === val);
            });
        }

        // Sync existing roof type from Design toggle to Site Reference hidden input
        function setExistingRoofFromDesign(value, btn) {
            // Update Site Reference hidden input
            document.getElementById('existingRoof').value = value;
            // Update Design section toggle buttons
            var group = btn.parentElement;
            group.querySelectorAll('.toggle-btn').forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            // Also sync Site Reference toggle buttons
            var siteGroup = document.getElementById('existingRoof');
            if (siteGroup && siteGroup.nextElementSibling) {
                siteGroup.nextElementSibling.querySelectorAll('.toggle-btn').forEach(function(b) {
                    b.classList.toggle('active', b.dataset.value === value);
                });
            }
            rebuildAll();
        }

        // Sync toggle button active states from hidden input values (used after import/load)
        function syncToggleButtons(groupId, value) {
            var group = document.getElementById(groupId);
            if (!group) return;
            group.querySelectorAll('.toggle-btn').forEach(function(b) {
                b.classList.toggle('active', b.dataset.value === value);
            });
        }

        function syncAllToggleButtons() {
            ['inRoofStyle', 'inConnection', 'inPostFix', 'inCeilingFinish', 'inHouseGutter', 'inLShape', 'inWraparound'].forEach(function(id) {
                var el = document.getElementById(id);
                if (!el) return;
                var group = el.nextElementSibling;
                if (!group || !group.classList.contains('toggle-btn-group')) return;
                group.querySelectorAll('.toggle-btn').forEach(function(b) {
                    b.classList.toggle('active', b.dataset.value === el.value);
                });
            });
            // Also sync site toggle buttons
            ['siteAccess', 'groundSurface', 'existingSite', 'fasciaMaterial', 'wallType', 'existingRoof'].forEach(function(id) {
                var el = document.getElementById(id);
                if (!el) return;
                var group = el.closest('.basics-field')?.querySelector('.toggle-btn-group') || el.parentElement;
                if (!group) return;
                group.querySelectorAll('.toggle-btn').forEach(function(b) {
                    b.classList.toggle('active', b.dataset.value === el.value);
                });
            });
        }

        // Smart default: Slab/Paving â†’ Bolt-down, Grass/Deck â†’ In-ground
        function smartPostFixDefault() {
            var surface = document.getElementById('groundSurface').value;
            var fixEl = document.getElementById('inPostFix');
            if (surface === 'slab' || surface === 'paving') {
                fixEl.value = 'baseplate';
            } else {
                fixEl.value = 'concrete';
            }
            syncAllToggleButtons();
            rebuildAll();
        }

        // Purlin validation display (inline in Structure)
        function updatePurlinValidation() {
            var el = document.getElementById('purlinValidationText');
            if (!el) return;
            var roofing = document.getElementById('inRoofing').value;
            var pitch = parseFloat(document.getElementById('inPitch').value) || 10;
            var projMm = (parseFloat(document.getElementById('inWidth').value) || 3) * 1000;
            var profiles = {
                solarspan75: { label: 'SolarSpan 75mm', maxSpan: 4500 },
                solarspan100: { label: 'SolarSpan 100mm', maxSpan: 5500 },
                trimdek: { label: 'Trimdek', maxSpan: 2600 },
                corrugated: { label: 'Corrugated', maxSpan: 1700 },
                spandek: { label: 'Spandek', maxSpan: 2600 },
                spanplus330: { label: 'SpanPlus 330', maxSpan: 2600 }
            };
            var p = profiles[roofing] || profiles.trimdek;
            var isSelfSpanning = (roofing === 'solarspan75' || roofing === 'solarspan100');
            var parentDiv = document.getElementById('purlinValidation');
            if (isSelfSpanning && projMm <= p.maxSpan) {
                el.innerHTML = p.label + ' @ ' + pitch + '&deg; &mdash; Max span: ' + p.maxSpan + 'mm<br><span style="color:#22C55E">&check; Self-spanning &mdash; no purlins required</span>';
                parentDiv.style.borderLeft = '3px solid #22C55E';
            } else if (isSelfSpanning) {
                el.innerHTML = p.label + ' @ ' + pitch + '&deg; &mdash; Max span: ' + p.maxSpan + 'mm<br><span style="color:#EF4444">&cross; Projection exceeds max span &mdash; purlins required</span>';
                parentDiv.style.borderLeft = '3px solid #EF4444';
            } else {
                el.innerHTML = p.label + ' @ ' + pitch + '&deg; &mdash; Max span: ' + p.maxSpan + 'mm<br><span style="color:var(--sw-text-sec)">Purlins/battens required for single-skin sheets</span>';
                parentDiv.style.borderLeft = '3px solid var(--sw-border)';
            }
        }

        // ==================== ATTACHMENT VISIBILITY ====================
        function updateAttachmentVisibility() {
            // Site Reference visibility is optional â€” always show for now
        }


        // ==================== AUTO-CALCULATE POSTS & TRUSSES ====================
        function autoCalculatePostsAndTrusses() {
            var length = (parseFloat(document.getElementById('inLength').value) || 6) * 1000;
            var projection = (parseFloat(document.getElementById('inWidth').value) || 3) * 1000;
            var roofStyle = document.getElementById('inRoofStyle').value;
            var orientation = document.getElementById('inOrientation').value;
            var pitch = parseFloat(document.getElementById('inPitch').value) || 10;
            var isGable = roofStyle === 'gable' || roofStyle === 'hip';

            // For gable perpendicular (Away from House): posts/trusses distribute along projection, span = house length
            // For all other cases: posts/trusses distribute along house length, span = projection
            var distributeAlong = (isGable && orientation === 'perpendicular') ? projection : length;
            var trussSpanMm = (isGable && orientation === 'perpendicular') ? length : projection;

            // Posts: use user override if set, otherwise auto-calculate every 2400mm
            var postsField = document.getElementById('inPosts');
            var postQtyOverride = document.getElementById('inPostQty');
            if (postsField) {
                if (postQtyOverride && postQtyOverride.value && parseInt(postQtyOverride.value) >= 2) {
                    postsField.value = parseInt(postQtyOverride.value);
                } else {
                    var postsPerSide = Math.ceil(distributeAlong / 2400) + 1;
                    postsField.value = postsPerSide;
                }
            }

            // Trusses: auto-calculate for gable unless user has overridden
            var trussQtyField = document.getElementById('inTrusses');
            if (trussQtyField && !trussQtyField.dataset.userOverride) {
                if (isGable) {
                    var trussQty = Math.ceil(distributeAlong / 2000) + 1;
                    trussQtyField.value = trussQty;
                }
            }

            // Rafters: auto for skillion (use spacing input, respect qty override)
            var raftersField = document.getElementById('inRafters');
            var rafterQtyOverride = document.getElementById('inRafterQtyOverride');
            var rafterSpacingInput = parseInt(document.getElementById('inRafterSpacing')?.value) || 900;
            if (raftersField) {
                if (rafterQtyOverride && rafterQtyOverride.value && parseInt(rafterQtyOverride.value) >= 2) {
                    raftersField.value = parseInt(rafterQtyOverride.value);
                } else {
                    var rc = calculateRafters(distributeAlong, rafterSpacingInput, 0);
                    raftersField.value = rc.rafterCount;
                }
            }

            // Update readonly display fields in truss calculator
            var trussSpanDisplay = document.getElementById('trussSpanDisplay');
            if (trussSpanDisplay) {
                trussSpanDisplay.value = (trussSpanMm / 1000) + 'm';
            }
            var trussPitchDisplay = document.getElementById('trussPitchDisplay');
            if (trussPitchDisplay) {
                trussPitchDisplay.value = pitch + '\u00B0';
            }
        }

        // Mark truss qty as user-overridden when manually changed
        document.addEventListener('DOMContentLoaded', function() {
            var trussQtyField = document.getElementById('inTrusses');
            if (trussQtyField) {
                trussQtyField.addEventListener('input', function() {
                    this.dataset.userOverride = 'true';
                });
            }
            updateExistingSite();
            updateAttachmentVisibility();
            updateLabour();
            renderPhotoGrid();
            updatePendingBadge();
        });

        function toggleTrussOpt() {
            var rOn = document.getElementById('trussRiserOn').checked;
            var eOn = document.getElementById('trussExtOn').checked;
            document.getElementById('trussRiserInputs').style.display = rOn ? 'flex' : 'none';
            document.getElementById('trussRiserLPanel').style.display = rOn ? '' : 'none';
            document.getElementById('trussRiserRPanel').style.display = rOn ? '' : 'none';
            document.getElementById('trussRiserTypePanel').style.display = rOn ? 'flex' : 'none';
            document.getElementById('trussExtInputs').style.display = eOn ? 'flex' : 'none';
            // Show/hide box gutter button based on riser state
            var bgBtn = document.getElementById('trussBoxGutterBtn');
            if (bgBtn) bgBtn.style.display = rOn ? '' : 'none';
            // Reset box gutter if risers disabled
            if (!rOn) {
                document.getElementById('trussBoxGutterOn').value = '0';
                if (bgBtn) bgBtn.classList.remove('active');
            }
        }

        // Sync truss riser dimensions to box gutter available space
        function syncRiserToBoxGutter() {
            var rLH = parseFloat(document.getElementById('riserLH').value) || 200;
            var rLV = parseFloat(document.getElementById('riserLV').value) || 150;
            var wEl = document.getElementById('bgAvailWidth');
            var dEl = document.getElementById('bgAvailDepth');
            if (wEl) wEl.value = rLH;
            if (dEl) dEl.value = rLV;
            calcBoxGutter();
        }

        // Sync left/right riser inputs when Lock L/R is on
        function syncRiserInputs(side) {
            var locked = document.getElementById('trussRiserLock').checked;
            if (!locked) return;
            if (side === 'L') {
                document.getElementById('riserRH').value = document.getElementById('riserLH').value;
                document.getElementById('riserRV').value = document.getElementById('riserLV').value;
            } else {
                document.getElementById('riserLH').value = document.getElementById('riserRH').value;
                document.getElementById('riserLV').value = document.getElementById('riserRV').value;
            }
            // Also sync to box gutter if enabled
            if (document.getElementById('trussBoxGutterOn')?.value === '1') syncRiserToBoxGutter();
        }

        // When lock is toggled on, sync right to match left
        function syncRiserLock() {
            if (document.getElementById('trussRiserLock').checked) {
                document.getElementById('riserRH').value = document.getElementById('riserLH').value;
                document.getElementById('riserRV').value = document.getElementById('riserLV').value;
            }
        }

        // ==================== QUICK SCOPE ESTIMATE ====================
        function updateEstimate() {
            const projM = parseFloat(document.getElementById('inWidth').value) || 3;
            const lenM = parseFloat(document.getElementById('inLength').value) || 6;
            const roofing = document.getElementById('inRoofing').value;
            const roofStyle = document.getElementById('inRoofStyle').value;
            const connection = document.getElementById('inConnection').value;
            // Include return area if wraparound active
            const wrapEstVal = document.getElementById('inWraparound')?.value || 'none';
            const retLenEst = wrapEstVal !== 'none' ? ((parseInt(document.getElementById('inReturnLength')?.value) || 3000) / 1000) : 0;
            const sqm = projM * lenM + (retLenEst * projM);

            const roofKey = roofing;
            const baseRate = (ROOFING_TYPES[roofKey] || ROOFING_TYPES.corrugated).sqmRate;

            // Style modifiers (ex-GST)
            let modifier = 1.0;
            if (roofStyle === 'gable') modifier *= 1.25;
            if (roofStyle === 'hip') modifier *= 1.35;

            // Connection modifiers
            if (connection === 'flyover') modifier *= 1.10;
            if (connection === 'freestanding') modifier *= 1.15;
            if (connection === 'riser') modifier *= 1.05;
            if (connection === 'wall') modifier *= 1.02;
            // fascia = baseline (1.0)

            // Span length factor â€” larger projections need heavier beams
            if (projM > 5) modifier *= 1.05;
            if (projM > 7) modifier *= 1.05;  // stacks: >7m = +10.25%

            const base = sqm * baseRate * modifier;
            const GST = 1.1;  // 10% GST
            const low = Math.round((base * 0.90 * GST) / 500) * 500;
            const high = Math.round((base * 1.15 * GST) / 500) * 500;

            var rpSqm = document.getElementById('rpEstSqm');
            var rpRange = document.getElementById('rpEstRange');
            if (rpSqm) rpSqm.textContent = sqm.toFixed(0) + ' sqm';
            if (rpRange) rpRange.textContent = '~$' + low.toLocaleString() + ' \u2013 $' + high.toLocaleString() + ' (inc GST)';

            // Sticky price card sqm
            var rpPS = document.getElementById('rpPriceSqm');
            if (rpPS) rpPS.textContent = sqm.toFixed(0) + ' sqm \u2014 est. ' + '~$' + low.toLocaleString() + ' \u2013 $' + high.toLocaleString();
        }

        function copyEstimate() {
            const projM = parseFloat(document.getElementById('inWidth').value) || 3;
            const lenM = parseFloat(document.getElementById('inLength').value) || 6;
            const roofStyle = document.getElementById('inRoofStyle').value;
            const roofing = document.getElementById('inRoofing').value;
            const roofName = (ROOFING_TYPES[roofing] || ROOFING_TYPES.corrugated).name;
            const styleName = roofStyle.charAt(0).toUpperCase() + roofStyle.slice(1);

            const rangeEl = document.getElementById('rpEstRange');
            const rangeText = rangeEl ? rangeEl.textContent : '';
            const text = 'SecureWorks Patio Estimate\n' +
                lenM.toFixed(1) + 'm \u00D7 ' + projM.toFixed(1) + 'm ' + styleName + ' - ' + roofName + '\n' +
                'Approximately ' + rangeText.replace('~', '') + ' inc GST\n\n' +
                'This is a preliminary estimate only.\nFinal price confirmed after detailed scope.';

            navigator.clipboard.writeText(text).then(function() {
                var btn = document.querySelector('.rp-est-btn .btn') || document.querySelector('.rp-price-card .btn-secondary');
                if (!btn) return;
                var orig = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(function() { btn.textContent = orig; }, 1500);
            });
        }

        // ==================== COLOR CHIPS ====================
        function initColorChips(containerId, labelId, setFn, defaultColor) {
            const container = document.getElementById(containerId);
            const defName = defaultColor ? defaultColor.name : COLORS[0].name;
            COLORS.forEach((c,i) => {
                const el = document.createElement('div');
                el.className = 'color-chip' + (c.name === defName ? ' active' : '');
                el.style.background = c.hex;
                el.title = c.name;
                el.onclick = () => {
                    setFn(c);
                    container.querySelectorAll('.color-chip').forEach(x=>x.classList.remove('active'));
                    el.classList.add('active');
                    document.getElementById(labelId).textContent = c.name;
                    rebuildAll();
                };
                container.appendChild(el);
            });
            document.getElementById(labelId).textContent = defName;
        }
        initColorChips('sheetChips', 'sheetLabel', c => sheetColor = c, sheetColor);
        initColorChips('steelChips', 'steelLabel', c => steelColor = c, steelColor);
        initColorChips('flashingChips', 'flashingLabel', c => flashingColor = c, flashingColor);

        // ==================== POLYCARBONATE ====================
        function hasPolycarbMatch(roofing) {
            var profile = SHEET_PROFILES[roofing];
            return profile && profile.polycarbMatch && POLYCARB_PROFILES[profile.polycarbMatch];
        }

        function isPolycarbEnabled() {
            return document.querySelector('input[name="polycarb"][value="yes"]')?.checked || false;
        }

        function getPolycarbConfig() {
            if (!isPolycarbEnabled()) return null;
            var roofing = document.getElementById('inRoofing').value;
            var matchKey = SHEET_PROFILES[roofing] && SHEET_PROFILES[roofing].polycarbMatch;
            if (!matchKey || !POLYCARB_PROFILES[matchKey]) return null;
            var pcProfile = POLYCARB_PROFILES[matchKey];
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintEl = document.getElementById('inPolycarbTint');
            const tint = tintEl.value || 'Clear';
            const level = parseInt(document.getElementById('inPolycarbLevel')?.value) || 1;
            const patternSel = document.getElementById('inPolycarbPattern').value;
            let steelPerPoly;
            if (patternSel === 'custom') {
                steelPerPoly = parseInt(document.getElementById('inPolycarbCustom').value) || 3;
            } else {
                steelPerPoly = parseInt(patternSel) - 1; // "Every 3rd" = 2 steel per 1 poly
            }
            return { brand, tint, level, steelPerPoly, patternN: steelPerPoly + 1, profile: pcProfile, profileName: pcProfile.name, matchKey: matchKey };
        }

        function getPolycarbSheetSplit(totalSheets) {
            const pc = getPolycarbConfig();
            if (!pc) return { colorbond: totalSheets, polycarb: 0 };
            const patternN = pc.patternN;
            const fullGroups = Math.floor(totalSheets / patternN);
            const remainder = totalSheets % patternN;
            const polycarb = fullGroups + (remainder >= patternN ? 1 : 0);
            const colorbond = totalSheets - polycarb;
            return { colorbond, polycarb };
        }

        function updatePolycarbUI() {
            const enabled = isPolycarbEnabled();
            document.getElementById('polycarbOptions').style.display = enabled ? 'block' : 'none';
            if (enabled) {
                updatePolycarbTints();
                updatePolycarbLevels();
                updatePolycarbPreview();
            }
        }

        function updatePolycarbTints() {
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintSelect = document.getElementById('inPolycarbTint');
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const currentVal = tintSelect.value;
            tintSelect.innerHTML = tints.map(t =>
                `<option value="${t.name}">${t.name}</option>`
            ).join('');
            // Restore previous selection if still valid
            if (tints.some(t => t.name === currentVal)) {
                tintSelect.value = currentVal;
            }
            updatePolycarbPreview();
        }

        function updatePolycarbPreview() {
            const container = document.getElementById('polycarbPreview');
            if (!container) return;
            const patternSel = document.getElementById('inPolycarbPattern').value;
            document.getElementById('polycarbCustomField').style.display = patternSel === 'custom' ? 'block' : 'none';
            const pc = getPolycarbConfig();
            if (!pc) { container.innerHTML = ''; return; }

            // Get tint colour for preview
            const brand = pc.brand;
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const tintObj = tints.find(t => t.name === pc.tint) || tints[0];
            const tintColor = tintObj.color;

            // Use actual sheet count if calc available, else show sample
            var roofing = document.getElementById('inRoofing').value;
            var lenMm = parseFloat(document.getElementById('inLength')?.value) || 6000;
            var sc = calculateSheets(Math.round(lenMm), roofing);
            var previewCount = Math.min(20, sc.totalSheets || Math.max(6, pc.patternN * 3));
            let html = '';
            for (let i = 0; i < previewCount; i++) {
                const isPoly = ((i + 1) % pc.patternN) === 0;
                var isPartial = sc.hasPartialSheet && i === previewCount - 1;
                var cls = isPoly ? 'pc-block polycarb' : 'pc-block steel';
                var style = isPoly ? 'background:' + tintColor : '';
                if (isPartial) {
                    var frac = Math.max(0.3, sc.partialSheetWidth / sc.coverWidth);
                    style += (style ? ';' : '') + 'width:' + Math.round(20 * frac) + 'px;border-style:dashed';
                }
                html += '<div class="' + cls + '" style="' + style + '" title="Sheet ' + (i + 1) + (isPartial ? ' (cut to ' + sc.partialSheetWidth + 'mm)' : '') + '"></div>';
            }
            // Summary line
            var split = getPolycarbSheetSplit(previewCount);
            html += '<div style="width:100%;font-size:9px;color:var(--sw-text-sec);margin-top:3px">';
            html += sc.totalSheets + ' sheets: ' + split.colorbond + ' steel, ' + split.polycarb + ' polycarb';
            if (sc.hasPartialSheet) html += ' \u2014 last cut to ' + sc.partialSheetWidth + 'mm';
            html += '</div>';
            container.innerHTML = html;
        }

        function calculateSheets(patioLengthMm, roofing) {
            var coverWidth = SHEET_COVERAGE[roofing] || 762;
            var fullSheets = Math.floor(patioLengthMm / coverWidth);
            var remainder = patioLengthMm % coverWidth;
            var totalSheets = remainder > 0 ? fullSheets + 1 : fullSheets;
            if (totalSheets < 1) totalSheets = 1;
            return {
                totalSheets: totalSheets,
                fullSheets: fullSheets,
                hasPartialSheet: remainder > 0,
                partialSheetWidth: remainder,
                coverWidth: coverWidth,
                orderQuantity: totalSheets,
                orderNote: remainder > 0 ? 'Last sheet cut to ' + remainder + 'mm' : 'All full width sheets'
            };
        }

        function updatePolycarbLevels() {
            var roofing = document.getElementById('inRoofing').value;
            var matchKey = SHEET_PROFILES[roofing] && SHEET_PROFILES[roofing].polycarbMatch;
            var pcProfile = matchKey ? POLYCARB_PROFILES[matchKey] : null;
            var levelSelect = document.getElementById('inPolycarbLevel');
            var profileLabel = document.getElementById('polycarbProfileLabel');
            if (!levelSelect) return;
            var levels = pcProfile ? pcProfile.levels : [1, 2];
            var currentVal = parseInt(levelSelect.value) || 1;
            levelSelect.innerHTML = levels.map(function(lv) {
                var label = lv === 1 ? 'Level 1 - Max Light' : lv === 2 ? 'Level 2 - Medium' : 'Level 3 - High Impact';
                return '<option value="' + lv + '"' + (lv === currentVal ? ' selected' : '') + '>' + label + '</option>';
            }).join('');
            if (!levels.includes(currentVal)) levelSelect.value = levels[0];
            if (profileLabel && pcProfile) {
                profileLabel.textContent = 'Profile: ' + pcProfile.name;
            }
        }

        // Init polycarb tints on load
        updatePolycarbTints();

        // Sync electrical checkboxes â†’ hidden dropdown for backward compatibility
        function syncElectricalCheckboxes() {
            var dl = document.getElementById('elecDownlights').checked;
            var fan = document.getElementById('elecFan').checked;
            var sel = document.getElementById('electrical');
            if (dl && fan) sel.value = 'both';
            else if (dl) sel.value = 'downlights';
            else if (fan) sel.value = 'fan';
            else sel.value = 'none';
            // Show SolarSpan note if relevant
            var roofing = (document.getElementById('inRoofing') || {}).value || '';
            var isSolar = roofing.indexOf('solarspan') === 0;
            var anyElec = dl || fan || document.getElementById('elecGPO').checked;
            var noteEl = document.getElementById('elecSolarSpanNote');
            if (noteEl) noteEl.style.display = (isSolar && anyElec) ? 'block' : 'none';
            updateUI();
        }

        // ==================== UI UPDATES ====================
        // Helper: enable/disable a toggle button by data-value within a group
        function setToggleBtnDisabled(groupId, value, disabled) {
            var group = document.getElementById(groupId);
            if (!group) return;
            var btn = group.querySelector('[data-value="' + value + '"]');
            if (btn) { btn.classList.toggle('disabled', disabled); }
        }

        function updateUI() {
            const roofEl = document.getElementById('inRoofStyle');
            const connEl = document.getElementById('inConnection');
            const roofingSelect = document.getElementById('inRoofing');
            let conn = connEl.value;
            const roofing = roofingSelect.value;
            const style = roofEl.value;
            const isGable = style === 'gable';
            const isHip = false; // hip removed

            // === RESTRICTION: Wall mount only works with skillion ===
            if (conn === 'wall') {
                if (isGable) { roofEl.value = 'skillion'; }
                setToggleBtnDisabled('roofStyleGroup', 'gable', true);
            } else {
                setToggleBtnDisabled('roofStyleGroup', 'gable', false);
            }

            // === RESTRICTION: Gable restricts wall connection ===
            if (isGable) {
                if (conn === 'wall') { connEl.value = 'riser'; conn = 'riser'; }
                setToggleBtnDisabled('connectionGroup', 'wall', true);
            } else {
                setToggleBtnDisabled('connectionGroup', 'wall', false);
            }

            // === RESTRICTION: Flyover only works with skillion (not gable) ===
            if (isGable) {
                if (conn === 'flyover') { connEl.value = 'riser'; conn = 'riser'; }
                setToggleBtnDisabled('connectionGroup', 'flyover', true);
            } else {
                setToggleBtnDisabled('connectionGroup', 'flyover', false);
            }

            // Sync toggle button active states after restriction changes
            syncAllToggleButtons();

            const isAttached = conn !== 'freestanding';

            // House Roof type toggle (attached only â€” freestanding has no house)
            var roofDesignField = document.getElementById('existingRoofDesignField');
            if (roofDesignField) roofDesignField.style.display = isAttached ? '' : 'none';

            // L-Shape house (attached only)
            document.getElementById('lshapeField').style.display = isAttached ? '' : 'none';
            if (!isAttached) document.getElementById('inLShape').value = 'none';

            // Wraparound patio (skillion + attached â€” independent of L-shape)
            const showWraparound = !isGable && isAttached &&
                (conn === 'riser' || conn === 'fascia' || conn === 'wall');
            document.getElementById('wraparoundField').style.display = showWraparound ? '' : 'none';

            // Validation: can't wraparound on same side as L-shape
            const wrapVal = document.getElementById('inWraparound').value;
            const lShapeVal = document.getElementById('inLShape').value;
            if (!showWraparound || (lShapeVal !== 'none' && wrapVal === lShapeVal)) {
                document.getElementById('inWraparound').value = 'none';
                document.getElementById('wraparoundDimsField').style.display = 'none';
                // Re-sync toggle button active state
                syncToggleButtons('wraparoundGroup', 'none');
            }
            const isWraparound = showWraparound && document.getElementById('inWraparound').value !== 'none';
            document.getElementById('wraparoundDimsField').style.display = isWraparound ? '' : 'none';
            // Show return projection info
            var wrapInfoEl = document.getElementById('wrapReturnInfo');
            if (wrapInfoEl && isWraparound) {
                var projMm = parseInt(document.getElementById('inWidth')?.value) || 4000;
                var retMm = parseInt(document.getElementById('inReturnLength')?.value) || 3000;
                wrapInfoEl.textContent = 'Proj: ' + projMm + 'mm | Hip 45Â°';
            }

            // Truss calculator section (gable only, not hip)
            document.getElementById('sec-truss').style.display = (style === 'gable') ? 'block' : 'none';

            // Gable infill in BASICS (gable or hip)
            document.getElementById('gableInfillField').style.display = isGable ? 'block' : 'none';

            // Auto-calculate posts and trusses from dimensions
            autoCalculatePostsAndTrusses();

            // Ceiling finish (SolarSpan only)
            document.getElementById('ceilingFinishField').style.display = isInsulated(roofing) ? 'block' : 'none';
            var cfcBlock = document.getElementById('ceilingFinishColorBlock');
            if (cfcBlock) cfcBlock.style.display = isInsulated(roofing) ? '' : 'none';

            // BMT dropdown (single-skin sheets only)
            const showBMT = (roofing === 'trimdek' || roofing === 'corrugated');
            document.getElementById('bmtField').style.display = showBMT ? 'block' : 'none';

            // Batten/Purlin calculator: show for all roof types
            document.getElementById('sec-battens').style.display = 'block';
            // Toggle subsections based on roof style
            document.getElementById('rafterSubsection').style.display = isGable ? 'none' : '';
            document.getElementById('skillionBattenSubsection').style.display = isGable ? 'none' : '';
            document.getElementById('gableBattenSubsection').style.display = isGable ? '' : 'none';
            // Update section title
            document.getElementById('battenSectionTitle').textContent = isGable ? 'Purlin Calculator' : 'Purlin & Batten Calculator';

            document.getElementById('pitchField').style.display = 'block';
            document.getElementById('calcPitchRow').style.display = 'none';

            // Connection sub-fields
            var showFasciaHeight = (conn === 'fascia' || conn === 'riser' || conn === 'flyover');
            document.getElementById('fasciaHeightField').style.display = showFasciaHeight ? 'block' : 'none';
            const showRiserOptions = conn === 'riser';
            document.getElementById('riserHeightField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserOffsetField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserQtyField').style.display = showRiserOptions ? 'block' : 'none';
            // Flyover options (show for flyover attachment)
            var flyoverField = document.getElementById('flyoverOptionsField');
            if (flyoverField) flyoverField.style.display = (conn === 'flyover') ? 'block' : 'none';
            // House Gutter Impact (show for riser attachment)
            var hgField = document.getElementById('houseGutterImpactField');
            if (hgField) hgField.style.display = showRiserOptions ? 'block' : 'none';
            var bgConfig = document.getElementById('boxGutterConfig');
            if (bgConfig) {
                var isBox = document.getElementById('inHouseGutter').value === 'box';
                bgConfig.style.display = isBox ? 'block' : 'none';
                if (isBox) updateBoxGutterSummary();
            }

            // Fascia brackets (show for gable with fascia connection)
            var showFasciaBrackets = isGable && conn === 'fascia';
            document.getElementById('fasciaBracketQtyField').style.display = showFasciaBrackets ? 'block' : 'none';

            // Polycarbonate: for profiles with a matching polycarb sheet
            const showPolycarb = !!hasPolycarbMatch(roofing);
            document.getElementById('polycarbField').style.display = showPolycarb ? 'block' : 'none';
            if (!showPolycarb) {
                const noRadio = document.querySelector('input[name="polycarb"][value="no"]');
                if (noRadio) noRadio.checked = true;
                var pcOpts = document.getElementById('polycarbOptions');
                if (pcOpts) pcOpts.style.display = 'none';
            }
            // Update polycarb level options based on profile
            if (showPolycarb) updatePolycarbLevels();

            // House attachment subsection: hide for freestanding
            updateAttachmentVisibility();
        }

        // ==================== GET INPUTS & CALCULATE ====================
        function getInputs() {
            const roofStyle = document.getElementById('inRoofStyle').value;
            const orientation = document.getElementById('inOrientation').value;
            const projInput = (parseFloat(document.getElementById('inWidth').value) || 3) * 1000;
            const lenInput = (parseFloat(document.getElementById('inLength').value) || 6) * 1000;
            const userPitch = parseFloat(document.getElementById('inPitch').value) || 10;
            const postH = (parseFloat(document.getElementById('inPostHeight').value) || 2.4) * 1000;
            const nPosts = parseInt(document.getElementById('inPosts').value) || 3;
            const nTruss = parseInt(document.getElementById('inTrusses').value) || 3;
            const nRafters = parseInt(document.getElementById('inRafters').value) || 5;
            const rafterSizeKey = document.getElementById('inRafterSize')?.value || '75x35';
            const rafterSize = RAFTER_SIZES[rafterSizeKey] || RAFTER_SIZES['75x35'];
            const rafterSpacing = parseInt(document.getElementById('inRafterSpacing')?.value) || 900;
            const rafterQtyOverrideVal = parseInt(document.getElementById('inRafterQtyOverride')?.value);
            const rafterQtyOverride = (rafterQtyOverrideVal >= 2) ? rafterQtyOverrideVal : 0;
            const purlinSizeKey = document.getElementById('inPurlinSize')?.value || '76x38';
            const purlinSize = PURLIN_SIZES[purlinSizeKey] || PURLIN_SIZES['76x38'];
            const postSizeKey = document.getElementById('inPostSize').value;
            const beamSizeKey = document.getElementById('inBeamSize').value;
            const framePost = FRAME_POSTS[postSizeKey] || FRAME_POSTS['90x90'];
            const frameBeam = FRAME_BEAMS[beamSizeKey] || FRAME_BEAMS['100x50'];
            const sheetBMT = document.getElementById('inBMT').value;
            const trussStyle = document.getElementById('inTrussBase').value;
            const trussChord = document.getElementById('inTrussChord').value;
            const trussSteel = document.getElementById('inTrussSteel').value;

            // Truss options: extender + separate risers (L/R)
            // Use helper to allow 0 as valid input (|| would treat 0 as falsy)
            function numVal(id, def) { const v = parseFloat(document.getElementById(id)?.value); return isNaN(v) ? def : v; }
            const trussExtOn = document.getElementById('trussExtOn')?.checked || false;
            const trussExtLen = trussExtOn ? numVal('trussExtLen', 300) : 0;
            const trussRiserOn = document.getElementById('trussRiserOn')?.checked || false;
            const trussRiserLocked = document.getElementById('trussRiserLock')?.checked ?? true;
            const trussRiserType = document.getElementById('riserTypeSeparate')?.checked ? 'separate' : 'welded';
            const riserLH = trussRiserOn ? numVal('riserLH', 200) : 0;
            const riserLV = trussRiserOn ? numVal('riserLV', 150) : 0;
            const riserRH = trussRiserOn ? numVal('riserRH', 200) : 0;
            const riserRV = trussRiserOn ? numVal('riserRV', 150) : 0;
            const roofing = document.getElementById('inRoofing').value;
            const infill = document.getElementById('inInfill').value;
            const connection = document.getElementById('inConnection').value;
            const fasciaH = parseFloat(document.getElementById('inFasciaHeight').value) || 2700;
            const riserH = parseFloat(document.getElementById('inRiserHeight').value) || 400;
            const riserOffset = parseFloat(document.getElementById('inRiserOffset').value) || 150;
            const riserQtyInput = parseInt(document.getElementById('inRiserQty').value);
            const houseGutter = document.getElementById('inHouseGutter').value;
            const riserGutter = document.getElementById('inRiserGutter')?.value || 'none';
            const fasciaBracketQty = parseInt(document.getElementById('inFasciaBracketQty').value) || 4;

            // Flyover configuration
            const houseRoofPitch = parseFloat(document.getElementById('inHouseRoofPitch')?.value) || 22.5;
            const houseRoofDepth = parseFloat(document.getElementById('inHouseRoofDepth')?.value) || 1500;
            const flyoverSetback = parseFloat(document.getElementById('inFlyoverSetback')?.value) || 600;
            const flyoverClearance = parseFloat(document.getElementById('inFlyoverClearance')?.value) || 150;

            const lShape = document.getElementById('inLShape')?.value || 'none';

            const isGable = roofStyle === 'gable' || roofStyle === 'hip';
            const isAttached = connection !== 'freestanding';
            const hasFascia = (connection === 'fascia' || connection === 'riser' || connection === 'flyover');
            const isRecvChan = (connection === 'fascia' && !isGable) || (connection === 'wall');

            let W, L;
            if (isGable && orientation === 'perpendicular') {
                W = lenInput;
                L = projInput;
            } else {
                W = projInput;
                L = lenInput;
            }

            // ========== V18 FIX: BEAM HEIGHTS - Proper stacking for gable+riser ==========
            let frontBeamY = postH;
            const beamH = frameBeam.h * 1000;  // beam height in mm from selected beam size
            const riserSteelKey = document.getElementById('inRiserSteel')?.value || '76x38';
            const RISER_STEEL_MAP = {
                '76x38': {w:0.076, h:0.038, name:'76Ã—38Ã—1.6 RHS', label:'76Ã—38 RHS'},
                '75x50': {w:0.075, h:0.05,  name:'75Ã—50Ã—2 RHS',   label:'75Ã—50 RHS'},
                '100x50':{w:0.1,   h:0.05,  name:'100Ã—50Ã—2 RHS',  label:'100Ã—50 RHS'}
            };
            const riserSteelSize = RISER_STEEL_MAP[riserSteelKey] || RISER_STEEL_MAP['76x38'];
            const riserMemberSize = riserSteelSize.w * 1000;  // riser RHS width in mm
            // Patio attaches at rafter level (fasciaH = wall top / rafter base)
            // This is ABOVE the fascia board and gutter which hang below

            let backBeamY, fasciaBeamY;
            if (isGable) {
                if (connection === 'riser') {
                    // Gable + Riser: fascia beam sits below house gutter, against lower house fascia
                    // Gutter front face 76mm + 5mm gap â‰ˆ beam top 50mm below fascia top
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    const elevatedBeamY = fasciaH + beamH + riserMemberSize + riserH;
                    frontBeamY = elevatedBeamY;
                    backBeamY = elevatedBeamY;
                } else if (connection === 'fascia') {
                    // Gable + Fascia: fascia beam below gutter, trusses ELEVATED via dogleg
                    // Dogleg drops from truss heel down around gutter to fascia beam
                    fasciaBeamY = fasciaH - 155;   // Below gutter, in exposed lower fascia zone
                    // Auto-calculate dogleg to clear gutter
                    const doglegV = trussRiserOn ? riserLV : 300;  // user override OR default 300mm
                    const doglegH = trussRiserOn ? riserLH : 200;  // user override OR default 200mm
                    const elevatedBeamY = fasciaBeamY + doglegV + beamH;
                    frontBeamY = elevatedBeamY;
                    backBeamY = elevatedBeamY;
                } else if (connection === 'wall') {
                    // Gable + Wall: channel mounts to wall surface at wall top
                    fasciaBeamY = null;
                    frontBeamY = fasciaH;
                    backBeamY = fasciaH;
                } else if (connection === 'flyover') {
                    // Gable + Flyover: beams above existing house roof
                    fasciaBeamY = fasciaH;
                    // Post position on roof: setback from fascia determines roof height at that point
                    const roofHeightAtPost = flyoverSetback * Math.tan(houseRoofPitch * Math.PI / 180);
                    const flyoverBeamY = fasciaH + roofHeightAtPost + flyoverClearance;
                    frontBeamY = flyoverBeamY;
                    backBeamY = flyoverBeamY;
                } else {
                    // Freestanding - back beam at post height
                    backBeamY = postH;
                    fasciaBeamY = null;
                }
            } else {
                // SKILLION â€” user always controls pitch
                const skillionRise = W * Math.tan(userPitch * Math.PI / 180);
                if (connection === 'freestanding') {
                    backBeamY = postH + skillionRise;
                    fasciaBeamY = null;
                } else if (connection === 'riser') {
                    // Fascia beam sits below house gutter, against lower house fascia
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    backBeamY = fasciaH + beamH + riserMemberSize + riserH;
                    frontBeamY = backBeamY - skillionRise;
                } else if (connection === 'flyover') {
                    fasciaBeamY = fasciaH;
                    // Post position on roof: setback determines roof height at post location
                    const roofHeightAtPost = flyoverSetback * Math.tan(houseRoofPitch * Math.PI / 180);
                    backBeamY = fasciaH + roofHeightAtPost + flyoverClearance;
                    frontBeamY = backBeamY - skillionRise;
                } else if (connection === 'fascia') {
                    // Fascia: beam below house gutter, in exposed fascia zone
                    // Receiving channel bolts to fascia face below gutter; sheets slide into it
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    backBeamY = fasciaH - 155;
                    frontBeamY = backBeamY - skillionRise;
                } else {
                    // Wall: channel mounts to wall surface at wall top
                    fasciaBeamY = null;
                    backBeamY = fasciaH;
                    frontBeamY = backBeamY - skillionRise;
                }
            }

            // ========== PITCH & RISE CALCULATION ==========
            let pitch, pitchRad, rise, rafter, trussSpan;

            if (isGable) {
                pitch = userPitch;
                pitchRad = pitch * Math.PI / 180;
                trussSpan = W;
                rise = (W / 2) * Math.tan(pitchRad);
                rafter = Math.sqrt((W / 2) ** 2 + rise ** 2);
            } else {
                pitch = userPitch;
                pitchRad = pitch * Math.PI / 180;
                rise = backBeamY - frontBeamY;
                rafter = Math.sqrt(W ** 2 + rise ** 2);
                trussSpan = W;
            }

            // Batten calculation for skillion with single-skin sheets
            const sheetSpanKey = getSheetSpanKey(roofing, sheetBMT);
            const extraBattensCount = parseInt(document.getElementById('extraBattensVal')?.textContent) || 0;
            const battenCalc = calculateBattens(sheetSpanKey, W, L, extraBattensCount);
            const bracketType = document.querySelector('input[name="bracketType"]:checked')?.value || 'internal';
            const bracketCalc = calculateBrackets(battenCalc.battensNeeded, L);
            const battenValidation = validateBattenSetup(sheetSpanKey, W, pitch);

            // Gable batten/purlin calculation
            const gableExtraBattens = parseInt(document.getElementById('gableExtraBattensVal')?.textContent) || 0;
            const gableBattenCalc = isGable ? calculateGableBattens(roofing, Math.round(rafter), Math.round(L), gableExtraBattens) : null;

            // Rafter calculation
            const rafterCalc = calculateRafters(L, rafterSpacing, rafterQtyOverride);

            calc = {
                roofStyle, orientation, W, L, projInput, lenInput, userPitch, pitch, pitchRad,
                postH, nPosts, nTruss, nRafters, trussStyle, trussChord, trussSteel, trussSpan,
                roofing, sheetBMT, infill, connection, fasciaH, riserH, riserOffset, houseGutter, riserGutter,
                ceilingFinish: document.getElementById('inCeilingFinish')?.value || 'plain',
                houseRoofPitch, houseRoofDepth, flyoverSetback, flyoverClearance,
                fasciaBracketQty,
                riserQty: riserQtyInput || Math.max(2, Math.ceil(L / 1200)),
                rise, rafter, isGable, isAttached, hasFascia, isRecvChan,
                frontBeamY, backBeamY, fasciaBeamY,
                steel: STEEL[trussSteel],
                framePost, frameBeam, rafterSize, purlinSize,
                sheetCoverage: SHEET_COVERAGE[roofing],
                sheetCalc: calculateSheets(Math.round(L), roofing),
                sheetSpanKey, battenCalc, bracketCalc, bracketType, battenValidation,
                gableBattenCalc,
                rafterCalc, rafterSpacing,
                postSpacing: nPosts > 1 ? Math.round(L / (nPosts - 1)) : L,
                postQtyOverride: !!(document.getElementById('inPostQty')?.value && parseInt(document.getElementById('inPostQty')?.value) >= 2),
                trussRiserLeft: { enabled: trussRiserOn, length: riserLH, height: riserLV },
                trussRiserRight: { enabled: trussRiserOn, length: riserRH, height: riserRV },
                trussRiserLocked: trussRiserLocked,
                riserType: trussRiserOn ? trussRiserType : null,
                trussExtender: { enabled: trussExtOn, length: trussExtLen },
                lShape: lShape,
                existingRoof: document.getElementById('existingRoof')?.value || 'tiles',
                wrapSide: (function() {
                    var v = document.getElementById('inWraparound')?.value || 'none';
                    return (v !== 'none' && !isGable && v !== lShape) ? v : 'none';
                })(),
                isWraparound: (function() {
                    var v = document.getElementById('inWraparound')?.value || 'none';
                    return v !== 'none' && !isGable && v !== lShape;
                })(),
                returnLength: parseInt(document.getElementById('inReturnLength')?.value) || 3000,
                returnPosts: parseInt(document.getElementById('inReturnPosts')?.value) || 2,
                postFix: document.getElementById('inPostFix')?.value || 'concrete',
                riserSteelSize: riserSteelSize,
                dpSelection: dpSelection.slice(),
                dpCount: getDpCount(),
                dpPostIndices: getDpPostIndices()
            };

            // Auto-enable house-side truss riser for gable+fascia (dogleg connection)
            if (isGable && connection === 'fascia' && !trussRiserOn) {
                const defLH = 200, defLV = 300;
                calc.trussRiserLeft = { enabled: true, length: defLH, height: defLV };
                calc.trussRiserRight = { enabled: false, length: 0, height: 0 };
                calc.riserType = 'welded';
                // Sync UI
                document.getElementById('trussRiserOn').checked = true;
                var lhEl = document.getElementById('riserLH'); if (lhEl) lhEl.value = defLH;
                var lvEl = document.getElementById('riserLV'); if (lvEl) lvEl.value = defLV;
                if (typeof toggleTrussOpt === 'function') toggleTrussOpt();
            }

            var calcRiseEl = document.getElementById('calcRise');
            if (calcRiseEl) calcRiseEl.textContent = Math.round(rise) + 'mm';
            var calcRafterEl = document.getElementById('calcRafter');
            if (calcRafterEl) calcRafterEl.textContent = Math.round(rafter) + 'mm';
            var calcPitchEl = document.getElementById('calcPitch');
            if (calcPitchEl) calcPitchEl.textContent = pitch.toFixed(1) + 'Â°';
            // Also update right panel
            var rpRiseEl = document.getElementById('rpRise');
            if (rpRiseEl) rpRiseEl.textContent = Math.round(rise) + 'mm';
            var rpRafterEl = document.getElementById('rpRafter');
            if (rpRafterEl) rpRafterEl.textContent = Math.round(rafter) + 'mm';
            // Set riser qty placeholder to show calculated default
            var riserQtyEl = document.getElementById('inRiserQty');
            if (riserQtyEl) riserQtyEl.placeholder = Math.max(2, Math.ceil(L / 1200));

            if (isGable) {
                const steelW = STEEL[trussSteel].w * 1000;
                const steelH = STEEL[trussSteel].h * 1000;
                const bmt = STEEL[trussSteel].bmt;
                const overhang = parseFloat(document.getElementById('inOverhang')?.value) || 0;
                const apexAngle = 90 - pitch;
                const heelAngle = pitch;
                const cosP = Math.cos(pitchRad);
                const sinP = Math.sin(pitchRad);

                // Bottom chord: full span (truss is a standard gable shape)
                const chordCut = Math.round(trussSpan - 2 * steelH * cosP);

                // Rafter cut length: from heel face to apex face
                const apexDeduct = steelH / (2 * sinP);
                const heelAllowance = steelH * cosP;
                const rafterCut = Math.round(rafter - apexDeduct - heelAllowance + overhang);

                // Truss steel: chord + 2 rafters
                let trussLM = (chordCut + 2 * rafterCut) / 1000;
                const stickLength = 6000;

                // Extender: extends bottom chord at BOTH ends (gutter bracket mount point)
                let extLM = 0;
                if (trussExtOn) {
                    extLM = (2 * trussExtLen) / 1000;
                }
                trussLM += extLM;

                const kingPostH = rise - steelH;

                // Web member calculations
                let webLM = 0;
                let webText = '';
                let webMembers = []; // array of {type, count, length}
                const showWeb = trussStyle !== 'open';
                document.getElementById('webCard').style.display = showWeb ? 'block' : 'none';

                const halfSpanMM = trussSpan / 2;
                const chordYmm = (trussChord === 'mid') ? (steelH + rise / 3) : steelH;
                const kh = Math.round(kingPostH);

                // Helper: get rafter Y at a given X distance from center
                function rafterYatX(x) {
                    return steelH + rise * (1 - x / halfSpanMM);
                }

                // Helper: calculate diagonal length between two points
                function diagLength(x1, y1, x2, y2) {
                    return Math.round(Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)));
                }

                // Legacy style mapping
                var effectiveStyle = trussStyle;
                if (trussStyle === 'kingfan' || trussStyle === 'queenpost') effectiveStyle = 'kingverticals';
                if (trussStyle === 'kingstrut' || trussStyle === 'fink' || trussStyle === 'open') effectiveStyle = 'web';

                if (effectiveStyle === 'kingpost') {
                    // Single center vertical: bottom chord to ridge
                    webMembers.push({type: 'King Post', count: 1, length: kh});
                    webLM = kh / 1000;
                    webText = '  King Post:     1 \u00D7 ' + kh + 'mm';

                } else if (effectiveStyle === 'kingverticals') {
                    // King post + additional verticals at quarter-span points
                    webMembers.push({type: 'King Post', count: 1, length: kh});
                    webLM = kh / 1000;

                    var qpx = halfSpanMM / 2;
                    var qpChordTop = chordYmm + steelH / 2;
                    var qpRafterBottom = rafterYatX(qpx) - steelH / 2;
                    var qpH = Math.round(qpRafterBottom - qpChordTop);
                    if (qpH > steelH) {
                        webMembers.push({type: 'Vertical', count: 2, length: qpH});
                        webLM += (qpH / 1000) * 2;
                    }

                    webText = '  King Post:     1 \u00D7 ' + kh + 'mm';
                    if (qpH > steelH) {
                        webText += '\n  Verticals:     2 \u00D7 ' + qpH + 'mm';
                    }

                } else if (effectiveStyle === 'web') {
                    // Web: king post + diagonal struts from king post base to rafter quarter-points
                    webMembers.push({type: 'King Post', count: 1, length: kh});
                    webLM = kh / 1000;

                    var wChordTop = chordYmm + steelH / 2;
                    var wQpX = halfSpanMM / 2;
                    var wRafterQpY = rafterYatX(wQpX) - steelH / 2;
                    var wDx = wQpX;
                    var wDy = wRafterQpY - wChordTop;
                    var webDiagLen = Math.round(Math.sqrt(wDx * wDx + wDy * wDy));
                    if (webDiagLen > steelH) {
                        webMembers.push({type: 'Web Diagonal', count: 2, length: webDiagLen});
                        webLM += (webDiagLen / 1000) * 2;
                    }

                    webText = '  King Post:     1 \u00D7 ' + kh + 'mm';
                    if (webDiagLen > steelH) {
                        webText += '\n  Web Diags:     2 \u00D7 ' + webDiagLen + 'mm';
                    }
                }

                // Update web card display
                if (showWeb) {
                    var styleNames = {kingpost:'King Post', kingverticals:'King Post + Verticals', web:'Web'};
                    var styleName = styleNames[effectiveStyle] || effectiveStyle;
                    var totalPcs = 0;
                    var cutList = [];
                    for (var wi = 0; wi < webMembers.length; wi++) {
                        totalPcs += webMembers[wi].count;
                        cutList.push(webMembers[wi].count + '\u00D7' + webMembers[wi].length + 'mm');
                    }
                    document.getElementById('webStyle').textContent = styleName;
                    document.getElementById('webCount').textContent = totalPcs + ' pcs';
                    document.getElementById('webCuts').textContent = cutList.join(', ') || '--';
                    document.getElementById('webLM').textContent = webLM.toFixed(2) + ' LM';
                }

                const totalLM = trussLM + webLM;
                const totalAllLM = totalLM * nTruss;
                const totalSticks = Math.ceil((totalAllLM * 1000) / stickLength);

                // Riser steel: SEPARATE pieces bolted to truss ends (not part of truss)
                const riserLeftLM = trussRiserOn ? (riserLH + riserLV) / 1000 : 0;
                const riserRightLM = trussRiserOn ? (riserRH + riserRV) / 1000 : 0;
                const riserTotalLM = (riserLeftLM + riserRightLM) * nTruss;

                // Update spec cards
                document.getElementById('specA').textContent = Math.round(trussSpan) + 'mm';
                document.getElementById('specB').textContent = Math.round(rise) + 'mm';
                document.getElementById('specC').textContent = Math.round(rafter) + 'mm';
                document.getElementById('specD').textContent = pitch.toFixed(1) + '\u00B0';

                // Conditional dimension items
                document.getElementById('specExtItem').style.display = trussExtOn ? 'block' : 'none';
                document.getElementById('specRiserLItem').style.display = trussRiserOn ? 'block' : 'none';
                document.getElementById('specRiserRItem').style.display = trussRiserOn ? 'block' : 'none';
                document.getElementById('specRiserLMitem').style.display = trussRiserOn ? 'block' : 'none';
                if (trussExtOn) {
                    document.getElementById('specExt').textContent = Math.round(trussExtLen) + 'mm';
                }
                if (trussRiserOn) {
                    document.getElementById('specRiserL').textContent = Math.round(riserLH) + 'mm \u00D7 ' + Math.round(riserLV) + 'mm';
                    document.getElementById('specRiserR').textContent = Math.round(riserRH) + 'mm \u00D7 ' + Math.round(riserRV) + 'mm';
                    document.getElementById('specRiserLM').textContent = (riserLeftLM + riserRightLM).toFixed(2) + 'lm';
                }

                document.getElementById('specChordCut').textContent = chordCut + 'mm' + (trussExtOn ? ' (+' + Math.round(trussExtLen * 2) + 'mm ext)' : '');
                document.getElementById('specRafterCut').textContent = rafterCut + 'mm' + (overhang > 0 ? ' (+' + overhang + 'mm)' : '');
                document.getElementById('specLMper').textContent = totalLM.toFixed(2) + 'lm';
                document.getElementById('specLMall').textContent = totalAllLM.toFixed(1) + 'lm' + (riserTotalLM > 0 ? ' (+' + riserTotalLM.toFixed(1) + 'lm risers)' : '');

                document.getElementById('angleApex').textContent = apexAngle.toFixed(1) + '\u00B0';
                document.getElementById('angleBase').textContent = heelAngle.toFixed(1) + '\u00B0';

                // Build CMI format order text
                const steelName = STEEL[trussSteel].name;
                const clr = steelColor.name;

                const baseNames = {kingpost:'King Post', kingverticals:'King Post + Verticals', web:'Web', kingfan:'King Post + Verticals', queenpost:'King Post + Verticals', kingstrut:'Web', fink:'Web', open:'Web'};
                const baseName = baseNames[trussStyle] || 'King Post';
                const chordName = trussChord === 'bottom' ? 'Bottom Chord' : (trussChord === 'mid' ? 'Mid Chord' : 'No Chord');
                let extras = '';
                if (trussExtOn) extras += ' + Extender';
                if (trussRiserOn) extras += ' + Risers (separate)';
                const line1 = nTruss + '\u00D7 Gable Truss - ' + baseName + ', ' + chordName + extras;

                let dims = 'SP: ' + Math.round(trussSpan) + '  HT: ' + Math.round(rise);
                if (trussExtOn) dims += '  Ext: ' + Math.round(trussExtLen);

                const line3 = steelName + ' RHS - ' + clr;

                let fab = line1 + '\n ' + dims + '\n ' + line3;

                fab += '\n\n\u2500\u2500 Cut List (per truss) \u2500\u2500';
                fab += '\n Chord:        1 \u00D7 ' + chordCut + 'mm';
                if (trussExtOn) {
                    fab += '\n Extender:     2 \u00D7 ' + Math.round(trussExtLen) + 'mm';
                }
                fab += '\n Rafters:      2 \u00D7 ' + rafterCut + 'mm';
                for (var wi = 0; wi < webMembers.length; wi++) {
                    var wm = webMembers[wi];
                    var label = (wm.type + ':').padEnd(14, ' ');
                    fab += '\n ' + label + wm.count + ' \u00D7 ' + wm.length + 'mm';
                }
                fab += '\n Apex Mitre:   ' + apexAngle.toFixed(1) + '\u00B0';
                fab += '\n Heel Mitre:   ' + heelAngle.toFixed(1) + '\u00B0';

                if (trussRiserOn) {
                    fab += '\n\n\u2500\u2500 Risers (separate steel) \u2500\u2500';
                    fab += '\n Left:  ' + Math.round(riserLH) + 'mm horiz + ' + Math.round(riserLV) + 'mm vert = ' + riserLeftLM.toFixed(2) + ' LM';
                    fab += '\n Right: ' + Math.round(riserRH) + 'mm horiz + ' + Math.round(riserRV) + 'mm vert = ' + riserRightLM.toFixed(2) + ' LM';
                    fab += '\n Total riser steel: ' + riserTotalLM.toFixed(2) + ' LM (' + nTruss + ' trusses)';
                }

                fab += '\n\n\u2500\u2500 Material \u2500\u2500';
                fab += '\n Truss LM/ea: ' + totalLM.toFixed(3) + ' LM';
                fab += '\n Truss total: ' + totalAllLM.toFixed(2) + ' LM';
                if (riserTotalLM > 0) fab += '\n Riser total: ' + riserTotalLM.toFixed(2) + ' LM';
                fab += '\n Grand total: ' + (totalAllLM + riserTotalLM).toFixed(2) + ' LM';
                fab += '\n Order:       ' + Math.ceil(((totalAllLM + riserTotalLM) * 1000) / stickLength) + ' \u00D7 6m sticks';

                document.getElementById('fabOrder').textContent = fab;

                // Store truss data for PDF export
                calc.trussData = {
                    steelName, bmt, clr, nTruss, trussSpan: Math.round(trussSpan),
                    rise: Math.round(rise), pitch, overhang, chordCut, rafterCut,
                    apexAngle, heelAngle, webText, webMembers, totalLM, totalAllLM, totalSticks,
                    trussStyle, trussChord, kingPostH: Math.round(kingPostH),
                    riserLeft: { enabled: trussRiserOn, length: riserLH, height: riserLV, lm: riserLeftLM },
                    riserRight: { enabled: trussRiserOn, length: riserRH, height: riserRV, lm: riserRightLM },
                    riserTotalLM: riserTotalLM,
                    extender: { enabled: trussExtOn, length: trussExtLen }
                };
            }

            return calc;
        }

        // ==================== 2D PLAN ====================
        function draw2DPlan() {
            const canvas = document.getElementById('plan2d');
            const p = canvas.parentElement;
            canvas.width = p.clientWidth; canvas.height = p.clientHeight;
            const ctx = canvas.getContext('2d');
            const c = calc;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            const planL = c.lenInput;
            const planW = c.projInput;
            const isWrap = c.wrapSide !== 'none';
            const isLeft = c.wrapSide === 'left';
            const retLen = isWrap ? c.returnLength : 0;
            const retW = isWrap ? c.projInput : 0;

            // Expand bounding box for wraparound (return extends in L direction, same W range)
            const totalW = isWrap ? Math.max(planW, retLen) : planW;
            const totalL = isWrap ? planL + retW : planL;

            const scale = Math.min((canvas.width-60)/totalL, (canvas.height-60)/totalW) * 0.85;
            // Offset origin to keep main patio centered with room for return
            const ox = isWrap ? (isLeft ? (canvas.width - totalL*scale)/2 + retW*scale : (canvas.width - totalL*scale)/2) : (canvas.width - planL*scale)/2;
            const oy = (canvas.height - totalW*scale)/2 + 10;

            if (c.connection !== 'freestanding') {
                ctx.fillStyle = '#D4C4B0';
                ctx.fillRect(ox-5, oy-20, planL*scale+10, 18);
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('HOUSE', ox+planL*scale/2, oy-6);
            }

            // Main patio rectangle
            ctx.strokeStyle = steelColor.hex;
            ctx.lineWidth = 2;
            ctx.strokeRect(ox, oy, planL*scale, planW*scale);

            ctx.strokeStyle = '#F15A29';
            ctx.lineWidth = 2;
            if (c.isGable) {
                if (c.orientation === 'lengthways') {
                    ctx.beginPath();
                    ctx.moveTo(ox, oy + planW*scale/2);
                    ctx.lineTo(ox + planL*scale, oy + planW*scale/2);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.fillText('RIDGE', ox + planL*scale/2, oy + planW*scale/2 - 5);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(ox + planL*scale/2, oy);
                    ctx.lineTo(ox + planL*scale/2, oy + planW*scale);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.save();
                    ctx.translate(ox + planL*scale/2 + 12, oy + planW*scale/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.fillText('RIDGE', 0, 0);
                    ctx.restore();
                }
            } else {
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2, oy + 15);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2 - 6, oy + planW*scale - 25);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.lineTo(ox + planL*scale/2 + 6, oy + planW*scale - 25);
                ctx.stroke();
                ctx.fillStyle = '#F15A29';
                ctx.font = '9px sans-serif';
                ctx.fillText('FALL ' + calc.pitch.toFixed(1) + 'Â°', ox + planL*scale/2 + 30, oy + planW*scale/2);
            }

            ctx.fillStyle = steelColor.hex;
            for (let i = 0; i < c.nPosts; i++) {
                const x = ox + (planL*scale/(c.nPosts-1)) * i;
                ctx.fillRect(x-4, oy + planW*scale - 4, 8, 8);
            }

            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = ox + (planL*scale/(c.nPosts-1)) * i;
                    ctx.fillRect(x-4, oy - 4, 8, 8);
                }
            }

            if (c.isAttached) {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.lineTo(ox + planL*scale, oy);
                ctx.stroke();
                ctx.fillStyle = '#666';
                ctx.font = '8px sans-serif';
                ctx.fillText('FASCIA', ox + planL*scale/2, oy + 10);
            }

            // Wraparound return section
            // Return extends from the wing wall TOWARD the gutter (downward in canvas Y)
            // Return projection (retW) runs along canvas X, away from wing wall
            // Return length (retLen) runs along canvas Y, from house wall toward gutter
            if (isWrap) {
                const wingEdgeX = isLeft ? ox : ox + planL*scale;
                const retRectX = isLeft ? wingEdgeX - retW*scale : wingEdgeX;
                const retRectY = oy;  // starts at house wall, extends toward gutter

                // Subtle fill for return section to visually distinguish it
                ctx.fillStyle = 'rgba(76, 106, 124, 0.06)';
                ctx.fillRect(retRectX, retRectY, retW*scale, retLen*scale);

                // Return rectangle outline
                ctx.strokeStyle = steelColor.hex;
                ctx.lineWidth = 2;
                ctx.strokeRect(retRectX, retRectY, retW*scale, retLen*scale);

                // Sheet direction arrows â€” main patio (vertical, toward gutter)
                ctx.strokeStyle = 'rgba(76, 106, 124, 0.3)';
                ctx.lineWidth = 1;
                var mainArrowX = ox + planL * scale * 0.3;
                var mainArrowY1 = oy + planW * scale * 0.35;
                var mainArrowY2 = oy + planW * scale * 0.65;
                ctx.beginPath();
                ctx.moveTo(mainArrowX, mainArrowY1);
                ctx.lineTo(mainArrowX, mainArrowY2);
                ctx.moveTo(mainArrowX - 4, mainArrowY2 - 8);
                ctx.lineTo(mainArrowX, mainArrowY2);
                ctx.lineTo(mainArrowX + 4, mainArrowY2 - 8);
                ctx.stroke();

                // Sheet direction arrows â€” return (horizontal, away from house wall)
                var retArrowDir = isLeft ? -1 : 1;
                var retArrowY = oy + retLen * scale * 0.4;
                var retArrowX1 = wingEdgeX + retArrowDir * retW * scale * 0.3;
                var retArrowX2 = wingEdgeX + retArrowDir * retW * scale * 0.7;
                ctx.beginPath();
                ctx.moveTo(retArrowX1, retArrowY);
                ctx.lineTo(retArrowX2, retArrowY);
                ctx.moveTo(retArrowX2 - retArrowDir * 8, retArrowY - 4);
                ctx.lineTo(retArrowX2, retArrowY);
                ctx.lineTo(retArrowX2 - retArrowDir * 8, retArrowY + 4);
                ctx.stroke();

                // Hip line (diagonal from house corner toward gutter)
                const hipEndX = isLeft ? wingEdgeX - retW*scale : wingEdgeX + retW*scale;
                const hipEndY = oy + Math.min(retLen, c.projInput) * scale;
                // Hip line fill (subtle triangle highlight)
                ctx.fillStyle = 'rgba(241, 90, 41, 0.05)';
                ctx.beginPath();
                ctx.moveTo(wingEdgeX, oy);
                ctx.lineTo(hipEndX, hipEndY);
                ctx.lineTo(wingEdgeX, hipEndY);
                ctx.closePath();
                ctx.fill();
                // Hip line stroke
                ctx.strokeStyle = '#F15A29';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(wingEdgeX, oy);
                ctx.lineTo(hipEndX, hipEndY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Hip label with background pill
                var hipLabelX = (wingEdgeX + hipEndX) / 2 + (isLeft ? -12 : 12);
                var hipLabelY = (oy + hipEndY) / 2;
                ctx.font = 'bold 8px sans-serif';
                var hipLabelW = ctx.measureText('HIP 45Â°').width + 6;
                ctx.fillStyle = 'rgba(241, 90, 41, 0.12)';
                ctx.beginPath();
                ctx.roundRect(hipLabelX - hipLabelW/2, hipLabelY - 6, hipLabelW, 12, 3);
                ctx.fill();
                ctx.fillStyle = '#F15A29';
                ctx.textAlign = 'center';
                ctx.fillText('HIP 45Â°', hipLabelX, hipLabelY + 3);

                // Return section label
                ctx.font = '9px sans-serif';
                ctx.fillStyle = '#4C6A7C';
                ctx.textAlign = 'center';
                var retCenterX = retRectX + retW * scale / 2;
                var retCenterY = oy + retLen * scale * 0.75;
                ctx.fillText('RETURN', retCenterX, retCenterY);

                // Return gutter posts along outer edge
                ctx.fillStyle = steelColor.hex;
                const retGutterEdgeX = isLeft ? retRectX : retRectX + retW*scale;
                for (let i = 0; i < c.returnPosts; i++) {
                    const y = oy + (c.returnPosts > 1 ? (retLen*scale / (c.returnPosts - 1)) * i : retLen*scale/2);
                    ctx.fillRect(retGutterEdgeX-4, y-4, 8, 8);
                }

                // Corner post at gutter intersection
                ctx.fillRect(wingEdgeX-4, oy + planW*scale - 4, 8, 8);

                // Return dimension label (along outer gutter edge)
                ctx.fillStyle = '#333';
                ctx.font = '11px monospace';
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(retGutterEdgeX + (isLeft ? -15 : 15), oy + retLen*scale/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(c.returnLength + 'mm', 0, 0);
                ctx.restore();

                // House side wall indication (runs alongside return from house wall)
                ctx.strokeStyle = '#D4C4B0';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(wingEdgeX, oy - 2);
                ctx.lineTo(wingEdgeX, oy + retLen*scale);
                ctx.stroke();
                // Side wall label
                ctx.fillStyle = '#999';
                ctx.font = '7px sans-serif';
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(wingEdgeX + (isLeft ? 8 : -8), oy + retLen*scale * 0.5);
                ctx.rotate(-Math.PI/2);
                ctx.fillText('SIDE WALL', 0, 0);
                ctx.restore();
            }

            ctx.fillStyle = '#333';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(planL + 'mm', ox + planL*scale/2, oy + planW*scale + 20);
            ctx.save();
            ctx.translate(ox - 15, oy + planW*scale/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText(planW + 'mm', 0, 0);
            ctx.restore();
        }

        // ==================== TRUSS 3D (Section 2) ====================
        let trussScene, trussCam, trussRend, trussGroup, trussControls;

        function initTruss3D() {
            const container = document.getElementById('trussViewport');
            const canvas = document.getElementById('trussCanvas');
            var w = container.clientWidth || 600;
            var h = container.clientHeight || 420;
            trussScene = new THREE.Scene();
            trussScene.background = new THREE.Color(0xF0F2F5);
            var frustumSize = 3;
            trussCam = new THREE.OrthographicCamera(
                -frustumSize * (w/h) / 2, frustumSize * (w/h) / 2,
                frustumSize / 2, -frustumSize / 2,
                0.01, 50
            );
            trussRend = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true});
            trussRend.setSize(w, h);
            trussRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            trussRend.outputEncoding = THREE.sRGBEncoding;
            trussRend.toneMapping = THREE.ReinhardToneMapping;
            trussRend.toneMappingExposure = 1.0;

            // Hemisphere light adds subtle top/bottom variation vs flat ambient
            trussScene.add(new THREE.HemisphereLight(0xffffff, 0xcccccc, 0.55));
            const keyLight = new THREE.DirectionalLight(0xffffff, 0.85);
            keyLight.position.set(3, 5, 4);
            trussScene.add(keyLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-2, 3, -3);
            trussScene.add(fillLight);

            // Procedural environment map for subtle PBR reflections
            (function() {
                var pmrem = new THREE.PMREMGenerator(trussRend);
                var envS = new THREE.Scene();
                envS.background = new THREE.Color(0xB0B4B8);
                trussScene.environment = pmrem.fromScene(envS, 0.04).texture;
                pmrem.dispose();
            })();

            trussGroup = new THREE.Group();
            trussScene.add(trussGroup);

            // OrbitControls - pan/zoom only (no orbit rotation)
            trussControls = new THREE.OrbitControls(trussCam, canvas);
            trussControls.enableDamping = true;
            trussControls.dampingFactor = 0.05;
            trussControls.screenSpacePanning = true;
            trussControls.enablePan = true;
            trussControls.enableZoom = true;
            trussControls.enableRotate = false;
            trussControls.minZoom = 0.3;
            trussControls.maxZoom = 10;
            trussControls.mouseButtons = {
                LEFT: THREE.MOUSE.PAN,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            trussControls.touches = {
                ONE: THREE.TOUCH.PAN,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            buildTruss3D();

            // Click-to-select for truss
            canvas.addEventListener('click', onTrussClick);

            // Edge panning disabled - truss uses pan/grab instead of orbit
            // setupEdgePanning3D(container, trussCam, trussControls);

            animateTruss();
        }

        // Truss is built in XY plane: X = span (horizontal), Y = rise (vertical), Z = depth
        function buildTruss3D() {
            // Clear selection state on rebuild
            if (trussSelectedObject) { trussSelectedObject = null; }
            hidePropertiesPanel(document.getElementById('trussPropertiesPanel'));
            while (trussGroup.children.length) trussGroup.remove(trussGroup.children[0]);
            if (!calc.isGable) return;

            const c = calc;
            const span = c.trussSpan / 1000;
            const rise = c.rise / 1000;
            const halfSpan = span / 2;
            const tw = c.steel.w;
            const th = c.steel.h;
            const overhang = (parseFloat(document.getElementById('inOverhang')?.value) || 0) / 1000;
            const mat = new THREE.MeshStandardMaterial({color: new THREE.Color(steelColor.hex).convertSRGBToLinear(), metalness: 0.0, roughness: 0.7});

            // Truss options (mm â†’ m)
            const extOn = c.trussExtender.enabled;
            const extLen = c.trussExtender.length / 1000;
            const riserOn = c.trussRiserLeft.enabled;
            const rLH = c.trussRiserLeft.length / 1000;
            const rLV = c.trussRiserLeft.height / 1000;
            const rRH = c.trussRiserRight.length / 1000;
            const rRV = c.trussRiserRight.height / 1000;
            const chordType = c.trussChord;
            const heelY = th;           // both heels at same level (standard gable)
            const apexY = th + rise;
            const jt = th * 0.6;        // joint overlap extension

            // Helper: box member between two 2D points
            // extS/extE = extend start/end past endpoints for joint overlap
            // memberType/memberName = optional metadata for selection
            function mbr(x1, y1, x2, y2, extS, extE, memberType, memberName) {
                if (extS === undefined) extS = 0;
                if (extE === undefined) extE = 0;
                const dx = x2 - x1, dy = y2 - y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len < 0.001) return;
                const ux = dx / len, uy = dy / len;
                const ax = x1 - ux * extS, ay = y1 - uy * extS;
                const bx = x2 + ux * extE, by = y2 + uy * extE;
                const totalLen = len + extS + extE;
                const geo = new THREE.BoxGeometry(totalLen, th, 0.001);
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.position.set((ax + bx) / 2, (ay + by) / 2, 0);
                mesh.rotation.z = Math.atan2(dy, dx);
                mesh.userData = {
                    selectable: true,
                    type: memberType || 'Member',
                    specs: {
                        'Name': memberName || (memberType || 'Member'),
                        'Size': c.steel.name + ' RHS',
                        'Length': Math.round(totalLen * 1000) + 'mm',
                        'Material': 'Steel',
                        'Colour': steelColor.name
                    }
                };
                trussGroup.add(mesh);
                return mesh;
            }

            // --- Bottom Chord (standard horizontal, full span) ---
            if (chordType === 'bottom') {
                mbr(-halfSpan, th / 2, halfSpan, th / 2, jt, jt, 'Bottom Chord', 'Bottom Chord');
                if (extOn) {
                    mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2, 0, jt, 'Extender', 'Left Extender');
                    mbr(halfSpan, th / 2, halfSpan + extLen, th / 2, jt, 0, 'Extender', 'Right Extender');
                }
            } else if (chordType === 'mid') {
                const midY = th + rise / 3;
                const lT = (midY - heelY) / (apexY - heelY);
                const midLeftX = lT > 0 ? -halfSpan * (1 - lT) : -halfSpan;
                const midRightX = lT > 0 ? halfSpan * (1 - lT) : halfSpan;
                if (midLeftX < midRightX) mbr(midLeftX, midY, midRightX, midY, jt, jt, 'Mid Chord', 'Mid Chord');
                if (extOn) {
                    mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2, 0, jt, 'Extender', 'Left Extender');
                    mbr(halfSpan, th / 2, halfSpan + extLen, th / 2, jt, 0, 'Extender', 'Right Extender');
                }
            } else if (extOn) {
                mbr(-halfSpan - extLen, th / 2, -halfSpan, th / 2, 0, 0, 'Extender', 'Left Extender');
                mbr(halfSpan, th / 2, halfSpan + extLen, th / 2, 0, 0, 'Extender', 'Right Extender');
            }

            // --- Rafters (symmetrical, both from heelY to apex) ---
            {
                const rdx = halfSpan, rdy = apexY - heelY;
                const rd = Math.sqrt(rdx * rdx + rdy * rdy);
                // Left rafter - extends past heel and apex for clean joints
                const lsX = overhang > 0 ? -halfSpan - (rdx / rd) * overhang : -halfSpan;
                const lsY = overhang > 0 ? heelY - (rdy / rd) * overhang : heelY;
                mbr(lsX, lsY, 0, apexY, overhang > 0 ? 0 : jt, jt, 'Rafter', 'Left Rafter');
                // Right rafter
                const rsX = overhang > 0 ? halfSpan + (rdx / rd) * overhang : halfSpan;
                const rsY = overhang > 0 ? heelY - (rdy / rd) * overhang : heelY;
                mbr(rsX, rsY, 0, apexY, overhang > 0 ? 0 : jt, jt, 'Rafter', 'Right Rafter');
            }

            // --- Web Members ---
            // Helper: get rafter Y at distance x from center (in meters)
            function rafterYat(x) { return th + rise * (1 - x / halfSpan); }

            const chordYm = chordType === 'mid' ? (th + rise / 3) : th;
            const kBottom = chordType === 'mid' ? (chordYm + th / 2) : th;
            const kTop = apexY - th;
            const qpX = halfSpan / 2;  // quarter-point X from center (meters)

            // Legacy style mapping for 3D view
            var eff3d = c.trussStyle;
            if (eff3d === 'kingfan' || eff3d === 'queenpost') eff3d = 'kingverticals';
            if (eff3d === 'kingstrut' || eff3d === 'fink' || eff3d === 'open') eff3d = 'web';

            if (eff3d === 'kingpost') {
                // Single center vertical from bottom chord to ridge
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop, jt, jt, 'Web', 'King Post');
                }

            } else if (eff3d === 'kingverticals') {
                // King post + verticals at quarter-span points
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop, jt, jt, 'Web', 'King Post');
                }
                var kvChordTop = chordYm + th / 2;
                var kvRafterBot = rafterYat(qpX) - th / 2;
                if (kvRafterBot > kvChordTop + th * 0.5) {
                    mbr(-qpX, kvChordTop, -qpX, kvRafterBot, jt, jt, 'Web', 'Left Vertical');
                    mbr(qpX, kvChordTop, qpX, kvRafterBot, jt, jt, 'Web', 'Right Vertical');
                }

            } else if (eff3d === 'web') {
                // King post + diagonal struts from king post base to rafter quarter-points
                if (kTop > kBottom) {
                    mbr(0, kBottom, 0, kTop, jt, jt, 'Web', 'King Post');
                }
                var webChordTop = chordYm + th / 2;
                var webRafterBot = rafterYat(qpX) - th / 2;
                if (webRafterBot > webChordTop + th * 0.5) {
                    mbr(0, webChordTop, -qpX, webRafterBot, jt, jt, 'Web', 'Left Web Diagonal');
                    mbr(0, webChordTop, qpX, webRafterBot, jt, jt, 'Web', 'Right Web Diagonal');
                }
            }

            // --- Risers (L-shaped pieces at heel ends) ---
            if (riserOn) {
                const riserType = c.riserType || 'welded';
                const riserTypeLabel = riserType === 'welded' ? 'Welded to Truss' : 'Separate Piece';
                const sepMat = riserType === 'separate' ? new THREE.MeshStandardMaterial({color: 0x888888, metalness: 0.0, roughness: 0.7}) : null;
                const gap = riserType === 'separate' ? 0.005 : 0;
                function applyRiserMat(mesh) { if (sepMat && mesh) mesh.material = sepMat.clone(); }
                function riserSpecs(mesh, dim) {
                    if (!mesh) return;
                    var s = mesh.userData.specs;
                    mesh.userData.specs = { 'Name': s['Name'], 'Size': s['Size'], 'Dimension': dim, 'Cut Length': s['Length'], 'Type': riserTypeLabel, 'Material': s['Material'], 'Colour': s['Colour'] };
                }

                const lHeelX = extOn ? -halfSpan - extLen : -halfSpan;
                var mLV = mbr(lHeelX, th / 2 - gap, lHeelX, th / 2 - rLV, jt, 0, 'Riser', 'Left Riser (Vert)');
                applyRiserMat(mLV);
                riserSpecs(mLV, Math.round(rLV * 1000) + 'mm');
                var mLH = mbr(lHeelX, th / 2 - rLV, lHeelX - rLH, th / 2 - rLV, jt, 0, 'Riser', 'Left Riser (Horiz)');
                applyRiserMat(mLH);
                riserSpecs(mLH, Math.round(rLH * 1000) + 'mm');

                const rHeelX = extOn ? halfSpan + extLen : halfSpan;
                var mRV = mbr(rHeelX, th / 2 - gap, rHeelX, th / 2 - rRV, jt, 0, 'Riser', 'Right Riser (Vert)');
                applyRiserMat(mRV);
                riserSpecs(mRV, Math.round(rRV * 1000) + 'mm');
                var mRH = mbr(rHeelX, th / 2 - rRV, rHeelX + rRH, th / 2 - rRV, jt, 0, 'Riser', 'Right Riser (Horiz)');
                applyRiserMat(mRH);
                riserSpecs(mRH, Math.round(rRH * 1000) + 'mm');
            }

            // --- Perimeter outline dimensions ---
            // Continuous orange polylines tracing truss outer edges, with corner dots and labels

            // Draw a closed orange polyline with dots at every vertex and labels on key segments
            function drawOutline(pts, labels) {
                var z = 0.02;
                var color = 0xF15A29;
                var mat = new THREE.LineBasicMaterial({color: color, depthTest: false, depthWrite: false});
                var verts = pts.map(function(p) { return new THREE.Vector3(p.x, p.y, z); });
                verts.push(verts[0].clone()); // close the loop
                trussGroup.add(new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints(verts), mat));
                pts.forEach(function(p) { addNodeMarker(p.x, p.y, color); });
                if (labels) labels.forEach(function(l) {
                    var p1 = pts[l.seg], p2 = pts[(l.seg + 1) % pts.length];
                    addCleanLabel(l.text, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2, true);
                });
            }

            // Draw a single dimension line (not closed) with dots at each end
            function drawDimLine(x1, y1, x2, y2, text) {
                var z = 0.02;
                var color = 0xF15A29;
                var mat = new THREE.LineBasicMaterial({color: color, depthTest: false, depthWrite: false});
                trussGroup.add(new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x1, y1, z), new THREE.Vector3(x2, y2, z)
                    ]), mat));
                addNodeMarker(x1, y1, color);
                addNodeMarker(x2, y2, color);
                addCleanLabel(text, (x1 + x2) / 2, (y1 + y2) / 2, true);
            }

            // 1. Main truss outline â€” chord/extender bottom + rafter outer edges
            var leftEnd = extOn ? -halfSpan - extLen : -halfSpan;
            var rightEnd = extOn ? halfSpan + extLen : halfSpan;
            var rd = Math.sqrt(halfSpan * halfSpan + rise * rise);
            var lnx = -rise / rd * th / 2, lny = halfSpan / rd * th / 2;
            var rnx =  rise / rd * th / 2, rny = halfSpan / rd * th / 2;

            var mainPts = [
                {x: leftEnd, y: 0},                               // A: chord/ext bottom-left
                {x: rightEnd, y: 0},                              // B: chord/ext bottom-right
                {x: halfSpan + rnx, y: heelY + rny},              // C: right rafter outer at heel
                {x: rnx, y: apexY + rny},                         // D: right rafter outer at apex
                {x: lnx, y: apexY + lny},                         // E: left rafter outer at apex
                {x: -halfSpan + lnx, y: heelY + lny}              // F: left rafter outer at heel
            ];
            drawOutline(mainPts, [
                {seg: 0, text: Math.round(c.trussSpan) + 'mm'},   // span (Aâ†’B)
                {seg: 2, text: Math.round(c.rafter) + 'mm'},      // right rafter (Câ†’D)
                {seg: 4, text: Math.round(c.rafter) + 'mm'}       // left rafter (Eâ†’F)
            ]);

            // 2. Riser dimensions â€” clean L-shape perimeter, no dots, two outside labels
            if (riserOn) {
                var dimZ = 0.02, dimColor = 0xF15A29;
                var dimMat = new THREE.LineBasicMaterial({color: dimColor, depthTest: false, depthWrite: false});

                // Left riser: 6-vertex closed perimeter, labels on outer height + outer width only
                var lhx = extOn ? -halfSpan - extLen : -halfSpan;
                var lP = [
                    {x: lhx - th / 2, y: 0},                // top-left
                    {x: lhx + th / 2, y: 0},                // top-right
                    {x: lhx + th / 2, y: -rLV},             // bottom-right
                    {x: lhx - rLH,    y: -rLV},             // tip bottom-left
                    {x: lhx - rLH,    y: th - rLV},         // tip top-left
                    {x: lhx - th / 2, y: th - rLV}          // inner concave corner
                ];
                var lVerts = lP.map(function(p) { return new THREE.Vector3(p.x, p.y, dimZ); });
                lVerts.push(lVerts[0].clone());
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(lVerts), dimMat));
                addCleanLabel(Math.round(c.trussRiserLeft.height) + 'mm',
                    lP[1].x + 0.06, (lP[1].y + lP[2].y) / 2, 'xs');
                addCleanLabel(Math.round((rLH + th / 2) * 1000) + 'mm',
                    (lP[2].x + lP[3].x) / 2, lP[2].y - 0.025, 'xs');

                // Right riser: mirror
                var rhx = extOn ? halfSpan + extLen : halfSpan;
                var rP = [
                    {x: rhx - th / 2, y: 0},                // top-left
                    {x: rhx + th / 2, y: 0},                // top-right
                    {x: rhx + th / 2, y: th - rRV},         // inner concave corner
                    {x: rhx + rRH,    y: th - rRV},         // tip top-right
                    {x: rhx + rRH,    y: -rRV},             // tip bottom-right
                    {x: rhx - th / 2, y: -rRV}              // bottom-left
                ];
                var rVerts = rP.map(function(p) { return new THREE.Vector3(p.x, p.y, dimZ); });
                rVerts.push(rVerts[0].clone());
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(rVerts), dimMat));
                addCleanLabel(Math.round(c.trussRiserRight.height) + 'mm',
                    rP[5].x - 0.06, (rP[5].y + rP[0].y) / 2, 'xs');
                addCleanLabel(Math.round((rRH + th / 2) * 1000) + 'mm',
                    (rP[4].x + rP[5].x) / 2, rP[4].y - 0.025, 'xs');
            }

            // 4. Rise dimension â€” separate vertical line (not part of perimeter)
            var htX = rightEnd + 0.06;
            drawDimLine(htX, th, htX, apexY, Math.round(c.rise) + 'mm');

            // 5. Pitch angle â€” single arc at left heel
            var accentMat = new THREE.LineBasicMaterial({color: 0xF15A29, depthTest: false, depthWrite: false});
            addInsideAngleArc(-halfSpan, heelY, 0.12, c.pitchRad, accentMat, 'heel-left');
            addCleanLabel(c.pitch.toFixed(1) + '\u00B0', -halfSpan + 0.14, heelY + 0.06, true);

            setTrussView('front', document.querySelector('.truss-view-btn.active'));
        }


        // Small circle marker at a geometry node point â€” always renders on top
        function addNodeMarker(x, y, colorHex) {
            const radius = 0.01;
            const segs = 16;
            const geo = new THREE.CircleGeometry(radius, segs);
            const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color: colorHex, side: THREE.DoubleSide, depthTest: false, depthWrite: false}));
            mesh.position.set(x, y, 0.007);
            trussGroup.add(mesh);
        }


        // Angle arc drawn INSIDE the triangle geometry
        function addInsideAngleArc(cx, cy, radius, pitchRad, mat, position) {
            const pts = [];
            const segs = 20;
            if (position === 'apex') {
                // Arc between the two rafters pointing downward from apex
                // Rafters go down-left and down-right at pitchRad from vertical
                var startA = Math.PI + pitchRad;
                var endA = 2 * Math.PI - pitchRad;
                for (var i = 0; i <= segs; i++) {
                    var a = startA + (endA - startA) * (i / segs);
                    pts.push(new THREE.Vector3(cx + radius * Math.cos(a), cy + radius * Math.sin(a), 0.005));
                }
            } else if (position === 'heel-left') {
                // Arc at left heel: between bottom chord (going right) and left rafter (going up-right)
                var startA2 = 0;  // along bottom chord toward right
                var endA2 = pitchRad;  // up along rafter
                for (var i2 = 0; i2 <= segs; i2++) {
                    var a2 = startA2 + (endA2 - startA2) * (i2 / segs);
                    pts.push(new THREE.Vector3(cx + radius * Math.cos(a2), cy + radius * Math.sin(a2), 0.005));
                }
            } else if (position === 'heel-right') {
                // Arc at right heel: between right rafter (going up-left) and bottom chord (going left)
                var startA3 = Math.PI - pitchRad;  // up along rafter
                var endA3 = Math.PI;  // along bottom chord toward left
                for (var i3 = 0; i3 <= segs; i3++) {
                    var a3 = startA3 + (endA3 - startA3) * (i3 / segs);
                    pts.push(new THREE.Vector3(cx + radius * Math.cos(a3), cy + radius * Math.sin(a3), 0.005));
                }
            }
            if (pts.length > 1) {
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
            }
        }

        // Clean dimension label - number with unit on a subtle white pill background
        // size: true/'sm' = small, 'xs' = extra-small (compact for tight spaces), falsy = large
        function addCleanLabel(text, x, y, size) {
            var dpr = 2;
            var isXS = size === 'xs';
            var isSmall = isXS || size === true || size === 'sm';
            var cv = document.createElement('canvas');
            var w = isXS ? 120 : (isSmall ? 200 : 260);
            var h = isXS ? 24 : (isSmall ? 32 : 36);
            cv.width = w * dpr; cv.height = h * dpr;
            var ctx = cv.getContext('2d');
            ctx.scale(dpr, dpr);
            ctx.fillStyle = 'rgba(255,255,255,0.88)';
            ctx.beginPath(); ctx.roundRect(2, 2, w - 4, h - 4, 4); ctx.fill();
            ctx.fillStyle = '#333';
            var fs = isXS ? 11 : (isSmall ? 14 : 17);
            ctx.font = 'bold ' + fs + 'px "SF Mono", Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, w / 2, h / 2);
            var tex = new THREE.CanvasTexture(cv);
            tex.minFilter = THREE.LinearFilter;
            var sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex, depthTest: false}));
            var sw = isXS ? 0.09 : (isSmall ? 0.20 : 0.28);
            var sh = isXS ? 0.020 : (isSmall ? 0.035 : 0.042);
            sprite.scale.set(sw, sh, 1);
            sprite.position.set(x, y, 0.03);
            trussGroup.add(sprite);
        }

        // ==================== FABRICATION CUT LIST ====================
        const JOINT_TYPES = {
            BUTT: 'butt',
            LAP_OVER: 'lap_over',
            LAP_UNDER: 'lap_under',
            MITRE: 'mitre',
            SADDLE: 'saddle'
        };

        const TUBING = {
            '76x38': { width: 76, height: 38, wall: 1.6 },
            '75x50': { width: 75, height: 50, wall: 2.0 },
            '100x50': { width: 100, height: 50, wall: 2.0 }
        };

        function generateCutList(trussData) {
            var tubing = TUBING[calc.trussSteel] || TUBING['76x38'];
            var cutList = [];
            var span = trussData.trussSpan;
            var rise = trussData.rise;
            var pitch = trussData.pitch;
            var pitchRad = pitch * Math.PI / 180;
            var cosP = Math.cos(pitchRad);
            var sinP = Math.sin(pitchRad);
            var steelH = tubing.height;
            var steelW = tubing.width;
            var halfSpan = span / 2;

            // Rafter theoretical length
            var rafterTheoretical = Math.sqrt(halfSpan * halfSpan + rise * rise);

            // Bottom chord cut: deduct rafter heel overlap at each end
            var chordDeduction = steelH * cosP;
            var chordCut = Math.round(span - 2 * chordDeduction);

            cutList.push({
                id: 'BC1',
                name: 'Bottom Chord',
                quantity: 1,
                theoretical: { length: span, description: 'Full span' },
                actual: {
                    length: chordCut,
                    leftEnd: { cut: 'square', angle: 90, description: 'Square cut' },
                    rightEnd: { cut: 'square', angle: 90, description: 'Square cut' }
                },
                tubing: tubing,
                orientation: steelW + 'mm vertical',
                notes: chordCut === span ? 'Full span' : 'Deduct ' + Math.round(chordDeduction) + 'mm each end for rafter heel'
            });

            // Rafter cut lengths (matching existing calculation)
            var apexDeduct = steelH / (2 * sinP);
            var heelAllowance = steelH * cosP;
            var overhang = parseFloat(document.getElementById('inOverhang')?.value) || 0;
            var rafterCut = Math.round(rafterTheoretical - apexDeduct - heelAllowance + overhang);
            var heelAngle = pitch;
            var apexAngle = 90 - pitch;

            // Left Rafter
            cutList.push({
                id: 'LR1',
                name: 'Left Rafter',
                quantity: 1,
                theoretical: { length: Math.round(rafterTheoretical), description: 'Slope length to ridge' },
                actual: {
                    length: rafterCut,
                    leftEnd: { cut: 'mitre', angle: heelAngle, description: heelAngle.toFixed(1) + '\u00B0 mitre (sits on bottom chord)' },
                    rightEnd: { cut: 'mitre', angle: apexAngle, description: apexAngle.toFixed(1) + '\u00B0 mitre (meets right rafter at ridge)' }
                },
                tubing: tubing,
                orientation: steelW + 'mm perpendicular to slope',
                notes: 'Mitre both ends' + (overhang > 0 ? ' (+' + overhang + 'mm overhang)' : '')
            });

            // Right Rafter (mirror)
            cutList.push({
                id: 'RR1',
                name: 'Right Rafter',
                quantity: 1,
                theoretical: { length: Math.round(rafterTheoretical), description: 'Slope length to ridge' },
                actual: {
                    length: rafterCut,
                    leftEnd: { cut: 'mitre', angle: apexAngle, description: apexAngle.toFixed(1) + '\u00B0 mitre (meets left rafter at ridge)' },
                    rightEnd: { cut: 'mitre', angle: heelAngle, description: heelAngle.toFixed(1) + '\u00B0 mitre (sits on bottom chord)' }
                },
                tubing: tubing,
                orientation: steelW + 'mm perpendicular to slope',
                notes: 'Mitre both ends - MIRROR of Left Rafter'
            });

            // Extender pieces
            if (trussData.extender && trussData.extender.enabled) {
                var extLen = trussData.extender.length;
                cutList.push({
                    id: 'EX1',
                    name: 'Extender',
                    quantity: 2,
                    theoretical: { length: extLen, description: 'Extension beyond heel' },
                    actual: {
                        length: Math.round(extLen),
                        leftEnd: { cut: 'square', angle: 90, description: 'Welds/bolts to chord end' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Outer edge' }
                    },
                    tubing: tubing,
                    orientation: steelW + 'mm vertical',
                    notes: 'Extends bottom chord at both ends'
                });
            }

            // Web members
            if (trussData.webMembers && trussData.webMembers.length > 0) {
                for (var wi = 0; wi < trussData.webMembers.length; wi++) {
                    var wm = trussData.webMembers[wi];
                    var webIdMap = {'King Post':'KP1','Fan Web':'FW1','Queen Post':'QP1','Inner Diagonal':'ID1','Outer Diagonal':'OD1','Strut':'ST1'};
                    var webId = webIdMap[wm.type] || ('W' + (wi + 1));
                    cutList.push({
                        id: webId,
                        name: wm.type,
                        quantity: wm.count,
                        theoretical: { length: wm.length, description: wm.type + ' web member' },
                        actual: {
                            length: wm.length,
                            leftEnd: { cut: 'square', angle: 90, description: 'Welds to chord/rafter' },
                            rightEnd: { cut: 'square', angle: 90, description: 'Welds to chord/rafter' }
                        },
                        tubing: tubing,
                        orientation: steelW + 'mm facing outward',
                        notes: wm.type + ' member'
                    });
                }
            }

            // Riser pieces (separate steel, bolted on)
            if (trussData.riserLeft && trussData.riserLeft.enabled) {
                var rLV = trussData.riserLeft.height;
                var rLH = trussData.riserLeft.length;
                var riserVertActual = Math.round(rLV - steelH);

                cutList.push({
                    id: 'RVL',
                    name: 'Riser Vertical (L)',
                    quantity: 1,
                    theoretical: { length: Math.round(rLV), description: 'Vertical drop from chord' },
                    actual: {
                        length: riserVertActual > 0 ? riserVertActual : Math.round(rLV),
                        leftEnd: { cut: 'square', angle: 90, description: 'Bolts to chord face' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Meets horizontal' }
                    },
                    tubing: tubing,
                    orientation: steelW + 'mm facing outward',
                    notes: riserVertActual > 0 ? 'Deduct ' + steelH + 'mm (chord thickness)' : 'Separate piece, bolted'
                });

                cutList.push({
                    id: 'RHL',
                    name: 'Riser Horizontal (L)',
                    quantity: 1,
                    theoretical: { length: Math.round(rLH), description: 'Horizontal extension' },
                    actual: {
                        length: Math.round(rLH),
                        leftEnd: { cut: 'square', angle: 90, description: 'Outer edge' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Meets vertical' }
                    },
                    tubing: tubing,
                    orientation: steelH + 'mm vertical (laid flat)',
                    notes: 'House-side extension'
                });
            }

            if (trussData.riserRight && trussData.riserRight.enabled) {
                var rRV = trussData.riserRight.height;
                var rRH = trussData.riserRight.length;
                var riserRVertActual = Math.round(rRV - steelH);

                cutList.push({
                    id: 'RVR',
                    name: 'Riser Vertical (R)',
                    quantity: 1,
                    theoretical: { length: Math.round(rRV), description: 'Vertical drop from chord' },
                    actual: {
                        length: riserRVertActual > 0 ? riserRVertActual : Math.round(rRV),
                        leftEnd: { cut: 'square', angle: 90, description: 'Bolts to chord face' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Meets horizontal' }
                    },
                    tubing: tubing,
                    orientation: steelW + 'mm facing outward',
                    notes: riserRVertActual > 0 ? 'Deduct ' + steelH + 'mm (chord thickness)' : 'Separate piece, bolted'
                });

                cutList.push({
                    id: 'RHR',
                    name: 'Riser Horizontal (R)',
                    quantity: 1,
                    theoretical: { length: Math.round(rRH), description: 'Horizontal extension' },
                    actual: {
                        length: Math.round(rRH),
                        leftEnd: { cut: 'square', angle: 90, description: 'Outer edge' },
                        rightEnd: { cut: 'square', angle: 90, description: 'Meets vertical' }
                    },
                    tubing: tubing,
                    orientation: steelH + 'mm vertical (laid flat)',
                    notes: 'House-side extension'
                });
            }

            return cutList;
        }

        function renderCutList(cutList) {
            var tbody = document.getElementById('cutListBody');
            if (!tbody) return;
            tbody.innerHTML = '';

            var totalPieces = 0;
            var totalLinear = 0;

            for (var i = 0; i < cutList.length; i++) {
                var item = cutList[i];
                var row = document.createElement('tr');

                var end1 = item.actual.leftEnd || item.actual.bottomEnd || item.actual.innerEnd;
                var end2 = item.actual.rightEnd || item.actual.topEnd || item.actual.outerEnd;

                function formatEnd(end) {
                    if (!end) return '-';
                    if (end.cut === 'square') {
                        return '<span class="square">SQUARE</span><span class="angle-info">90\u00B0</span>';
                    } else if (end.cut === 'mitre') {
                        return '<span class="mitre">MITRE</span><span class="angle-info">' + end.angle.toFixed(1) + '\u00B0</span>';
                    }
                    return end.cut;
                }

                row.innerHTML =
                    '<td><strong>' + item.id + '</strong></td>' +
                    '<td>' + item.name + '<span class="angle-info">' + item.orientation + '</span></td>' +
                    '<td>' + item.quantity + '</td>' +
                    '<td><span class="cut-length">' + item.actual.length + '</span><span class="angle-info">mm</span></td>' +
                    '<td>' + formatEnd(end1) + '</td>' +
                    '<td>' + formatEnd(end2) + '</td>' +
                    '<td><small>' + (item.notes || '') + '</small></td>';

                tbody.appendChild(row);

                totalPieces += item.quantity;
                totalLinear += item.actual.length * item.quantity;
            }

            document.getElementById('totalPieces').textContent = totalPieces;
            document.getElementById('totalLinear').textContent = (totalLinear / 1000).toFixed(2) + 'm';
            document.getElementById('stockLengths').textContent = Math.ceil(totalLinear / 6500);
        }

        function updateCutListPanel() {
            var panel = document.getElementById('cutListPanel');
            if (!panel) return;
            if (!calc.isGable || !calc.trussData) {
                return;
            }
            var tubing = TUBING[calc.trussSteel] || TUBING['76x38'];
            var steelInfo = STEEL[calc.trussSteel] || STEEL['76x38'];
            document.getElementById('cutListTubing').textContent = steelInfo.name + ' RHS';
            var cutList = generateCutList(calc.trussData);
            calc.cutList = cutList;
            renderCutList(cutList);
        }

        function printCutList() {
            var panel = document.getElementById('cutListPanel');
            if (!panel) return;
            var printWin = window.open('', '_blank', 'width=900,height=700');
            printWin.document.write('<html><head><title>Fabrication Cut List</title>');
            printWin.document.write('<style>');
            printWin.document.write('body{font-family:"SF Mono",Consolas,monospace;margin:20px;font-size:13px;}');
            printWin.document.write('table{width:100%;border-collapse:collapse;}');
            printWin.document.write('th{background:#333;color:#fff;padding:8px 12px;text-align:left;font-size:11px;text-transform:uppercase;-webkit-print-color-adjust:exact;print-color-adjust:exact;}');
            printWin.document.write('td{padding:10px 12px;border-bottom:1px solid #ddd;vertical-align:top;}');
            printWin.document.write('.cut-length{font-size:18px;font-weight:bold;color:#d32f2f;}');
            printWin.document.write('.angle-info{font-size:11px;color:#666;display:block;}');
            printWin.document.write('.mitre{color:#1976d2;font-weight:600;}');
            printWin.document.write('.square{color:#388e3c;}');
            printWin.document.write('.totals{display:flex;gap:24px;margin-top:16px;padding-top:12px;border-top:2px solid #333;}');
            printWin.document.write('.total-item{display:flex;flex-direction:column;}');
            printWin.document.write('.total-item span:first-child{font-size:11px;color:#666;text-transform:uppercase;}');
            printWin.document.write('.total-item span:last-child{font-size:20px;font-weight:bold;}');
            printWin.document.write('.btn-small{display:none;}');
            printWin.document.write('h4{margin:0 0 16px 0;font-size:16px;letter-spacing:1px;border-bottom:2px solid #333;padding-bottom:12px;}');
            printWin.document.write('</style></head><body>');
            printWin.document.write(panel.innerHTML);
            printWin.document.write('</body></html>');
            printWin.document.close();
            printWin.focus();
            printWin.print();
        }

        function copyCutList() {
            if (!calc.cutList) return;
            var lines = ['ID\tPart\tQty\tCut Length (mm)\tEnd 1\tEnd 2\tNotes'];
            for (var i = 0; i < calc.cutList.length; i++) {
                var item = calc.cutList[i];
                var end1 = item.actual.leftEnd || item.actual.bottomEnd || item.actual.innerEnd;
                var end2 = item.actual.rightEnd || item.actual.topEnd || item.actual.outerEnd;
                var e1 = end1 ? (end1.cut === 'mitre' ? 'MITRE ' + end1.angle.toFixed(1) + '\u00B0' : 'SQUARE 90\u00B0') : '-';
                var e2 = end2 ? (end2.cut === 'mitre' ? 'MITRE ' + end2.angle.toFixed(1) + '\u00B0' : 'SQUARE 90\u00B0') : '-';
                lines.push(item.id + '\t' + item.name + '\t' + item.quantity + '\t' + item.actual.length + '\t' + e1 + '\t' + e2 + '\t' + (item.notes || ''));
            }
            var totalPieces = 0, totalLinear = 0;
            for (var j = 0; j < calc.cutList.length; j++) {
                totalPieces += calc.cutList[j].quantity;
                totalLinear += calc.cutList[j].actual.length * calc.cutList[j].quantity;
            }
            lines.push('');
            lines.push('Total Pieces:\t' + totalPieces);
            lines.push('Total Linear:\t' + (totalLinear / 1000).toFixed(2) + 'm');
            lines.push('Stock Lengths (6.5m):\t' + Math.ceil(totalLinear / 6500));
            var text = lines.join('\n');
            navigator.clipboard.writeText(text).then(function() {
                showToast('Cut list copied to clipboard', 'success');
            }).catch(function() {
                // Fallback
                var ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                showToast('Cut list copied to clipboard', 'success');
            });
        }

        function setTrussView(v, btn) {
            document.querySelectorAll('.truss-view-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');

            const container = document.getElementById('trussViewport');
            const w = container ? container.clientWidth : 600;
            const h = container ? container.clientHeight : 420;
            const aspect = w / h;

            // Auto-fit camera to actual truss content using bounding box
            var box = new THREE.Box3().setFromObject(trussGroup);
            if (box.isEmpty()) {
                // Fallback to parametric estimate if trussGroup is empty
                var span = (calc.trussSpan || 3000) / 1000;
                var riseEst = (calc.rise || 264) / 1000;
                var apexEst = (calc.steel ? calc.steel.h : 0.038) + riseEst;
                box.min.set(-span/2 - 0.2, -0.2, -1);
                box.max.set(span/2 + 0.2, apexEst + 0.2, 1);
            }

            var center = new THREE.Vector3();
            box.getCenter(center);
            var size = new THREE.Vector3();
            box.getSize(size);

            var padding = 1.12; // 12% padding
            var frustumH = size.y * padding;
            var frustumW = size.x * padding;
            if (frustumW / aspect > frustumH) {
                frustumH = frustumW / aspect;
            }

            trussCam.left = -frustumH * aspect / 2;
            trussCam.right = frustumH * aspect / 2;
            trussCam.top = frustumH / 2;
            trussCam.bottom = -frustumH / 2;
            trussCam.zoom = 1;
            trussCam.updateProjectionMatrix();

            var target = new THREE.Vector3(center.x, center.y, 0);
            if (trussControls) trussControls.target.copy(target);
            trussCam.position.set(center.x, center.y, 10);
            trussCam.lookAt(target);
            if (trussControls) trussControls.update();
        }

        function toggleTrussFullscreen() {
            const viewer = document.getElementById('trussViewport');
            if (!document.fullscreenElement) {
                viewer.requestFullscreen().then(() => resizeTruss());
            } else {
                document.exitFullscreen().then(() => resizeTruss());
            }
        }

        function toggleTrussDimensions() {
            const show = document.getElementById('showTrussDims').checked;
            if (!trussGroup) return;
            trussGroup.children.forEach(child => {
                if (child.isSprite || child.isLine) {
                    child.visible = show;
                }
            });
        }

        function animateTruss() {
            requestAnimationFrame(animateTruss);
            if (trussControls) trussControls.update();
            if (trussRend && trussScene && trussCam) {
                trussRend.render(trussScene, trussCam);
            }
        }

        // ==================== BOX GUTTER CALCULATOR ====================
        const PERTH_RAINFALL_100YR = 207; // mm/hr - 100 year ARI
        const DOWNPIPE_CAP = {'100x75': 3.5, '100x100': 5.0, '90round': 2.8};
        const GUTTER_MIN = {width: 200, depth: 75, freeboard: 30, backUpstand: 50, frontUpstand: 40, turnIn: 25};

        function openGutterDesigner() {
            // Route to flashing creator's Box Gutter tab
            openFlashModalBoxGutter();
            return;
            var modal = document.getElementById('gutterDesignerModal');
            if (!modal) return;
            modal.style.display = 'flex';
            syncRiserToBoxGutter();
            calcBoxGutter();
            // Delay canvas redraw so modal renders first and has dimensions
            setTimeout(function() { calcBoxGutter(); }, 50);
        }

        function closeGutterDesigner() {
            var modal = document.getElementById('gutterDesignerModal');
            if (modal) modal.style.display = 'none';
        }

        function saveGutterToTruss() {
            document.getElementById('trussBoxGutterOn').value = '1';
            var btn = document.getElementById('trussBoxGutterBtn');
            if (btn) btn.classList.add('active');
            closeGutterDesigner();
            rebuildAll();
        }

        function removeGutterFromTruss() {
            document.getElementById('trussBoxGutterOn').value = '0';
            var btn = document.getElementById('trussBoxGutterBtn');
            if (btn) btn.classList.remove('active');
            closeGutterDesigner();
            rebuildAll();
        }

        function calcBoxGutter() {
            var el = document.getElementById('bgResults');
            if (!el) return;
            var houseCatch = parseFloat(document.getElementById('bgHouseCatch').value) || 0;
            var patioCatch = parseFloat(document.getElementById('bgPatioCatch').value) || 0;
            var availW = parseFloat(document.getElementById('bgAvailWidth').value) || 300;
            var availD = parseFloat(document.getElementById('bgAvailDepth').value) || 150;
            var runLen = parseFloat(document.getElementById('bgRunLength').value) || 6000;
            var fallRatio = parseFloat(document.getElementById('bgFallRatio').value) || 60;
            var dpSize = document.getElementById('bgDownpipe').value || '100x75';

            var totalCatch = houseCatch + patioCatch;
            // Q = (A * I) / 3600  (L/s)
            var flowRate = (totalCatch * PERTH_RAINFALL_100YR) / 3600;

            // Fall
            var fallPerM = 1000 / fallRatio; // mm per metre
            var fallTotal = (runLen / 1000) * fallPerM;

            // Gutter sole width (must be calculated before depth)
            var soleW = Math.max(GUTTER_MIN.width, Math.min(availW - 20, 400));

            // Manning equation for wide rectangular channel
            // Water depth d = (Q * n / (w * sqrt(S)))^(3/5)
            // n = 0.014 (Manning's n for Colorbond steel)
            var manningN = 0.014;
            var Q = flowRate / 1000;        // L/s to mÂ³/s
            var S = fallPerM / 1000;        // mm/m to dimensionless slope
            var w = soleW / 1000;           // mm to m
            var waterDepthM = (S > 0 && w > 0 && Q > 0)
                ? Math.pow(Q * manningN / (w * Math.sqrt(S)), 0.6)
                : 0;
            var reqDepth = Math.ceil(waterDepthM * 1000);  // back to mm
            var soleD = Math.max(reqDepth + GUTTER_MIN.freeboard, GUTTER_MIN.depth + GUTTER_MIN.freeboard);
            var freeboard = soleD - reqDepth;

            var backUp = 60;   // Standard back upstand - laps under house roof flashing
            var frontUp = 50;  // Standard front upstand - laps over patio roofing
            var turnIn = GUTTER_MIN.turnIn;
            var totalGirth = backUp + soleW + soleD + frontUp + turnIn + 50; // +50 for bends

            // Downpipes
            var dpCap = DOWNPIPE_CAP[dpSize] || 3.5;
            var dpCount = Math.max(1, Math.ceil(flowRate / dpCap));

            // Validation
            var issues = [];
            var status = 'ok';
            if (soleW < GUTTER_MIN.width) { issues.push('Width ' + soleW + 'mm below min ' + GUTTER_MIN.width + 'mm'); status = 'fail'; }
            if (soleD > availD) { issues.push('Required depth ' + soleD + 'mm exceeds available ' + availD + 'mm'); status = 'fail'; }
            if (freeboard < GUTTER_MIN.freeboard) { issues.push('Freeboard ' + freeboard + 'mm below min ' + GUTTER_MIN.freeboard + 'mm'); if (status !== 'fail') status = 'warn'; }
            if (runLen > 12000 && dpCount < 2) { issues.push('Run > 12m may need mid-point downpipe'); if (status !== 'fail') status = 'warn'; }

            // Update UI
            document.getElementById('bgResCatch').textContent = totalCatch + ' m\u00B2';
            document.getElementById('bgResFlow').textContent = flowRate.toFixed(2) + ' L/s';
            document.getElementById('bgResDP').textContent = dpCount + '\u00D7 ' + dpSize;
            document.getElementById('bgResBack').textContent = backUp + 'mm';
            document.getElementById('bgResSoleW').textContent = soleW + 'mm';
            document.getElementById('bgResSoleD').textContent = soleD + 'mm';
            document.getElementById('bgResFront').textContent = frontUp + 'mm';
            document.getElementById('bgResTurnIn').textContent = turnIn + 'mm';
            document.getElementById('bgResGirth').textContent = totalGirth + 'mm';
            document.getElementById('bgResFB').textContent = freeboard + 'mm';
            document.getElementById('bgResFall').textContent = fallTotal.toFixed(0) + 'mm / ' + (runLen/1000).toFixed(1) + 'm';

            var stEl = document.getElementById('bgStatus');
            if (status === 'ok') {
                stEl.innerHTML = '<span class="gutter-badge ok">\u2713 COMPLIANT</span>';
            } else if (status === 'warn') {
                stEl.innerHTML = '<span class="gutter-badge warn">\u26A0 WARNING</span><div class="gutter-issues">' + issues.join('<br>') + '</div>';
            } else {
                stEl.innerHTML = '<span class="gutter-badge fail">\u2717 DOES NOT FIT</span><div class="gutter-issues">' + issues.join('<br>') + '</div>';
            }

            // Pass riser + steel context for the full cross-section view
            var riserH = parseFloat(document.getElementById('riserLH')?.value) || availW;
            var riserV = parseFloat(document.getElementById('riserLV')?.value) || availD;
            var steelName = (calc.steel ? calc.steel.name : '76x38x1.6');
            var steelW = calc.steel ? calc.steel.w * 1000 : 38;
            var steelH = calc.steel ? calc.steel.h * 1000 : 76;
            drawGutterProfile({backUp: backUp, soleW: soleW, soleD: soleD, frontUp: frontUp, turnIn: turnIn, waterLevel: reqDepth, status: status, riserH: riserH, riserV: riserV, steelW: steelW, steelH: steelH, steelName: steelName});
        }

        function drawGutterProfile(d) {
            var box = document.getElementById('bgCrossSectionBox');
            var canvas = document.getElementById('bgCanvas');
            if (!box || !canvas) return;
            canvas.width = box.clientWidth * 2;
            canvas.height = box.clientHeight * 2;
            canvas.style.width = box.clientWidth + 'px';
            canvas.style.height = box.clientHeight + 'px';
            var ctx = canvas.getContext('2d');
            ctx.scale(2, 2);
            var cw = box.clientWidth, ch = box.clientHeight;

            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, cw, ch);

            // Get riser/steel context
            var rH = d.riserH || d.soleW + 20;  // riser horizontal (gap width)
            var rV = d.riserV || d.soleD + 40;   // riser vertical (drop)
            var stW = d.steelW || 38;             // steel tube width
            var stH = d.steelH || 76;             // steel tube height
            var steelName = d.steelName || '';

            // Total scene dimensions (mm) â€” show the full riser context
            var houseWallW = 40;  // house wall/fascia thickness visual
            var roofOverhang = 60; // visual roof overhang
            var sceneW = houseWallW + rH + stW + 60;
            var sceneH = Math.max(rV + stH + 40, d.backUp + 80);
            var sc = Math.min((cw - 120) / sceneW, (ch - 90) / sceneH);

            // Origin: bottom-left of the gutter sole, centered in canvas
            var ox = cw / 2 - (sceneW * sc) / 2 + (houseWallW + 10) * sc;
            var oy = ch - 45;

            function sx(v) { return ox + v * sc; }
            function sy(v) { return oy - v * sc; }

            // === HOUSE WALL / FASCIA (left side) ===
            ctx.fillStyle = '#e0ddd8';
            ctx.fillRect(sx(-houseWallW - 10), sy(rV + stH + 30), houseWallW * sc, (rV + stH + 30) * sc);
            // Fascia board
            ctx.fillStyle = '#c5bfb5';
            ctx.fillRect(sx(-10), sy(rV + 20), 10 * sc, (rV + 20) * sc);

            // House roof line (angled, coming down from top-left)
            ctx.beginPath();
            ctx.moveTo(sx(-houseWallW - roofOverhang), sy(rV + stH + 60));
            ctx.lineTo(sx(-10), sy(rV + 20));
            ctx.strokeStyle = '#8b7d6b';
            ctx.lineWidth = 3;
            ctx.stroke();
            // Roof label
            ctx.fillStyle = '#8b7d6b';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('HOUSE ROOF', sx(-houseWallW / 2 - roofOverhang / 2), sy(rV + stH + 50));

            // === TRUSS RISER STEEL (right side) â€” the RHS tube ===
            // Vertical riser piece
            ctx.fillStyle = '#b0b0b0';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            ctx.fillRect(sx(rH), sy(rV), stW * sc, rV * sc);
            ctx.strokeRect(sx(rH), sy(rV), stW * sc, rV * sc);
            // Horizontal riser piece (extending right from bottom of vertical)
            ctx.fillRect(sx(rH), sy(stH), (stW + 30) * sc, stH * sc);
            ctx.strokeRect(sx(rH), sy(stH), (stW + 30) * sc, stH * sc);

            // Steel section label
            ctx.fillStyle = '#666';
            ctx.font = 'bold 8px "SF Mono", monospace';
            ctx.textAlign = 'left';
            ctx.fillText(steelName + ' RHS', sx(rH + stW + 4), sy(rV / 2));

            // Patio roof line (angled, going right from top of riser)
            ctx.beginPath();
            ctx.moveTo(sx(rH + stW / 2), sy(rV));
            ctx.lineTo(sx(rH + stW + 80), sy(rV - 30));
            ctx.strokeStyle = '#F15A29';
            ctx.lineWidth = 2.5;
            ctx.stroke();
            // Roof label
            ctx.fillStyle = '#F15A29';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('PATIO ROOF', sx(rH + stW + 20), sy(rV - 18));

            // === BOX GUTTER (in the gap) ===
            // Gutter profile outline
            ctx.beginPath();
            ctx.moveTo(sx(0), sy(0));
            ctx.lineTo(sx(0), sy(d.backUp));                          // Back upstand (against house)
            ctx.moveTo(sx(0), sy(0));
            ctx.lineTo(sx(d.soleW), sy(0));                           // Sole
            ctx.lineTo(sx(d.soleW), sy(d.frontUp));                   // Front upstand
            ctx.lineTo(sx(d.soleW + d.turnIn), sy(d.frontUp - 10));   // Turn-in
            ctx.strokeStyle = d.status === 'fail' ? '#c62828' : '#333';
            ctx.lineWidth = 2.5;
            ctx.lineJoin = 'round';
            ctx.stroke();

            // Fill gutter body
            ctx.beginPath();
            ctx.moveTo(sx(0), sy(0));
            ctx.lineTo(sx(0), sy(d.soleD));
            ctx.lineTo(sx(d.soleW), sy(d.soleD));
            ctx.lineTo(sx(d.soleW), sy(0));
            ctx.closePath();
            ctx.fillStyle = 'rgba(200,200,200,0.15)';
            ctx.fill();

            // Water fill
            if (d.waterLevel > 0) {
                ctx.beginPath();
                ctx.moveTo(sx(2), sy(1));
                ctx.lineTo(sx(2), sy(d.waterLevel));
                ctx.lineTo(sx(d.soleW - 2), sy(d.waterLevel));
                ctx.lineTo(sx(d.soleW - 2), sy(1));
                ctx.closePath();
                ctx.fillStyle = 'rgba(33,150,243,0.2)';
                ctx.fill();

                // Water level line
                ctx.beginPath();
                ctx.moveTo(sx(4), sy(d.waterLevel));
                ctx.lineTo(sx(d.soleW - 4), sy(d.waterLevel));
                ctx.strokeStyle = '#2196f3';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // === DIMENSION LABELS ===
            ctx.font = 'bold 10px "SF Mono", Consolas, monospace';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';

            // Sole width
            ctx.fillText(d.soleW + 'mm', (sx(0) + sx(d.soleW)) / 2, oy + 18);
            drawArrow(ctx, sx(0), oy + 10, sx(d.soleW), oy + 10);

            // Back upstand (left)
            ctx.save();
            ctx.translate(sx(0) - 14, (sy(0) + sy(d.backUp)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(d.backUp + 'mm', 0, 0);
            ctx.restore();

            // Sole depth
            ctx.save();
            ctx.translate(sx(d.soleW) + 14, (sy(0) + sy(d.soleD)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(d.soleD + 'mm', 0, 0);
            ctx.restore();

            // Front upstand
            ctx.save();
            ctx.translate(sx(d.soleW + d.turnIn) + 16, (sy(0) + sy(d.frontUp)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(d.frontUp + 'mm', 0, 0);
            ctx.restore();

            // === RISER DIMENSION LABELS (blue) ===
            ctx.fillStyle = '#2196F3';
            ctx.font = 'bold 10px "SF Mono", Consolas, monospace';

            // Riser horizontal (gap width) â€” shown below the gutter
            ctx.textAlign = 'center';
            ctx.fillText(Math.round(rH) + 'mm horiz', (sx(0) + sx(rH)) / 2, oy + 32);
            drawArrow(ctx, sx(0), oy + 25, sx(rH), oy + 25);

            // Riser vertical (drop) â€” shown on right side
            ctx.save();
            ctx.translate(sx(rH + stW + 6), (sy(0) + sy(rV)) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(Math.round(rV) + 'mm vert', 0, 0);
            ctx.restore();

            // Freeboard label
            if (d.soleD > d.waterLevel + 5) {
                ctx.fillStyle = '#4caf50';
                ctx.font = 'bold 9px "SF Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(d.soleD - d.waterLevel) + 'mm FB', (sx(0) + sx(d.soleW)) / 2, sy(d.soleD) - 6);
            }

            // Water level label
            if (d.waterLevel > 0) {
                ctx.fillStyle = '#2196f3';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Water Level', (sx(0) + sx(d.soleW)) / 2, sy(d.waterLevel) - 6);
            }

            // Title and orientation labels
            ctx.fillStyle = '#555';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('BOX GUTTER CROSS-SECTION', 8, 14);
            ctx.fillStyle = '#8b7d6b';
            ctx.font = 'bold 9px Arial';
            ctx.fillText('\u2190 HOUSE (High)', 8, 27);
            ctx.fillStyle = '#F15A29';
            ctx.textAlign = 'right';
            ctx.fillText('PATIO (Low) \u2192', cw - 8, 27);
        }

        function drawArrow(ctx, x1, y, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y);
            ctx.lineTo(x2, y);
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.stroke();
            // Arrow heads
            ctx.fillStyle = '#999';
            ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x1 + 4, y - 3); ctx.lineTo(x1 + 4, y + 3); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(x2, y); ctx.lineTo(x2 - 4, y - 3); ctx.lineTo(x2 - 4, y + 3); ctx.closePath(); ctx.fill();
        }

        function updatePatioCatchment() {
            var w = parseFloat(document.getElementById('inWidth').value) || 3;
            var l = parseFloat(document.getElementById('inLength').value) || 6;
            var el = document.getElementById('bgPatioCatch');
            if (el) el.value = (w * l).toFixed(1);
            // Sync riser offset to available width
            var rOff = parseFloat(document.getElementById('inRiserOffset')?.value);
            var wEl = document.getElementById('bgAvailWidth');
            if (rOff && wEl) wEl.value = rOff;
            // Sync gutter run to patio length
            var runEl = document.getElementById('bgRunLength');
            if (runEl && calc.L) runEl.value = calc.L;
            // Sync gutter data if box gutter is active
            var trussRiserBG = document.getElementById('trussRiserOn')?.checked && document.getElementById('trussBoxGutterOn')?.value === '1';
            if (trussRiserBG) syncRiserToBoxGutter();
            calcBoxGutter();
        }

        // ==================== ASSEMBLY 3D (Section 3) ====================
        let asmScene, asmCam, asmRend, asmRay, asmMouse, asmControls;
        // rpRend removed â€” single renderer now lives in right panel as asmRend
        let steelGrp, roofGrp, accGrp, houseGrp;
        var backyardEnvGrp, carportEnvGrp;
        let compData = new Map();
        let hovered = null;

        // Dimension display system
        let dimensionGroup = null;       // THREE.Group for all dimension objects
        let dimensionsVisible = false;   // Toggle state
        let asmOrthoCamera = null;       // Orthographic camera for elevation views
        let asmCurrentView = '3d';       // Current view preset
        let asmCurrentSection = '';      // Current section cut
        let asmClippingPlane = null;     // Active clipping plane

        // Navigation: focus/zoom animation state
        var focusAnimating = false;
        var focusTargetGoal = null;
        var focusCamGoal = null;
        var zoomAnimating = false;
        var zoomDistGoal = 0;
        var FOCUS_LERP = 0.1;

        function initAsm3D() {
            const container = document.getElementById('asmViewport');
            const canvas = document.getElementById('asmCanvas');
            var w = container.clientWidth || 600;
            var h = container.clientHeight || 360;
            asmScene = new THREE.Scene();
            // Sky gradient background â€” Perth afternoon sky
            (function() {
                var c = document.createElement('canvas');
                c.width = 2; c.height = 512;
                var ctx = c.getContext('2d');
                var g = ctx.createLinearGradient(0, 0, 0, 512);
                g.addColorStop(0.0, '#3A6FB8');   // warm blue zenith
                g.addColorStop(0.2, '#6AA0D0');
                g.addColorStop(0.4, '#95C4E0');
                g.addColorStop(0.6, '#C0D8E8');
                g.addColorStop(0.72, '#DEEADC');  // warm pale horizon
                g.addColorStop(0.82, '#E0DCC8');  // golden afternoon haze
                g.addColorStop(0.88, '#C8D4B8');  // warm tree canopy
                g.addColorStop(0.94, '#6B8F50');  // tree line
                g.addColorStop(1.0, '#558A38');   // lawn meets horizon
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, 2, 512);
                var tex = new THREE.CanvasTexture(c);
                asmScene.background = tex;
            })();
            asmCam = new THREE.PerspectiveCamera(35, w/h, 0.1, 200);
            asmRend = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true, preserveDrawingBuffer: true});
            asmRend.setSize(w, h);
            asmRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            asmRend.shadowMap.enabled = true;
            asmRend.shadowMap.type = THREE.PCFSoftShadowMap;
            asmRend.localClippingEnabled = true;  // enable per-material clipping planes for hip cuts
            asmRend.outputEncoding = THREE.sRGBEncoding;
            asmRend.toneMapping = THREE.ReinhardToneMapping;
            asmRend.toneMappingExposure = 1.2;  // slightly brighter for warm afternoon

            asmRay = new THREE.Raycaster();
            asmMouse = new THREE.Vector2();

            // PBR environment map for realistic steel reflections
            (function() {
                var pmrem = new THREE.PMREMGenerator(asmRend);
                pmrem.compileEquirectangularShader();
                // Procedural sky environment â€” warm Perth daylight
                var envScene = new THREE.Scene();
                envScene.background = new THREE.Color(0xB8C8D8);
                // Warm ground bounce
                var groundGeo = new THREE.PlaneGeometry(100, 100);
                var groundMat = new THREE.MeshBasicMaterial({color: 0xD4C4A8});
                var groundMesh = new THREE.Mesh(groundGeo, groundMat);
                groundMesh.rotation.x = -Math.PI / 2;
                groundMesh.position.y = -1;
                envScene.add(groundMesh);
                asmScene.environment = pmrem.fromScene(envScene, 0.04).texture;
                pmrem.dispose();
            })();

            // Hemisphere light â€” warm afternoon sky above, warm grass bounce below
            asmScene.add(new THREE.HemisphereLight(0xE8D8C0, 0x7B9450, 0.55));

            const sun = new THREE.DirectionalLight(0xFFF0D0, 1.0);  // warm golden afternoon sun
            sun.position.set(6, 8, 5);  // lower angle = more afternoon feel
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 50;
            sun.shadow.camera.left = -15;
            sun.shadow.camera.right = 15;
            sun.shadow.camera.top = 15;
            sun.shadow.camera.bottom = -15;
            sun.shadow.bias = -0.0005;
            sun.shadow.normalBias = 0.02;
            asmScene.add(sun);

            // Warm fill light (afternoon ambient bounce)
            const fill = new THREE.DirectionalLight(0xFFF0E0, 0.25);
            fill.position.set(-3, 2, -3);
            asmScene.add(fill);

            // Ground plane to receive shadows
            var gpGeo = new THREE.PlaneGeometry(40, 40);
            var gpMat = new THREE.ShadowMaterial({opacity: 0.15});
            var groundPlane = new THREE.Mesh(gpGeo, gpMat);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = 0;
            groundPlane.receiveShadow = true;
            asmScene.add(groundPlane);

            // Light atmospheric haze â€” pushed far back so patio is crisp
            asmScene.fog = new THREE.Fog(0xD8DDD4, 55, 130);  // warm haze, afternoon feel

            // ===== SCENE ENVIRONMENT GROUPS =====
            backyardEnvGrp = new THREE.Group();
            carportEnvGrp = new THREE.Group();
            carportEnvGrp.visible = false;
            asmScene.add(backyardEnvGrp);
            asmScene.add(carportEnvGrp);

            // Shared materials
            var wallMat = new THREE.MeshStandardMaterial({color: 0xC8B89A, roughness: 0.85, metalness: 0.0});
            var roofHouseMat = new THREE.MeshStandardMaterial({color: 0x5A5A55, roughness: 0.5, metalness: 0.1});
            var concreteMat = new THREE.MeshStandardMaterial({color: 0xBFB5A0, roughness: 0.82, metalness: 0.0});
            var fencePanelMat = new THREE.MeshStandardMaterial({color: 0x6B6B65, roughness: 0.5, metalness: 0.1});
            var fencePostMat = new THREE.MeshStandardMaterial({color: 0x5A5A55, roughness: 0.45, metalness: 0.1});
            var mulchMat = new THREE.MeshStandardMaterial({color: 0x5C3A1E, roughness: 0.95, metalness: 0.0});
            var shrubMat = new THREE.MeshStandardMaterial({color: 0x3D6B28, roughness: 0.88, metalness: 0.0});
            var shrubMat2 = new THREE.MeshStandardMaterial({color: 0x5A8840, roughness: 0.88, metalness: 0.0});
            var trunkMat = new THREE.MeshStandardMaterial({color: 0x6B4F3A, roughness: 0.9, metalness: 0.0});
            var leafMat = new THREE.MeshStandardMaterial({color: 0x4A7A32, roughness: 0.85, metalness: 0.0});

            // Procedural paver texture â€” warm WA limestone/reconstituted pavers
            var paverTex = (function() {
                var pc = document.createElement('canvas');
                pc.width = 512; pc.height = 512;
                var px = pc.getContext('2d');
                // Sand-fill base (visible as grout/joints) â€” warm sand tone
                px.fillStyle = '#A89878';
                px.fillRect(0, 0, 512, 512);
                // 400x200mm pavers in stretcher bond (brick pattern)
                var pw = 80, ph = 40, gap = 3;
                var rows = Math.ceil(512 / (ph + gap));
                // WA reconstituted limestone palette â€” warm cream/buff tones
                var paverPalette = [
                    [210, 195, 168],  // warm cream
                    [200, 186, 160],  // standard buff
                    [218, 202, 176],  // light limestone
                    [192, 178, 154],  // mid sandstone
                    [205, 190, 162],  // golden sand
                    [188, 174, 150]   // weathered stone
                ];
                for (var row = 0; row < rows; row++) {
                    var offset = (row % 2 === 0) ? 0 : pw / 2;
                    var y = row * (ph + gap);
                    for (var col = -1; col < Math.ceil(512 / pw) + 2; col++) {
                        var x = col * (pw + gap) + offset;
                        var base = paverPalette[Math.floor(Math.random() * paverPalette.length)];
                        var v = Math.floor(Math.random() * 10) - 5;
                        var r = Math.min(255, Math.max(0, base[0] + v));
                        var g = Math.min(255, Math.max(0, base[1] + v));
                        var b = Math.min(255, Math.max(0, base[2] + v));
                        px.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                        px.fillRect(x + gap, y + gap, pw - gap, ph - gap);
                        // Subtle surface speckle for stone texture
                        for (var sp = 0; sp < 4; sp++) {
                            var sx = x + gap + Math.random() * (pw - gap*2);
                            var sy = y + gap + Math.random() * (ph - gap*2);
                            var sv = Math.floor(Math.random() * 16) - 8;
                            px.fillStyle = 'rgba(' + (r+sv) + ',' + (g+sv) + ',' + (b+sv) + ',0.35)';
                            px.fillRect(sx, sy, 3 + Math.random()*5, 2 + Math.random()*3);
                        }
                    }
                }
                var t = new THREE.CanvasTexture(pc);
                t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
                return t;
            })();

            // Helper: build a colorbond fence run
            function buildFenceRun(grp, startX, startZ, endX, endZ, fH) {
                fH = fH || 1.8;
                var dx = endX - startX, dz = endZ - startZ;
                var len = Math.sqrt(dx*dx + dz*dz);
                var panelW = 2.4, postW = 0.065, panelT = 0.008;
                var count = Math.ceil(len / panelW);
                var angle = Math.atan2(dx, dz);
                for (var i = 0; i <= count; i++) {
                    var t = i / count;
                    var px = startX + dx * t, pz = startZ + dz * t;
                    var post = new THREE.Mesh(new THREE.BoxGeometry(postW, fH + 0.05, postW), fencePostMat);
                    post.position.set(px, fH/2, pz);
                    post.castShadow = true;
                    grp.add(post);
                    if (i < count) {
                        var midT = (i + 0.5) / count;
                        var mx = startX + dx * midT, mz = startZ + dz * midT;
                        var segLen = Math.min(panelW - postW, len / count);
                        // Panel: thin in X, tall in Y, long in Z â€” then rotate to fence direction
                        var panel = new THREE.Mesh(new THREE.BoxGeometry(panelT, fH, segLen), fencePanelMat);
                        panel.position.set(mx, fH/2, mz);
                        panel.rotation.y = angle;
                        panel.castShadow = true; panel.receiveShadow = true;
                        grp.add(panel);
                    }
                }
            }

            // Helper: add shrubs
            function addShrubs(grp, positions) {
                positions.forEach(function(p, idx) {
                    var s = 0.4 + Math.random() * 0.5;
                    var mat = idx % 3 === 0 ? shrubMat2 : shrubMat;
                    var sh = new THREE.Mesh(new THREE.SphereGeometry(s, 6, 5), mat);
                    sh.position.set(p[0], s * 0.7, p[1]);
                    sh.scale.y = 0.7 + Math.random() * 0.3;
                    sh.castShadow = true;
                    grp.add(sh);
                });
            }

            // Helper: add a tree
            function addTree(grp, x, z, height, canopyR) {
                var trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.1, height, 6), trunkMat);
                trunk.position.set(x, height/2, z); trunk.castShadow = true; grp.add(trunk);
                var canopy = new THREE.Mesh(new THREE.SphereGeometry(canopyR, 8, 6), leafMat);
                canopy.position.set(x, height + canopyR * 0.6, z); canopy.scale.y = 1.2; canopy.castShadow = true; grp.add(canopy);
            }

            // Helper: basic house body (walls + gable roof)
            function buildHouseBody(grp, houseW, houseD, wallH, roofPeakH, posZ) {
                var hw = houseW, hd = houseD;
                var renderMat = new THREE.MeshStandardMaterial({color: 0xC8B89A, roughness: 0.85, metalness: 0.0});
                var roofMat2 = new THREE.MeshStandardMaterial({color: 0x5A5A55, roughness: 0.5, metalness: 0.1, side: THREE.DoubleSide});
                // Back wall
                var bw = new THREE.Mesh(new THREE.BoxGeometry(hw, wallH, 0.15), renderMat);
                bw.position.set(0, wallH/2, posZ - hd); bw.receiveShadow = true; grp.add(bw);
                // Left wall
                var lw = new THREE.Mesh(new THREE.BoxGeometry(0.15, wallH, hd), renderMat);
                lw.position.set(-hw/2, wallH/2, posZ - hd/2); lw.receiveShadow = true; grp.add(lw);
                // Right wall
                var rw = new THREE.Mesh(new THREE.BoxGeometry(0.15, wallH, hd), renderMat);
                rw.position.set(hw/2, wallH/2, posZ - hd/2); rw.receiveShadow = true; grp.add(rw);
                // Gable roof â€” thin boxes tilted to form slopes
                var roofOverhang = 0.3;
                var roofHalfW = hw/2 + roofOverhang;
                var roofD = hd + 0.4;
                var slopeLen = Math.sqrt(roofHalfW * roofHalfW + roofPeakH * roofPeakH);
                var slopeAngle = Math.atan2(roofPeakH, roofHalfW);
                // Left slope (tilts up to right toward ridge)
                var leftRoof = new THREE.Mesh(new THREE.BoxGeometry(slopeLen, 0.025, roofD), roofMat2);
                leftRoof.rotation.z = slopeAngle;
                leftRoof.position.set(-roofHalfW/2, wallH + roofPeakH/2, posZ - hd/2);
                leftRoof.castShadow = true; leftRoof.receiveShadow = true; grp.add(leftRoof);
                // Right slope (tilts up to left toward ridge)
                var rightRoof = new THREE.Mesh(new THREE.BoxGeometry(slopeLen, 0.025, roofD), roofMat2);
                rightRoof.rotation.z = -slopeAngle;
                rightRoof.position.set(roofHalfW/2, wallH + roofPeakH/2, posZ - hd/2);
                rightRoof.castShadow = true; rightRoof.receiveShadow = true; grp.add(rightRoof);
                // Ridge cap
                var ridge = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, roofD), roofMat2);
                ridge.position.set(0, wallH + roofPeakH, posZ - hd/2);
                grp.add(ridge);
            }

            // Procedural grass texture â€” Perth buffalo grass with natural variation
            var grassTex = (function() {
                var gc = document.createElement('canvas');
                gc.width = 256; gc.height = 256;
                var gx = gc.getContext('2d');
                // Base grass green
                gx.fillStyle = '#5C8A3C';
                gx.fillRect(0, 0, 256, 256);
                // Add grass blade variation â€” random short strokes
                for (var i = 0; i < 2000; i++) {
                    var bx = Math.random() * 256;
                    var by = Math.random() * 256;
                    var v = Math.floor(Math.random() * 30) - 15;
                    var r = Math.min(255, Math.max(0, 92 + v));
                    var g2 = Math.min(255, Math.max(0, 138 + v));
                    var b = Math.min(255, Math.max(0, 60 + v));
                    gx.strokeStyle = 'rgba(' + r + ',' + g2 + ',' + b + ',0.6)';
                    gx.lineWidth = 0.5 + Math.random();
                    gx.beginPath();
                    gx.moveTo(bx, by);
                    gx.lineTo(bx + (Math.random() - 0.5) * 3, by - 2 - Math.random() * 4);
                    gx.stroke();
                }
                // Add dry patches (Perth summer)
                for (var p = 0; p < 40; p++) {
                    var px = Math.random() * 256;
                    var py = Math.random() * 256;
                    gx.fillStyle = 'rgba(140, 130, 80, 0.15)';
                    gx.fillRect(px, py, 3 + Math.random() * 8, 2 + Math.random() * 5);
                }
                var t = new THREE.CanvasTexture(gc);
                t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
                t.repeat.set(20, 20);
                return t;
            })();

            // ===== BACKYARD SCENE =====
            (function() {
                var g = backyardEnvGrp;
                // Lawn with grass texture
                var lawn = new THREE.Mesh(new THREE.PlaneGeometry(80, 80),
                    new THREE.MeshStandardMaterial({map: grassTex, roughness: 0.92, metalness: 0.0}));
                lawn.rotation.x = -Math.PI/2; lawn.position.y = -0.01; lawn.receiveShadow = true; g.add(lawn);
                // Pavers under patio
                var pt = paverTex.clone(); pt.repeat.set(6, 6);
                var paving = new THREE.Mesh(new THREE.PlaneGeometry(14, 12),
                    new THREE.MeshStandardMaterial({map: pt, roughness: 0.8, metalness: 0.0}));
                paving.rotation.x = -Math.PI/2; paving.position.set(0, -0.004, 1); paving.receiveShadow = true; g.add(paving);
                // Concrete path to back yard
                var path = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 6), concreteMat);
                path.rotation.x = -Math.PI/2; path.position.set(0, -0.003, 8); path.receiveShadow = true; g.add(path);
                // Paver edging
                var edgeMat = new THREE.MeshStandardMaterial({color: 0x8C7A68, roughness: 0.85, metalness: 0.0});
                var eF = new THREE.Mesh(new THREE.BoxGeometry(14, 0.12, 0.15), edgeMat);
                eF.position.set(0, 0.06, 7.1); g.add(eF);
                var eL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.12, 12), edgeMat);
                eL.position.set(-7.08, 0.06, 1); g.add(eL);
                var eR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.12, 12), edgeMat);
                eR.position.set(7.08, 0.06, 1); g.add(eR);
                // Fences â€” left, right, back
                buildFenceRun(g, -10, -4, -10, 18);
                buildFenceRun(g, 10, -4, 10, 18);
                buildFenceRun(g, -10, 18, 10, 18);
                // Garden beds
                var bedL = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.08, 18), mulchMat);
                bedL.position.set(-9.2, 0.04, 5); bedL.receiveShadow = true; g.add(bedL);
                var bedR = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.08, 18), mulchMat);
                bedR.position.set(9.2, 0.04, 5); bedR.receiveShadow = true; g.add(bedR);
                var bedB = new THREE.Mesh(new THREE.BoxGeometry(16, 0.08, 2), mulchMat);
                bedB.position.set(0, 0.04, 16.5); bedB.receiveShadow = true; g.add(bedB);
                addShrubs(g, [[-9.2,3],[-9.2,5.5],[-9.2,8],[-9.2,11],[-9.2,14],
                    [9.2,2],[9.2,5],[9.2,7.5],[9.2,10],[9.2,13],[-4,16.5],[-1.5,16.5],[2,16.5],[5,16.5]]);
                // Trees
                addTree(g, -8, 15, 4, 1.8);
                addTree(g, 8, 14, 3, 1.4);
                addTree(g, 9, 8, 2, 0.9);
            })();

            // ===== CARPORT SCENE =====
            (function() {
                var g = carportEnvGrp;
                // Concrete driveway â€” larger area
                var driveway = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), concreteMat.clone());
                driveway.rotation.x = -Math.PI/2; driveway.position.y = -0.01; driveway.receiveShadow = true; g.add(driveway);
                // Exposed aggregate driveway under carport
                var expAggMat = new THREE.MeshStandardMaterial({color: 0xA89888, roughness: 0.75, metalness: 0.0});
                var dw = new THREE.Mesh(new THREE.PlaneGeometry(8, 14), expAggMat);
                dw.rotation.x = -Math.PI/2; dw.position.set(0, -0.004, 3); dw.receiveShadow = true; g.add(dw);
                // Lawn strips beside driveway â€” use grass texture
                var cpGrassTex = grassTex.clone(); cpGrassTex.repeat.set(5, 15);
                var lawnMat = new THREE.MeshStandardMaterial({map: cpGrassTex, roughness: 0.92, metalness: 0.0});
                var lawnL = new THREE.Mesh(new THREE.PlaneGeometry(10, 30), lawnMat);
                lawnL.rotation.x = -Math.PI/2; lawnL.position.set(-9, -0.005, 5); lawnL.receiveShadow = true; g.add(lawnL);
                var lawnR = new THREE.Mesh(new THREE.PlaneGeometry(10, 30), lawnMat.clone());
                lawnR.rotation.x = -Math.PI/2; lawnR.position.set(9, -0.005, 5); lawnR.receiveShadow = true; g.add(lawnR);
                // Street curb at far end
                var curbMat = new THREE.MeshStandardMaterial({color: 0x999999, roughness: 0.8, metalness: 0.0});
                var curb = new THREE.Mesh(new THREE.BoxGeometry(30, 0.15, 0.3), curbMat);
                curb.position.set(0, 0.075, 14); g.add(curb);
                // Road beyond curb
                var roadMat = new THREE.MeshStandardMaterial({color: 0x4A4A4A, roughness: 0.9, metalness: 0.0});
                var road = new THREE.Mesh(new THREE.PlaneGeometry(30, 10), roadMat);
                road.rotation.x = -Math.PI/2; road.position.set(0, -0.008, 19); road.receiveShadow = true; g.add(road);
                // Side fences
                buildFenceRun(g, -10, -4, -10, 10);
                buildFenceRun(g, 10, -4, 10, 10);
                // Front garden shrubs
                addShrubs(g, [[-7,9],[-8.5,9],[7,9],[8.5,9]]);
                // Street tree
                addTree(g, -8, 16, 3.5, 1.6);
                addTree(g, 7, 17, 3, 1.3);
                // Letterbox
                var lbPost = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.0, 0.1), new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.6}));
                lbPost.position.set(4.8, 0.5, 10.5); g.add(lbPost);
                var lbBox = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.25, 0.2), new THREE.MeshStandardMaterial({color: 0xCC4422, roughness: 0.6}));
                lbBox.position.set(4.8, 1.0, 10.5); g.add(lbBox);
            })();

            steelGrp = new THREE.Group();
            roofGrp = new THREE.Group();
            accGrp = new THREE.Group();
            houseGrp = new THREE.Group();
            dimensionGroup = new THREE.Group();
            dimensionGroup.visible = false;
            asmScene.add(steelGrp);
            asmScene.add(roofGrp);
            asmScene.add(accGrp);
            asmScene.add(houseGrp);
            asmScene.add(dimensionGroup);

            // Orthographic camera for elevation views
            var aspect = w / h;
            var frustum = 10;
            asmOrthoCamera = new THREE.OrthographicCamera(
                frustum * aspect / -2, frustum * aspect / 2,
                frustum / 2, frustum / -2, 0.1, 1000
            );
            asmOrthoCamera.position.set(0, 1.5, 15);
            asmOrthoCamera.zoom = 0.5;
            asmOrthoCamera.updateProjectionMatrix();

            // OrbitControls - drag to orbit, scroll/pinch to zoom, right-drag to pan
            asmControls = new THREE.OrbitControls(asmCam, canvas);
            asmControls.enableDamping = true;
            asmControls.dampingFactor = 0.05;
            asmControls.enablePan = true;
            asmControls.panSpeed = 0.5;           // gentle pan so it doesn't fly off
            asmControls.enableZoom = true;
            asmControls.enableRotate = true;
            asmControls.minDistance = 1.0;
            asmControls.maxDistance = 20;
            asmControls.minPolarAngle = 0.1;       // prevent flipping over the top
            asmControls.maxPolarAngle = Math.PI / 2 - 0.05; // prevent going below ground
            asmControls.target.set(0, 1.5, 0);

            // Initialize focus animation vectors (declared at outer scope)
            focusTargetGoal = new THREE.Vector3();
            focusCamGoal = new THREE.Vector3();

            // Hover detection (keep for tooltip)
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                asmMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                asmMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                checkHover(e.clientX - rect.left, e.clientY - rect.top);
            });
            canvas.addEventListener('mouseleave', () => { clearHover(); });

            // Click-to-select (debounced to avoid firing on double-click)
            var asmClickTimer = null;
            canvas.addEventListener('click', function(e) {
                clearTimeout(asmClickTimer);
                asmClickTimer = setTimeout(function() { onAsmClick(e); }, 220);
            });

            // Double-click to focus on component (orbit centres on it, camera frames it)
            canvas.addEventListener('dblclick', function(e) {
                clearTimeout(asmClickTimer); // cancel the pending single-click
                if (asmCurrentView !== '3d') return;
                var rect = canvas.getBoundingClientRect();
                var ndc = new THREE.Vector2(
                    ((e.clientX - rect.left) / rect.width) * 2 - 1,
                    -((e.clientY - rect.top) / rect.height) * 2 + 1
                );
                var ray = new THREE.Raycaster();
                ray.setFromCamera(ndc, asmCam);
                var all = [];
                if (steelGrp && steelGrp.visible) all.push.apply(all, steelGrp.children);
                if (roofGrp && roofGrp.visible) all.push.apply(all, roofGrp.children);
                if (accGrp && accGrp.visible) all.push.apply(all, accGrp.children);
                var hits = ray.intersectObjects(all, true);

                if (hits.length > 0) {
                    // Find the registered component
                    var obj = hits[0].object;
                    while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;

                    // Get bounding box of the hit component
                    var bbox = new THREE.Box3().setFromObject(obj);
                    var compCentre = new THREE.Vector3();
                    var compSize = new THREE.Vector3();
                    bbox.getCenter(compCentre);
                    bbox.getSize(compSize);

                    // Frame distance: enough to see the component with context
                    var radius = compSize.length() / 2;
                    var frameDist = Math.max(radius * 3.5, 1.5); // min 1.5m away
                    frameDist = Math.min(frameDist, 12); // max 12m away

                    // Camera direction: keep current angle, just reposition
                    var camDir = asmCam.position.clone().sub(asmControls.target).normalize();
                    focusTargetGoal.copy(compCentre);
                    focusCamGoal.copy(compCentre).add(camDir.multiplyScalar(frameDist));

                    // Select the component too
                    if (selectedObject) {
                        restoreOriginalMaterial(selectedObject);
                        restoreDimmedComponents();
                    }
                    selectedObject = obj;
                    applySelectHighlight(obj);
                    dimOtherComponents(obj);
                    if (compData.has(obj.uuid)) {
                        var panel = document.getElementById('asmPropertiesPanel');
                        var data = compData.get(obj.uuid);
                        showPropertiesPanel(panel, data.name, data.specs);
                    }
                } else {
                    // Double-click on empty space = reset to patio centre
                    var box = new THREE.Box3();
                    if (steelGrp && steelGrp.children.length) box.expandByObject(steelGrp);
                    if (roofGrp && roofGrp.children.length) box.expandByObject(roofGrp);
                    var centre = new THREE.Vector3();
                    box.getCenter(centre);
                    var camDir = asmCam.position.clone().sub(asmControls.target).normalize();
                    var dist = asmCam.position.distanceTo(asmControls.target);
                    focusTargetGoal.copy(centre);
                    focusCamGoal.copy(centre).add(camDir.multiplyScalar(Math.max(dist, 6)));

                    // Clear selection
                    if (selectedObject) {
                        restoreOriginalMaterial(selectedObject);
                        restoreDimmedComponents();
                        selectedObject = null;
                    }
                    var panel = document.getElementById('asmPropertiesPanel');
                    if (panel) panel.style.display = 'none';
                }
                focusAnimating = true;
                zoomAnimating = false;
            });

            // Double-tap detection for touch
            var lastTapTime = 0;
            var lastTapX = 0;
            var lastTapY = 0;
            canvas.addEventListener('touchend', function(e) {
                var now = Date.now();
                var touch = e.changedTouches[0];
                var dx = touch.clientX - lastTapX;
                var dy = touch.clientY - lastTapY;
                if (now - lastTapTime < 300 && Math.sqrt(dx * dx + dy * dy) < 30) {
                    // Synthesize dblclick at touch position
                    var dblEvt = new MouseEvent('dblclick', {
                        clientX: touch.clientX, clientY: touch.clientY,
                        bubbles: true
                    });
                    canvas.dispatchEvent(dblEvt);
                    lastTapTime = 0;
                } else {
                    lastTapTime = now;
                    lastTapX = touch.clientX;
                    lastTapY = touch.clientY;
                }
            });

            // Set default 3D view position
            asmCam.position.set(8, 5, 8);
            asmCam.lookAt(0, 1.5, 0);
            asmControls.update();

            buildAsm3D();

            // Edge panning disabled â€” too easy to trigger accidentally
            // setupEdgePanning3D(container, asmCam, asmControls);

            animateAsm();
        }

        function createCorrugatedGeometry(width, length, segments = 50) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const waveHeight = 0.006;
            const waveFreq = 12;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                pos.setZ(i, Math.sin(x * waveFreq * Math.PI) * waveHeight);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createTrimdekGeometry(width, length, segments = 120) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const ribHeight = 0.012;
            const ribWidth = 0.04;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const phase = ((x / ribWidth) % 1 + 1) % 1;
                let z = 0;
                // Sharp trapezoidal profile â€” steep rise, flat top, steep fall, flat trough
                if (phase < 0.08) z = ribHeight * (phase / 0.08);
                else if (phase < 0.38) z = ribHeight;
                else if (phase < 0.46) z = ribHeight * (1 - (phase - 0.38) / 0.08);
                else z = 0;
                pos.setZ(i, z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createInsulatedGeometry(width, length, thickness, ribsOnNegZ) {
            // SolarSpan panel: thick sandwich with Trimdek ribs on the sky-facing surface
            // ribsOnNegZ: true for skillion & gable-left (-Z faces up after rotation)
            //             false for gable-right (+Z faces up after rotation)
            const t = thickness || 0.075;
            const geo = new THREE.BoxGeometry(width, length, t, 100, 1, 1);
            const pos = geo.attributes.position;
            const ribHeight = 0.010;
            const ribWidth = 0.04;
            const halfT = t / 2;

            for (let i = 0; i < pos.count; i++) {
                const z = pos.getZ(i);
                const x = pos.getX(i);
                const phase = ((x / ribWidth) % 1 + 1) % 1;
                let rib = 0;
                if (phase < 0.08) rib = ribHeight * (phase / 0.08);
                else if (phase < 0.38) rib = ribHeight;
                else if (phase < 0.46) rib = ribHeight * (1 - (phase - 0.38) / 0.08);

                if (ribsOnNegZ) {
                    // Ribs on -Z face (faces UP for skillion & gable-left after rotation)
                    if (z < -halfT + 0.001) {
                        pos.setZ(i, z - rib);
                    }
                } else {
                    // Ribs on +Z face (faces UP for gable-right after rotation)
                    if (z > halfT - 0.001) {
                        pos.setZ(i, z + rib);
                    }
                }
            }
            geo.computeVertexNormals();
            return geo;
        }

        function buildAsm3D() {
            if (!steelGrp || !calc.W) return;
            // Clear selection state on rebuild
            if (selectedObject) { selectedObject = null; }
            hidePropertiesPanel(document.getElementById('asmPropertiesPanel'));
            originalMaterials.clear();
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => {
                while(g.children.length) {
                    var child = g.children[0];
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(function(m) { if (m.map) m.map.dispose(); m.dispose(); });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    }
                    g.remove(child);
                }
            });
            compData.clear();

            const c = calc;
            const W = c.W / 1000;
            const L = c.L / 1000;
            const postH = c.postH / 1000;
            const rise = c.rise / 1000;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;
            const th = c.steel.h;
            const frontBeamY = c.frontBeamY / 1000;
            const backBeamY = c.backBeamY / 1000;
            const fasciaBeamY = c.fasciaBeamY ? c.fasciaBeamY / 1000 : null;

            const steelCol = new THREE.Color(steelColor.hex).convertSRGBToLinear();
            const sheetCol = new THREE.Color(sheetColor.hex).convertSRGBToLinear();
            console.log('Steel colour:', steelColor.name, steelColor.hex);
            console.log('Sheet colour:', sheetColor.name, sheetColor.hex);
            // Structural steel (posts, beams) - polymer-coated Colorbond (dielectric over metal)
            // Classic finish: metalness 0.1, roughness 0.4 per PBR coated-steel spec
            const sMat = () => new THREE.MeshStandardMaterial({color: steelCol, metalness: 0.1, roughness: 0.4, transparent: false, depthWrite: true});
            // Roofing sheets - Colorbond Classic finish
            const rMat = () => new THREE.MeshStandardMaterial({color: sheetCol, metalness: 0.1, roughness: 0.4, side: THREE.DoubleSide, transparent: false, depthWrite: true});

            // SolarSpan ceiling material â€” driven by ceiling finish selector
            const ceilingFinish = c.ceilingFinish || 'plain';
            let ceilingMat;
            if (ceilingFinish === 'cedar') {
                // Cedar Look finish (warm timber aesthetic)
                const cedarCanvas = document.createElement('canvas');
                cedarCanvas.width = 512; cedarCanvas.height = 256;
                const cedarCtx = cedarCanvas.getContext('2d');
                cedarCtx.fillStyle = '#B5804A';
                cedarCtx.fillRect(0, 0, 512, 256);
                for (let y = 0; y < 256; y++) {
                    const noise = Math.sin(y * 0.3) * 8 + Math.sin(y * 1.2) * 3 + Math.sin(y * 4.5) * 1.5;
                    const r = 165 + noise + (Math.random() - 0.5) * 12;
                    const g = 115 + noise * 0.7 + (Math.random() - 0.5) * 8;
                    const b = 62 + noise * 0.4 + (Math.random() - 0.5) * 6;
                    cedarCtx.fillStyle = 'rgb(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(b) + ')';
                    cedarCtx.fillRect(0, y, 512, 1);
                }
                for (let i = 0; i < 40; i++) {
                    const y = Math.random() * 256;
                    cedarCtx.strokeStyle = 'rgba(100,65,30,' + (0.15 + Math.random() * 0.2) + ')';
                    cedarCtx.lineWidth = 0.5 + Math.random() * 1.5;
                    cedarCtx.beginPath();
                    cedarCtx.moveTo(0, y);
                    cedarCtx.lineTo(512, y + (Math.random() - 0.5) * 3);
                    cedarCtx.stroke();
                }
                for (let k = 0; k < 3; k++) {
                    const kx = 50 + Math.random() * 412;
                    const ky = 30 + Math.random() * 196;
                    cedarCtx.fillStyle = 'rgba(90,55,25,0.3)';
                    cedarCtx.beginPath();
                    cedarCtx.ellipse(kx, ky, 4 + Math.random() * 6, 2 + Math.random() * 3, 0, 0, Math.PI * 2);
                    cedarCtx.fill();
                }
                const cedarTex = new THREE.CanvasTexture(cedarCanvas);
                cedarTex.encoding = THREE.sRGBEncoding;
                cedarTex.wrapS = cedarTex.wrapT = THREE.RepeatWrapping;
                cedarTex.repeat.set(2, 4);
                ceilingMat = () => new THREE.MeshStandardMaterial({
                    map: cedarTex, metalness: 0.0, roughness: 0.7, side: THREE.DoubleSide
                });
            } else if (ceilingFinish === 'vj') {
                // VJ Groove finish â€” Surfmist with subtle horizontal V-grooves
                const vjCanvas = document.createElement('canvas');
                vjCanvas.width = 512; vjCanvas.height = 256;
                const vjCtx = vjCanvas.getContext('2d');
                // Surfmist base
                vjCtx.fillStyle = '#E8E6E1';
                vjCtx.fillRect(0, 0, 512, 256);
                // V-groove lines every 30px
                vjCtx.strokeStyle = 'rgba(180,175,168,0.6)';
                vjCtx.lineWidth = 1.5;
                for (let y = 0; y < 256; y += 30) {
                    vjCtx.beginPath();
                    vjCtx.moveTo(0, y);
                    vjCtx.lineTo(512, y);
                    vjCtx.stroke();
                    // Shadow below groove
                    vjCtx.strokeStyle = 'rgba(160,155,148,0.3)';
                    vjCtx.beginPath();
                    vjCtx.moveTo(0, y + 1.5);
                    vjCtx.lineTo(512, y + 1.5);
                    vjCtx.stroke();
                    vjCtx.strokeStyle = 'rgba(180,175,168,0.6)';
                }
                const vjTex = new THREE.CanvasTexture(vjCanvas);
                vjTex.encoding = THREE.sRGBEncoding;
                vjTex.wrapS = vjTex.wrapT = THREE.RepeatWrapping;
                vjTex.repeat.set(2, 4);
                ceilingMat = () => new THREE.MeshStandardMaterial({
                    map: vjTex, metalness: 0.0, roughness: 0.5, side: THREE.DoubleSide
                });
            } else {
                // Plain â€” smooth Surfmist Colorbond
                const surfmistCol = new THREE.Color('#E8E6E1').convertSRGBToLinear();
                ceilingMat = () => new THREE.MeshStandardMaterial({
                    color: surfmistCol, metalness: 0.05, roughness: 0.45, side: THREE.DoubleSide
                });
            }

            // EPS foam core material (white insulation)
            const coreMat = () => new THREE.MeshStandardMaterial({color: 0xf5f5f5, roughness: 0.9, metalness: 0.0});

            // For insulated panels: BoxGeometry(width, rafter, thickness)
            // After rotation around X, which face is "up" depends on rotation direction:
            //   Skillion (rot=+Ï€/2+pitch) and Gable left (rot=+Ï€/2-pitch): -Z faces UP (sky)
            //   Gable right (rot=-(Ï€/2-pitch)): +Z faces UP (sky)
            // negZisTop=true for skillion & gable left, false for gable right
            function insulatedMaterials(negZisTop) {
                if (negZisTop) {
                    return [
                        coreMat(), coreMat(),   // +X, -X (side edges)
                        coreMat(), coreMat(),   // +Y, -Y (end caps)
                        ceilingMat(),           // +Z face â†’ faces DOWN after rotation = ceiling
                        rMat()                  // -Z face â†’ faces UP after rotation = roof colour
                    ];
                } else {
                    return [
                        coreMat(), coreMat(),   // +X, -X (side edges)
                        coreMat(), coreMat(),   // +Y, -Y (end caps)
                        rMat(),                 // +Z face â†’ faces UP after rotation = roof colour
                        ceilingMat()            // -Z face â†’ faces DOWN after rotation = ceiling
                    ];
                }
            }

            const fasciaCol = new THREE.Color(steelColor.hex).convertSRGBToLinear();
            const fasciaMat = () => new THREE.MeshStandardMaterial({color: fasciaCol, metalness: 0.0, roughness: 0.7});

            const riserCol = new THREE.Color(steelColor.hex).convertSRGBToLinear();
            const riserMat = () => new THREE.MeshStandardMaterial({color: riserCol, metalness: 0.0, roughness: 0.7});

            // Flashings, gutters, downpipes â€” separate colour selection
            const flashCol = new THREE.Color(flashingColor.hex).convertSRGBToLinear();
            const fMat = () => new THREE.MeshStandardMaterial({color: flashCol, metalness: 0.1, roughness: 0.4});

            const beamW = c.frameBeam.w, beamH = c.frameBeam.h, postW = c.framePost.w;

            const isPerpendicular = c.isGable && c.orientation === 'perpendicular';

            // ===== FRONT POSTS (Gutter side) =====
            const fpostH = frontBeamY;  // May be elevated for gable+riser
            for (let i = 0; i < c.nPosts; i++) {
                const x = -L/2 + (L / (c.nPosts - 1)) * i;
                const post = new THREE.Mesh(new THREE.BoxGeometry(postW, fpostH, postW), sMat());
                if (isPerpendicular) {
                    post.position.set(W/2, fpostH/2, x);
                } else {
                    post.position.set(x, fpostH/2, W/2);
                }
                post.castShadow = true;
                steelGrp.add(post);
                regComp(post, 'Front Post ' + (i+1), {'Size': c.framePost.name, 'Height': Math.round(fpostH*1000) + 'mm'});
            }

            // ===== BACK POSTS (freestanding only) =====
            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = -L/2 + (L / (c.nPosts - 1)) * i;
                    const bpostH = backBeamY;
                    const post = new THREE.Mesh(new THREE.BoxGeometry(postW, bpostH, postW), sMat());
                    if (isPerpendicular) {
                        post.position.set(-W/2, bpostH/2, x);
                    } else {
                        post.position.set(x, bpostH/2, -W/2);
                    }
                    post.castShadow = true;
                    steelGrp.add(post);
                    regComp(post, 'Back Post ' + (i+1), {'Size': c.framePost.name, 'Height': Math.round(bpostH*1000) + 'mm'});
                }
            }

            // ===== GUTTER BEAM (Front beam on posts) =====
            // Trim beam on wing side when L-shape active
            const wallThick = 0.15;  // house wall thickness (metres)
            const wingTrim = (c.lShape !== 'none' && c.isAttached) ? wallThick : 0;
            const wingSign = c.lShape === 'left' ? -1 : (c.lShape === 'right' ? 1 : 0);

            // Wraparound variables (independent of L-shape)
            const wrapSign = c.wrapSide === 'left' ? -1 : (c.wrapSide === 'right' ? 1 : 0);
            const isWrap = c.wrapSide !== 'none';

            const wrapTrim = (isWrap && c.isAttached) ? wallThick : 0;
            const beamLen = L - wingTrim - wrapTrim;
            const beamShift = (wingSign * wingTrim - wrapSign * wrapTrim) / 2;
            const gutterBeam = new THREE.Mesh(new THREE.BoxGeometry(beamLen, beamH, beamW), sMat());
            if (isPerpendicular) {
                gutterBeam.rotation.y = Math.PI / 2;
                gutterBeam.position.set(W/2, frontBeamY + beamH/2, beamShift);
            } else {
                gutterBeam.position.set(beamShift, frontBeamY + beamH/2, W/2);
            }
            gutterBeam.castShadow = true;
            steelGrp.add(gutterBeam);
            regComp(gutterBeam, 'Gutter Beam', {'Size': c.frameBeam.name, 'Length': Math.round(beamLen * 1000) + 'mm'});

            // ===== FASCIA BEAM (on house - for fascia/riser/wall only, NOT flyover) =====
            // Against house fascia board face, below gutter in exposed fascia zone
            // Flyover connects via posts on roof â€” no fascia beam needed
            if (c.isAttached && fasciaBeamY !== null && c.connection !== 'flyover') {
                const fasciaBeam = new THREE.Mesh(new THREE.BoxGeometry(beamLen, beamW * 1.1, beamH * 1.2), fasciaMat());
                // Z: against house fascia face (wall face + fascia board thickness offset)
                const fbmZ = -W/2 - 0.02;
                if (isPerpendicular) {
                    fasciaBeam.rotation.y = Math.PI / 2;
                    fasciaBeam.position.set(fbmZ, fasciaBeamY + beamW/2, beamShift);
                } else {
                    fasciaBeam.position.set(beamShift, fasciaBeamY + beamW/2, fbmZ);
                }
                fasciaBeam.castShadow = true;
                steelGrp.add(fasciaBeam);
                regComp(fasciaBeam, 'Fascia Beam', {'Size': c.frameBeam.name, 'Length': Math.round(beamLen * 1000) + 'mm', 'Height': c.fasciaH + 'mm', 'Note': 'House connection'});
            }

            // ===== RAFTER BRACKETS (for skillion+fascia only, not gable) =====
            if (c.connection === 'fascia' && !c.isGable) {
                const bracketLen = 0.5;
                const bracketH = 0.006;
                const bracketW = 0.05;
                const bracketCount = Math.max(3, Math.ceil(L / 1.0));
                for (let i = 0; i < bracketCount; i++) {
                    const x = -L/2 + (L / (bracketCount - 1)) * i;
                    const bracket = new THREE.Mesh(
                        new THREE.BoxGeometry(bracketW, bracketH, bracketLen),
                        sMat()
                    );
                    if (isPerpendicular) {
                        bracket.rotation.y = Math.PI / 2;
                        bracket.position.set(-W/2 - bracketLen/2 - 0.08, fasciaBeamY + beamH + 0.1, x);
                    } else {
                        bracket.position.set(x, fasciaBeamY + beamH + 0.1, -W/2 - bracketLen/2 - 0.08);
                    }
                    steelGrp.add(bracket);
                }
            }

            // ===== V18 FIX: RISERS with correct stacking =====
            if (c.connection === 'riser') {
                // V18: Riser beam sits ON TOP of risers
                const riserOff = c.riserOffset / 1000;
                const riserSize = c.riserSteelSize ? c.riserSteelSize.w : postW;  // riser RHS width
                const count = c.riserQty;

                // Calculate actual vertical rise of risers
                // Span from fascia beam top (horiz piece) up to riser beam bottom (backBeamY)
                const actualRiserH = backBeamY - (fasciaBeamY + beamH + riserSize);

                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;

                    // HORIZONTAL piece (comes out from fascia beam)
                    const horizPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, riserSize, riserOff),
                        riserMat()
                    );

                    // VERTICAL piece (rises up)
                    const vertPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, actualRiserH, riserSize),
                        riserMat()
                    );

                    if (isPerpendicular) {
                        horizPiece.rotation.y = Math.PI / 2;
                        horizPiece.position.set(-W/2 + riserOff/2, fasciaBeamY + beamH + riserSize/2, x);
                        vertPiece.position.set(-W/2 + riserOff, fasciaBeamY + beamH + riserSize + actualRiserH/2, x);
                    } else {
                        horizPiece.position.set(x, fasciaBeamY + beamH + riserSize/2, -W/2 + riserOff/2);
                        vertPiece.position.set(x, fasciaBeamY + beamH + riserSize + actualRiserH/2, -W/2 + riserOff);
                    }

                    horizPiece.castShadow = true;
                    vertPiece.castShadow = true;
                    steelGrp.add(horizPiece);
                    steelGrp.add(vertPiece);
                    regComp(vertPiece, 'Riser (Welded L) ' + (i+1), {
                        'Size': c.framePost.name,
                        'Offset': c.riserOffset + 'mm',
                        'Rise': Math.round(actualRiserH * 1000) + 'mm',
                        'Note': '90Â° elbow clears house gutter'
                    });
                }

                // Riser brackets â€“ threaded rod through house fascia, clamps fascia beam tight
                // Strip lays along rafter top, threaded rod pokes through fascia board
                const galvMat = () => new THREE.MeshStandardMaterial({color: 0xC0C0C0, metalness: 0.5, roughness: 0.45});
                const fasciaHmR = c.fasciaH / 1000; // rafter base Y (independent of fascia beam)
                const fasciaBdH = 0.15; // house fascia board height
                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;
                    const stripLen = 0.45;   // 450mm long
                    const stripW = 0.03;     // 30mm wide
                    const stripT = 0.006;    // 6mm thick galv plate
                    // Y: vertically centred on house fascia board
                    const bkY = fasciaHmR - fasciaBdH / 2;
                    // House fascia front face is 50mm behind patio edge
                    // Fascia beam front face is 10mm past patio edge
                    const fasciaFaceOff = -0.05; // house fascia front face relative to -W/2
                    const fbmFrontOff = 0.01;    // fascia beam front face relative to -W/2
                    // Threaded rod: from fascia face through to fascia beam front face
                    const rodLen = fbmFrontOff - fasciaFaceOff; // 60mm
                    const rodD = 0.012; // M12 threaded rod
                    // Strip: mostly behind wall, tip at house fascia face
                    const strip = new THREE.Mesh(
                        new THREE.BoxGeometry(stripW, stripT, stripLen),
                        galvMat()
                    );
                    // Threaded rod: pokes through fascia, does NOT protrude past fascia beam
                    const bolt = new THREE.Mesh(
                        new THREE.BoxGeometry(rodD, rodD, rodLen),
                        galvMat()
                    );
                    if (isPerpendicular) {
                        strip.rotation.y = Math.PI / 2;
                        strip.position.set(-W/2 + fasciaFaceOff - stripLen/2, bkY, x);
                        bolt.rotation.y = Math.PI / 2;
                        bolt.position.set(-W/2 + fasciaFaceOff + rodLen/2, bkY, x);
                    } else {
                        strip.position.set(x, bkY, -W/2 + fasciaFaceOff - stripLen/2);
                        bolt.position.set(x, bkY, -W/2 + fasciaFaceOff + rodLen/2);
                    }
                    steelGrp.add(strip);
                    steelGrp.add(bolt);
                    regComp(strip, 'Riser Bracket ' + (i+1), {'Size': '450Ã—30Ã—6mm Galv Flat Bar', 'Rod': 'M12 threaded rod', 'Note': 'Threaded rod through fascia, clamps fascia beam tight'});
                }

                // Box gutter (if selected) - sits in gap between house wall and riser beam
                if (c.houseGutter === 'box') {
                    // Width sized to fit the gap between house fascia and riser beam
                    const boxGutterW = riserOff;
                    const boxGutterD = 0.1;       // inner wall height (house side)
                    const boxGutterOuter = 0.12;  // outer wall height (riser side, taller to catch water)
                    const wallT = 0.01;

                    // U-shaped cross-section: X=0 is house side, X=boxGutterW is riser side
                    const gutterShape = new THREE.Shape();
                    gutterShape.moveTo(0, 0);
                    gutterShape.lineTo(boxGutterW, 0);
                    gutterShape.lineTo(boxGutterW, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, wallT);
                    gutterShape.lineTo(wallT, wallT);
                    gutterShape.lineTo(wallT, boxGutterD);
                    gutterShape.lineTo(0, boxGutterD);
                    gutterShape.closePath();

                    const extrudeSettings = { depth: L, bevelEnabled: false };
                    const gutterGeo = new THREE.ExtrudeGeometry(gutterShape, extrudeSettings);
                    const boxGutter = new THREE.Mesh(gutterGeo, fMat());

                    // Y: gutter bottom sits ON TOP of the welded l horizontal pieces
                    // horiz piece top = fasciaBeamY + beamH + riserSize
                    const boxGutterY = fasciaBeamY + beamH + riserSize;

                    if (isPerpendicular) {
                        // House wall at X = -W/2, riser beam at X = -W/2 + riserOff
                        // rotation.y = Ï€: local X â†’ world -X, local +Z â†’ world -Z
                        // Shape X=0 (house side) â†’ world X = position.x (riser beam)
                        // Shape X=gutterW (riser side) â†’ world X = position.x - gutterW = -W/2 (house)
                        // So we need to flip: position at -W/2, no extra rotation for X direction
                        // Use rotation.y = 0: local X â†’ world +X, local Z â†’ world +Z
                        // Shape X=0 (house side) at world X = -W/2, X=gutterW at -W/2 + riserOff
                        boxGutter.rotation.y = 0;
                        boxGutter.position.set(-W/2, boxGutterY, -L/2);
                    } else {
                        // House wall at Z = -W/2, riser beam at Z = -W/2 + riserOff
                        // rotation.y = -Ï€/2: local X â†’ world +Z, local +Z â†’ world -X
                        // Shape X=0 (house side) at world Z = -W/2
                        // Shape X=gutterW (riser side) at world Z = -W/2 + riserOff
                        // Extrusion goes -X, so position at X = +L/2
                        boxGutter.rotation.y = -Math.PI / 2;
                        boxGutter.position.set(L/2, boxGutterY, -W/2);
                    }
                    accGrp.add(boxGutter);
                    regComp(boxGutter, 'Box Gutter', {'Width': Math.round(riserOff*1000)+'mm', 'Inner Depth': '100mm', 'Outer Depth': '120mm'});
                }

                // Patio gutter on riser beam (gable only) - catches back slope water
                if (c.isGable && c.riserGutter === 'quad') {
                    const rgW = 0.115;     // 115mm quad gutter
                    const rgFront = 0.076; // 76mm front face
                    const rgBack = 0.045;  // 45mm back face
                    const rgT = 0.001;     // 1mm sheet steel
                    const rgs = new THREE.Shape();
                    rgs.moveTo(0, 0);
                    rgs.lineTo(rgW, 0);
                    rgs.lineTo(rgW, rgFront);
                    rgs.lineTo(rgW - rgT, rgFront);
                    rgs.lineTo(rgW - rgT, rgT);
                    rgs.lineTo(rgT, rgT);
                    rgs.lineTo(rgT, rgBack);
                    rgs.lineTo(0, rgBack);
                    rgs.closePath();
                    const rgGeo = new THREE.ExtrudeGeometry(rgs, { depth: L, bevelEnabled: false });
                    const riserGutterMesh = new THREE.Mesh(rgGeo, fMat());
                    // Sits on top of riser beam
                    const riserBeamTop = backBeamY + beamW; // riser beam on edge: height = beam width
                    if (isPerpendicular) {
                        riserGutterMesh.position.set(-W/2 + riserOff - rgW/2, riserBeamTop, -L/2);
                    } else {
                        riserGutterMesh.rotation.y = -Math.PI / 2;
                        riserGutterMesh.position.set(L/2, riserBeamTop, -W/2 + riserOff - rgW/2);
                    }
                    accGrp.add(riserGutterMesh);
                    regComp(riserGutterMesh, 'Riser Beam Gutter', {'Type': '115mm Quad', 'Length': c.L + 'mm', 'Note': 'Catches gable back slope water'});
                }
            }

            // ===== BOX GUTTER for Gable+Fascia (dogleg pocket) =====
            if (c.connection === 'fascia' && c.isGable && c.houseGutter === 'box') {
                const doglegH = c.trussRiserLeft.length / 1000;
                const boxGutterW = doglegH;
                const boxGutterD = 0.1;
                const boxGutterOuter = 0.12;
                const wallT = 0.01;
                const gutterShape = new THREE.Shape();
                gutterShape.moveTo(0, 0);
                gutterShape.lineTo(boxGutterW, 0);
                gutterShape.lineTo(boxGutterW, boxGutterOuter);
                gutterShape.lineTo(boxGutterW - wallT, boxGutterOuter);
                gutterShape.lineTo(boxGutterW - wallT, wallT);
                gutterShape.lineTo(wallT, wallT);
                gutterShape.lineTo(wallT, boxGutterD);
                gutterShape.lineTo(0, boxGutterD);
                gutterShape.closePath();
                const bgGeo = new THREE.ExtrudeGeometry(gutterShape, { depth: L, bevelEnabled: false });
                const boxGutter = new THREE.Mesh(bgGeo, fMat());
                // Box gutter sits on top of fascia beam + riser vertical piece
                const boxGutterY = fasciaBeamY + beamH;
                if (isPerpendicular) {
                    boxGutter.rotation.y = 0;
                    boxGutter.position.set(-W/2, boxGutterY, -L/2);
                } else {
                    boxGutter.rotation.y = -Math.PI / 2;
                    boxGutter.position.set(L/2, boxGutterY, -W/2);
                }
                accGrp.add(boxGutter);
                regComp(boxGutter, 'Box Gutter', {'Width': Math.round(doglegH*1000)+'mm', 'Inner Depth': '100mm', 'Outer Depth': '120mm', 'Note': 'Sits in dogleg pocket'});
            }

            // ===== CARRY / BACK BEAM - NOT for receiving channel (fascia/wall use channel instead) =====
            // Flyover extension: patio back edge extends to flyover post position on the roof
            const flyoverExt = c.connection === 'flyover' ? (c.flyoverSetback || 600) / 1000 : 0;

            if ((c.connection !== 'fascia' && c.connection !== 'wall') || (c.connection === 'fascia' && c.isGable)) {
                const isRiser = c.connection === 'riser';
                const isFlyover = c.connection === 'flyover';
                const isGableFascia = c.connection === 'fascia' && c.isGable;
                // Riser: beam on edge (swap w/h), Flyover: always 150Ã—50, Default: selected beam
                const beamHeight = isRiser ? beamW : (isFlyover ? 0.05 : beamH);
                const beamWidth = isRiser ? beamH : (isFlyover ? 0.15 : beamW);
                const riserOff = isRiser ? c.riserOffset/1000 : (isGableFascia ? c.trussRiserLeft.length / 1000 : 0);
                // For flyover, beam sits at flyover post position (setback behind house wall)
                const beamBackZ = isFlyover ? (-W/2 - flyoverExt) : (-W/2 + riserOff);

                const carryBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamHeight, beamWidth), sMat());
                if (isPerpendicular) {
                    carryBeam.rotation.y = Math.PI / 2;
                    carryBeam.position.set(beamBackZ, backBeamY + beamHeight/2, 0);
                } else {
                    carryBeam.position.set(0, backBeamY + beamHeight/2, beamBackZ);
                }
                carryBeam.castShadow = true;
                steelGrp.add(carryBeam);
                const beamName = isRiser ? 'Riser Beam' : (isFlyover ? 'Flyover Beam' : 'Back Beam');
                const beamSpec = isRiser ? (c.frameBeam.name + ' (on edge)') : (isFlyover ? '150Ã—50Ã—2 RHS' : c.frameBeam.name);
                regComp(carryBeam, beamName, {'Size': beamSpec, 'Length': c.L + 'mm', 'Height': Math.round(backBeamY*1000) + 'mm'});
            }

            // ===== FLYOVER POSTS - small posts on top of house rafters =====
            // Posts penetrate through roof sheets and bolt to house rafters
            // Positioned at user-defined setback from fascia up the roof slope
            if (c.connection === 'flyover') {
                const fasciaHm = c.fasciaH / 1000;
                const hRafterH = 0.09; // house rafter height
                const houseRoofPitchRad = (c.houseRoofPitch || 22.5) * Math.PI / 180;
                const setbackM = (c.flyoverSetback || 600) / 1000; // setback from fascia in metres
                // Roof surface height at the post position (fascia + rise along slope)
                const roofSurfaceAtPost = fasciaHm + hRafterH + setbackM * Math.tan(houseRoofPitchRad);
                const strutSize = postW; // flyover posts match main post size
                const strutH = Math.max(0.15, backBeamY - roofSurfaceAtPost);
                const strutCount = Math.max(2, Math.ceil(L / 1.2));

                for (let i = 0; i < strutCount; i++) {
                    const x = -L/2 + (L / (strutCount - 1)) * i;
                    // Position posts at setback distance from fascia (into the roof)
                    const postZ = -W/2 - setbackM;
                    const strut = new THREE.Mesh(
                        new THREE.BoxGeometry(strutSize, strutH, strutSize),
                        sMat()
                    );
                    if (isPerpendicular) {
                        strut.position.set(postZ, roofSurfaceAtPost + strutH/2, x);
                    } else {
                        strut.position.set(x, roofSurfaceAtPost + strutH/2, postZ);
                    }
                    strut.castShadow = true;
                    steelGrp.add(strut);
                    regComp(strut, 'Flyover Post ' + (i+1), {
                        'Size': c.framePost.name,
                        'Height': Math.round(strutH*1000) + 'mm',
                        'Setback': (c.flyoverSetback || 600) + 'mm from fascia',
                        'Note': 'Bolted to house rafter, flashing boot at roof penetration'
                    });

                    // Flashing boot at roof penetration (visible plate around post base)
                    const bootSize = strutSize * 2.5;
                    const bootH = 0.005;
                    const boot = new THREE.Mesh(
                        new THREE.BoxGeometry(bootSize, bootH, bootSize),
                        new THREE.MeshLambertMaterial({color: 0x888888})
                    );
                    if (isPerpendicular) {
                        boot.rotation.z = houseRoofPitchRad;
                        boot.position.set(postZ, roofSurfaceAtPost + bootH/2, x);
                    } else {
                        boot.rotation.x = houseRoofPitchRad;
                        boot.position.set(x, roofSurfaceAtPost + bootH/2, postZ);
                    }
                    houseGrp.add(boot);
                    if (i === 0) regComp(boot, 'Flashing Boots', {'Qty': strutCount, 'Note': 'Seal roof penetrations around flyover posts'});
                }
            }

            // ===== ROOF STRUCTURE =====
            const frontTop = frontBeamY + beamH;
            const backTop = backBeamY + beamH;
            const sheetW = c.sheetCoverage / 1000;

            // V18: Calculate actual gutter height for downpipes
            let gutterY;

            if (c.isGable) {
                // ========== GABLE ROOF ==========
                // For flyover, extend the gable truss span to reach the flyover posts
                // For gable+fascia, subtract dogleg offset â€” trusses span from elevated back beam to front beam
                const gableFasciaOff = (c.connection === 'fascia' && c.isGable) ? (c.trussRiserLeft.length / 1000) : 0;
                const gableW = W + flyoverExt - gableFasciaOff;
                const gableShift = (-flyoverExt + gableFasciaOff) / 2;  // shift center to align with beam positions
                const gableRise = rise;
                const gableRafter = Math.sqrt((gableW/2) * (gableW/2) + gableRise * gableRise);
                const trussBaseY = (frontTop + backTop) / 2;
                const tiltAngle = Math.atan2(backTop - frontTop, gableW);
                gutterY = frontTop - 0.04;

                // Trusses (peak from internal geometry; tilt spans between beams when heights differ)
                for (let i = 0; i < c.nTruss; i++) {
                    const x = -L/2 + (L / (c.nTruss - 1)) * i;
                    const truss = createTrussUnit(gableW, gableRise, gableRafter, tw, th, sMat(), c);
                    if (isPerpendicular) {
                        truss.rotation.order = 'ZYX';
                        truss.rotation.y = Math.PI / 2;
                        truss.rotation.z = -tiltAngle;
                        truss.position.set(gableShift, trussBaseY, x);
                    } else {
                        truss.rotation.x = tiltAngle;
                        truss.position.set(x, trussBaseY, gableShift);
                    }
                    steelGrp.add(truss);
                    regComp(truss, 'Truss ' + (i+1), {'Span': Math.round(c.trussSpan) + 'mm', 'Rise': Math.round(c.rise) + 'mm'});

                    // Gable infill
                    if ((i === 0 || i === c.nTruss - 1) && c.infill !== 'none') {
                        const shape = new THREE.Shape();
                        shape.moveTo(-gableW/2, th);
                        shape.lineTo(0, gableRise + th);
                        shape.lineTo(gableW/2, th);
                        shape.closePath();
                        const isTransparent = c.infill === 'polycarbonate';
                        const isLouvre = c.infill === 'louvre';
                        const infillMat = isTransparent
                            ? new THREE.MeshStandardMaterial({color: 0xDDEEEE, transparent: true, opacity: 0.6, roughness: 0.1, metalness: 0.0, side: THREE.DoubleSide})
                            : new THREE.MeshStandardMaterial({color: isLouvre ? 0xCCCCCC : sheetCol, metalness: 0.0, roughness: 0.65, side: THREE.DoubleSide});
                        const infillMesh = new THREE.Mesh(new THREE.ShapeGeometry(shape), infillMat);

                        if (isPerpendicular) {
                            infillMesh.rotation.y = x > 0 ? Math.PI : 0;
                            infillMesh.position.set(gableShift, trussBaseY, x);
                        } else {
                            infillMesh.rotation.y = Math.PI / 2;
                            infillMesh.position.set(x, trussBaseY, gableShift);
                        }
                        roofGrp.add(infillMesh);
                        const infillLabel = {colorbond:'Colorbond', polycarbonate:'Polycarbonate', louvre:'Louvre'}[c.infill] || c.infill;
                        regComp(infillMesh, 'Gable Infill', {'Material': infillLabel});
                    }
                }

                // Purlins - use gable batten calculator positions
                const gbc = c.gableBattenCalc;
                if (gbc && gbc.totalBattens > 0 && !isInsulated(c.roofing)) {
                    const rafterMm = gableRafter * 1000;
                    const apexOffset = 75;
                    for (let side = -1; side <= 1; side += 2) {
                        for (let i = 0; i < gbc.positionsPerSide.length; i++) {
                            const pos = gbc.positionsPerSide[i];
                            const frac = (apexOffset + pos) / rafterMm;
                            const zPos = gableShift + (gableW/2) * frac * side;
                            const yPos = trussBaseY + th + gableRise * (1 - frac);
                            const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                            if (isPerpendicular) {
                                purlin.rotation.y = Math.PI / 2;
                                purlin.position.set(zPos, yPos, 0);
                            } else {
                                purlin.position.set(0, yPos, zPos);
                            }
                            steelGrp.add(purlin);
                            const sideLabel = side === -1 ? 'L' : 'R';
                            regComp(purlin, 'Purlin ' + sideLabel + (i+1), {'Size': c.steel.name, 'Length': Math.round(c.L) + 'mm', 'Position': Math.round(apexOffset + pos) + 'mm from ridge'});
                        }
                    }
                } else if (!gbc) {
                    // Fallback if calculator not available
                    const purlinCount = Math.max(2, Math.ceil(gableRafter / 0.8));
                    for (let side = -1; side <= 1; side += 2) {
                        for (let p = 1; p <= purlinCount; p++) {
                            const frac = p / (purlinCount + 1);
                            const zPos = gableShift + (gableW/2) * frac * side;
                            const yPos = trussBaseY + th + gableRise * (1 - frac);
                            const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                            if (isPerpendicular) {
                                purlin.rotation.y = Math.PI / 2;
                                purlin.position.set(zPos, yPos, 0);
                            } else {
                                purlin.position.set(0, yPos, zPos);
                            }
                            steelGrp.add(purlin);
                        }
                    }
                }

                // V18 FIX: Roof sheets - corrected rotation for perpendicular mode
                const numSheets = Math.ceil(L / sheetW);
                const gableSc = c.sheetCalc;
                const gablePc = hasPolycarbMatch(c.roofing) ? getPolycarbConfig() : null;
                for (let side = -1; side <= 1; side += 2) {
                    for (let s = 0; s < numSheets; s++) {
                        // Partial sheet: last sheet uses actual remaining width
                        const isPartial = gableSc && gableSc.hasPartialSheet && s === numSheets - 1;
                        const thisW = isPartial ? (gableSc.partialSheetWidth / 1000) : sheetW;
                        const sheetPos = -L/2 + (s * sheetW) + thisW / 2;
                        const isPolySheet = gablePc && ((s + 1) % gablePc.patternN === 0);
                        let sheetGeo;
                        const gSheetLen = gableRafter + 0.05;
                        if (c.roofing === 'corrugated') {
                            sheetGeo = createCorrugatedGeometry(thisW, gSheetLen);
                        } else if (c.roofing === 'trimdek' || c.roofing === 'spandek') {
                            sheetGeo = createTrimdekGeometry(thisW, gSheetLen);
                        } else {
                            // SolarSpan: ribs on sky-facing surface (left=-Z up, right=+Z up)
                            sheetGeo = createInsulatedGeometry(thisW, gSheetLen, c.roofing === 'solarspan100' ? 0.1 : 0.075, side === -1);
                        }

                        let sheetMat;
                        if (isPolySheet) {
                            const tintData = POLYCARB_3D_TINTS[gablePc.tint] || POLYCARB_3D_TINTS['Clear'];
                            sheetMat = new THREE.MeshStandardMaterial({
                                color: tintData.color, transparent: true, opacity: tintData.opacity,
                                roughness: 0.1, metalness: 0.0, side: THREE.DoubleSide
                            });
                        } else if (isInsulated(c.roofing)) {
                            sheetMat = insulatedMaterials(side === -1);  // left: -Z up, right: +Z up
                        } else {
                            sheetMat = rMat();
                        }
                        const sheet = new THREE.Mesh(sheetGeo, sheetMat);

                        if (isPerpendicular) {
                            sheet.rotation.order = 'YXZ';
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                            sheet.rotation.y = Math.PI / 2;

                            const midHeight = trussBaseY + th + gableRise/2;
                            sheet.position.set(gableShift + side * gableW/4, midHeight + th/2 + 0.02, sheetPos);
                        } else {
                            sheet.position.set(sheetPos, trussBaseY + th + th/2 + gableRise/2 + 0.01, gableShift + side * gableW/4);
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                        }
                        sheet.castShadow = !isPolySheet;
                        roofGrp.add(sheet);
                        const sideLabel = side === -1 ? 'A' : 'B';
                        const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                        const widthNote = isPartial ? ' (cut to ' + gableSc.partialSheetWidth + 'mm)' : '';
                        regComp(sheet, 'Roof Sheet ' + sideLabel + (s+1), {'Profile': sheetType, 'Width': Math.round(thisW * 1000) + 'mm' + widthNote, 'Length': Math.round((rafter + 0.05)*1000) + 'mm', 'Side': side === -1 ? 'Left slope' : 'Right slope'});
                    }
                }

                // Ridge capping
                const ridge = new THREE.Mesh(new THREE.BoxGeometry(L, 0.04, 0.3), fMat());
                if (isPerpendicular) {
                    ridge.rotation.y = Math.PI / 2;
                    ridge.position.set(gableShift, trussBaseY + th + gableRise + 0.02, 0);
                } else {
                    ridge.position.set(0, trussBaseY + th + gableRise + 0.02, gableShift);
                }
                accGrp.add(ridge);
                regComp(ridge, 'Ridge Cap', {'Length': c.L + 'mm'});

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), fMat());
                if (isPerpendicular) {
                    gutter.rotation.y = Math.PI / 2;
                    gutter.position.set(W/2 + 0.07, gutterY, 0);
                } else {
                    gutter.position.set(0, gutterY, W/2 + 0.07);
                }
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.L + 'mm'});

                // Gutter flashing (SolarSpan only) â€” between panel ends and gutter
                if (isInsulated(c.roofing)) {
                    const gfThick = c.roofing === 'solarspan100' ? 0.1 : 0.075;
                    const gutterFlashGable = new THREE.Mesh(new THREE.BoxGeometry(L, gfThick, 0.003), fMat());
                    if (isPerpendicular) {
                        gutterFlashGable.rotation.y = Math.PI / 2;
                        gutterFlashGable.position.set(W/2 + 0.01, gutterY + 0.04 + gfThick/2, 0);
                    } else {
                        gutterFlashGable.position.set(0, gutterY + 0.04 + gfThick/2, W/2 + 0.01);
                    }
                    accGrp.add(gutterFlashGable);
                    regComp(gutterFlashGable, 'Gutter Flashing', {'Length': c.L + 'mm', 'Height': Math.round(gfThick*1000) + 'mm'});
                }

                // Gable barges
                const bargeThick = 0.008;
                const bargeWidth = 0.15;
                const bargeLen = rafter + 0.05;

                if (isPerpendicular) {
                    [-L/2, L/2].forEach((zEnd, idx) => {
                        const bargeL = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            fMat()
                        );
                        bargeL.position.set(-W/4, trussBaseY + th + rise/2, zEnd);
                        bargeL.rotation.z = c.pitchRad;
                        accGrp.add(bargeL);
                        regComp(bargeL, 'Barge Flashing ' + (idx === 0 ? '1L' : '2L'), {'Length': Math.round(bargeLen*1000) + 'mm'});

                        const bargeR = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            fMat()
                        );
                        bargeR.position.set(W/4, trussBaseY + th + rise/2, zEnd);
                        bargeR.rotation.z = -c.pitchRad;
                        accGrp.add(bargeR);
                        regComp(bargeR, 'Barge Flashing ' + (idx === 0 ? '1R' : '2R'), {'Length': Math.round(bargeLen*1000) + 'mm'});
                    });
                } else {
                    [-L/2, L/2].forEach((xEnd, idx) => {
                        const bargeHouse = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            fMat()
                        );
                        bargeHouse.position.set(xEnd, trussBaseY + th + rise/2, -W/4);
                        bargeHouse.rotation.x = -c.pitchRad;
                        accGrp.add(bargeHouse);
                        regComp(bargeHouse, 'Barge Flashing ' + (idx === 0 ? '1 House' : '2 House'), {'Length': Math.round(bargeLen*1000) + 'mm'});

                        const bargeGutter = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            fMat()
                        );
                        bargeGutter.position.set(xEnd, trussBaseY + th + rise/2, W/4);
                        bargeGutter.rotation.x = c.pitchRad;
                        accGrp.add(bargeGutter);
                        regComp(bargeGutter, 'Barge Flashing ' + (idx === 0 ? '1 Gutter' : '2 Gutter'), {'Length': Math.round(bargeLen*1000) + 'mm'});
                    });
                }

            } else {
                // ========== SKILLION ROOF ==========
                gutterY = frontTop - 0.04;  // V18: Store gutter Y for downpipes

                const riserOff = c.connection === 'riser' ? c.riserOffset / 1000 : 0;
                // For flyover, patio extends back to the flyover post position
                const backEdgeZ = c.connection === 'flyover' ? (-W/2 - flyoverExt) : (-W/2 + riserOff);
                // Effective rafter/sheet length extends along the slope for the extra flyover distance
                const extRafter = c.connection === 'flyover' ? (rafter + flyoverExt / Math.cos(c.pitchRad)) : rafter;

                // Rafters (use rafter calculator count and size) â€” SolarSpan spans beam-to-beam, no rafters
                if (!isInsulated(c.roofing)) {
                    const raftCount = c.rafterCalc ? c.rafterCalc.rafterCount : c.nRafters;
                    const raftW = c.rafterSize ? c.rafterSize.w : tw;
                    const raftH = c.rafterSize ? c.rafterSize.h : th;
                    const raftName = c.rafterSize ? c.rafterSize.name : c.steel.name;
                    for (let i = 0; i < raftCount; i++) {
                        let x = -L/2 + (raftCount > 1 ? (L / (raftCount - 1)) * i : 0);
                        // Offset outermost rafter on wing side inward to avoid clipping through wing wall
                        if (c.lShape !== 'none' && c.isAttached) {
                            const wingEdge = wingSign * L/2;
                            if (Math.abs(x - wingEdge) < postW) {
                                x = wingEdge - wingSign * postW/2;
                            }
                        }
                        const rafterGeo = new THREE.BoxGeometry(raftW, raftH, extRafter);
                        rafterGeo.translate(0, 0, extRafter/2);
                        const raft = new THREE.Mesh(rafterGeo, sMat());
                        raft.position.set(x, backTop + raftH/2, backEdgeZ);
                        raft.rotation.x = c.pitchRad;
                        steelGrp.add(raft);
                        regComp(raft, 'Rafter ' + (i+1), {'Size': raftName, 'Length': Math.round(c.rafter) + 'mm'});
                    }
                }

                // Purlins / Battens - use batten calculator positions when available
                // SolarSpan spans beam-to-beam, no purlins needed
                const effectiveW = W + flyoverExt - riserOff;
                const bc = c.battenCalc;
                let purlinPositionsFrac;
                if (isInsulated(c.roofing)) {
                    purlinPositionsFrac = [];
                } else if (bc && bc.battensNeeded > 0) {
                    // Use calculated batten positions (mm from back beam) converted to fractions
                    purlinPositionsFrac = bc.battenPositions.map(p => p / (effectiveW * 1000));
                } else if (!isInsulated(c.roofing) && !(bc && bc.battensNeeded === 0)) {
                    // Fallback: even spacing (skip for SpanPlus/sheets that span full projection)
                    const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9));
                    purlinPositionsFrac = [];
                    for (let p = 1; p < purlinCount; p++) purlinPositionsFrac.push(p / purlinCount);
                } else {
                    purlinPositionsFrac = [];
                }
                for (let p = 0; p < purlinPositionsFrac.length; p++) {
                    const frac = purlinPositionsFrac[p];
                    const zPos = backEdgeZ + effectiveW * frac;
                    const yPos = backTop + th - (backTop - frontTop) * frac;
                    // Extend purlin to hip line on wrap side (jack purlin into hip rafter)
                    var purlinLen = L - 0.1;
                    var purlinX = 0;
                    if (isWrap && c.isAttached) {
                        var retLenM = c.returnLength / 1000;
                        var hipDistLocal = Math.min(retLenM, W);
                        var distFromCorner = zPos + W/2;
                        if (distFromCorner > 0 && distFromCorner <= hipDistLocal) {
                            purlinLen += distFromCorner;
                            purlinX = wrapSign * distFromCorner / 2;
                        }
                    }
                    const purlin = new THREE.Mesh(new THREE.BoxGeometry(purlinLen, 0.038, 0.076), sMat());
                    purlin.position.set(purlinX, yPos, zPos);
                    steelGrp.add(purlin);
                    regComp(purlin, 'Batten ' + (p+1), {'Size': c.purlinSize ? c.purlinSize.name : '76Ã—38Ã—1.6 RHS', 'Length': Math.round(purlinLen * 1000) + 'mm', 'Position': Math.round(frac * effectiveW * 1000) + 'mm from back'});
                }

                // Roof sheets
                const sheetInset = c.isRecvChan ? 0.03 : 0; // 30mm into channel
                const numSheets = Math.ceil(L / sheetW);
                const skillSc = c.sheetCalc;
                const skillPc = hasPolycarbMatch(c.roofing) ? getPolycarbConfig() : null;
                for (let s = 0; s < numSheets; s++) {
                    // Partial sheet: last sheet uses actual remaining width
                    const isPartial = skillSc && skillSc.hasPartialSheet && s === numSheets - 1;
                    const thisW = isPartial ? (skillSc.partialSheetWidth / 1000) : sheetW;
                    const xPos = -L/2 + (s * sheetW) + thisW / 2;
                    const isPolySheet = skillPc && ((s + 1) % skillPc.patternN === 0);
                    let sheetGeo;
                    if (c.roofing === 'corrugated') {
                        sheetGeo = createCorrugatedGeometry(thisW, extRafter);
                    } else if (c.roofing === 'trimdek' || c.roofing === 'spandek') {
                        sheetGeo = createTrimdekGeometry(thisW, extRafter);
                    } else {
                        // SolarSpan: ribs on -Z face (faces UP for skillion after rotation)
                        sheetGeo = createInsulatedGeometry(thisW, extRafter, c.roofing === 'solarspan100' ? 0.1 : 0.075, true);
                    }
                    sheetGeo.translate(0, extRafter/2, 0);

                    let sheetMat;
                    if (isPolySheet) {
                        const tintData = POLYCARB_3D_TINTS[skillPc.tint] || POLYCARB_3D_TINTS['Clear'];
                        sheetMat = new THREE.MeshStandardMaterial({
                            color: tintData.color, transparent: true, opacity: tintData.opacity,
                            roughness: 0.1, metalness: 0.0, side: THREE.DoubleSide
                        });
                    } else if (isInsulated(c.roofing)) {
                        sheetMat = insulatedMaterials(true);  // skillion: -Z faces up
                    } else {
                        sheetMat = rMat();
                    }
                    const sheet = new THREE.Mesh(sheetGeo, sheetMat);
                    // Receiving channel (fascia/wall): no rafters, sheets sit lower on beam
                    const sheetYOffset = c.isRecvChan ? 0.005 : (th + th/2 + 0.01);
                    sheet.position.set(xPos, backTop + sheetYOffset, backEdgeZ - sheetInset);
                    sheet.rotation.x = Math.PI/2 + c.pitchRad;
                    sheet.castShadow = !isPolySheet;
                    roofGrp.add(sheet);
                    const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                    const widthNote = isPartial ? ' (cut to ' + skillSc.partialSheetWidth + 'mm)' : '';
                    regComp(sheet, 'Roof Sheet ' + (s+1), {'Profile': sheetType, 'Width': Math.round(thisW * 1000) + 'mm' + widthNote, 'Length': Math.round(rafter*1000) + 'mm'});
                }

                // Gutter â€” trimmed on wing side (L-shape) and wrap side (wraparound)
                const gutterLen = L - wingTrim - wrapTrim;
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(gutterLen, 0.08, 0.12), fMat());
                gutter.position.set(beamShift, gutterY, W/2 + 0.07);
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': Math.round(gutterLen * 1000) + 'mm'});

                // Gutter flashing (SolarSpan only) â€” between panel ends and gutter
                if (isInsulated(c.roofing)) {
                    const gfThick = c.roofing === 'solarspan100' ? 0.1 : 0.075;
                    const gutterFlash = new THREE.Mesh(new THREE.BoxGeometry(L, gfThick, 0.003), fMat());
                    gutterFlash.position.set(0, gutterY + 0.04 + gfThick/2, W/2 + 0.01);
                    accGrp.add(gutterFlash);
                    regComp(gutterFlash, 'Gutter Flashing', {'Length': c.lenInput + 'mm', 'Height': Math.round(gfThick*1000) + 'mm', 'Note': 'Between panel ends and gutter'});
                }

                // Back flashing - skip for riser+box gutter AND receiving channel (channel acts as flashing)
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    const flash = new THREE.Mesh(new THREE.BoxGeometry(L, 0.15, 0.003), fMat());
                    flash.position.set(0, backTop + 0.08, backEdgeZ - 0.05);
                    flash.rotation.x = -0.3;
                    accGrp.add(flash);
                    regComp(flash, 'Back Flashing', {'Length': c.lenInput + 'mm'});
                }

                // Barge flashings â€” skip on wing side (L-shape) and wrap side (wraparound)
                [-L/2, L/2].forEach((xPos, idx) => {
                    const isWingSide = c.lShape !== 'none' && c.isAttached &&
                        ((c.lShape === 'left' && xPos < 0) || (c.lShape === 'right' && xPos > 0));
                    const isWrapSide = isWrap &&
                        ((c.wrapSide === 'left' && xPos < 0) || (c.wrapSide === 'right' && xPos > 0));
                    if (isWingSide || isWrapSide) return;
                    const barge = new THREE.Mesh(new THREE.BoxGeometry(0.12, rafter, 0.008), fMat());
                    barge.position.set(xPos, (backTop + frontTop)/2 + th, 0);
                    barge.rotation.x = -(Math.PI/2 - c.pitchRad);
                    accGrp.add(barge);
                    regComp(barge, 'Barge Flashing ' + (idx === 0 ? 'L' : 'R'), {'Length': Math.round(rafter*1000) + 'mm'});
                });
            }

            // ===== DOWNPIPES â€” placed at selected post positions =====
            const dpIndices = (c.dpPostIndices && c.dpPostIndices.length > 0) ? c.dpPostIndices : [0, Math.max(0, c.nPosts - 1)];
            dpIndices.forEach((postIdx, dpIdx) => {
                const x = c.nPosts > 1 ? (-L/2 + (L / (c.nPosts - 1)) * postIdx) : 0;
                const dpHeight = gutterY + 0.04;
                const dp = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, dpHeight, 12), fMat());
                if (isPerpendicular) {
                    dp.position.set(W/2 + 0.1, dpHeight/2, x);
                } else {
                    dp.position.set(x, dpHeight/2, W/2 + 0.1);
                }
                accGrp.add(dp);
                regComp(dp, 'Downpipe ' + (dpIdx+1), {'Size': '90mm Round', 'Height': Math.round(dpHeight*1000) + 'mm', 'At': 'Post ' + (postIdx + 1)});
            });

            // ===== PROCEDURAL TILE TEXTURE =====
            function createTileTexture() {
                var tc = document.createElement('canvas');
                tc.width = 512; tc.height = 512;
                var tx = tc.getContext('2d');
                // Dark mortar/batten colour between tiles
                tx.fillStyle = '#3A3530';
                tx.fillRect(0, 0, 512, 512);
                var tileW = 56, tileH = 26, gap = 4;
                var rows = Math.ceil(512 / (tileH + gap));
                // Darker, richer terracotta palette
                var tilePalette = [
                    [165, 68, 38],   // deep terracotta
                    [150, 60, 32],   // dark clay
                    [175, 72, 40],   // warm terracotta
                    [140, 55, 28],   // burnt umber
                    [158, 65, 35],   // mid terracotta
                    [180, 76, 42],   // rich terracotta
                    [145, 58, 30],   // dark sienna
                    [168, 70, 38],   // rustic red
                    [135, 52, 26],   // deep clay brown
                    [155, 63, 34]    // aged terracotta
                ];
                for (var row = 0; row < rows; row++) {
                    var offset = (row % 2 === 0) ? 0 : tileW / 2; // staggered rows
                    var yy = row * (tileH + gap);
                    for (var col = -1; col < Math.ceil(512 / tileW) + 1; col++) {
                        var xx = col * (tileW + gap) + offset;
                        var base = tilePalette[Math.floor(Math.random() * tilePalette.length)];
                        var v = Math.floor(Math.random() * 16) - 8;
                        var r = Math.min(255, Math.max(0, base[0] + v));
                        var g = Math.min(255, Math.max(0, base[1] + v));
                        var b = Math.min(255, Math.max(0, base[2] + v));
                        // Base tile fill
                        tx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                        tx.fillRect(xx + gap/2, yy + gap/2, tileW, tileH);
                        // Barrel tile highlight â€” curved highlight at top third
                        var grad = tx.createLinearGradient(xx, yy + gap/2, xx, yy + gap/2 + tileH);
                        grad.addColorStop(0, 'rgba(255,220,180,0.18)');
                        grad.addColorStop(0.3, 'rgba(255,255,255,0.08)');
                        grad.addColorStop(0.5, 'rgba(0,0,0,0.0)');
                        grad.addColorStop(0.7, 'rgba(0,0,0,0.06)');
                        grad.addColorStop(1, 'rgba(0,0,0,0.15)');
                        tx.fillStyle = grad;
                        tx.fillRect(xx + gap/2, yy + gap/2, tileW, tileH);
                        // Ridge highlight at top edge
                        tx.fillStyle = 'rgba(255,200,160,0.22)';
                        tx.fillRect(xx + gap/2 + 2, yy + gap/2, tileW - 4, 2);
                        // Deep shadow at bottom edge (underlap)
                        tx.fillStyle = 'rgba(0,0,0,0.2)';
                        tx.fillRect(xx + gap/2, yy + gap/2 + tileH - 2, tileW, 2);
                        // Subtle weathering noise â€” random dark speckles
                        for (var sp = 0; sp < 3; sp++) {
                            var sx = xx + gap/2 + Math.random() * tileW;
                            var sy = yy + gap/2 + Math.random() * tileH;
                            tx.fillStyle = 'rgba(60,30,15,' + (0.05 + Math.random() * 0.08) + ')';
                            tx.fillRect(sx, sy, 1 + Math.random() * 2, 1 + Math.random() * 2);
                        }
                    }
                }
                var t = new THREE.CanvasTexture(tc);
                t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
                return t;
            }

            // ===== HOUSE / WALL REPRESENTATION =====
            // riser, fascia, flyover: house with wall + fascia board + Colorbond roof
            // wall: flat wall only (receiving channel bolts to wall surface)
            // freestanding: no wall
            if (c.isAttached) {
                const fasciaHm = c.fasciaH / 1000;
                const wallThick = 0.15;
                const wallLen = L + 2.0;  // extend wall 1m each side past patio
                // Procedural brick texture â€” dark industrial brick (Mt Lawley character)
                const brickTex = (function() {
                    var bc = document.createElement('canvas');
                    bc.width = 512; bc.height = 512;
                    var bx = bc.getContext('2d');
                    // Dark grey mortar joints
                    bx.fillStyle = '#4A4540';
                    bx.fillRect(0, 0, 512, 512);
                    var brickW = 64, brickH = 20, mortarW = 3;
                    var rows = Math.ceil(512 / (brickH + mortarW));
                    // Dark industrial brick palette â€” charcoal, deep brown, iron oxide
                    var brickPalette = [
                        [85, 52, 42],    // dark chocolate
                        [72, 45, 38],    // deep brown
                        [95, 58, 45],    // dark clay
                        [65, 42, 35],    // charcoal brown
                        [78, 48, 40],    // iron oxide
                        [88, 55, 44],    // dark terracotta
                        [60, 38, 32],    // near-black brick
                        [75, 50, 42]     // moody brown
                    ];
                    for (var row = 0; row < rows; row++) {
                        var offset = (row % 2 === 0) ? 0 : brickW / 2; // stretcher bond
                        var y = row * (brickH + mortarW);
                        for (var col = -1; col < Math.ceil(512 / brickW) + 1; col++) {
                            var x = col * (brickW + mortarW) + offset;
                            // Pick a base colour from palette with slight random variation
                            var base = brickPalette[Math.floor(Math.random() * brickPalette.length)];
                            var v = Math.floor(Math.random() * 14) - 7;
                            var r = Math.min(255, Math.max(0, base[0] + v));
                            var g = Math.min(255, Math.max(0, base[1] + v));
                            var b = Math.min(255, Math.max(0, base[2] + v));
                            bx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                            bx.fillRect(x + mortarW/2, y + mortarW/2, brickW, brickH);
                            // Add subtle surface texture (worn spots)
                            for (var sp = 0; sp < 2; sp++) {
                                var sx = x + mortarW + Math.random() * (brickW - mortarW*2);
                                var sy = y + mortarW + Math.random() * (brickH - mortarW*2);
                                var sv = Math.floor(Math.random() * 16) - 8;
                                bx.fillStyle = 'rgba(' + (r+sv) + ',' + (g+sv) + ',' + (b+sv) + ',0.35)';
                                bx.fillRect(sx, sy, 4 + Math.random()*6, 2 + Math.random()*3);
                            }
                        }
                    }
                    var t = new THREE.CanvasTexture(bc);
                    t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
                    t.repeat.set(wallLen / 2.5, 1);
                    return t;
                })();
                const wallMat = new THREE.MeshStandardMaterial({map: brickTex, roughness: 0.88, metalness: 0.0});
                const fasciaTimberMat = new THREE.MeshStandardMaterial({color: 0x8B7355, roughness: 0.75, metalness: 0.0});
                // House roof material â€” conditional on existingRoof type
                const existingRoofType = c.existingRoof || 'tiles';
                let houseRoofMat;
                if (existingRoofType === 'tiles') {
                    const tileTex = createTileTexture();
                    tileTex.repeat.set(wallLen / 2.0, 1);
                    houseRoofMat = new THREE.MeshStandardMaterial({map: tileTex, roughness: 0.75, metalness: 0.0});
                } else if (existingRoofType === 'flat') {
                    houseRoofMat = new THREE.MeshStandardMaterial({color: 0x9A9A9A, roughness: 0.8, metalness: 0.0});
                } else {
                    // Colorbond â€” Monument colour
                    houseRoofMat = new THREE.MeshStandardMaterial({color: new THREE.Color(COLORBOND_COLOURS['Monument']).convertSRGBToLinear(), metalness: 0.1, roughness: 0.4});
                }
                // Keep roofColorbondMat reference for house gutter etc.
                const roofColorbondMat = new THREE.MeshStandardMaterial({color: new THREE.Color(COLORBOND_COLOURS['Monument']).convertSRGBToLinear(), metalness: 0.1, roughness: 0.4});

                if (c.connection === 'wall') {
                    // === WALL MODE: just a flat brick/render wall ===
                    const wallH = Math.max(backBeamY + 0.5, fasciaHm + 0.5);
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                } else {
                    // === HOUSE MODE (riser, fascia, flyover): wall + fascia + roof ===
                    const wallH = fasciaHm;
                    const wallZ = -W/2 - wallThick;

                    // Door opening dimensions
                    const isCarportScene = (currentScenePreset === 'carport');
                    const doorW = isCarportScene ? Math.min(4.8, L * 0.8) : 2.4;  // garage 4.8m or sliding 2.4m
                    const doorH = isCarportScene ? Math.min(2.4, wallH - 0.1) : 2.1;  // garage 2.4m or sliding 2.1m
                    const doorX = 0;  // centered on patio

                    // Build wall segments around door opening
                    // Left segment
                    const leftW = (wallLen - doorW) / 2;
                    if (leftW > 0.01) {
                        const wallL = new THREE.Mesh(new THREE.BoxGeometry(leftW, wallH, wallThick), wallMat);
                        if (isPerpendicular) {
                            wallL.rotation.y = Math.PI / 2;
                            wallL.position.set(-W/2 - wallThick, wallH/2, doorX - doorW/2 - leftW/2);
                        } else {
                            wallL.position.set(doorX - doorW/2 - leftW/2, wallH/2, wallZ);
                        }
                        wallL.receiveShadow = true; houseGrp.add(wallL);
                    }
                    // Right segment
                    const rightW = (wallLen - doorW) / 2;
                    if (rightW > 0.01) {
                        const wallR = new THREE.Mesh(new THREE.BoxGeometry(rightW, wallH, wallThick), wallMat);
                        if (isPerpendicular) {
                            wallR.rotation.y = Math.PI / 2;
                            wallR.position.set(-W/2 - wallThick, wallH/2, doorX + doorW/2 + rightW/2);
                        } else {
                            wallR.position.set(doorX + doorW/2 + rightW/2, wallH/2, wallZ);
                        }
                        wallR.receiveShadow = true; houseGrp.add(wallR);
                    }
                    // Header above door
                    if (wallH > doorH + 0.05) {
                        const headerH = wallH - doorH;
                        const wallTop = new THREE.Mesh(new THREE.BoxGeometry(doorW, headerH, wallThick), wallMat);
                        if (isPerpendicular) {
                            wallTop.rotation.y = Math.PI / 2;
                            wallTop.position.set(-W/2 - wallThick, doorH + headerH/2, doorX);
                        } else {
                            wallTop.position.set(doorX, doorH + headerH/2, wallZ);
                        }
                        wallTop.receiveShadow = true; houseGrp.add(wallTop);
                    }

                    // Door rendering
                    const doorFrameMat = new THREE.MeshStandardMaterial({color: isCarportScene ? 0x555555 : 0x3C3C3C, roughness: 0.4, metalness: 0.3});
                    const doorFrameT = 0.06;  // 60mm frame depth

                    if (isCarportScene) {
                        // === GARAGE DOOR: sectional panels with horizontal lines ===
                        const panelCount = 5;
                        const panelH = doorH / panelCount;
                        const garageMat = new THREE.MeshStandardMaterial({color: 0xD8D4CE, roughness: 0.5, metalness: 0.15});
                        for (let p = 0; p < panelCount; p++) {
                            const panelY = p * panelH + panelH / 2;
                            const panel = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.06, panelH - 0.015, 0.04), garageMat);
                            if (isPerpendicular) {
                                panel.rotation.y = Math.PI / 2;
                                panel.position.set(-W/2 - wallThick/2, panelY, doorX);
                            } else {
                                panel.position.set(doorX, panelY, wallZ + wallThick/2);
                            }
                            houseGrp.add(panel);
                        }
                        // Garage frame
                        const frameParts = [
                            {w: doorFrameT, h: doorH, x: -doorW/2 + doorFrameT/2, y: doorH/2},  // left
                            {w: doorFrameT, h: doorH, x: doorW/2 - doorFrameT/2, y: doorH/2},    // right
                            {w: doorW, h: doorFrameT, x: 0, y: doorH - doorFrameT/2}              // top
                        ];
                        frameParts.forEach(function(fp) {
                            const fm = new THREE.Mesh(new THREE.BoxGeometry(fp.w, fp.h, 0.05), doorFrameMat);
                            if (isPerpendicular) {
                                fm.rotation.y = Math.PI / 2;
                                fm.position.set(-W/2 - wallThick/2, fp.y, doorX + fp.x);
                            } else {
                                fm.position.set(doorX + fp.x, fp.y, wallZ + wallThick/2);
                            }
                            houseGrp.add(fm);
                        });
                    } else {
                        // === SLIDING DOOR: 2-panel glass with aluminium frame ===
                        const glassMat = new THREE.MeshStandardMaterial({
                            color: 0x8FAABC, transparent: true, opacity: 0.35,
                            roughness: 0.05, metalness: 0.1, side: THREE.DoubleSide
                        });
                        const slideFrameMat = new THREE.MeshStandardMaterial({color: 0x3C3C3C, roughness: 0.3, metalness: 0.5});
                        const panelW = doorW / 2;
                        // Glass panels
                        for (let p = 0; p < 2; p++) {
                            const px = doorX + (p === 0 ? -panelW/2 : panelW/2);
                            const glass = new THREE.Mesh(new THREE.BoxGeometry(panelW - 0.06, doorH - 0.1, 0.01), glassMat);
                            if (isPerpendicular) {
                                glass.rotation.y = Math.PI / 2;
                                glass.position.set(-W/2 - wallThick/2, doorH/2, px);
                            } else {
                                glass.position.set(px, doorH/2, wallZ + wallThick/2);
                            }
                            houseGrp.add(glass);
                        }
                        // Frame: outer + centre mullion
                        const slideFrameParts = [
                            {w: 0.05, h: doorH, x: -doorW/2 + 0.025, y: doorH/2},   // left
                            {w: 0.05, h: doorH, x: doorW/2 - 0.025, y: doorH/2},     // right
                            {w: 0.04, h: doorH, x: 0, y: doorH/2},                    // centre mullion
                            {w: doorW, h: 0.05, x: 0, y: doorH - 0.025},              // top
                            {w: doorW, h: 0.08, x: 0, y: 0.04}                        // sill/track
                        ];
                        slideFrameParts.forEach(function(fp) {
                            const fm = new THREE.Mesh(new THREE.BoxGeometry(fp.w, fp.h, 0.05), slideFrameMat);
                            if (isPerpendicular) {
                                fm.rotation.y = Math.PI / 2;
                                fm.position.set(-W/2 - wallThick/2, fp.y, doorX + fp.x);
                            } else {
                                fm.position.set(doorX + fp.x, fp.y, wallZ + wallThick/2);
                            }
                            houseGrp.add(fm);
                        });
                    }

                    // Fascia board (timber) covers the full rafter end face
                    if (fasciaHm > 0) {
                        const fasciaBoardH = 0.15;   // 150mm tall
                        const fasciaBoardT = 0.025;  // 25mm thick
                        const fasciaBoard = new THREE.Mesh(
                            new THREE.BoxGeometry(wallLen, fasciaBoardH, fasciaBoardT),
                            fasciaTimberMat
                        );
                        // Fascia board top aligns with rafter bottom (fasciaHm)
                        // Gutter sits against fascia front face at the top half
                        const fbZ = -W/2 - wallThick/2 + fasciaBoardT/2;
                        const fbY = fasciaHm - fasciaBoardH/2; // center of board, top at rafter bottom
                        if (isPerpendicular) {
                            fasciaBoard.rotation.y = Math.PI / 2;
                            fasciaBoard.position.set(fbZ, fbY, 0);
                        } else {
                            fasciaBoard.position.set(0, fbY, fbZ);
                        }
                        fasciaBoard.castShadow = true;
                        houseGrp.add(fasciaBoard);
                        regComp(fasciaBoard, 'Fascia Board (House Wall)', {'Size': '150Ã—25mm Timber', 'Height': c.fasciaH + 'mm'});
                    }

                    // House roof â€” conditional on existingRoof type
                    const roofDepth = 2.0;       // 2.0m visible depth (enough for flyover posts)
                    const roofPitch = (c.houseRoofPitch || 22.5) * Math.PI / 180;
                    const roofRise = roofDepth * Math.tan(roofPitch);
                    const roofBaseY = fasciaHm;  // rafters sit on wall top plate
                    const roofCenterY = roofBaseY + roofRise / 2;
                    const roofZCenter = -W/2 - wallThick/2 - roofDepth/2;

                    if (existingRoofType === 'flat') {
                        // === FLAT ROOF: parapet cap on top of house wall, no pitched roof ===
                        const parapetH = 0.08;   // 80mm cap
                        const parapetW = wallThick + 0.1;
                        const parapet = new THREE.Mesh(
                            new THREE.BoxGeometry(wallLen, parapetH, parapetW),
                            houseRoofMat.clone()
                        );
                        if (isPerpendicular) {
                            parapet.rotation.y = Math.PI / 2;
                            parapet.position.set(-W/2 - wallThick/2, fasciaHm + parapetH/2, 0);
                        } else {
                            parapet.position.set(0, fasciaHm + parapetH/2, -W/2 - wallThick/2);
                        }
                        parapet.castShadow = true;
                        houseGrp.add(parapet);
                        regComp(parapet, 'Existing House Roof', {'Type': 'Flat', 'Note': 'Parapet cap'});
                    } else {
                        // === PITCHED ROOF (tiles or colorbond): timber rafters + sheets ===
                        const rafterW = 0.045, rafterH = 0.09, rafterSpacing = 0.6;
                        const rafterCount = Math.max(2, Math.ceil(wallLen / rafterSpacing) + 1);
                        for (let i = 0; i < rafterCount; i++) {
                            const pos = -wallLen/2 + (wallLen / (rafterCount - 1)) * i;
                            const hRafter = new THREE.Mesh(
                                new THREE.BoxGeometry(rafterW, rafterH, roofDepth),
                                fasciaTimberMat
                            );
                            if (isPerpendicular) {
                                hRafter.rotation.order = 'YXZ';
                                hRafter.rotation.y = Math.PI / 2;
                                hRafter.rotation.x = roofPitch;
                                hRafter.position.set(roofZCenter, roofCenterY, pos);
                            } else {
                                hRafter.rotation.x = roofPitch;
                                hRafter.position.set(pos, roofCenterY, roofZCenter);
                            }
                            hRafter.castShadow = true;
                            houseGrp.add(hRafter);
                        }
                        if (houseGrp.children.length > 0) {
                            const lastRafter = houseGrp.children[houseGrp.children.length - 1];
                            regComp(lastRafter, 'House Rafter', {'Size': '45Ã—90mm Timber', 'Spacing': '600mm', 'Qty': rafterCount});
                        }

                        // Roof sheets on top of rafters
                        const hSheetW = 0.762;
                        const hOverhang = 0.05;
                        const hSheetDepth = roofDepth + hOverhang;
                        const hSheetZCenter = roofZCenter + hOverhang/2;
                        const hSheetCount = Math.max(1, Math.ceil(wallLen / hSheetW));
                        const hSheetCenterY = roofCenterY + rafterH/2 + 0.001;
                        for (let i = 0; i < hSheetCount; i++) {
                            const sw = (i === hSheetCount - 1) ? (wallLen - hSheetW * i) : hSheetW;
                            const pos = -wallLen/2 + hSheetW * i + sw/2;
                            let hSheetGeo, hSheetMaterial;
                            if (existingRoofType === 'tiles') {
                                // Tiles: flat panel with tile texture
                                hSheetGeo = new THREE.PlaneGeometry(sw, hSheetDepth);
                                hSheetMaterial = houseRoofMat.clone();
                            } else {
                                // Colorbond: corrugated profile
                                hSheetGeo = createCorrugatedGeometry(sw, hSheetDepth);
                                hSheetMaterial = houseRoofMat.clone();
                            }
                            const hSheet = new THREE.Mesh(hSheetGeo, hSheetMaterial);
                            if (isPerpendicular) {
                                hSheet.rotation.order = 'YXZ';
                                hSheet.rotation.y = Math.PI / 2;
                                hSheet.rotation.x = -Math.PI / 2 + roofPitch;
                                hSheet.position.set(hSheetZCenter, hSheetCenterY, pos);
                            } else {
                                hSheet.rotation.x = -Math.PI / 2 + roofPitch;
                                hSheet.position.set(pos, hSheetCenterY, hSheetZCenter);
                            }
                            hSheet.castShadow = true;
                            hSheet.receiveShadow = true;
                            houseGrp.add(hSheet);
                        }
                        const roofLabel = c.connection === 'flyover' ? 'Existing House Roof (Flyover)' : 'Existing House Roof';
                        const roofMatLabel = existingRoofType === 'tiles' ? 'Tiles' : 'Colorbond';
                        if (houseGrp.children.length > 0) {
                            const lastSheet = houseGrp.children[houseGrp.children.length - 1];
                            regComp(lastSheet, roofLabel, {'Pitch': Math.round(c.houseRoofPitch || 22.5) + 'Â°', 'Material': roofMatLabel, 'Sheets': hSheetCount});
                        }
                    }

                    // House quad gutter â€“ sits against front face of fascia, at the top half
                    // Hidden when box gutter is selected (box gutter replaces it)
                    const showHouseGutter = !(c.connection === 'riser' && c.houseGutter === 'box');
                    if (showHouseGutter) {
                    const hGutterW = 0.115;    // 115mm wide
                    const hGutterFront = 0.076; // 76mm front face
                    const hGutterBack = 0.045;  // 45mm back face
                    const hGutterT = 0.001;     // 1mm sheet steel
                    const hgs = new THREE.Shape();
                    hgs.moveTo(0, 0);
                    hgs.lineTo(hGutterW, 0);
                    hgs.lineTo(hGutterW, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterBack);
                    hgs.lineTo(0, hGutterBack);
                    hgs.closePath();
                    // House gutter spans full wall length (extends past patio both sides)
                    const hGutterLen = wallLen;
                    const hGutterGeo = new THREE.ExtrudeGeometry(hgs, { depth: hGutterLen, bevelEnabled: false });
                    const hGutter = new THREE.Mesh(hGutterGeo, roofColorbondMat.clone());
                    // Back lip top at fasciaHm â€“ gutter against top half of fascia face
                    const hGutterY = fasciaHm - hGutterBack;
                    const hGutterZ = -W/2 - wallThick/2 + 0.025; // at fascia board front face
                    if (isPerpendicular) {
                        hGutter.position.set(hGutterZ, hGutterY, -hGutterLen/2);
                    } else {
                        hGutter.rotation.y = -Math.PI / 2;
                        hGutter.position.set(hGutterLen/2, hGutterY, hGutterZ);
                    }
                    houseGrp.add(hGutter);
                    regComp(hGutter, 'House Quad Gutter', {'Size': '115mm Quad', 'Front': '76mm', 'Back': '45mm'});
                    } // end showHouseGutter
                }

                // === L-SHAPED HOUSE WING ===
                if (c.lShape !== 'none' && c.isAttached) {
                    const wingSide = c.lShape;  // 'left' or 'right'
                    const wingDepth = 2.5;      // wing extends 2.5m from main wall
                    const wingLen = W + wallThick + wingDepth; // wing runs from patio front edge back past main wall
                    const wingWallH = fasciaHm;
                    const wingSign = wingSide === 'left' ? -1 : 1;

                    // Wing wall (perpendicular to main house wall, runs along patio side)
                    const wingWall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallThick, wingWallH, wingLen),
                        wallMat.clone()
                    );
                    const wingX = wingSign * (L/2 + wallThick/2);
                    // Position so front face of wing aligns at z = W/2
                    wingWall.position.set(wingX, wingWallH/2, W/2 - wingLen/2);
                    wingWall.receiveShadow = true;
                    houseGrp.add(wingWall);

                    // Wing fascia board (on the patio-facing side of the wing)
                    const wfH = 0.15, wfT = 0.025;
                    const wingFascia = new THREE.Mesh(
                        new THREE.BoxGeometry(wfT, wfH, wingLen),
                        fasciaTimberMat.clone()
                    );
                    const wfX = wingSign * (L/2 + wallThick/2 - wfT/2) + (wingSign < 0 ? wallThick/2 : -wallThick/2);
                    wingFascia.position.set(wingX - wingSign * (wallThick/2 - wfT/2), fasciaHm - wfH/2, W/2 - wingLen/2);
                    wingFascia.castShadow = true;
                    houseGrp.add(wingFascia);

                    // Wing roof (slopes away from patio) â€” matches existingRoof type
                    const wingRoofDepth = wingDepth + 0.5;
                    const wingRoofPitch = (c.houseRoofPitch || 22.5) * Math.PI / 180;
                    const wingRoofRise = wingRoofDepth * Math.tan(wingRoofPitch);
                    const wingRoofBaseY = fasciaHm;
                    const wingSheetStartZ = W/2 - wingLen;

                    if (existingRoofType === 'flat') {
                        // Flat roof: parapet cap on wing wall
                        const wParapetH = 0.08;
                        const wParapetW = wallThick + 0.1;
                        const wParapet = new THREE.Mesh(
                            new THREE.BoxGeometry(wParapetW, wParapetH, wingLen),
                            houseRoofMat.clone()
                        );
                        wParapet.position.set(wingX, fasciaHm + wParapetH/2, W/2 - wingLen/2);
                        wParapet.castShadow = true;
                        houseGrp.add(wParapet);
                    } else {
                        // Pitched roof sheets (tiles or colorbond)
                        for (let i = 0; i < Math.ceil(wingLen / 0.762); i++) {
                            const sw = Math.min(0.762, wingLen - i * 0.762);
                            const wingSheet = new THREE.Mesh(
                                new THREE.BoxGeometry(wingRoofDepth + 0.3, 0.02, sw),
                                houseRoofMat.clone()
                            );
                            const sheetZPos = wingSheetStartZ + i * 0.762 + sw/2;
                            wingSheet.rotation.z = wingSign * wingRoofPitch;
                            wingSheet.position.set(
                                wingX + wingSign * (wingRoofDepth/2 + 0.15),
                                wingRoofBaseY + wingRoofRise/2 + 0.09,
                                sheetZPos
                            );
                            wingSheet.castShadow = true;
                            wingSheet.receiveShadow = true;
                            houseGrp.add(wingSheet);
                        }
                    }

                    // Wing quad gutter (on patio-facing side)
                    const wGutterLen = wingLen;
                    const wGutterGeo = new THREE.ExtrudeGeometry(
                        (function() {
                            var s = new THREE.Shape();
                            s.moveTo(0, 0); s.lineTo(0.115, 0); s.lineTo(0.115, 0.076);
                            s.lineTo(0.114, 0.076); s.lineTo(0.114, 0.001);
                            s.lineTo(0.001, 0.001); s.lineTo(0.001, 0.045); s.lineTo(0, 0.045);
                            s.closePath(); return s;
                        })(),
                        { depth: wGutterLen, bevelEnabled: false }
                    );
                    const wGutter = new THREE.Mesh(wGutterGeo, roofColorbondMat.clone());
                    const wGutterY = fasciaHm - 0.045;
                    // Gutter runs along wing wall, patio side
                    wGutter.rotation.y = wingSign > 0 ? 0 : Math.PI;
                    const wGutterX = wingX - wingSign * (wallThick/2 + 0.01);
                    wGutter.position.set(
                        wingSign > 0 ? wGutterX - 0.115 : wGutterX + 0.115,
                        wGutterY,
                        W/2 - wingLen/2 - wGutterLen/2
                    );
                    houseGrp.add(wGutter);

                    // Polycarbonate/twin-wall infill panel (always renders for L-shape)
                    {
                        const infillPanelH = Math.abs(fasciaHm - (backBeamY > 0 ? backBeamY : 2.0)) + 0.2;
                        const infillPanel = new THREE.Mesh(
                            new THREE.BoxGeometry(0.025, infillPanelH, W),
                            new THREE.MeshStandardMaterial({
                                color: 0xDDEEEE, transparent: true, opacity: 0.5,
                                roughness: 0.1, metalness: 0.0, side: THREE.DoubleSide
                            })
                        );
                        infillPanel.position.set(
                            wingSign * L/2,
                            fasciaHm - infillPanelH/2,
                            0
                        );
                        houseGrp.add(infillPanel);
                        regComp(infillPanel, 'Polycarbonate Infill (L-Shape)', {
                            'Material': 'Twin-wall Polycarbonate',
                            'Height': (infillPanelH * 1000).toFixed(0) + 'mm',
                            'Width': (W * 1000).toFixed(0) + 'mm'
                        });
                    }

                }

                // ===== WRAPAROUND PATIO (return section at house end â€” independent of L-shape) =====
                // The return patio wraps around the END of the house (external corner).
                // It shares the same Z range as the main patio (house wall â†’ gutter).
                // Return projection runs along X (away from house end), same distance W.
                // retLen = how far along the house side wall (in Z) the return extends from the house wall.
                // Hip rafter runs at 45Â° in plan from house corner diagonally outward.
                if (isWrap && c.isAttached) {
                    const retLen = c.returnLength / 1000;  // return Z extent in metres
                    const retPosts = c.returnPosts;

                    // Geometry reference points:
                    //   House corner:    (wrapSign*L/2, -, -W/2)
                    //   Main gutter at wrap side: (wrapSign*L/2, -, +W/2)
                    //   Return gutter edge:  (wrapSign*(L/2 + W), -, Z)
                    // Return runs from Z = -W/2 (house wall) TOWARD Z = +W/2 (gutter line)
                    const retStartZ = -W/2;               // house wall Z
                    const retEndZ = -W/2 + retLen;        // toward gutter line
                    const retMidZ = (retStartZ + retEndZ) / 2;
                    const retGutterX = wrapSign * (L/2 + W);  // return outer gutter edge (same projection as main)

                    // â”€â”€ Hip clipping planes â”€â”€
                    // Hip line in plan: from house corner (wrapSign*L/2, -W/2) at 45Â° toward
                    // (wrapSign*(L/2+d), -W/2+d).  Normal pointing INTO main patio = (-wrapSign, 0, 1).
                    const hipCornerPt = new THREE.Vector3(wrapSign * L/2, 0, -W/2);
                    const mainClipNorm = new THREE.Vector3(-wrapSign, 0, 1).normalize();
                    const retClipNorm = new THREE.Vector3(wrapSign, 0, -1).normalize();
                    const mainHipClip = new THREE.Plane().setFromNormalAndCoplanarPoint(mainClipNorm, hipCornerPt);
                    const retHipClip = new THREE.Plane().setFromNormalAndCoplanarPoint(retClipNorm, hipCornerPt);

                    // â”€â”€ House side wall on wrap side â”€â”€ perpendicular to front wall at house corner
                    // Extends from behind the house wall (-W/2 - depth) to the return end (retEndZ)
                    const sideWallBackDepth = 2.0;  // 2m visible behind house front wall
                    const sideWallH = fasciaHm;
                    const sideWallTotalLen = sideWallBackDepth + wallThick + retLen; // behind house + wall thickness + return length
                    const sideWallCenterZ = -W/2 - sideWallBackDepth + sideWallTotalLen/2 - wallThick;
                    const sideWallX = wrapSign * (L/2 + wallThick/2);
                    const sideWall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallThick, sideWallH, sideWallTotalLen),
                        wallMat.clone()
                    );
                    sideWall.position.set(sideWallX, sideWallH / 2, sideWallCenterZ);
                    sideWall.receiveShadow = true;
                    houseGrp.add(sideWall);

                    // â”€â”€ Side wall fascia board (patio-facing side) â”€â”€
                    var sideFasciaH = 0.15, sideFasciaT = 0.025;
                    var sideFasciaMat = typeof fasciaTimberMat !== 'undefined' ? fasciaTimberMat.clone() :
                        new THREE.MeshStandardMaterial({color: 0x8B7355, roughness: 0.75});
                    var sideFascia = new THREE.Mesh(
                        new THREE.BoxGeometry(sideFasciaT, sideFasciaH, retLen + wallThick),
                        sideFasciaMat
                    );
                    sideFascia.position.set(
                        sideWallX - wrapSign * (wallThick/2 - sideFasciaT/2),
                        fasciaHm - sideFasciaH/2,
                        -W/2 + retLen/2
                    );
                    houseGrp.add(sideFascia);

                    // â”€â”€ Side house roof slope (extends away from patio) â”€â”€
                    var sideRoofDepth = sideWallBackDepth + 0.5;
                    var sideRoofPitch = (c.houseRoofPitch || 22.5) * Math.PI / 180;
                    var sideRoofRise = sideRoofDepth * Math.tan(sideRoofPitch);
                    var sideRoofSlope = sideRoofDepth / Math.cos(sideRoofPitch);
                    var sideRoofLen = retLen + wallThick;
                    var sideRoofMat = typeof houseRoofMat !== 'undefined' ? houseRoofMat.clone() :
                        new THREE.MeshStandardMaterial({color: 0x8B4513, roughness: 0.7});
                    var sideRoof = new THREE.Mesh(
                        new THREE.BoxGeometry(sideRoofSlope, 0.025, sideRoofLen),
                        sideRoofMat
                    );
                    sideRoof.position.set(
                        sideWallX + wrapSign * sideRoofDepth/2,
                        fasciaHm + sideRoofRise/2,
                        -W/2 + retLen/2
                    );
                    sideRoof.rotation.z = wrapSign * sideRoofPitch;
                    houseGrp.add(sideRoof);

                    // â”€â”€ Corner post â”€â”€ at wrap-side gutter corner (main gutter meets house end)
                    const cornerPostH = frontBeamY;
                    const cornerPost = new THREE.Mesh(new THREE.BoxGeometry(postW, cornerPostH, postW), sMat());
                    cornerPost.position.set(wrapSign * L/2, cornerPostH/2, W/2);
                    cornerPost.castShadow = true;
                    steelGrp.add(cornerPost);
                    regComp(cornerPost, 'Corner Post (Wraparound)', {'Size': c.framePost.name, 'Height': Math.round(cornerPostH*1000) + 'mm'});

                    // â”€â”€ Return gutter posts â”€â”€ along return outer gutter edge, distributed in Z
                    for (let i = 0; i < retPosts; i++) {
                        const z = retStartZ + (retPosts > 1 ? (retLen / (retPosts - 1)) * i : retLen / 2);
                        const rpostH = frontBeamY;
                        const rpost = new THREE.Mesh(new THREE.BoxGeometry(postW, rpostH, postW), sMat());
                        rpost.position.set(retGutterX, rpostH/2, z);
                        rpost.castShadow = true;
                        steelGrp.add(rpost);
                        regComp(rpost, 'Return Post ' + (i+1), {'Size': c.framePost.name, 'Height': Math.round(rpostH*1000) + 'mm'});
                    }

                    // â”€â”€ Return gutter beam â”€â”€ along Z at return outer edge
                    const retGutterBeam = new THREE.Mesh(new THREE.BoxGeometry(beamW, beamH, retLen), sMat());
                    retGutterBeam.position.set(retGutterX, frontBeamY + beamH/2, retMidZ);
                    retGutterBeam.castShadow = true;
                    steelGrp.add(retGutterBeam);
                    regComp(retGutterBeam, 'Return Gutter Beam', {'Size': c.frameBeam.name, 'Length': Math.round(retLen*1000) + 'mm'});

                    // â”€â”€ Return back beam / connection â”€â”€ along Z on house side wall outer face
                    if (c.connection === 'riser') {
                        const retRiserBeam = new THREE.Mesh(new THREE.BoxGeometry(beamW, beamH, retLen), sMat());
                        retRiserBeam.position.set(wrapSign * (L/2 + wallThick + beamW/2), backBeamY + beamH/2, retMidZ);
                        retRiserBeam.castShadow = true;
                        steelGrp.add(retRiserBeam);
                        regComp(retRiserBeam, 'Return Back Beam', {'Size': c.frameBeam.name, 'Length': Math.round(retLen*1000) + 'mm'});
                    } else {
                        const retChan = new THREE.Mesh(new THREE.BoxGeometry(0.075, 0.03, retLen), sMat());
                        retChan.position.set(wrapSign * (L/2 + wallThick + 0.04), backBeamY + 0.015, retMidZ);
                        steelGrp.add(retChan);
                        regComp(retChan, 'Return Receiving Channel', {'Length': Math.round(retLen*1000) + 'mm'});
                    }

                    // â”€â”€ Return rafters â”€â”€ run along X from house side wall outward, distributed along Z
                    const riserOff = c.connection === 'riser' ? c.riserOffset / 1000 : 0;
                    const retBackEdgeX = wrapSign * (L/2 + wallThick + riserOff);
                    if (!isInsulated(c.roofing)) {
                        const retRaftCount = Math.max(2, Math.ceil(retLen / (c.rafterSpacing / 1000)) + 1);
                        const raftW = c.rafterSize ? c.rafterSize.w : tw;
                        const raftH = c.rafterSize ? c.rafterSize.h : th;
                        const retHipDist = Math.min(retLen, W);
                        for (let i = 0; i < retRaftCount; i++) {
                            const z = retStartZ + (retRaftCount > 1 ? (retLen / (retRaftCount - 1)) * i : 0);
                            // Jack rafter: trim at hip line (progressively shorter toward gutter)
                            const distFromCorner = z + W/2;  // distance from house corner along Z
                            let thisLen = rafter;
                            let startX = retBackEdgeX;
                            let startY = backTop + raftH/2;
                            if (distFromCorner > 0 && distFromCorner <= retHipDist) {
                                const hipPlanFromBack = distFromCorner - wallThick - riserOff;
                                const jackPlanLen = W/2 - z;
                                if (jackPlanLen < 0.05) continue;  // too short, skip
                                if (hipPlanFromBack > 0) {
                                    thisLen = jackPlanLen / Math.cos(c.pitchRad);
                                    startX = wrapSign * (L/2 + distFromCorner);
                                    startY = backTop - hipPlanFromBack * Math.tan(c.pitchRad) + raftH/2;
                                }
                            }
                            const rafterGeo = new THREE.BoxGeometry(raftW, raftH, thisLen);
                            rafterGeo.translate(0, 0, thisLen/2);
                            const raft = new THREE.Mesh(rafterGeo, sMat());
                            raft.position.set(startX, startY, z);
                            raft.rotation.order = 'YXZ';
                            raft.rotation.y = wrapSign * Math.PI/2;
                            raft.rotation.x = c.pitchRad;
                            steelGrp.add(raft);
                            regComp(raft, 'Return Rafter ' + (i+1), {'Size': c.rafterSize ? c.rafterSize.name : 'RHS', 'Length': Math.round(thisLen*1000) + 'mm'});
                        }
                    }

                    // â”€â”€ Return roof sheets â”€â”€ run along X, distributed along Z, clipped at hip
                    const retSheetCount = Math.ceil(retLen / sheetW);
                    const retSheetYOff = c.isRecvChan ? 0.005 : (th + th/2 + 0.01);
                    for (let s = 0; s < retSheetCount; s++) {
                        const isPartial = s === retSheetCount - 1 && (retLen % sheetW > 0.01);
                        const thisW = isPartial ? (retLen - s * sheetW) : sheetW;
                        const zPos = retStartZ + s * sheetW + thisW / 2;
                        let retSheetGeo;
                        if (c.roofing === 'corrugated') {
                            retSheetGeo = createCorrugatedGeometry(thisW, rafter);
                        } else if (c.roofing === 'trimdek' || c.roofing === 'spandek') {
                            retSheetGeo = createTrimdekGeometry(thisW, rafter);
                        } else {
                            retSheetGeo = createInsulatedGeometry(thisW, rafter, c.roofing === 'solarspan100' ? 0.1 : 0.075, true);
                        }
                        retSheetGeo.translate(0, rafter/2, 0);
                        let retSheetMat;
                        if (isInsulated(c.roofing)) {
                            retSheetMat = insulatedMaterials(true);
                        } else {
                            retSheetMat = rMat();
                        }
                        // Apply clipping: trim at hip line + DoubleSide to hide interior at clipped edge
                        if (Array.isArray(retSheetMat)) {
                            retSheetMat.forEach(function(m) { m.clippingPlanes = [retHipClip]; m.side = THREE.DoubleSide; });
                        } else {
                            retSheetMat.clippingPlanes = [retHipClip];
                            retSheetMat.side = THREE.DoubleSide;
                        }
                        const retSheet = new THREE.Mesh(retSheetGeo, retSheetMat);
                        retSheet.position.set(retBackEdgeX, backTop + retSheetYOff, zPos);
                        retSheet.rotation.order = 'YXZ';
                        retSheet.rotation.y = wrapSign * Math.PI/2;
                        retSheet.rotation.x = Math.PI/2 + c.pitchRad;
                        retSheet.castShadow = true;
                        retSheet.userData.isReturnSheet = true;
                        roofGrp.add(retSheet);
                        regComp(retSheet, 'Return Sheet ' + (s+1), {'Profile': c.roofing, 'Width': Math.round(thisW*1000) + 'mm'});
                    }

                    // â”€â”€ Corner extension sheets â”€â”€ fill from L/2 to hip line
                    // These represent the portions of main sheets that extend past the house corner.
                    // mainHipClip clips each sheet at the 45Â° hip diagonal.
                    // Recompute skillion-scoped values needed for positioning
                    const cRiserOff = c.connection === 'riser' ? c.riserOffset / 1000 : 0;
                    const cBackEdgeZ = c.connection === 'flyover' ? (-W/2 - flyoverExt) : (-W/2 + cRiserOff);
                    const cExtRafter = c.connection === 'flyover' ? (rafter + flyoverExt / Math.cos(c.pitchRad)) : rafter;
                    const cSheetInset = c.isRecvChan ? 0.03 : 0;
                    const cornerHipDist = Math.min(retLen, W);
                    const cornerSheetCount = Math.ceil(cornerHipDist / sheetW);
                    for (let s = 0; s < cornerSheetCount; s++) {
                        const isLast = s === cornerSheetCount - 1 && (cornerHipDist % sheetW > 0.01);
                        const cW = isLast ? (cornerHipDist - s * sheetW) : sheetW;
                        const cX = wrapSign * (L/2 + s * sheetW + cW/2);
                        let cornerGeo;
                        if (c.roofing === 'corrugated') {
                            cornerGeo = createCorrugatedGeometry(cW, cExtRafter);
                        } else if (c.roofing === 'trimdek' || c.roofing === 'spandek') {
                            cornerGeo = createTrimdekGeometry(cW, cExtRafter);
                        } else {
                            cornerGeo = createInsulatedGeometry(cW, cExtRafter, c.roofing === 'solarspan100' ? 0.1 : 0.075, true);
                        }
                        cornerGeo.translate(0, cExtRafter/2, 0);
                        let cornerMat;
                        if (isInsulated(c.roofing)) {
                            cornerMat = insulatedMaterials(true);
                        } else {
                            cornerMat = rMat();
                        }
                        // Apply mainHipClip to create the diagonal cut at the hip line + DoubleSide
                        if (Array.isArray(cornerMat)) {
                            cornerMat.forEach(function(m) { m.clippingPlanes = [mainHipClip]; m.side = THREE.DoubleSide; });
                        } else {
                            cornerMat.clippingPlanes = [mainHipClip];
                            cornerMat.side = THREE.DoubleSide;
                        }
                        const cornerSheet = new THREE.Mesh(cornerGeo, cornerMat);
                        const cornerYOff = c.isRecvChan ? 0.005 : (th + th/2 + 0.01);
                        cornerSheet.position.set(cX, backTop + cornerYOff, cBackEdgeZ - cSheetInset);
                        cornerSheet.rotation.x = Math.PI/2 + c.pitchRad;
                        cornerSheet.castShadow = true;
                        cornerSheet.userData.isReturnSheet = true;  // prevent double-clipping by main hip clip loop
                        roofGrp.add(cornerSheet);
                        regComp(cornerSheet, 'Corner Sheet ' + (s+1), {'Profile': c.roofing, 'Width': Math.round(cW*1000) + 'mm', 'Note': 'Hip cut'});
                    }

                    // â”€â”€ Clip main patio sheets near house end at hip line â”€â”€
                    // Apply hip clipping to main patio sheets that are within hipDist of the house end
                    const hipDist = Math.min(retLen, W);
                    roofGrp.children.forEach(function(child) {
                        if (!child.isMesh) return;
                        // Check if this is a main patio sheet near the house end
                        var xDist = Math.abs(child.position.x - wrapSign * L/2);
                        if (xDist < hipDist && child.position.z < 0 && !child.userData.isReturnSheet) {
                            // This sheet is near the hip â€” add clipping + DoubleSide to hide interior
                            if (Array.isArray(child.material)) {
                                child.material.forEach(function(m) {
                                    if (!m.clippingPlanes) m.clippingPlanes = [];
                                    m.clippingPlanes.push(mainHipClip);
                                    m.side = THREE.DoubleSide;
                                });
                            } else if (child.material) {
                                if (!child.material.clippingPlanes) child.material.clippingPlanes = [];
                                child.material.clippingPlanes.push(mainHipClip);
                                child.material.side = THREE.DoubleSide;
                            }
                        }
                    });

                    // â”€â”€ Hip rafter â”€â”€ diagonal from house corner to gutter intersection
                    // In plan: 45Â° from (wrapSign*L/2, -W/2) to (wrapSign*(L/2+hipDist), -W/2+hipDist)
                    const hipHeightDrop = (backTop - frontTop) * (hipDist / W);  // proportional height drop
                    const hipPlanLen = hipDist * Math.SQRT2;  // diagonal distance in plan
                    const hipLen = Math.sqrt(hipPlanLen * hipPlanLen + hipHeightDrop * hipHeightDrop);
                    const hipStartX = wrapSign * L/2;
                    const hipStartZ = -W/2;
                    const hipStartY = backTop + th/2;
                    const hipEndX = wrapSign * (L/2 + hipDist);
                    const hipEndZ = -W/2 + hipDist;
                    const hipEndY = hipStartY - hipHeightDrop;
                    const hipRafter = new THREE.Mesh(new THREE.BoxGeometry(tw * 2, th * 1.2, hipLen), sMat());
                    hipRafter.position.set(
                        (hipStartX + hipEndX) / 2,
                        (hipStartY + hipEndY) / 2,
                        (hipStartZ + hipEndZ) / 2
                    );
                    // Rotate: first yaw 45Â° in plan, then pitch down
                    const hipYaw = Math.atan2(hipEndX - hipStartX, hipEndZ - hipStartZ);
                    const hipPitch = Math.atan2(hipHeightDrop, hipPlanLen);
                    hipRafter.rotation.order = 'YXZ';
                    hipRafter.rotation.y = hipYaw;
                    hipRafter.rotation.x = hipPitch;
                    steelGrp.add(hipRafter);
                    regComp(hipRafter, 'Hip Rafter (Wraparound)', {'Length': Math.round(hipLen*1000) + 'mm'});

                    // â”€â”€ Hip cap flashing â”€â”€ ridge cap along the diagonal hip line
                    // V-shaped cap sitting on top of the hip rafter covering the sheet junction
                    const hipCapW = 0.20;  // 200mm wide cap flashing
                    const hipCapH = 0.04;  // 40mm ridge height
                    const hipCapShape = new THREE.Shape();
                    hipCapShape.moveTo(-hipCapW/2, 0);
                    hipCapShape.lineTo(0, hipCapH);
                    hipCapShape.lineTo(hipCapW/2, 0);
                    hipCapShape.lineTo(hipCapW/2 - 0.003, 0);
                    hipCapShape.lineTo(0, hipCapH - 0.005);
                    hipCapShape.lineTo(-hipCapW/2 + 0.003, 0);
                    hipCapShape.closePath();
                    const hipCapGeo = new THREE.ExtrudeGeometry(hipCapShape, { depth: hipLen, bevelEnabled: false });
                    hipCapGeo.translate(0, 0, -hipLen/2);
                    const hipCapMat = fMat();
                    hipCapMat.side = THREE.DoubleSide;
                    const hipCap = new THREE.Mesh(hipCapGeo, hipCapMat);
                    // Position on top of the hip rafter (above sheet surface)
                    const hipCapYOff = th * 0.6 + (c.isRecvChan ? 0.005 : (th + 0.01));
                    hipCap.position.set(
                        (hipStartX + hipEndX) / 2,
                        (hipStartY + hipEndY) / 2 + hipCapYOff,
                        (hipStartZ + hipEndZ) / 2
                    );
                    hipCap.rotation.order = 'YXZ';
                    hipCap.rotation.y = hipYaw;
                    hipCap.rotation.x = hipPitch;
                    accGrp.add(hipCap);
                    regComp(hipCap, 'Hip Cap Flashing', {'Width': '200mm', 'Length': Math.round(hipLen*1000) + 'mm'});

                    // â”€â”€ Return gutter â”€â”€ along return outer edge
                    const retGutter = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, retLen), fMat());
                    retGutter.position.set(retGutterX + wrapSign * 0.07, gutterY, retMidZ);
                    accGrp.add(retGutter);
                    regComp(retGutter, 'Return Gutter', {'Type': '150mm Quad', 'Length': Math.round(retLen*1000) + 'mm'});

                    // â”€â”€ Return barge flashing â”€â”€ on the far Z end of the return
                    // Center X on the actual return span (from retBackEdgeX to retGutterX)
                    const retBargeCenterX = (retBackEdgeX + retGutterX) / 2;
                    const retBarge = new THREE.Mesh(new THREE.BoxGeometry(rafter, 0.12, 0.008), fMat());
                    retBarge.position.set(retBargeCenterX, (backTop + frontTop)/2 + th, retEndZ);
                    retBarge.rotation.order = 'YXZ';
                    retBarge.rotation.y = wrapSign * Math.PI/2;
                    retBarge.rotation.z = -(Math.PI/2 - c.pitchRad);
                    accGrp.add(retBarge);
                    regComp(retBarge, 'Return Barge Flashing', {'Length': Math.round(rafter*1000) + 'mm'});

                    // â”€â”€ Return downpipe â”€â”€
                    const retDpH = gutterY + 0.04;
                    const retDp = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, retDpH, 12), fMat());
                    retDp.position.set(retGutterX + wrapSign * 0.1, retDpH/2, retEndZ);
                    accGrp.add(retDp);
                    regComp(retDp, 'Return Downpipe', {'Size': '90mm Round'});
                }

                // C-Channel - for receiving channel modes (fascia and wall only)
                if (c.isRecvChan) {
                    const chanW = 0.075;  // 75mm wide â€“ captures sheet edges
                    const chanH = 0.03;   // 30mm tall
                    const chanT = 0.003;  // 3mm steel thickness
                    // C-channel profile (U-shape opening toward patio)
                    const chanShape = new THREE.Shape();
                    chanShape.moveTo(0, 0);
                    chanShape.lineTo(chanW, 0);
                    chanShape.lineTo(chanW, chanT);
                    chanShape.lineTo(chanT, chanT);
                    chanShape.lineTo(chanT, chanH - chanT);
                    chanShape.lineTo(chanW, chanH - chanT);
                    chanShape.lineTo(chanW, chanH);
                    chanShape.lineTo(0, chanH);
                    chanShape.closePath();

                    const chanGeo = new THREE.ExtrudeGeometry(chanShape, { depth: L, bevelEnabled: false });
                    const channel = new THREE.Mesh(chanGeo, sMat());

                    if (c.connection === 'fascia') {
                        // On fascia board face, directly below house gutter â€” receiving channel captures sheet edges
                        // Gutter back lip is 45mm; channel top sits at gutter bottom
                        const chanY = fasciaHm - 0.045 - chanH;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    } else {
                        // Wall mode: on wall surface at connection height
                        const chanY = fasciaHm - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    }
                    steelGrp.add(channel);
                    regComp(channel, 'Receiving Channel', {'Size': '75Ã—30mm C-Channel', 'Length': c.L + 'mm', 'Type': c.connection === 'fascia' ? 'Fascia mount' : 'Wall mount'});
                }
            }

            updateMatList();

            // Update camera orbit target to center of combined patio + house
            const bbox = new THREE.Box3();
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => {
                if (g.children.length > 0) bbox.expandByObject(g);
            });
            if (!bbox.isEmpty() && asmControls) {
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                asmControls.target.copy(center);
                asmControls.update();
            }

            // Refresh dimension labels/lines if visible
            if (dimensionsVisible) updateAsmDimensions();
        }

        function createTrussUnit(W, rise, rafter, tw, th, mat, c) {
            const g = new THREE.Group();
            const halfW = W / 2;
            const heelY = th;
            const apexY = th + rise;

            const extOn = c.trussExtender.enabled;
            const extLen = c.trussExtender.length / 1000;
            const riserOn = c.trussRiserLeft.enabled;
            const rLH = c.trussRiserLeft.length / 1000;
            const rLV = c.trussRiserLeft.height / 1000;
            const rRH = c.trussRiserRight.length / 1000;
            const rRV = c.trussRiserRight.height / 1000;
            const chordType = c.trussChord;
            const style = c.trussStyle;

            // Helper: box member between two ZY points (Z = span, Y = height)
            function mbr(z1, y1, z2, y2) {
                const dz = z2 - z1, dy = y2 - y1;
                const len = Math.sqrt(dz * dz + dy * dy);
                if (len < 0.001) return;
                const geo = new THREE.BoxGeometry(tw, th, len);
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.position.set(0, (y1 + y2) / 2, (z1 + z2) / 2);
                mesh.rotation.x = -Math.atan2(dy, dz);
                g.add(mesh);
            }

            // --- Bottom Chord (standard horizontal, full span) ---
            if (chordType === 'bottom') {
                mbr(-halfW, th / 2, halfW, th / 2);
                if (extOn) {
                    mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                    mbr(halfW, th / 2, halfW + extLen, th / 2);
                }
            } else if (chordType === 'mid') {
                const midY = th + rise / 3;
                const lT = (midY - heelY) / (apexY - heelY);
                const midHalfZ = lT > 0 ? halfW * (1 - lT) : halfW;
                mbr(-midHalfZ, midY, midHalfZ, midY);
                if (extOn) {
                    mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                    mbr(halfW, th / 2, halfW + extLen, th / 2);
                }
            } else if (extOn) {
                mbr(-halfW - extLen, th / 2, -halfW, th / 2);
                mbr(halfW, th / 2, halfW + extLen, th / 2);
            }

            // --- Rafters (symmetrical) ---
            mbr(-halfW, heelY, 0, apexY);
            mbr(halfW, heelY, 0, apexY);

            // --- Web Members ---
            function asmRafterY(x) { return th + rise * (1 - x / halfW); }
            const asmChordYm = chordType === 'mid' ? (th + rise / 3) : th;
            const asmKBottom = chordType === 'mid' ? (asmChordYm + th / 2) : th;
            const asmKTop = apexY - th;
            const asmQpX = halfW / 2;

            // Legacy style mapping for assembly view
            var asmEff = style;
            if (asmEff === 'kingfan' || asmEff === 'queenpost') asmEff = 'kingverticals';
            if (asmEff === 'kingstrut' || asmEff === 'fink' || asmEff === 'open') asmEff = 'web';

            if (asmEff === 'kingpost') {
                if (asmKTop > asmKBottom) mbr(0, asmKBottom, 0, asmKTop);

            } else if (asmEff === 'kingverticals') {
                if (asmKTop > asmKBottom) mbr(0, asmKBottom, 0, asmKTop);
                var akvChordTop = asmChordYm + th / 2;
                var akvRafterBot = asmRafterY(asmQpX) - th / 2;
                if (akvRafterBot > akvChordTop + th * 0.5) {
                    mbr(-asmQpX, akvChordTop, -asmQpX, akvRafterBot);
                    mbr(asmQpX, akvChordTop, asmQpX, akvRafterBot);
                }

            } else if (asmEff === 'web') {
                // King post (vertical centre)
                if (asmKTop > asmKBottom) mbr(0, asmKBottom, 0, asmKTop);
                // Diagonal webs â€” connect from king post base to rafter at ~30% from apex (steeper angle)
                var webX = halfW * 0.3;
                var awChordTop = asmChordYm + th / 2;
                var awRafterBot = asmRafterY(webX) - th / 2;
                if (awRafterBot > awChordTop + th * 0.5) {
                    mbr(0, awChordTop, -webX, awRafterBot);
                    mbr(0, awChordTop, webX, awRafterBot);
                }
                // Outer struts â€” from web-rafter junction down to bottom chord at 60% span
                var outerX = halfW * 0.6;
                var outerChordY = asmChordYm + th / 2;
                if (awRafterBot > outerChordY + th * 0.5) {
                    mbr(-webX, awRafterBot, -outerX, outerChordY);
                    mbr(webX, awRafterBot, outerX, outerChordY);
                }
            }

            // --- Risers (L-shaped pieces at heel ends) ---
            if (riserOn) {
                const riserType = c.riserType || 'welded';
                // Separate risers use a distinct shade; welded use same truss material
                const sepMat = new THREE.MeshStandardMaterial({color: 0x888888, metalness: 0.0, roughness: 0.7});
                function rmbr(z1, y1, z2, y2) {
                    const dz = z2 - z1, dy = y2 - y1;
                    const len = Math.sqrt(dz * dz + dy * dy);
                    if (len < 0.001) return;
                    const geo = new THREE.BoxGeometry(tw, th, len);
                    const m = riserType === 'separate' ? sepMat.clone() : mat.clone();
                    const mesh = new THREE.Mesh(geo, m);
                    mesh.position.set(0, (y1 + y2) / 2, (z1 + z2) / 2);
                    mesh.rotation.x = -Math.atan2(dy, dz);
                    g.add(mesh);
                }
                // Small gap for separate type to show joint line
                const gap = riserType === 'separate' ? 0.005 : 0;
                const lhz = extOn ? -halfW - extLen : -halfW;
                rmbr(lhz, th / 2 - gap, lhz, th / 2 - rLV);
                rmbr(lhz, th / 2 - rLV, lhz - rLH, th / 2 - rLV);
                const rhz = extOn ? halfW + extLen : halfW;
                rmbr(rhz, th / 2 - gap, rhz, th / 2 - rRV);
                rmbr(rhz, th / 2 - rRV, rhz + rRH, th / 2 - rRV);
            }

            return g;
        }

        function regComp(mesh, name, specs) {
            mesh.userData.selectable = true;
            compData.set(mesh.uuid, {name, specs});
        }

        function checkHover(mx, my) {
            asmRay.setFromCamera(asmMouse, getActiveAsmCamera());
            const all = [];
            if (steelGrp.visible) all.push(...steelGrp.children);
            if (roofGrp.visible) all.push(...roofGrp.children);
            if (accGrp.visible) all.push(...accGrp.children);
            if (houseGrp.visible) all.push(...houseGrp.children);
            const hits = asmRay.intersectObjects(all, true);
            if (hits.length > 0) {
                let obj = hits[0].object;
                while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;
                if (compData.has(obj.uuid)) {
                    // Don't override selection highlight with hover
                    if (obj === selectedObject) {
                        showTooltip(mx, my, compData.get(obj.uuid));
                        return;
                    }
                    if (hovered !== obj) { clearHover(); hovered = obj; highlight(obj); }
                    showTooltip(mx, my, compData.get(obj.uuid));
                    return;
                }
            }
            clearHover();
        }

        function highlight(mesh) {
            const hl = new THREE.Color(0xF15A29);
            if (mesh.material) { mesh.material.emissive = hl; mesh.material.emissiveIntensity = 0.3; }
            mesh.traverse(c => { if (c.material) { c.material.emissive = hl; c.material.emissiveIntensity = 0.3; }});
        }

        function clearHover() {
            if (hovered) {
                // Don't clear if this is the selected object
                if (hovered === selectedObject) { hovered = null; hideTooltip(); return; }
                if (hovered.material) { hovered.material.emissive = new THREE.Color(0); hovered.material.emissiveIntensity = 0; }
                hovered.traverse(c => { if (c.material) { c.material.emissive = new THREE.Color(0); c.material.emissiveIntensity = 0; }});
                hovered = null;
            }
            hideTooltip();
        }

        function showTooltip(x, y, data) {
            const tt = document.getElementById('tooltip');
            document.getElementById('ttTitle').textContent = data.name;
            document.getElementById('ttContent').innerHTML = Object.entries(data.specs)
                .map(([k,v]) => `<div class="tooltip-row"><span class="tooltip-label">${k}</span><span class="tooltip-value">${v}</span></div>`).join('');
            tt.style.left = (x + 15) + 'px';
            tt.style.top = (y + 15) + 'px';
            tt.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        // ==================== 3D SELECTION SYSTEM ====================
        let selectedObject = null;
        let trussSelectedObject = null;
        const originalMaterials = new Map();

        const selectHighlightColor = new THREE.Color(0x00aaff);
        const hoverHighlightColor = new THREE.Color(0xF15A29);

        function storeOriginalMaterial(obj) {
            if (!originalMaterials.has(obj.uuid) && obj.material) {
                originalMaterials.set(obj.uuid, {
                    emissive: obj.material.emissive ? obj.material.emissive.clone() : new THREE.Color(0),
                    emissiveIntensity: obj.material.emissiveIntensity || 0
                });
            }
        }

        function restoreOriginalMaterial(obj) {
            if (originalMaterials.has(obj.uuid) && obj.material) {
                const stored = originalMaterials.get(obj.uuid);
                obj.material.emissive = stored.emissive;
                obj.material.emissiveIntensity = stored.emissiveIntensity;
                originalMaterials.delete(obj.uuid);
            }
            obj.traverse(c => {
                if (originalMaterials.has(c.uuid) && c.material) {
                    const stored = originalMaterials.get(c.uuid);
                    c.material.emissive = stored.emissive;
                    c.material.emissiveIntensity = stored.emissiveIntensity;
                    originalMaterials.delete(c.uuid);
                }
            });
        }

        function applySelectHighlight(obj) {
            if (obj.material) {
                storeOriginalMaterial(obj);
                obj.material.emissive = selectHighlightColor;
                obj.material.emissiveIntensity = 0.5;
            }
            obj.traverse(c => {
                if (c.material) {
                    storeOriginalMaterial(c);
                    c.material.emissive = selectHighlightColor;
                    c.material.emissiveIntensity = 0.5;
                }
            });
        }

        // Dim all components except the selected one
        function dimOtherComponents(selectedObj) {
            [steelGrp, roofGrp, accGrp].forEach(grp => {
                if (!grp) return;
                grp.children.forEach(child => {
                    if (child === selectedObj) return;
                    var applyDim = function(mesh) {
                        if (mesh.material) {
                            if (!mesh.userData._origOpacity) {
                                mesh.userData._origOpacity = mesh.material.opacity !== undefined ? mesh.material.opacity : 1;
                                mesh.userData._origTransparent = mesh.material.transparent;
                            }
                            mesh.material.transparent = true;
                            mesh.material.opacity = 0.3;
                        }
                    };
                    applyDim(child);
                    if (child.traverse) child.traverse(applyDim);
                });
            });
        }

        // Restore all dimmed components
        function restoreDimmedComponents() {
            [steelGrp, roofGrp, accGrp].forEach(grp => {
                if (!grp) return;
                grp.children.forEach(child => {
                    var restoreDim = function(mesh) {
                        if (mesh.material && mesh.userData._origOpacity !== undefined) {
                            mesh.material.opacity = mesh.userData._origOpacity;
                            mesh.material.transparent = mesh.userData._origTransparent;
                            delete mesh.userData._origOpacity;
                            delete mesh.userData._origTransparent;
                        }
                    };
                    restoreDim(child);
                    if (child.traverse) child.traverse(restoreDim);
                });
            });
        }

        // Assembly 3D click handler
        function onAsmClick(event) {
            const canvas = document.getElementById('asmCanvas');
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const ray = new THREE.Raycaster();
            ray.setFromCamera(mouse, getActiveAsmCamera());
            const all = [];
            if (steelGrp && steelGrp.visible) all.push(...steelGrp.children);
            if (roofGrp && roofGrp.visible) all.push(...roofGrp.children);
            if (accGrp && accGrp.visible) all.push(...accGrp.children);
            const hits = ray.intersectObjects(all, true);

            // Clear previous selection and restore dimming
            if (selectedObject) {
                restoreOriginalMaterial(selectedObject);
                restoreDimmedComponents();
                selectedObject = null;
            }

            const panel = document.getElementById('asmPropertiesPanel');

            if (hits.length > 0) {
                let obj = hits[0].object;
                while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;
                if (compData.has(obj.uuid)) {
                    selectedObject = obj;
                    applySelectHighlight(obj);
                    dimOtherComponents(obj);
                    const data = compData.get(obj.uuid);
                    showPropertiesPanel(panel, data.name, data.specs);
                    return;
                }
            }
            hidePropertiesPanel(panel);
        }

        // Truss 3D click handler
        function onTrussClick(event) {
            const canvas = document.getElementById('trussCanvas');
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const ray = new THREE.Raycaster();
            ray.setFromCamera(mouse, trussCam);
            const hits = ray.intersectObjects(trussGroup ? trussGroup.children : [], true);

            // Clear previous selection
            if (trussSelectedObject) {
                restoreOriginalMaterial(trussSelectedObject);
                trussSelectedObject = null;
            }

            const panel = document.getElementById('trussPropertiesPanel');

            if (hits.length > 0) {
                const obj = hits[0].object;
                if (obj.userData && obj.userData.selectable) {
                    trussSelectedObject = obj;
                    applySelectHighlight(obj);
                    showPropertiesPanel(panel, obj.userData.type || 'Component', obj.userData.specs || {});
                    return;
                }
            }
            hidePropertiesPanel(panel);
        }

        function showPropertiesPanel(panel, name, specs) {
            panel.style.display = 'block';
            let content = '';
            if (specs) {
                Object.entries(specs).forEach(([k, v]) => {
                    content += '<div><strong>' + k + ':</strong> ' + v + '</div>';
                });
            }
            // Add Colorbond swatch picker for the selected component
            var colourRow = '';
            if (selectedObject && selectedObject.material) {
                var mat = Array.isArray(selectedObject.material) ? selectedObject.material.find(function(m) { return m && m.color; }) : selectedObject.material;
                var curHex = mat && mat.color ? '#' + mat.color.clone().convertLinearToSRGB().getHexString().toUpperCase() : '#888888';
                // Find current colour name
                var curName = '';
                Object.entries(COLORBOND_COLOURS).forEach(function(e) {
                    if (e[1].toUpperCase() === curHex) curName = e[0];
                });
                // Build swatch grid
                var swatches = '';
                Object.entries(COLORBOND_COLOURS).forEach(function(e) {
                    var isActive = e[1].toUpperCase() === curHex;
                    swatches += '<div onclick="changeComponentColour(\'' + e[1] + '\',\'' + e[0].replace(/'/g,"\\'") + '\')" ' +
                        'title="' + e[0] + '" ' +
                        'style="width:18px;height:18px;border-radius:3px;background:' + e[1] + ';cursor:pointer;' +
                        'border:2px solid ' + (isActive ? '#F15A29' : 'rgba(255,255,255,0.2)') + ';' +
                        'box-shadow:' + (isActive ? '0 0 0 1px #F15A29' : 'none') + '">' +
                        '</div>';
                });
                colourRow = '<div style="margin-top:6px;padding-top:6px;border-top:1px solid rgba(255,255,255,0.1)">' +
                    '<strong>Colour:</strong> <span id="compColLabel" style="font-size:10px;opacity:0.7">' + (curName || curHex) + '</span>' +
                    '<div style="display:flex;flex-wrap:wrap;gap:3px;margin-top:4px">' + swatches + '</div>' +
                    '</div>';
            }
            panel.innerHTML =
                '<div class="props-header"><span>' + name + '</span><button onclick="hidePropertiesPanel(this.parentElement.parentElement)">Ã—</button></div>' +
                '<div class="props-content">' + (content || '<div>No details</div>') + colourRow + '</div>';
        }

        function changeComponentColour(hex, name) {
            if (!selectedObject) return;
            var col = new THREE.Color(hex).convertSRGBToLinear();
            var mats = Array.isArray(selectedObject.material) ? selectedObject.material : [selectedObject.material];
            mats.forEach(function(m) {
                if (m && m.color) m.color.copy(col);
            });
            var label = document.getElementById('compColLabel');
            if (label) label.textContent = name || hex;
            // Update swatch borders to show active
            var panel = document.getElementById('asmPropertiesPanel');
            if (panel) {
                panel.querySelectorAll('.props-content div[onclick]').forEach(function(sw) {
                    var isActive = sw.getAttribute('onclick').indexOf(hex) > -1;
                    sw.style.border = '2px solid ' + (isActive ? '#F15A29' : 'rgba(255,255,255,0.2)');
                    sw.style.boxShadow = isActive ? '0 0 0 1px #F15A29' : 'none';
                });
            }
        }

        function hidePropertiesPanel(panel) {
            if (panel) panel.style.display = 'none';
        }

        var currentScenePreset = 'backyard';
        function switchScenePreset(preset) {
            currentScenePreset = preset;
            if (backyardEnvGrp) backyardEnvGrp.visible = (preset === 'backyard');
            if (carportEnvGrp) carportEnvGrp.visible = (preset === 'carport');
            buildAsm3D(); // rebuild to swap door type (sliding vs garage)
        }

        function toggleLayer(layer, el) {
            el.classList.toggle('active');
            const vis = el.classList.contains('active');
            if (layer === 'steel') steelGrp.visible = vis;
            if (layer === 'roof') roofGrp.visible = vis;
            if (layer === 'acc') accGrp.visible = vis;
            if (layer === 'house') houseGrp.visible = vis;
        }

        function toggleFullscreen() {
            const container = document.getElementById('asmViewport');

            function resizeRenderer() {
                setTimeout(() => {
                    if (asmRend && container) {
                        var w = container.clientWidth, h = container.clientHeight;
                        if (w > 0 && h > 0) {
                            if (asmCam) {
                                asmCam.aspect = w / h;
                                asmCam.updateProjectionMatrix();
                            }
                            if (asmOrthoCamera) {
                                var aspect = w / h;
                                var halfH = (asmOrthoCamera.top - asmOrthoCamera.bottom) / 2;
                                asmOrthoCamera.left = -halfH * aspect;
                                asmOrthoCamera.right = halfH * aspect;
                                asmOrthoCamera.updateProjectionMatrix();
                            }
                            asmRend.setSize(w, h);
                        }
                    }
                }, 100);
            }

            if (!document.fullscreenElement) {
                container.classList.add('fullscreen-mode');
                container.requestFullscreen().catch(err => {
                    // Fallback: use fixed position maximise
                    container.classList.add('fullscreen');
                });
                resizeRenderer();
            } else {
                document.exitFullscreen();
                container.classList.remove('fullscreen-mode');
                container.classList.remove('fullscreen');
                resizeRenderer();
            }
        }

        document.addEventListener('fullscreenchange', () => {
            const container = document.getElementById('asmViewport');
            if (!document.fullscreenElement) {
                container.classList.remove('fullscreen-mode');
                container.classList.remove('fullscreen');
                setTimeout(() => {
                    if (asmRend && container) {
                        var w = container.clientWidth, h = container.clientHeight;
                        if (w > 0 && h > 0) {
                            if (asmCam) {
                                asmCam.aspect = w / h;
                                asmCam.updateProjectionMatrix();
                            }
                            if (asmOrthoCamera) {
                                var aspect = w / h;
                                var halfH = (asmOrthoCamera.top - asmOrthoCamera.bottom) / 2;
                                asmOrthoCamera.left = -halfH * aspect;
                                asmOrthoCamera.right = halfH * aspect;
                                asmOrthoCamera.updateProjectionMatrix();
                            }
                            asmRend.setSize(w, h);
                        }
                    }
                }, 100);
            }
        });

        function getSheetMatEntries(numSheets, roofing) {
            const pc = hasPolycarbMatch(roofing) ? getPolycarbConfig() : null;
            var sc = calc ? calc.sheetCalc : null;
            var cutNote = sc && sc.hasPartialSheet ? ' \u2014 last sheet cut to ' + sc.partialSheetWidth + 'mm' : '';
            if (!pc) return [{d: roofingLabel(roofing) + ' Sheets' + cutNote, q: numSheets}];
            const split = getPolycarbSheetSplit(numSheets);
            const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
            const colorbondColour = sheetColor ? sheetColor.name : '';
            const pcProfileLabel = pc.profileName || 'Polycarb';
            const levelLabel = pc.level ? ' Lv' + pc.level : '';
            const entries = [];
            if (split.colorbond > 0) entries.push({d: roofingLabel(roofing) + (colorbondColour ? ' ' + colorbondColour : '') + ' Sheets', q: split.colorbond});
            if (split.polycarb > 0) entries.push({d: brandLabel + ' ' + pcProfileLabel + ' ' + pc.tint + levelLabel + ' Sheets', q: split.polycarb});
            if (cutNote) entries.push({d: 'Note: ' + sc.orderNote, q: '', isNote: true});
            return entries;
        }

        function updateMatList() {
            const c = calc;
            let mats = [];
            const sheetCover = c.sheetCoverage;

            if (c.isGable) {
                const gsc = c.sheetCalc;
                const numSheets = gsc ? gsc.totalSheets * 2 : Math.ceil(c.L / sheetCover) * 2;
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                const riserCount = c.riserQty;
                // Beam count depends on connection type
                let beamCount;
                if (c.connection === 'freestanding') {
                    beamCount = 2;  // Gutter beam + back beam
                } else if (c.connection === 'riser') {
                    beamCount = 3;  // Gutter beam + fascia beam + riser beam
                } else {
                    beamCount = 2;  // Gutter beam + fascia/back beam
                }
                const purlinCount = (c.gableBattenCalc && c.gableBattenCalc.totalBattens > 0) ? c.gableBattenCalc.totalBattens : Math.max(2, Math.ceil(c.rafter / 1000 / 0.8)) * 2;
                // Truss riser type affects material listing
                const trussRiserOn = c.trussRiserLeft.enabled;
                const trussRiserType = c.riserType || 'welded';
                const trussLabel = trussRiserOn && trussRiserType === 'welded'
                    ? 'Trusses ' + c.steel.name + ' (risers welded \u2014 ' + Math.round(c.trussRiserLeft.length) + 'H\u00D7' + Math.round(c.trussRiserLeft.height) + 'V)'
                    : 'Trusses ' + c.steel.name + (trussRiserOn ? ' (flat ends)' : '');
                mats = [
                    {d: 'Posts ' + c.framePost.label, q: postCount},
                    ...(c.postFix === 'concrete' ? [{d: 'Kwikset Concrete (5 bags/post)', q: postCount * 5}] : []),
                    {d: 'Beams ' + c.frameBeam.label, q: beamCount},
                    {d: trussLabel, q: c.nTruss},
                    {d: 'Purlins ' + (c.purlinSize ? c.purlinSize.name : '76Ã—38Ã—1.6 RHS'), q: purlinCount},
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Ridge Cap', q: 1},
                    {d: 'Gable Barges', q: 4},
                    {d: 'Quad Gutter 115mm', q: 1},
                    {d: 'Downpipes', q: Math.max(1, c.dpCount || 2)}
                ];
                if (c.infill !== 'none') mats.push({d: 'Gable Infill', q: 2});
                // Separate truss risers get their own line item
                if (trussRiserOn && trussRiserType === 'separate') {
                    mats.push({d: 'Riser Pieces ' + c.steel.name + ' (' + Math.round(c.trussRiserLeft.length) + 'H\u00D7' + Math.round(c.trussRiserLeft.height) + 'V)', q: c.nTruss, note: 'Site-installed, 1 set per truss'});
                }
                if (c.connection === 'fascia') {
                    // Direct to fascia: fascia brackets instead of riser
                    mats.push({d: 'Fascia Brackets', q: c.fasciaBracketQty});
                } else if (c.connection === 'riser') {
                    mats.push({d: 'Rafter Brackets (Galv)', q: riserCount});
                    mats.push({d: 'Risers (Welded L) ' + (c.riserSteelSize ? c.riserSteelSize.label : '76Ã—38 RHS'), q: riserCount});
                    mats.push({d: 'Riser Beam ' + c.frameBeam.label, q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                    if (c.riserGutter === 'quad') {
                        mats.push({d: 'Riser Beam Gutter 115mm Quad', q: 1});
                    }
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'Fascia Board (House Wall)', q: 1});
                }
            } else {
                const ssc = c.sheetCalc;
                const numSheets = ssc ? ssc.totalSheets : Math.ceil(c.L / sheetCover);
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                let beamCount;
                if (c.connection === 'riser') {
                    beamCount = 3;  // gutter + fascia + riser beam
                } else if (c.isRecvChan) {
                    beamCount = 1;  // gutter beam only (channel replaces back beam)
                } else {
                    beamCount = 2;  // gutter + back/flyover beam
                }
                const riserCount = c.riserQty;
                const bc = c.battenCalc;
                const bk = c.bracketCalc;
                // Use batten calculator for purlin/batten count, fallback to old logic
                // SpanPlus/sheets that span full projection without battens: purlinCount = 0
                const effectiveW = (c.W - (c.connection === 'riser' ? c.riserOffset : 0)) / 1000;
                const purlinCount = (bc && bc.battensNeeded > 0) ? bc.battensNeeded : ((isInsulated(c.roofing) || (bc && bc.battensNeeded === 0)) ? 0 : Math.max(2, Math.ceil(effectiveW / 0.9)) + 1);
                mats = [
                    {d: 'Posts ' + c.framePost.label, q: postCount},
                    ...(c.postFix === 'concrete' ? [{d: 'Kwikset Concrete (5 bags/post)', q: postCount * 5}] : []),
                    {d: 'Beams ' + c.frameBeam.label, q: beamCount},
                    {d: 'Rafters ' + (c.rafterSize ? c.rafterSize.name : c.steel.name), q: (c.rafterCalc ? c.rafterCalc.rafterCount : c.nRafters)},
                ];
                if (purlinCount > 0) {
                    mats.push({d: 'Battens ' + (c.purlinSize ? c.purlinSize.name : '76Ã—38Ã—1.6 RHS'), q: purlinCount});
                }
                if (bk && bk.bracketsNeeded > 0) {
                    var btLabel = c.bracketType === 'external' ? 'External' : 'Internal';
                    mats.push({d: 'Tubing Brackets (' + btLabel + ')', q: bk.bracketsNeeded});
                }
                mats.push(
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Barge Flashings', q: 2},
                    {d: 'Quad Gutter 115mm', q: 1},
                    {d: 'Downpipes', q: Math.max(1, c.dpCount || 2)}
                );
                // Back flashing - skip for riser+box gutter AND receiving channel
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    mats.splice(5, 0, {d: 'Back Flashing', q: 1});
                }
                if (c.connection === 'riser') {
                    mats.splice(2, 0, {d: 'Rafter Brackets (Galv)', q: riserCount});
                    mats.splice(3, 0, {d: 'Risers (Welded L) ' + (c.riserSteelSize ? c.riserSteelSize.label : '76Ã—38 RHS'), q: riserCount});
                    mats.splice(4, 0, {d: 'Riser Beam ' + c.frameBeam.label, q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                }
                if (c.connection === 'flyover') {
                    const strutCount = Math.max(2, Math.ceil(c.L / 1200));
                    mats.push({d: 'Flyover Posts ' + c.framePost.label, q: strutCount});
                    mats.push({d: 'Flyover Beam ' + c.frameBeam.label, q: 1});
                    mats.push({d: 'Flashing Boots (roof penetration)', q: strutCount});
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'Fascia Board (House Wall)', q: 1});
                }
                // Wraparound return materials
                if (c.wrapSide !== 'none') {
                    const retLenM = c.returnLength / 1000;
                    const coverW = ROOFING_TYPES[c.roofing] ? ROOFING_TYPES[c.roofing].coverWidth / 1000 : 0.762;
                    mats.push({d: 'Return Posts ' + c.framePost.label, q: c.returnPosts + 1});  // +1 for corner post
                    if (c.postFix === 'concrete') mats.push({d: 'Return Post Concrete (5 bags/post)', q: (c.returnPosts + 1) * 5});
                    mats.push({d: 'Return Beams ' + c.frameBeam.label, q: c.connection === 'riser' ? 2 : 1});
                    if (!isInsulated(c.roofing)) {
                        const retRafterCount = Math.max(2, Math.ceil(retLenM / (c.rafterSpacing / 1000)) + 1);
                        mats.push({d: 'Return Rafters ' + (c.rafterSize ? c.rafterSize.name : 'RHS'), q: retRafterCount});
                    }
                    // Hip-aware sheet count: main sheet offcuts cover return positions in the hip zone
                    const hipDistBom = Math.min(retLenM, c.W / 1000);
                    const sharedSheets = Math.ceil(hipDistBom / coverW);
                    const totalRetSheets = Math.ceil(retLenM / coverW);
                    const extraRetSheets = Math.max(0, totalRetSheets - sharedSheets);
                    if (extraRetSheets > 0) {
                        mats.push({d: 'Return Sheets (' + (ROOFING_TYPES[c.roofing] || {}).name + ')', q: extraRetSheets});
                    }
                    const hipCutSheets = Math.min(sharedSheets, totalRetSheets);
                    mats.push({d: 'Note: ' + hipCutSheets + ' main sheets hip-cut at corner \u2014 offcuts cover return', q: '', isNote: true});
                    mats.push({d: 'Hip Rafter', q: 1});
                    mats.push({d: 'Return Gutter 150mm Quad', q: 1});
                    mats.push({d: 'Return Downpipe', q: 1});
                    mats.push({d: 'Return Barge Flashing', q: 1});
                    mats.push({d: 'Hip Flashing', q: 1});
                    if (c.isRecvChan) mats.push({d: 'Return Receiving Channel', q: 1});
                }
            }

            // Group materials by build sequence
            const groups = [
                { id: 'cfg-structure',  num: '1', name: 'Structure',  items: [] },
                { id: 'cfg-roofing',    num: '2', name: 'Roofing',    items: [] },
                { id: 'cfg-drainage',   num: '3', name: 'Drainage',   items: [] },
                { id: 'cfg-finishing',   num: '4', name: 'Finishing',  items: [] },
                { id: 'cfg-fixings',    num: '5', name: 'Fixings',    items: [] }
            ];

            mats.forEach(function(m) {
                const d = m.d.toLowerCase();
                if (d.includes('post') || d.includes('beam') ||
                    d.includes('purlin') || d.includes('truss') || d.includes('rafter') ||
                    d.includes('welded l') || d.includes('strut') ||
                    d.includes('batten') || d.includes('bracket') || d.includes('fascia bracket')) {
                    groups[0].items.push(m);
                } else if (d.includes('sheet') || d.includes('solarspan') || d.includes('trimdek') ||
                           d.includes('corrugated') || d.includes('spanplus') || d.includes('ridge cap') ||
                           d.includes('polycarb')) {
                    groups[1].items.push(m);
                } else if (d.includes('gutter') || d.includes('downpipe') || d.includes('box gutter')) {
                    groups[2].items.push(m);
                } else if (d.includes('barge') || d.includes('infill') || d.includes('flashing') ||
                           d.includes('fascia') || d.includes('channel') ||
                           d.includes('boot')) {
                    groups[3].items.push(m);
                } else {
                    groups[4].items.push(m);
                }
            });

            // Helpers to extract size, display name, length, colour for each material
            function matSize(desc) {
                var d = desc.toLowerCase();
                if (d.includes('65Ã—65'))    return '65Ã—65Ã—2 SHS';
                if (d.includes('75Ã—75'))    return '75Ã—75Ã—2 SHS';
                if (d.includes('90Ã—90'))    return '90Ã—90Ã—2 SHS';
                if (d.includes('100Ã—100'))  return '100Ã—100Ã—2 SHS';
                if (d.includes('125Ã—125'))  return '125Ã—125Ã—3 SHS';
                if (d.includes('150Ã—150'))  return '150Ã—150Ã—3 SHS';
                if (d.includes('c200'))     return 'C200 Purlin';
                if (d.includes('c150'))     return 'C150 Purlin';
                if (d.includes('150Ã—50'))   return '150Ã—50Ã—2 RHS';
                if (d.includes('125Ã—50'))   return '125Ã—50Ã—2 RHS';
                if (d.includes('100Ã—50'))   return '100Ã—50Ã—2 RHS';
                if (d.includes('75Ã—50'))    return '75Ã—50Ã—2 RHS';
                if (d.includes('76Ã—38'))    return '76Ã—38Ã—1.6 RHS';
                if (d.includes('solarspan'))return 'Insulated Panel';
                if (d.includes('trimdek'))  return 'Trimdek';
                if (d.includes('corrugated'))return 'Corrugated';
                if (d.includes('spanplus')) return 'SpanPlus 330';
                if (d.includes('115mm'))    return '115mm Quad';
                return '\u2014';
            }
            function matName(desc) {
                var d = desc.toLowerCase();
                if (d.includes('post'))         return 'Posts';
                if (d.includes('riser beam gutter')) return 'Riser Beam Gutter';
                if (d.includes('riser beam'))   return 'Riser Beam';
                if (d.includes('welded l'))  return 'Risers (Welded L)';
                if (d.includes('flyover beam')) return 'Flyover Beam';
                if (d.includes('flyover post')) return 'Flyover Posts';
                if (d.includes('flyover strut'))return 'Flyover Posts';
                if (d.includes('flashing boot'))return 'Flashing Boots';
                if (d.includes('beam'))         return 'Beams';
                if (d.includes('truss'))        return 'Trusses';
                if (d.includes('rafter'))       return 'Rafters';
                if (d.includes('batten'))       return 'Battens';
                if (d.includes('tubing bracket')) return 'Tubing Brackets';
                if (d.includes('purlin'))       return 'Purlins';
                if (d.includes('ridge cap'))    return 'Ridge Cap';
                if (d.includes('downpipe'))     return 'Downpipes';
                if (d.includes('box gutter'))   return 'Box Gutter';
                if (d.includes('gutter'))       return 'Gutter';
                if (d.includes('barge'))        return 'Barge Flashings';
                if (d.includes('back flashing'))return 'Back Flashing';
                if (d.includes('infill'))       return 'Gable Infill';
                if (d.includes('fascia bracket')) return 'Fascia Brackets';
                if (d.includes('fascia board')) return 'Fascia Board (House Wall)';
                if (d.includes('channel'))      return 'Receiving Channel';
                if (d.includes('kwikset'))      return 'Kwikset Concrete';
                if (d.includes('polycarb'))     return 'Polycarb Sheets';
                if (d.includes('sheet'))        return 'Sheets';
                return desc;
            }
            function matLen(desc) {
                var len = getItemLength(desc);
                if (len <= 0) return '\u2014';
                // Show nesting info for steel items
                if (isSteelItem(desc)) {
                    var dLow = desc.toLowerCase();
                    var plan = c.steelNestingPlan || [];
                    var entry = null;
                    if (dLow.includes('post')) entry = plan.find(function(p){return p.label==='Posts';});
                    else if (dLow.includes('flyover beam')) entry = plan.find(function(p){return p.label==='Flyover Beam';});
                    else if (dLow.includes('flyover post') || dLow.includes('flyover strut')) entry = plan.find(function(p){return p.label==='Flyover Posts'||p.label==='Flyover Struts';});
                    else if (dLow.includes('riser beam')) entry = plan.find(function(p){return p.label==='Riser Beam';});
                    else if (dLow.includes('welded l')) entry = plan.find(function(p){return p.label==='Risers (Welded L)';});
                    else if (dLow.includes('beam')) entry = plan.find(function(p){return p.label==='Beams';});
                    else if (dLow.includes('truss')) entry = plan.find(function(p){return p.label==='Trusses';});
                    else if (dLow.includes('rafter')) entry = plan.find(function(p){return p.label==='Rafters';});
                    else if (dLow.includes('batten') || dLow.includes('purlin')) entry = plan.find(function(p){return p.label==='Battens'||p.label==='Purlins';});

                    if (entry && entry.nesting) {
                        var n = entry.nesting;
                        if (n.specialOrder) {
                            return entry.cutMm + 'mm cut<br><span style="font-size:9px;color:#c00;font-weight:600">REQUIRES SPECIAL ORDER</span>';
                        }
                        var stockM = (n.stockLength / 1000).toFixed(1);
                        var line1 = entry.cutMm + 'mm cut';
                        var line2 = '<span style="font-size:9px;color:var(--sw-text-sec)">\u2192 ' + n.totalSticks + '\u00D7 ' + stockM + 'm sticks';
                        if (n.piecesPerStick > 1) line2 += ' (' + n.piecesPerStick + '/stick)';
                        line2 += '</span>';
                        return line1 + '<br>' + line2;
                    }
                }
                return len.toFixed(1) + 'm';
            }
            function matColour(desc) {
                var d = desc.toLowerCase();
                if (d.includes('post') || d.includes('beam') || d.includes('purlin') ||
                    d.includes('batten') || d.includes('bracket') ||
                    d.includes('truss') || d.includes('rafter') || d.includes('strut') ||
                    d.includes('75Ã—75') || d.includes('barge') || d.includes('gutter') ||
                    d.includes('downpipe') || d.includes('ridge') || d.includes('flashing') ||
                    d.includes('channel')) return steelColor.name;
                if (d.includes('polycarb')) return '\u2014';
                if (d.includes('sheet') || d.includes('infill')) return sheetColor.name;
                return '\u2014';
            }

            var hdrRow = '<div class="mat-hdr"><span>Item</span><span style="text-align:right">Qty</span><span>Size</span><span style="text-align:right">Length</span><span>Colour</span></div>';

            let html = '';
            groups.forEach(function(g, idx) {
                const isOpen = idx === 0;
                var rows = '';
                if (g.items.length > 0) {
                    rows = hdrRow + g.items.map(function(m) {
                        if (m.isNote) {
                            return '<div class="mat-row mat-note" style="grid-template-columns:1fr;font-size:10px;color:var(--sw-text-sec);font-style:italic">' +
                                '<span>' + m.d + '</span></div>';
                        }
                        return '<div class="mat-row" data-desc="' + m.d.replace(/"/g, '&quot;') + '">' +
                            '<span>' + matName(m.d) + '</span>' +
                            '<span class="mat-qty">' + m.q + 'Ã—</span>' +
                            '<span class="mat-size">' + matSize(m.d) + '</span>' +
                            '<span class="mat-len">' + matLen(m.d) + '</span>' +
                            '<span class="mat-clr">' + matColour(m.d) + '</span>' +
                            '</div>';
                    }).join('');
                }
                const body = g.items.length > 0 ? rows : '<div class="cfg-group-empty">No items in this category</div>';
                html += '<div class="cfg-group">' +
                    '<div class="cfg-group-hdr" onclick="toggleCfgGroup(\'' + g.id + '\')">' +
                        '<span class="cfg-group-arrow' + (isOpen ? ' open' : '') + '" id="' + g.id + '-arrow">&#9654;</span>' +
                        '<span class="cfg-group-num">' + g.num + '.</span> ' + g.name +
                    '</div>' +
                    '<div class="cfg-group-body' + (isOpen ? ' open' : '') + '" id="' + g.id + '-body">' + body + '</div>' +
                '</div>';
            });

            // Steel Order Summary
            var nestPlan = c.steelNestingPlan || [];
            if (nestPlan.length > 0) {
                var soHtml = '<div class="cfg-group">' +
                    '<div class="cfg-group-hdr" onclick="toggleCfgGroup(\'cfg-steelorder\')">' +
                        '<span class="cfg-group-arrow" id="cfg-steelorder-arrow">&#9654;</span>' +
                        '<span class="cfg-group-num">\u2692</span> Steel Order Summary' +
                    '</div>' +
                    '<div class="cfg-group-body" id="cfg-steelorder-body">' +
                    '<div style="padding:8px 14px">';
                // Table header
                soHtml += '<div style="display:grid;grid-template-columns:100px 1fr 70px 90px;gap:4px;font-size:10px;font-weight:600;color:var(--sw-text-sec);border-bottom:1px solid var(--sw-border);padding-bottom:4px;margin-bottom:4px">' +
                    '<span>Item</span><span>Nesting</span><span style="text-align:right">Order</span><span style="text-align:right">Cost</span></div>';
                var totalSticks = 0, totalCost = 0;
                nestPlan.forEach(function(p) {
                    var n = p.nesting;
                    var rate = STEEL_RATES[p.sizeKey] || 0;
                    var stickCost = 0;
                    if (n.specialOrder) {
                        stickCost = (p.cutMm / 1000) * rate * p.qty;
                    } else {
                        n.sticks.forEach(function(st) { stickCost += (st.stockLength / 1000) * rate; });
                    }
                    totalCost += stickCost;
                    totalSticks += n.totalSticks;
                    var nestDesc = '';
                    if (n.specialOrder) {
                        nestDesc = '<span style="color:#c00;font-weight:600">SPECIAL ORDER &gt;' + (Math.max.apply(null, getStockLengthsForSize(p.sizeKey)) / 1000).toFixed(1) + 'm</span>';
                    } else if (n.piecesPerStick > 1) {
                        nestDesc = p.qty + '\u00D7 ' + p.cutMm + 'mm \u2192 ' + n.totalSticks + '\u00D7 ' + (n.stockLength / 1000).toFixed(1) + 'm (' + n.piecesPerStick + ' pcs/stick, ' + Math.round(n.totalWaste) + 'mm waste)';
                    } else {
                        nestDesc = p.qty + '\u00D7 ' + p.cutMm + 'mm \u2192 ' + n.totalSticks + '\u00D7 ' + (n.stockLength / 1000).toFixed(1) + 'm (' + Math.round(n.totalWaste) + 'mm waste)';
                    }
                    var orderStr = n.totalSticks + '\u00D7 ' + (n.specialOrder ? 'SPL' : (n.stockLength / 1000).toFixed(1) + 'm');
                    soHtml += '<div style="display:grid;grid-template-columns:100px 1fr 70px 90px;gap:4px;font-size:11px;padding:3px 0;border-bottom:1px solid #f5f5f5;align-items:baseline">' +
                        '<span style="font-weight:600">' + p.label + '</span>' +
                        '<span style="font-size:10px;color:var(--sw-text-sec)">' + nestDesc + '</span>' +
                        '<span style="text-align:right;font-family:\'SF Mono\',monospace;font-size:10px">' + orderStr + '</span>' +
                        '<span style="text-align:right;font-family:\'SF Mono\',monospace;font-size:10px">$' + stickCost.toFixed(0) + ' (' + p.sizeName + ')</span>' +
                        '</div>';
                });
                // Totals
                soHtml += '<div style="display:grid;grid-template-columns:100px 1fr 70px 90px;gap:4px;font-size:11px;padding:6px 0 2px;border-top:2px solid var(--sw-border);font-weight:700">' +
                    '<span>TOTAL</span><span></span>' +
                    '<span style="text-align:right">' + totalSticks + ' sticks</span>' +
                    '<span style="text-align:right;font-family:\'SF Mono\',monospace">$' + totalCost.toFixed(0) + '</span></div>';
                soHtml += '</div></div></div>';
                html += soHtml;
            }

            document.getElementById('matList').innerHTML = html;

            // Pre-order validation checks
            var checks = [];

            // 1. Sheet coverage check
            var totalSheets = 0;
            mats.forEach(function(m) {
                if (m.d.toLowerCase().includes('sheet')) totalSheets += m.q;
            });
            // For gable, sheets cover one side; coverage = sheets/2 * coverWidth vs L
            var coverageMm, requiredMm;
            if (c.isGable) {
                coverageMm = Math.floor(totalSheets / 2) * sheetCover;
                requiredMm = c.L;
            } else {
                coverageMm = totalSheets * sheetCover;
                requiredMm = c.L;
            }
            if (coverageMm < requiredMm) {
                var shortBy = requiredMm - coverageMm;
                checks.push({ ok: false, text: 'May be short by ' + Math.round(shortBy) + 'mm \u2014 check sheet count' });
            } else {
                checks.push({ ok: true, text: 'Sheet coverage OK' });
            }

            // 2. Gutter overhang check
            var sheetLenMm = c.isGable ? c.rafter : c.rafter;
            var projMm = c.W;
            var overhangNeeded = projMm + 50;
            if (sheetLenMm < overhangNeeded) {
                checks.push({ ok: false, text: 'Add 50mm for gutter overhang' });
            } else {
                checks.push({ ok: true, text: 'Gutter overhang OK' });
            }

            // 3. Downpipe count
            var dpCount = 0;
            mats.forEach(function(m) {
                if (m.d.toLowerCase().includes('downpipe')) dpCount += m.q;
            });
            var widthMm = c.L;
            if (widthMm > 12000 && dpCount < 2) {
                checks.push({ ok: false, text: 'Consider 2 downpipes for 12m+ gutter' });
            } else {
                checks.push({ ok: true, text: 'Downpipe count OK' });
            }

            var checksHtml = '<div class="preorder-box"><div class="preorder-title">Pre-Order Checks</div>';
            checks.forEach(function(ch) {
                if (ch.ok) {
                    checksHtml += '<div class="preorder-item preorder-ok">\u2713 ' + ch.text + '</div>';
                } else {
                    checksHtml += '<div class="preorder-item preorder-warn">\u26A0\uFE0F ' + ch.text + '</div>';
                }
            });
            checksHtml += '</div>';
            document.getElementById('preOrderChecks').innerHTML = checksHtml;
        }

        function toggleCfgGroup(id) {
            var body = document.getElementById(id + '-body');
            var arrow = document.getElementById(id + '-arrow');
            body.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        function getActiveAsmCamera() {
            return (asmCurrentView !== '3d' && asmOrthoCamera) ? asmOrthoCamera : asmCam;
        }

        function zoomStep(dir) {
            if (!asmCam || !asmControls) return;
            if (asmCurrentView !== '3d' && asmOrthoCamera) {
                // Ortho: adjust zoom property
                var factor = dir > 0 ? 1.2 : 0.83;
                asmOrthoCamera.zoom = Math.max(0.1, asmOrthoCamera.zoom * factor);
                asmOrthoCamera.updateProjectionMatrix();
                return;
            }
            var dist = asmCam.position.distanceTo(asmControls.target);
            var factor = dir > 0 ? 0.85 : 1.18; // 15% closer / further
            zoomDistGoal = THREE.MathUtils.clamp(dist * factor, asmControls.minDistance, asmControls.maxDistance);
            zoomAnimating = true;
            focusAnimating = false;
        }

        function animateAsm() {
            requestAnimationFrame(animateAsm);
            if (asmControls) asmControls.update();

            // Focus lerp (double-click zoom)
            if (focusAnimating && asmCam && asmControls) {
                asmControls.target.lerp(focusTargetGoal, FOCUS_LERP);
                asmCam.position.lerp(focusCamGoal, FOCUS_LERP);
                if (asmControls.target.distanceTo(focusTargetGoal) < 0.01) {
                    asmControls.target.copy(focusTargetGoal);
                    asmCam.position.copy(focusCamGoal);
                    focusAnimating = false;
                }
            }

            // Zoom button lerp
            if (zoomAnimating && asmCam && asmControls) {
                var dir = asmCam.position.clone().sub(asmControls.target).normalize();
                var curDist = asmCam.position.distanceTo(asmControls.target);
                var newDist = THREE.MathUtils.lerp(curDist, zoomDistGoal, FOCUS_LERP);
                asmCam.position.copy(asmControls.target).add(dir.multiplyScalar(newDist));
                if (Math.abs(newDist - zoomDistGoal) < 0.01) {
                    zoomAnimating = false;
                }
            }

            var cam = getActiveAsmCamera();
            if (asmRend && asmScene && cam) {
                asmRend.render(asmScene, cam);
            }
        }

        // ==================== DIMENSION DISPLAY SYSTEM ====================

        function createDimSprite(text) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            ctx.font = 'bold 28px Arial, sans-serif';
            var tw = ctx.measureText(text).width;
            canvas.width = Math.ceil(tw + 16);
            canvas.height = 36;
            ctx.font = 'bold 28px Arial, sans-serif';
            // Background pill
            ctx.fillStyle = 'rgba(255,255,255,0.92)';
            ctx.strokeStyle = '#bbb';
            ctx.lineWidth = 1.5;
            var r = 6;
            var w = canvas.width, h = canvas.height;
            ctx.beginPath();
            ctx.moveTo(r, 0); ctx.lineTo(w - r, 0); ctx.quadraticCurveTo(w, 0, w, r);
            ctx.lineTo(w, h - r); ctx.quadraticCurveTo(w, h, w - r, h);
            ctx.lineTo(r, h); ctx.quadraticCurveTo(0, h, 0, h - r);
            ctx.lineTo(0, r); ctx.quadraticCurveTo(0, 0, r, 0);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            // Text
            ctx.fillStyle = '#1a365d';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, w / 2, h / 2);

            var tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            var spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false });
            var sprite = new THREE.Sprite(spriteMat);
            var scale = 0.004; // world units per pixel
            sprite.scale.set(canvas.width * scale, canvas.height * scale, 1);
            return sprite;
        }

        function createDimensionLine(start, end, offset, labelText) {
            var group = new THREE.Group();
            var dir = new THREE.Vector3().subVectors(end, start);
            var len = dir.length();
            if (len < 0.01) return group;
            dir.normalize();

            // Perpendicular offset direction (in XZ plane for horizontal, in XY for vertical)
            var perp;
            if (Math.abs(dir.y) > 0.9) {
                // Vertical line - offset in X or Z
                perp = new THREE.Vector3(offset > 0 ? 1 : -1, 0, 0).multiplyScalar(Math.abs(offset));
            } else {
                perp = new THREE.Vector3(-dir.z, 0, dir.x).normalize().multiplyScalar(offset);
            }

            var s = start.clone().add(perp);
            var e = end.clone().add(perp);

            var lineMat = new THREE.LineBasicMaterial({ color: 0x1a365d, depthTest: false });

            // Main dimension line
            var mainGeo = new THREE.BufferGeometry().setFromPoints([s, e]);
            group.add(new THREE.Line(mainGeo, lineMat));

            // Extension lines
            var ext1Geo = new THREE.BufferGeometry().setFromPoints([start, s]);
            var ext2Geo = new THREE.BufferGeometry().setFromPoints([end, e]);
            group.add(new THREE.Line(ext1Geo, lineMat));
            group.add(new THREE.Line(ext2Geo, lineMat));

            // Tick marks at ends (small perpendicular ticks)
            var tickSize = 0.04;
            var tickPerp = dir.clone().multiplyScalar(tickSize);
            var t1a = s.clone().sub(tickPerp), t1b = s.clone().add(tickPerp);
            var t2a = e.clone().sub(tickPerp), t2b = e.clone().add(tickPerp);
            group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([t1a, t1b]), lineMat));
            group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([t2a, t2b]), lineMat));

            // Label sprite at midpoint
            var mid = s.clone().add(e).multiplyScalar(0.5);
            var label = createDimSprite(labelText);
            label.position.copy(mid);
            group.add(label);

            group.renderOrder = 999;
            return group;
        }

        function updateAsmDimensions() {
            if (!dimensionGroup || !calc || !calc.W) return;
            // Clear existing
            while (dimensionGroup.children.length > 0) {
                var child = dimensionGroup.children[0];
                dimensionGroup.remove(child);
                if (child.traverse) child.traverse(function(o) {
                    if (o.geometry) o.geometry.dispose();
                    if (o.material) { if (o.material.map) o.material.map.dispose(); o.material.dispose(); }
                });
            }

            var c = calc;
            var W = c.W / 1000;    // projection (depth)
            var L = c.L / 1000;    // length
            var postH = c.frontBeamY / 1000;
            var backH = c.backBeamY / 1000;
            var fasciaH = c.fasciaBeamY ? c.fasciaBeamY / 1000 : null;
            var rise = c.rise / 1000;
            var pitch = c.pitch;
            var riserH = c.riserH / 1000;
            var riserOffset = c.riserOffset / 1000;
            var isPerpendicular = c.isGable && c.orientation === 'perpendicular';

            var off = 0.3; // offset for dimension lines

            // ===== OVERALL DIMENSIONS =====

            if (isPerpendicular) {
                // Length along front (Z axis)
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(W / 2, 0, -L / 2),
                    new THREE.Vector3(W / 2, 0, L / 2),
                    off,
                    Math.round(c.L) + 'mm'
                ));
                // Projection depth (X axis) â€” full distance from house wall to front posts
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(-W / 2, 0, L / 2 + off),
                    new THREE.Vector3(W / 2, 0, L / 2 + off),
                    off,
                    'Projection: ' + Math.round(c.W) + 'mm'
                ));
            } else {
                // Length along front (X axis)
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(-L / 2, 0, W / 2),
                    new THREE.Vector3(L / 2, 0, W / 2),
                    off,
                    Math.round(c.L) + 'mm'
                ));
                // Projection depth (Z axis) â€” full distance from house wall to front posts
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(L / 2 + off, 0, -W / 2),
                    new THREE.Vector3(L / 2 + off, 0, W / 2),
                    off,
                    Math.round(c.W) + 'mm'
                ));
            }

            // Front post height â€” simple label
            var phX = isPerpendicular ? W / 2 : L / 2;
            var phZ = isPerpendicular ? L / 2 : W / 2;
            var aboveGround = Math.round(c.frontBeamY);
            dimensionGroup.add(createDimensionLine(
                new THREE.Vector3(phX, 0, phZ),
                new THREE.Vector3(phX, postH, phZ),
                off,
                'Post: ' + aboveGround + 'mm above ground + 600mm embedment'
            ));

            // Back beam height â€” dimension line from ground to back beam
            if (c.isAttached && backH > 0.05) {
                var bbX = isPerpendicular ? -W / 2 - off * 1.5 : L / 2 + off * 2;
                var bbZ = isPerpendicular ? L / 2 + off : -W / 2;
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(bbX, 0, bbZ),
                    new THREE.Vector3(bbX, backH, bbZ),
                    off * 0.5,
                    'Back beam: ' + Math.round(c.backBeamY) + 'mm'
                ));
            }

            // Fascia beam height â€” dimension line from ground (only if different from back beam)
            if (fasciaH && Math.abs(fasciaH - backH) > 0.05) {
                var fbX = isPerpendicular ? -W / 2 - off * 3 : L / 2 + off * 3.5;
                var fbZ = isPerpendicular ? L / 2 + off * 2 : -W / 2 - off;
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(fbX, 0, fbZ),
                    new THREE.Vector3(fbX, fasciaH, fbZ),
                    off * 0.5,
                    'Fascia: ' + Math.round(c.fasciaBeamY) + 'mm'
                ));
            }

            // Ridge height (for gable)
            if (c.isGable && rise > 0.05) {
                var ridgeY = postH + rise;
                var ridgeLabel = createDimSprite(Math.round(ridgeY * 1000) + 'mm');
                ridgeLabel.position.set(isPerpendicular ? 0 : 0, ridgeY + 0.15, isPerpendicular ? 0 : W / 4);
                dimensionGroup.add(ridgeLabel);
            }

            // ===== SPACING DIMENSIONS =====

            // Post-to-post spacing along front
            if (c.nPosts > 1) {
                var spacing = L / (c.nPosts - 1);
                var sp0X = isPerpendicular ? W / 2 : -L / 2;
                var sp0Z = isPerpendicular ? -L / 2 : W / 2;
                var sp1X = isPerpendicular ? W / 2 : -L / 2 + spacing;
                var sp1Z = isPerpendicular ? -L / 2 + spacing : W / 2;
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(sp0X, -0.1, sp0Z),
                    new THREE.Vector3(sp1X, -0.1, sp1Z),
                    off * 2,
                    Math.round(c.postSpacing) + 'mm'
                ));
            }

            // ===== ROOF DIMENSIONS =====

            // Pitch angle label
            if (pitch > 0.5) {
                var pitchLabel = createDimSprite(pitch.toFixed(1) + '\u00B0');
                if (isPerpendicular) {
                    pitchLabel.position.set(W / 4, postH + rise * 0.3, 0);
                } else {
                    pitchLabel.position.set(0, (postH + backH) / 2 + 0.15, W / 4);
                }
                dimensionGroup.add(pitchLabel);
            }

            // Riser height â€” vertical dim line from fascia beam to back beam
            if (c.connection === 'riser' && riserH > 0.05 && fasciaH) {
                var riserBaseY = fasciaH;
                var riserTopY = backH;
                var rX = isPerpendicular ? -W / 2 - off * 1.5 : 0;
                var rZ = isPerpendicular ? 0 : -W / 2 - off * 1.5;
                dimensionGroup.add(createDimensionLine(
                    new THREE.Vector3(rX, riserBaseY, rZ),
                    new THREE.Vector3(rX, riserTopY, rZ),
                    off * 0.5,
                    'Back beam: ' + Math.round(c.backBeamY) + 'mm (riser ' + Math.round(c.riserH) + 'mm)'
                ));
            }
        }

        function toggleAsmDimensions() {
            dimensionsVisible = !dimensionsVisible;
            if (dimensionGroup) dimensionGroup.visible = dimensionsVisible;
            var btn = document.getElementById('dimToggleBtn');
            if (btn) btn.classList.toggle('active', dimensionsVisible);
            if (dimensionsVisible) updateAsmDimensions();
        }

        // ==================== ORTHOGRAPHIC CAMERA & PRESET VIEWS ====================

        function setAsmView(v, btn) {
            focusAnimating = false; zoomAnimating = false;
            document.querySelectorAll('.view-panel .view-btn').forEach(function(b) { b.classList.remove('active'); });
            if (btn) btn.classList.add('active');

            var container = document.getElementById('asmViewport');
            var w = container ? container.clientWidth : 600;
            var h = container ? container.clientHeight : 400;
            var aspect = w / h;

            // Compute scene center and distance (include house for proper framing)
            var box = new THREE.Box3();
            if (steelGrp && steelGrp.children.length) box.expandByObject(steelGrp);
            if (roofGrp && roofGrp.children.length) box.expandByObject(roofGrp);
            if (houseGrp && houseGrp.visible && houseGrp.children.length) box.expandByObject(houseGrp);
            var center = new THREE.Vector3();
            var size = new THREE.Vector3();
            box.getCenter(center);
            box.getSize(size);
            if (size.length() === 0) { size.set(6, 3, 4); center.set(0, 1.5, 0); }
            var maxDim = Math.max(size.x, size.y, size.z);

            asmCurrentView = v;

            if (v === '3d') {
                // Switch to perspective camera
                if (asmControls.object !== asmCam) {
                    asmControls.object = asmCam;
                }
                asmCam.aspect = aspect;
                asmCam.updateProjectionMatrix();
                asmControls.enableRotate = true;

                var d = maxDim * 1.5;
                asmCam.position.set(center.x + d * 0.55, center.y + d * 0.4, center.z + d * 0.7);
                asmControls.target.copy(center);
                asmControls.update();
            } else {
                // Switch to orthographic camera for elevation views
                var frustum = maxDim * 1.2;
                asmOrthoCamera.left = frustum * aspect / -2;
                asmOrthoCamera.right = frustum * aspect / 2;
                asmOrthoCamera.top = frustum / 2;
                asmOrthoCamera.bottom = frustum / -2;
                asmOrthoCamera.zoom = 1;
                asmOrthoCamera.updateProjectionMatrix();

                if (asmControls.object !== asmOrthoCamera) {
                    asmControls.object = asmOrthoCamera;
                }
                asmControls.enableRotate = false; // Pan only in ortho views

                if (v === 'front') {
                    asmOrthoCamera.position.set(center.x, center.y, center.z + maxDim * 2);
                    asmControls.target.copy(center);
                } else if (v === 'side') {
                    asmOrthoCamera.position.set(center.x + maxDim * 2, center.y, center.z);
                    asmControls.target.copy(center);
                } else if (v === 'top') {
                    asmOrthoCamera.position.set(center.x, center.y + maxDim * 2, center.z + 0.01);
                    asmControls.target.copy(center);
                }

                asmOrthoCamera.lookAt(asmControls.target);
                asmOrthoCamera.updateProjectionMatrix();
                asmControls.update();
            }

            // Update dimensions if visible
            if (dimensionsVisible) updateAsmDimensions();
        }

        // ==================== SECTION CUT VIEWS ====================

        function handleAsmSectionChange(val) {
            if (!val) {
                clearAsmSectionView();
                return;
            }
            setAsmSectionView(val);
        }

        function setAsmSectionView(sectionName) {
            focusAnimating = false; zoomAnimating = false;
            if (!asmRend || !asmScene) return;
            asmCurrentSection = sectionName;

            // Use PATIO-ONLY bounding box for section framing (not house)
            var pBox = new THREE.Box3();
            if (steelGrp && steelGrp.children.length) pBox.expandByObject(steelGrp);
            if (roofGrp && roofGrp.children.length) pBox.expandByObject(roofGrp);
            if (accGrp && accGrp.children.length) pBox.expandByObject(accGrp);
            var pc = new THREE.Vector3();
            var ps = new THREE.Vector3();
            pBox.getCenter(pc);
            pBox.getSize(ps);
            if (ps.length() === 0) { ps.set(6, 3, 4); pc.set(0, 1.5, 0); }

            // Also get full box for house-relative clipping
            var fullBox = pBox.clone();
            if (houseGrp && houseGrp.children.length) fullBox.expandByObject(houseGrp);
            var fc = new THREE.Vector3();
            fullBox.getCenter(fc);

            // Enable clipping
            asmRend.localClippingEnabled = true;

            var plane, camPos, camTarget, visLayers;
            // Camera distance - tighter framing for detail views
            var detailDist = Math.max(ps.x, ps.z) * 0.6;

            if (sectionName === 'riser') {
                // Riser: clip to show back wall connection area
                // Plane clips front half away, revealing riser-to-fascia joint
                var riserZ = pBox.min.z + ps.z * 0.15; // clip near the back (house side)
                plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -riserZ);
                // Camera: side view looking at the riser connection
                camPos = new THREE.Vector3(pc.x - detailDist * 1.5, pc.y + ps.y * 0.3, riserZ);
                camTarget = new THREE.Vector3(pc.x, pc.y * 0.8, riserZ);
                visLayers = { steel: true, roof: false, acc: false, house: true };
            } else if (sectionName === 'post') {
                // Post: clip to isolate one post from the side
                var postX = pBox.max.x - ps.x * 0.2; // clip near right edge to show one post
                plane = new THREE.Plane(new THREE.Vector3(-1, 0, 0), postX);
                // Camera: front-right angle, eye-level, close
                camPos = new THREE.Vector3(postX + detailDist * 0.5, pc.y + ps.y * 0.2, pc.z + detailDist * 1.0);
                camTarget = new THREE.Vector3(postX - ps.x * 0.1, pc.y * 0.4, pc.z + ps.z * 0.3);
                visLayers = { steel: true, roof: false, acc: false, house: false };
            } else if (sectionName === 'gutter') {
                // Gutter: clip to show front gutter area
                var gutterZ = pBox.max.z - ps.z * 0.15; // front edge where gutter sits
                plane = new THREE.Plane(new THREE.Vector3(0, 0, -1), gutterZ);
                // Camera: looking up at the gutter from below and front
                camPos = new THREE.Vector3(pc.x + detailDist * 0.3, pc.y + ps.y * 0.4, gutterZ + detailDist * 0.8);
                camTarget = new THREE.Vector3(pc.x, pc.y + ps.y * 0.5, gutterZ - ps.z * 0.05);
                visLayers = { steel: true, roof: true, acc: true, house: false };
            } else if (sectionName === 'ridge') {
                // Ridge: clip through centre to show ridge apex
                plane = new THREE.Plane(new THREE.Vector3(1, 0, 0), -pc.x);
                // Camera: front angle looking at the ridge peak
                camPos = new THREE.Vector3(pc.x - detailDist * 1.0, pc.y + ps.y * 0.7, pc.z + detailDist * 0.5);
                camTarget = new THREE.Vector3(pc.x, pc.y + ps.y * 0.6, pc.z);
                visLayers = { steel: true, roof: true, acc: false, house: false };
            } else {
                clearAsmSectionView();
                return;
            }

            asmClippingPlane = plane;

            // Apply section clipping plane to all meshes (ADD to existing clips, don't replace)
            // This preserves wraparound hip clipping planes on individual materials
            asmScene.traverse(function(obj) {
                if (obj.isMesh && obj.material) {
                    var mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                    mats.forEach(function(m) {
                        if (!m.clippingPlanes) m.clippingPlanes = [];
                        m.clippingPlanes.push(plane);
                        m.clipShadows = true;
                        m.needsUpdate = true;
                    });
                }
            });

            // Set layer visibility
            if (steelGrp) steelGrp.visible = visLayers.steel;
            if (roofGrp) roofGrp.visible = visLayers.roof;
            if (accGrp) accGrp.visible = visLayers.acc;
            if (houseGrp) houseGrp.visible = visLayers.house;

            // Update layer panel UI to reflect
            document.querySelectorAll('.layer-item').forEach(function(el) {
                var layer = el.getAttribute('data-layer');
                var vis = visLayers[layer] !== undefined ? visLayers[layer] : true;
                el.classList.toggle('active', vis);
            });

            // Move camera to section view â€” use tighter FOV for detail
            var origFov = asmCam.fov;
            asmCam.fov = 30; // tighter for detail views
            asmCam.updateProjectionMatrix();
            asmCam.position.copy(camPos);
            asmControls.target.copy(camTarget);
            asmCam.lookAt(camTarget);
            asmControls.update();
            asmCurrentView = '3d'; // Use perspective for section views
            if (asmControls.object !== asmCam) asmControls.object = asmCam;
            asmControls.enableRotate = true;

            document.querySelectorAll('.view-panel .view-btn').forEach(function(b) { b.classList.remove('active'); });
        }

        function clearAsmSectionView() {
            var sectionPlane = asmClippingPlane;
            asmCurrentSection = '';
            asmClippingPlane = null;
            // Keep localClippingEnabled = true â€” wraparound hip clipping needs it
            if (asmRend) asmRend.localClippingEnabled = true;

            // Remove only the section clipping plane from meshes (preserve hip clips etc.)
            if (asmScene && sectionPlane) {
                asmScene.traverse(function(obj) {
                    if (obj.isMesh && obj.material) {
                        var mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                        mats.forEach(function(m) {
                            if (m.clippingPlanes && m.clippingPlanes.length) {
                                m.clippingPlanes = m.clippingPlanes.filter(function(p) { return p !== sectionPlane; });
                            }
                            m.needsUpdate = true;
                        });
                    }
                });
            }

            // Restore all layers visible
            if (steelGrp) steelGrp.visible = true;
            if (roofGrp) roofGrp.visible = true;
            if (accGrp) accGrp.visible = true;
            if (houseGrp) houseGrp.visible = true;
            document.querySelectorAll('.layer-item').forEach(function(el) { el.classList.add('active'); });

            // Reset dropdown
            var sel = document.getElementById('asmSectionSelect');
            if (sel) sel.value = '';

            // Restore default FOV (section views use tighter FOV)
            if (asmCam) {
                asmCam.fov = 35;
                asmCam.updateProjectionMatrix();
            }

            // Reset to 3D view
            setAsmView('3d');
        }

        // ==================== EXPORT VIEWS FOR WORK ORDER ====================

        async function exportWorkOrderViews() {
            if (!asmRend || !asmScene || !asmCam || !asmControls) { alert('3D viewer not ready'); return; }

            var exports = {};
            // Save FULL camera state for restoration
            var origPos = asmCam.position.clone();
            var origTarget = asmControls.target.clone();
            var origFov = asmCam.fov;
            var origOrthoPos = asmOrthoCamera ? asmOrthoCamera.position.clone() : null;
            var origOrthoZoom = asmOrthoCamera ? asmOrthoCamera.zoom : 1;
            var origDims = dimensionsVisible;
            var origView = asmCurrentView;
            var origSection = asmCurrentSection;

            // Enable dimensions
            if (!dimensionsVisible) toggleAsmDimensions();

            var container = document.getElementById('asmViewport');
            var origW = asmRend.domElement.width;
            var origH = asmRend.domElement.height;

            // Wait for 3 frames â€” more reliable for clipping plane / camera changes to settle
            function waitFrame() {
                return new Promise(function(resolve) {
                    requestAnimationFrame(function() {
                        requestAnimationFrame(function() {
                            requestAnimationFrame(resolve);
                        });
                    });
                });
            }

            function captureCurrentView() {
                var cam = getActiveAsmCamera();
                asmRend.render(asmScene, cam);
                return asmRend.domElement.toDataURL('image/png');
            }

            // Lightweight section clear â€” just removes clip plane and restores visibility
            // WITHOUT resetting the camera (avoids wasted setAsmView('3d') between captures)
            function quickClearSection() {
                var sp = asmClippingPlane;
                asmCurrentSection = '';
                asmClippingPlane = null;
                if (asmScene && sp) {
                    asmScene.traverse(function(obj) {
                        if (obj.isMesh && obj.material) {
                            var mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                            mats.forEach(function(m) {
                                if (m.clippingPlanes && m.clippingPlanes.length) {
                                    m.clippingPlanes = m.clippingPlanes.filter(function(p) { return p !== sp; });
                                }
                                m.needsUpdate = true;
                            });
                        }
                    });
                }
                if (steelGrp) steelGrp.visible = true;
                if (roofGrp) roofGrp.visible = true;
                if (accGrp) accGrp.visible = true;
                if (houseGrp) houseGrp.visible = true;
            }

            var origBackground = asmScene.background ? asmScene.background.clone() : null;

            try {
                // â”€â”€ Main views: white background (saves ink) â”€â”€
                asmScene.background = new THREE.Color(0xFFFFFF);

                // 1. Hero shot â€” custom architectural perspective angle
                var woBox = new THREE.Box3();
                if (steelGrp) woBox.expandByObject(steelGrp);
                if (roofGrp) woBox.expandByObject(roofGrp);
                if (accGrp) woBox.expandByObject(accGrp);
                if (houseGrp && houseGrp.visible && houseGrp.children.length) woBox.expandByObject(houseGrp);
                var woCenter = new THREE.Vector3();
                var woSize = new THREE.Vector3();
                woBox.getCenter(woCenter);
                woBox.getSize(woSize);
                if (woSize.length() === 0) { woSize.set(6, 3, 4); woCenter.set(0, 1.5, 0); }
                var woMax = Math.max(woSize.x, woSize.z);

                asmCam.fov = 35; // reset to default
                asmCam.updateProjectionMatrix();
                asmCam.position.set(
                    woCenter.x + woMax * 1.1,
                    woCenter.y + woSize.y * 0.6,
                    woCenter.z + woMax * 1.2
                );
                asmControls.target.set(woCenter.x, woCenter.y * 0.5, woCenter.z);
                asmControls.update();
                await waitFrame();
                exports.hero = captureCurrentView();

                // 2. Front elevation
                setAsmView('front');
                await waitFrame();
                exports.frontElevation = captureCurrentView();

                // 3. Side elevation
                setAsmView('side');
                await waitFrame();
                exports.sideElevation = captureCurrentView();

                // 4. Top/site plan
                setAsmView('top');
                await waitFrame();
                exports.sitePlan = captureCurrentView();

                // â”€â”€ Section details: light grey background so clipped edges are visible â”€â”€
                asmScene.background = new THREE.Color(0xF0F2F5);

                // Reset to perspective for section captures
                asmCurrentView = '3d';
                if (asmControls.object !== asmCam) asmControls.object = asmCam;
                asmControls.enableRotate = true;

                setAsmSectionView('riser');
                await waitFrame();
                exports.riserDetail = captureCurrentView();
                quickClearSection();
                await waitFrame();

                setAsmSectionView('post');
                await waitFrame();
                exports.postDetail = captureCurrentView();
                quickClearSection();
                await waitFrame();

                setAsmSectionView('gutter');
                await waitFrame();
                exports.gutterDetail = captureCurrentView();
                quickClearSection();
                await waitFrame();

                if (calc && calc.isGable) {
                    setAsmSectionView('ridge');
                    await waitFrame();
                    exports.ridgeDetail = captureCurrentView();
                    quickClearSection();
                    await waitFrame();
                }
            } catch (err) {
                console.error('Export views error:', err);
            }

            // Restore FULL state
            asmScene.background = origBackground || new THREE.Color(0x87CEEB);
            asmCam.fov = origFov;
            asmCam.updateProjectionMatrix();
            asmCam.position.copy(origPos);
            asmControls.target.copy(origTarget);
            if (origOrthoPos && asmOrthoCamera) {
                asmOrthoCamera.position.copy(origOrthoPos);
                asmOrthoCamera.zoom = origOrthoZoom;
                asmOrthoCamera.updateProjectionMatrix();
            }
            asmControls.update();
            if (origView !== '3d') {
                setAsmView(origView);
            } else {
                setAsmView('3d');
            }
            if (origSection) setAsmSectionView(origSection);
            if (!origDims && dimensionsVisible) toggleAsmDimensions();

            // Store exports globally for work order PDF
            window._workOrderViews = exports;
            showToast('Exported ' + Object.keys(exports).length + ' views for work order');
            return exports;
        }

        // ==================== PRICING ====================
        const DEFAULT_RATES = {
            // Steel ($/LM)
            '65Ã—65Ã—2 SHS':     22.00,
            '75Ã—75Ã—2 SHS':     28.00,
            '90Ã—90Ã—2 SHS':     35.50,
            '100Ã—100Ã—2 SHS':   42.00,
            '125Ã—125Ã—3 SHS':   58.00,
            '150Ã—150Ã—3 SHS':   72.00,
            '76Ã—38Ã—1.6 RHS':   15.50,
            '75Ã—50Ã—2 RHS':     26.00,
            '100Ã—50Ã—2 RHS':    30.00,
            '125Ã—50Ã—2 RHS':    34.00,
            '150Ã—50Ã—2 RHS':    39.05,
            '150Ã—50Ã—3 RHS':    50.00,
            'C150 Purlin':     28.00,
            'C200 Purlin':     35.00,
            // Roofing ($/LM)
            'Solarspan 75mm':  110.00,
            'Corrugated Colorbond': 12.04,
            'Trimdek Colorbond':   14.00,
            'Spandek Colorbond':   14.50,
            'Ampelite Solasafe 5-Rib': 25.00,
            'Ampelite Solasafe Corrugated': 23.00,
            'Laserlite 2000 5-Rib':    27.00,
            // Flashings ($/LM) â€” $24/m standard
            'Ridge Cap':       24.00,
            'Barge Flashing':  24.00,
            'Back Flashing':   24.00,
            'Gutter Flashing': 24.00,
            // Gutters & Drainage ($/LM)
            'Quad Gutter 115mm': 22.00,
            'Box Gutter':      45.00,
            'Downpipe 90mm':   22.22,  // $40 per 1800mm stick
            // Extras
            'Gable Infill (sqm)': 45.00,
            'Riser 76Ã—38 (ea)':  50.00,
            'Riser 75Ã—50 (ea)':  55.00,
            'Riser 100Ã—50 (ea)': 60.00,
            'Riser Bracket (ea)': 12.00,
            'Tubing Bracket (ea)': 2.50,
            'Fixings ($/sqm)': 2.50,
            'Concrete Kwikset (bag)': 5.00,
            // Labour ($/day)
            'Skilled Trade':   400.00,
            'Labourer':        250.00,
            'Electrician':     450.00
        };

        const DEFAULT_SELL_MARKUP = 1.35; // 35% default markup on cost for sell price

        // ==================== STEEL STOCK LENGTHS ====================
        // Per-size stock lengths (mm) â€” powder coated, Australian suppliers
        const STEEL_STOCK_LENGTHS_BY_SIZE = {
            '76Ã—38Ã—1.6':  [3000, 4000, 6100, 7300, 8000],
            '75Ã—50Ã—2':    [8000],
            '100Ã—50Ã—2':   [5500, 6500, 8000],
            '150Ã—50Ã—2':   [5500, 6500, 8000],
            '150Ã—50Ã—3':   [8000],
            '125Ã—50Ã—2':   [6500, 8000],
            '90Ã—90Ã—2':    [3100, 4100, 6200, 8000],
            '65Ã—65Ã—2':    [6500, 8000],
            '75Ã—75Ã—2':    [6500, 8000],
            '100Ã—100Ã—2':  [6500, 8000],
            '125Ã—125Ã—3':  [6500, 8000],
            '150Ã—150Ã—3':  [6500, 8000]
        };
        // Backward compat wrapper
        const STEEL_STOCK_LENGTHS = {
            'RHS': [6500, 8000],
            'SHS': [6500, 8000],
            'PATIO_TUBE': [3000, 4000, 6100, 7300, 8000]
        };
        // Fixed-price riser items (powder coated, each)
        const RISER_PRICES = {
            '76Ã—38Ã—1.6': 50,
            '75Ã—50Ã—2':   55,
            '100Ã—50Ã—2':  60
        };

        function getStockLengthsForSize(sizeKey) {
            return STEEL_STOCK_LENGTHS_BY_SIZE[sizeKey] || [6500, 8000];
        }

        const STEEL_RATES = {
            '76Ã—38Ã—1.6': 15.50,
            '75Ã—50Ã—2': 26.00,
            '100Ã—50Ã—2': 30.00,
            '150Ã—50Ã—2': 39.05,
            '150Ã—50Ã—3': 50.00,
            '90Ã—90Ã—2': 35.50,
            '65Ã—65Ã—2': 22.00,
            '75Ã—75Ã—2': 28.00,
            '100Ã—100Ã—2': 42.00,
            '125Ã—125Ã—3': 58.00,
            '150Ã—150Ã—3': 72.00,
            '125Ã—50Ã—2': 34.00
        };

        function calculateStockRequired(requiredLengthMm, stockLengths) {
            const sorted = [...stockLengths].sort((a, b) => a - b);
            for (const stockLen of sorted) {
                if (requiredLengthMm <= stockLen) {
                    return { stockLength: stockLen, waste: stockLen - requiredLengthMm, qty: 1, needsJoiner: false };
                }
            }
            const maxStock = sorted[sorted.length - 1];
            const qty = Math.ceil(requiredLengthMm / maxStock);
            return { stockLength: maxStock, waste: (qty * maxStock) - requiredLengthMm, qty, needsJoiner: true };
        }

        // Nesting: pack multiple cut pieces into minimum stock lengths (first-fit decreasing)
        // Returns { sticks: [{stockLength, cuts:[mm,...], waste},...], totalSticks, totalWaste, specialOrder }
        // opts.onePerStick: force 1 piece per stick (e.g. posts â€” no combining)
        function nestCuts(cutLengthMm, qty, stockLengths, opts) {
            const SAW_KERF = 3; // 3mm saw cut allowance
            const sorted = [...stockLengths].sort((a, b) => a - b);
            const maxStock = sorted[sorted.length - 1];

            // Check for special order (single piece too long for any stock)
            if (cutLengthMm > maxStock) {
                return {
                    sticks: [],
                    totalSticks: qty,
                    totalWaste: 0,
                    specialOrder: true,
                    cutLength: cutLengthMm,
                    piecesPerStick: 1,
                    orderSummary: qty + 'Ã— SPECIAL ORDER (>' + (maxStock / 1000).toFixed(1) + 'm)'
                };
            }

            // Pick the smallest stock that fits at least one piece
            var bestStock = maxStock;
            for (var si = 0; si < sorted.length; si++) {
                if (sorted[si] >= cutLengthMm) {
                    bestStock = sorted[si];
                    break;
                }
            }

            // One-per-stick mode: each piece gets its own smallest stock (e.g. posts)
            if (opts && opts.onePerStick) {
                var sticks = [];
                for (var i = 0; i < qty; i++) {
                    sticks.push({ stockLength: bestStock, cuts: [cutLengthMm], waste: bestStock - cutLengthMm });
                }
                var totalWaste = sticks.reduce(function(s, st) { return s + st.waste; }, 0);
                return {
                    sticks: sticks,
                    totalSticks: qty,
                    totalWaste: totalWaste,
                    specialOrder: false,
                    cutLength: cutLengthMm,
                    piecesPerStick: 1,
                    stockLength: bestStock,
                    orderSummary: qty + 'Ã— ' + (bestStock / 1000).toFixed(1) + 'm sticks'
                };
            }

            // How many pieces fit in one stick?
            var piecesPerStick = 0;
            var testLen = 0;
            while (testLen + cutLengthMm <= bestStock) {
                piecesPerStick++;
                testLen += cutLengthMm + SAW_KERF;
            }
            if (piecesPerStick < 1) piecesPerStick = 1;

            // Could we fit more pieces using a longer stock?
            for (var li = sorted.indexOf(bestStock) + 1; li < sorted.length; li++) {
                var bigStock = sorted[li];
                var bigPieces = 0;
                var tl = 0;
                while (tl + cutLengthMm <= bigStock) {
                    bigPieces++;
                    tl += cutLengthMm + SAW_KERF;
                }
                // Only use longer stock if it reduces total sticks needed
                var sticksSmall = Math.ceil(qty / piecesPerStick);
                var sticksBig = Math.ceil(qty / bigPieces);
                if (sticksBig < sticksSmall) {
                    bestStock = bigStock;
                    piecesPerStick = bigPieces;
                }
            }

            var totalSticks = Math.ceil(qty / piecesPerStick);
            var sticks = [];
            var remaining = qty;
            for (var i = 0; i < totalSticks; i++) {
                var n = Math.min(remaining, piecesPerStick);
                var used = n * cutLengthMm + (n - 1) * SAW_KERF;
                var waste = bestStock - used;
                var cuts = [];
                for (var j = 0; j < n; j++) cuts.push(cutLengthMm);
                sticks.push({ stockLength: bestStock, cuts: cuts, waste: waste });
                remaining -= n;
            }

            var totalWaste = sticks.reduce(function(s, st) { return s + st.waste; }, 0);
            var stockLabel = (bestStock / 1000).toFixed(1) + 'm';
            var orderSummary = totalSticks + 'Ã— ' + stockLabel + ' sticks';
            if (piecesPerStick > 1) {
                orderSummary += ' (' + piecesPerStick + ' pcs/stick';
                if (sticks.length > 0 && sticks[sticks.length - 1].cuts.length < piecesPerStick) {
                    orderSummary += ', last stick ' + sticks[sticks.length - 1].cuts.length + ' pcs';
                }
                orderSummary += ')';
            }

            return {
                sticks: sticks,
                totalSticks: totalSticks,
                totalWaste: totalWaste,
                specialOrder: false,
                cutLength: cutLengthMm,
                piecesPerStick: piecesPerStick,
                stockLength: bestStock,
                orderSummary: orderSummary
            };
        }

        // Build complete steel nesting plan from current calc state
        // Returns array of { label, sizeKey, sizeName, cutMm, qty, nesting:{...} }
        function buildSteelNestingPlan() {
            var c = calc;
            if (!c || !c.L) return [];
            var plan = [];
            var Lmm = c.lenInput || c.L;
            var Wmm = c.projInput || c.W;
            var postHmm = c.connection === 'freestanding' ? (c.postH || 2400) : (Math.round(c.frontBeamY) || c.postH || 2400);
            var postFix = (document.getElementById('inPostFix') || {}).value || 'concrete';
            var postCut = postFix === 'concrete' ? postHmm + 600 : postHmm;
            var postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;

            // Posts
            var postSizeKey = c.framePost ? getSteelSizeKey(c.framePost.name) : '90Ã—90Ã—2';
            var postSizeName = c.framePost ? c.framePost.name : '90Ã—90Ã—2 SHS';
            plan.push({
                label: 'Posts',
                sizeKey: postSizeKey,
                sizeName: postSizeName,
                cutMm: Math.round(postCut),
                qty: postCount,
                nesting: nestCuts(Math.round(postCut), postCount, getStockLengthsForSize(postSizeKey), { onePerStick: true })
            });

            // Beams
            var beamSizeKey = c.frameBeam ? getSteelSizeKey(c.frameBeam.name) : '100Ã—50Ã—2';
            var beamSizeName = c.frameBeam ? c.frameBeam.name : '100Ã—50Ã—2 RHS';
            var beamCount;
            if (c.isGable) {
                beamCount = c.connection === 'freestanding' ? 2 : (c.connection === 'riser' ? 3 : 2);
            } else {
                beamCount = c.connection === 'riser' ? 3 : (c.isRecvChan ? 1 : 2);
            }
            plan.push({
                label: 'Beams',
                sizeKey: beamSizeKey,
                sizeName: beamSizeName,
                cutMm: Math.round(Lmm),
                qty: beamCount,
                nesting: nestCuts(Math.round(Lmm), beamCount, getStockLengthsForSize(beamSizeKey), { onePerStick: true })
            });

            // Trusses (gable) or Rafters (skillion)
            if (c.isGable) {
                var trussSizeKey = c.steel ? getSteelSizeKey(c.steel.name) : '76Ã—38Ã—1.6';
                var trussSizeName = c.steel ? c.steel.name : '76Ã—38Ã—1.6';
                var trussCutMm = Math.round(c.rafter || (Wmm / Math.cos(c.pitchRad || 0)));
                plan.push({
                    label: 'Trusses',
                    sizeKey: trussSizeKey,
                    sizeName: trussSizeName,
                    cutMm: trussCutMm,
                    qty: c.nTruss || 4,
                    nesting: nestCuts(trussCutMm, c.nTruss || 4, getStockLengthsForSize(trussSizeKey))
                });
            } else {
                var rafterSizeKey = c.rafterSize ? getSteelSizeKey(c.rafterSize.name) : (c.steel ? getSteelSizeKey(c.steel.name) : '76Ã—38Ã—1.6');
                var rafterSizeName = c.rafterSize ? c.rafterSize.name : (c.steel ? c.steel.name : '76Ã—38Ã—1.6');
                var rafterCutMm = Math.round(c.rafter || Wmm);
                var rafterQty = c.rafterCalc ? c.rafterCalc.rafterCount : (c.nRafters || 4);
                plan.push({
                    label: 'Rafters',
                    sizeKey: rafterSizeKey,
                    sizeName: rafterSizeName,
                    cutMm: rafterCutMm,
                    qty: rafterQty,
                    nesting: nestCuts(rafterCutMm, rafterQty, getStockLengthsForSize(rafterSizeKey))
                });
            }

            // Purlins / Battens
            var purlinCount = 0;
            if (c.isGable) {
                purlinCount = (c.gableBattenCalc && c.gableBattenCalc.totalBattens > 0) ? c.gableBattenCalc.totalBattens : Math.max(2, Math.ceil(c.rafter / 1000 / 0.8)) * 2;
            } else {
                var bc = c.battenCalc;
                purlinCount = (bc && bc.battensNeeded > 0) ? bc.battensNeeded : 0;
            }
            if (purlinCount > 0) {
                var purlinSizeKey = c.purlinSize ? c.purlinSize.name.replace(' RHS', '') : '76Ã—38Ã—1.6';
                var purlinSizeName = c.purlinSize ? c.purlinSize.name : '76Ã—38Ã—1.6 RHS';
                plan.push({
                    label: c.isGable ? 'Purlins' : 'Battens',
                    sizeKey: purlinSizeKey,
                    sizeName: purlinSizeName,
                    cutMm: Math.round(Lmm),
                    qty: purlinCount,
                    nesting: nestCuts(Math.round(Lmm), purlinCount, getStockLengthsForSize(purlinSizeKey))
                });
            }

            // Flyover posts (small posts bolted to house rafters at setback position)
            if (!c.isGable && c.connection === 'flyover') {
                var strutCount = Math.max(2, Math.ceil(c.L / 1200));
                var strutSizeKey = c.framePost ? getSteelSizeKey(c.framePost.name) : '90Ã—90Ã—2';
                // Calculate post height from roof surface at setback to beam
                var setbackRise = (c.flyoverSetback || 600) * Math.tan((c.houseRoofPitch || 22.5) * Math.PI / 180);
                var flyoverPostH = Math.max(150, Math.round(setbackRise + (c.flyoverClearance || 150)));
                plan.push({
                    label: 'Flyover Posts',
                    sizeKey: strutSizeKey,
                    sizeName: c.framePost ? c.framePost.name : '90Ã—90Ã—2 SHS',
                    cutMm: flyoverPostH,
                    qty: strutCount,
                    nesting: nestCuts(flyoverPostH, strutCount, getStockLengthsForSize(strutSizeKey))
                });
            }

            // Flyover beam â€” uses user-selected beam size
            if (!c.isGable && c.connection === 'flyover') {
                var flyBeamKey = c.frameBeam ? getSteelSizeKey(c.frameBeam.name) : '150Ã—50Ã—2';
                plan.push({
                    label: 'Flyover Beam',
                    sizeKey: flyBeamKey,
                    sizeName: c.frameBeam ? c.frameBeam.name : '150Ã—50Ã—2 RHS',
                    cutMm: Math.round(Lmm),
                    qty: 1,
                    nesting: nestCuts(Math.round(Lmm), 1, getStockLengthsForSize(flyBeamKey))
                });
            }

            // Riser beam (connection=riser) â€” elbows are pre-made, not cut from stock
            if (c.connection === 'riser') {
                plan.push({
                    label: 'Riser Beam',
                    sizeKey: c.frameBeam ? getSteelSizeKey(c.frameBeam.name) : '100Ã—50Ã—2',
                    sizeName: c.frameBeam ? c.frameBeam.name : '100Ã—50Ã—2 RHS',
                    cutMm: Math.round(Lmm),
                    qty: 1,
                    nesting: nestCuts(Math.round(Lmm), 1, getStockLengthsForSize(c.frameBeam ? getSteelSizeKey(c.frameBeam.name) : '100Ã—50Ã—2'))
                });
            }

            // Cache on calc for other consumers
            c.steelNestingPlan = plan;
            return plan;
        }

        function getSteelCategory(desc) {
            const d = desc.toLowerCase();
            if (d.includes('76Ã—38') || d.includes('76x38') || d.includes('patio tub')) return 'PATIO_TUBE';
            if (d.includes('shs') || d.includes('post') || d.includes('strut')) return 'SHS';
            if (d.includes('c150') || d.includes('c200')) return 'RHS';
            return 'RHS';
        }

        function getSteelSizeKey(desc) {
            const d = desc.toLowerCase();
            if (d.includes('c200 purlin') || d.includes('c200')) return 'C200 Purlin';
            if (d.includes('c150 purlin') || d.includes('c150')) return 'C150 Purlin';
            if (d.includes('150Ã—50') || d.includes('150x50')) return '150Ã—50Ã—2';
            if (d.includes('125Ã—50') || d.includes('125x50')) return '125Ã—50Ã—2';
            if (d.includes('100Ã—50') || d.includes('100x50')) return '100Ã—50Ã—2';
            if (d.includes('150Ã—150') || d.includes('150x150')) return '150Ã—150Ã—3';
            if (d.includes('125Ã—125') || d.includes('125x125')) return '125Ã—125Ã—3';
            if (d.includes('100Ã—100') || d.includes('100x100')) return '100Ã—100Ã—2';
            if (d.includes('90Ã—90') || d.includes('90x90')) return '90Ã—90Ã—2';
            if (d.includes('76Ã—38') || d.includes('76x38')) return '76Ã—38Ã—1.6';
            if (d.includes('75Ã—75') || d.includes('75x75')) return '75Ã—75Ã—2';
            if (d.includes('75Ã—50') || d.includes('75x50')) return '75Ã—50Ã—2';
            if (d.includes('65Ã—65') || d.includes('65x65')) return '65Ã—65Ã—2';
            return null;
        }

        function isSteelItem(desc) {
            const d = desc.toLowerCase();
            return d.includes('post') || d.includes('beam') || d.includes('rafter') ||
                   d.includes('truss') || d.includes('batten') || d.includes('purlin') ||
                   d.includes('strut') || d.includes('flyover beam') || d.includes('flyover post');
        }

        // Gutter rates
        const GUTTER_RATES = { standard: 22, box: 45 };
        const FLASHING_RATES = { standard: 24, solarspan: 24 };
        const LABOUR_RATES = { roof_plumber_day: 800 };

        let storedRates = {};
        let jobRows = [];      // {desc, qty, length, unitCost, unitSell, isAddon, stockInfo}
        let labourRows = [];   // {desc, trades, days, dayRate, sell}
        let extrasRows = [];   // {desc, qty, unitCost, unitSell, type}
        let pricingState = {}; // cached pricing calcs for PDF access

        function loadRates() {
            try {
                const saved = localStorage.getItem('patioRates');
                storedRates = saved ? JSON.parse(saved) : { ...DEFAULT_RATES };
                // Merge in any new default keys missing from saved data
                Object.keys(DEFAULT_RATES).forEach(k => {
                    if (!(k in storedRates)) storedRates[k] = DEFAULT_RATES[k];
                });
            } catch (e) {
                storedRates = { ...DEFAULT_RATES };
            }
        }

        function saveRates() {
            localStorage.setItem('patioRates', JSON.stringify(storedRates));
        }

        function renderRatesPanel() {
            const body = document.getElementById('ratesBody');
            body.innerHTML = Object.entries(storedRates).map(([k, v]) =>
                `<tr><td>${k}</td><td><input type="number" class="rate-input" step="0.01" value="${v.toFixed(2)}" onchange="updateRate('${k}', this.value)"></td></tr>`
            ).join('');
        }

        function updateRate(key, val) {
            storedRates[key] = parseFloat(val) || 0;
            saveRates();
            buildJobRows();
            updatePricing();
        }

        function openRatesModal() {
            loadSettingsDefaults();
            renderRatesPanel();
            document.getElementById('ratesModal').style.display = '';
        }

        function saveSettingsDefaults() {
            var defs = {
                markup: parseFloat(document.getElementById('settingsDefaultMarkup').value) || 35,
                tradesCostHr: parseFloat(document.getElementById('settingsTradesCostHr').value) || 45,
                tradesSellHr: parseFloat(document.getElementById('settingsTradesSellHr').value) || 110,
                labourerCostHr: parseFloat(document.getElementById('settingsLabourerCostHr').value) || 35,
                labourerSellHr: parseFloat(document.getElementById('settingsLabourerSellHr').value) || 90,
                hoursPerDay: parseFloat(document.getElementById('settingsHoursPerDay').value) || 8,
                scopeFootings: parseFloat(document.getElementById('settingsScopeFootings').value) || 85,
                scopeDemo: parseFloat(document.getElementById('settingsScopeDemo').value) || 500,
                scopeCrane: parseFloat(document.getElementById('settingsScopeCrane').value) || 600,
                scopePermit: parseFloat(document.getElementById('settingsScopePermit').value) || 350,
                scopeSoakwell: parseFloat(document.getElementById('settingsScopeSoakwell').value) || 800,
                scopeSkip: parseFloat(document.getElementById('settingsScopeSkip').value) || 350,
                scopeDelivery: parseFloat(document.getElementById('settingsScopeDelivery').value) || 200,
                scopeElectrical: parseFloat(document.getElementById('settingsScopeElectrical').value) || 0,
                showWoCosts: document.getElementById('settingsShowWoCosts').checked,
                itemisedQuote: document.getElementById('settingsItemisedQuote').checked
            };
            try { localStorage.setItem('patioSettingsDefaults', JSON.stringify(defs)); } catch(e) {}
        }

        function loadSettingsDefaults() {
            try {
                var saved = localStorage.getItem('patioSettingsDefaults');
                if (saved) {
                    var d = JSON.parse(saved);
                    if (d.markup != null) document.getElementById('settingsDefaultMarkup').value = d.markup;
                    if (d.tradesCostHr != null) document.getElementById('settingsTradesCostHr').value = d.tradesCostHr;
                    if (d.tradesSellHr != null) document.getElementById('settingsTradesSellHr').value = d.tradesSellHr;
                    if (d.labourerCostHr != null) document.getElementById('settingsLabourerCostHr').value = d.labourerCostHr;
                    if (d.labourerSellHr != null) document.getElementById('settingsLabourerSellHr').value = d.labourerSellHr;
                    if (d.hoursPerDay != null) document.getElementById('settingsHoursPerDay').value = d.hoursPerDay;
                    if (d.scopeFootings != null) document.getElementById('settingsScopeFootings').value = d.scopeFootings;
                    if (d.scopeDemo != null) document.getElementById('settingsScopeDemo').value = d.scopeDemo;
                    if (d.scopeCrane != null) document.getElementById('settingsScopeCrane').value = d.scopeCrane;
                    if (d.scopePermit != null) document.getElementById('settingsScopePermit').value = d.scopePermit;
                    if (d.scopeSoakwell != null) document.getElementById('settingsScopeSoakwell').value = d.scopeSoakwell;
                    if (d.scopeSkip != null) document.getElementById('settingsScopeSkip').value = d.scopeSkip;
                    if (d.scopeDelivery != null) document.getElementById('settingsScopeDelivery').value = d.scopeDelivery;
                    if (d.scopeElectrical != null) document.getElementById('settingsScopeElectrical').value = d.scopeElectrical;
                    if (d.showWoCosts != null) document.getElementById('settingsShowWoCosts').checked = d.showWoCosts;
                    if (d.itemisedQuote != null) document.getElementById('settingsItemisedQuote').checked = d.itemisedQuote;
                }
            } catch(e) {}
        }

        function getSettingsDefaults() {
            try {
                var saved = localStorage.getItem('patioSettingsDefaults');
                if (saved) return JSON.parse(saved);
            } catch(e) {}
            return { markup: 35, dayRate: 400, trades: 2, days: 1.5, scopeFootings: 85, scopeDemo: 500, scopeCrane: 600, scopePermit: 350, scopeSoakwell: 800, scopeSkip: 350, scopeDelivery: 200, scopeElectrical: 0, showWoCosts: false, itemisedQuote: false };
        }


        function matchRate(desc) {
            const d = desc.toLowerCase();
            // Steel - SHS (posts/struts/risers)
            if (d.includes('65Ã—65') || d.includes('65x65')) return storedRates['65Ã—65Ã—2 SHS'] || 0;
            if (d.includes('75Ã—75') || d.includes('75x75')) return storedRates['75Ã—75Ã—2 SHS'] || 0;
            if (d.includes('90Ã—90') || d.includes('90x90')) return storedRates['90Ã—90Ã—2 SHS'] || 0;
            if (d.includes('100Ã—100') || d.includes('100x100')) return storedRates['100Ã—100Ã—2 SHS'] || 0;
            if (d.includes('125Ã—125') || d.includes('125x125')) return storedRates['125Ã—125Ã—3 SHS'] || 0;
            if (d.includes('150Ã—150') || d.includes('150x150')) return storedRates['150Ã—150Ã—3 SHS'] || 0;
            // Steel - RHS (beams/trusses/rafters)
            if (d.includes('c200 purlin') || d.includes('c200')) return storedRates['C200 Purlin'] || 0;
            if (d.includes('c150 purlin') || d.includes('c150')) return storedRates['C150 Purlin'] || 0;
            if (d.includes('76Ã—38') || d.includes('76x38')) return storedRates['76Ã—38Ã—1.6 RHS'] || 0;
            if (d.includes('125Ã—50') || d.includes('125x50')) return storedRates['125Ã—50Ã—2 RHS'] || 0;
            if (d.includes('75Ã—50') || d.includes('75x50')) return storedRates['75Ã—50Ã—2 RHS'] || 0;
            if (d.includes('150Ã—50') || d.includes('150x50')) return storedRates['150Ã—50Ã—2 RHS'] || 0;
            if (d.includes('100Ã—50') || d.includes('100x50')) return storedRates['100Ã—50Ã—2 RHS'] || 0;
            // Roofing
            if (d.includes('solarspan')) return storedRates['Solarspan 75mm'] || 0;
            if (d.includes('polycarb') && d.includes('laserlite')) return storedRates['Laserlite 2000 5-Rib'] || 0;
            if (d.includes('polycarb') && d.includes('corrugated')) return storedRates['Ampelite Solasafe Corrugated'] || storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('polycarb') && d.includes('ampelite')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('polycarb')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('trimdek') && d.includes('sheet')) return storedRates['Trimdek Colorbond'] || 0;
            if (d.includes('spandek') && d.includes('sheet')) return storedRates['Spandek Colorbond'] || 0;
            if (d.includes('sheet') && !d.includes('solarspan')) return storedRates['Corrugated Colorbond'] || 0;
            // Flashings
            if (d.includes('ridge cap') || d.includes('ridge flash')) return storedRates['Ridge Cap'] || 0;
            if (d.includes('barge')) return storedRates['Barge Flashing'] || 0;
            if (d.includes('back flash') || d.includes('wall flash')) return storedRates['Back Flashing'] || 0;
            if (d.includes('gutter flash')) return storedRates['Gutter Flashing'] || 0;
            // Gutters & drainage
            if (d.includes('box gutter')) return storedRates['Box Gutter'] || 0;
            if (d.includes('gutter') && !d.includes('box') && !d.includes('downpipe') && !d.includes('flash')) return storedRates['Quad Gutter 115mm'] || 0;
            if (d.includes('downpipe')) return storedRates['Downpipe 90mm'] || 0;
            // Extras
            if (d.includes('infill')) return storedRates['Gable Infill (sqm)'] || 0;
            if (d.includes('welded l') && d.includes('100Ã—50')) return storedRates['Riser 100Ã—50 (ea)'] || 60;
            if (d.includes('welded l') && d.includes('75Ã—50')) return storedRates['Riser 75Ã—50 (ea)'] || 55;
            if (d.includes('welded l') && d.includes('76Ã—38')) return storedRates['Riser 76Ã—38 (ea)'] || 50;
            if (d.includes('welded l')) return storedRates['Riser 76Ã—38 (ea)'] || 50;
            if (d.includes('rafter bracket')) return storedRates['Riser Bracket (ea)'] || 12;
            if (d.includes('riser') && d.includes('bracket')) return storedRates['Riser Bracket (ea)'] || 0;
            if (d.includes('kwikset') || d.includes('concrete bag')) return storedRates['Concrete Kwikset (bag)'] || 5;
            if (d.includes('channel') && !d.includes('gutter')) return storedRates['Back Flashing'] || 0;
            if (d.includes('batten')) return storedRates['76Ã—38Ã—1.6 RHS'] || 0;
            if (d.includes('tubing bracket')) return storedRates['Tubing Bracket (ea)'] || 0;
            if (d.includes('strut')) return storedRates['76Ã—38Ã—1.6 RHS'] || 0;
            if (d.includes('elbow')) return storedRates['Downpipe 90mm'] || 0;
            if (d.includes('fascia bracket')) return storedRates['Riser Bracket (ea)'] || 12;
            if (d.includes('fascia board')) return storedRates['Barge Flashing'] || 0;
            return 0;
        }

        function getItemLength(desc) {
            const c = calc;
            const d = desc.toLowerCase();
            const Lm = c.L / 1000;
            const Wm = c.W / 1000;
            if (d.includes('kwikset') || d.includes('concrete bag')) return 1;  // per bag
            if (d.includes('rafter bracket')) return 1;  // per piece (galv hardware)
            if (d.includes('post')) return c.postH / 1000;
            if (d.includes('barge') || d.includes('flashing') || d.includes('gutter') || d.includes('channel')) return Lm + 0.2;  // +200mm join allowance
            if (d.includes('beam') || d.includes('ridge') || d.includes('fascia board')) return Lm;
            if (d.includes('truss') || d.includes('rafter')) return c.rafter / 1000;
            if (d.includes('batten')) return Lm;  // battens run side-to-side = patio length
            if (d.includes('tubing bracket')) return 1;  // per piece
            if (d.includes('fascia bracket')) return 1;  // per piece
            if (d.includes('purlin')) return Lm;
            if (d.includes('sheet') && d.includes('solarspan')) return Math.ceil((c.rafter + 50) / 100) * 100 / 1000;
            if (d.includes('sheet')) return Math.ceil((c.rafter + 50) / 100) * 100 / 1000;
            if (d.includes('downpipe')) return Math.round(c.frontBeamY) / 1000 || 1.8;
            if (d.includes('strut')) return 0.5;
            if (d.includes('welded l')) return 0.5;
            if (d.includes('infill')) return c.rafter / 1000;
            if (d.includes('boot')) return 1;  // per piece
            return 1;
        }

        // Build jobRows from the materials list (called after rebuildAll)
        function buildJobRows() {
            const matRowEls = document.querySelectorAll('#matList .mat-row');
            // Preserve existing addon rows
            const addons = jobRows.filter(r => r.isAddon);
            jobRows = [];

            // Build nesting plan for steel items
            const nestingPlan = buildSteelNestingPlan();
            // Index nesting plan by label for quick lookup
            const nestingByLabel = {};
            nestingPlan.forEach(function(p) { nestingByLabel[p.label] = p; });

            matRowEls.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length < 2) return;
                const desc = row.dataset.desc || spans[0].textContent.trim();
                const qty = parseInt(spans[1].textContent.trim().replace('Ã—', '')) || 1;
                const length = getItemLength(desc);
                const unitCost = matchRate(desc);

                // Steel: use nesting-based stock costing
                if (isSteelItem(desc) && length > 0) {
                    const sizeKey = getSteelSizeKey(desc);
                    if (sizeKey && STEEL_RATES[sizeKey]) {
                        // Find matching nesting plan entry
                        var nestEntry = null;
                        var dLow = desc.toLowerCase();
                        if (dLow.includes('post') && nestingByLabel['Posts']) nestEntry = nestingByLabel['Posts'];
                        else if (dLow.includes('flyover beam') && nestingByLabel['Flyover Beam']) nestEntry = nestingByLabel['Flyover Beam'];
                        else if ((dLow.includes('flyover post') || dLow.includes('flyover strut')) && (nestingByLabel['Flyover Posts'] || nestingByLabel['Flyover Struts'])) nestEntry = nestingByLabel['Flyover Posts'] || nestingByLabel['Flyover Struts'];
                        else if (dLow.includes('riser beam') && nestingByLabel['Riser Beam']) nestEntry = nestingByLabel['Riser Beam'];
                        else if (dLow.includes('welded l') && nestingByLabel['Risers (Welded L)']) nestEntry = nestingByLabel['Risers (Welded L)'];
                        else if (dLow.includes('beam') && nestingByLabel['Beams']) nestEntry = nestingByLabel['Beams'];
                        else if (dLow.includes('truss') && nestingByLabel['Trusses']) nestEntry = nestingByLabel['Trusses'];
                        else if (dLow.includes('rafter') && nestingByLabel['Rafters']) nestEntry = nestingByLabel['Rafters'];
                        else if ((dLow.includes('batten') || dLow.includes('purlin')) && (nestingByLabel['Battens'] || nestingByLabel['Purlins'])) nestEntry = nestingByLabel['Battens'] || nestingByLabel['Purlins'];

                        if (nestEntry && nestEntry.nesting && !nestEntry.nesting.specialOrder) {
                            var n = nestEntry.nesting;
                            // Cost = total sticks Ã— stock length in metres Ã— $/m
                            var totalStockCost = 0;
                            n.sticks.forEach(function(st) {
                                totalStockCost += (st.stockLength / 1000) * STEEL_RATES[sizeKey];
                            });
                            var totalStockSell = +(totalStockCost * DEFAULT_SELL_MARKUP).toFixed(2);
                            jobRows.push({
                                desc: desc, qty: qty, length: length, unit: 'nested',
                                unitCost: totalStockCost, unitSell: totalStockSell,
                                isAddon: false, stockInfo: null, nestEntry: nestEntry
                            });
                            return;
                        }

                        // Fallback: per-piece stock costing
                        var stockLengths = getStockLengthsForSize(sizeKey);
                        var requiredMm = Math.round(length * 1000);
                        var stockInfo = calculateStockRequired(requiredMm, stockLengths);
                        var stockCostPerItem = (stockInfo.stockLength / 1000) * STEEL_RATES[sizeKey] * stockInfo.qty;
                        var perUnitSell = +(stockCostPerItem * DEFAULT_SELL_MARKUP).toFixed(2);
                        jobRows.push({ desc, qty, length, unit: 'stock', unitCost: stockCostPerItem, unitSell: perUnitSell, isAddon: false, stockInfo });
                        return;
                    }
                }

                // Check for riser items with fixed pricing
                var dLow2 = desc.toLowerCase();
                if (dLow2.includes('welded l')) {
                    var riserKey = getSteelSizeKey(desc);
                    var riserPrice = riserKey ? (RISER_PRICES[riserKey] || 0) : 0;
                    if (riserPrice > 0) {
                        var riserSell = +(riserPrice * DEFAULT_SELL_MARKUP).toFixed(2);
                        jobRows.push({ desc, qty, length: 1, unit: 'each', unitCost: riserPrice, unitSell: riserSell, isAddon: false });
                        return;
                    }
                }

                const unitSell = +(unitCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc, qty, length, unit: 'LM', unitCost, unitSell, isAddon: false, stockInfo: null });
            });
            // Auto-add fixings estimate based on patio area
            const c = calc;
            if (c.L && c.W) {
                const areaSqm = (c.L / 1000) * (c.W / 1000);
                const fixCost = storedRates['Fixings ($/sqm)'] || 2.50;
                const fixSell = +(fixCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc: 'Fixings (screws, anchors, silicone, foam)', qty: +areaSqm.toFixed(1), length: 1, unit: 'sqm', unitCost: fixCost, unitSell: fixSell, isAddon: false });
            }
            // Auto-add roof plumber day rate when box gutter is present
            if (c.houseGutter === 'box' && c.connection === 'riser') {
                const rpCost = LABOUR_RATES.roof_plumber_day;
                const rpSell = +(rpCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc: 'Roof Plumber (box gutter install)', qty: 1, length: 1, unit: 'each', unitCost: rpCost, unitSell: rpSell, isAddon: false });
            }
            // Re-append addons
            addons.forEach(a => { if (!a.unit) a.unit = 'each'; jobRows.push(a); });
        }

        const UNIT_OPTIONS = ['each', 'LM', 'sqm', 'hours', 'days', 'lot'];

        // Keep renderJobTable for compatibility (materials modal uses it internally)
        function renderJobTable() { /* now handled by materials modal */ }

        // Extras presets
        function addExtra(type) {
            const nPosts = calc.nPosts ? (calc.connection === 'freestanding' ? calc.nPosts * 2 : calc.nPosts) : 6;
            const sd = getSettingsDefaults();
            const mk = (sd.markup || 35) / 100 + 1; // markup multiplier
            const presets = {
                footings:    { desc: 'Concrete Footings (' + nPosts + ')', qty: nPosts, unitCost: sd.scopeFootings || 85, unitSell: Math.round((sd.scopeFootings || 85) * mk), type: 'footings' },
                electrical:  { desc: 'Electrical',        qty: 1,      unitCost: sd.scopeElectrical || 0, unitSell: Math.round((sd.scopeElectrical || 0) * mk), type: 'electrical' },
                downlights:  { desc: 'Downlights',        qty: 4,      unitCost: 50,  unitSell: 85,  type: 'downlights' },
                demo:        { desc: 'Demo/Removal',      qty: 1,      unitCost: sd.scopeDemo || 500, unitSell: Math.round((sd.scopeDemo || 500) * mk), type: 'demo' },
                delivery:    { desc: 'Delivery',           qty: 1,      unitCost: sd.scopeDelivery || 200, unitSell: Math.round((sd.scopeDelivery || 200) * mk), type: 'delivery' },
                crane:       { desc: 'Crane Hire',         qty: 1,      unitCost: sd.scopeCrane || 600, unitSell: Math.round((sd.scopeCrane || 600) * mk), type: 'crane' },
                permit:      { desc: 'Council/Permit',     qty: 1,      unitCost: sd.scopePermit || 350, unitSell: Math.round((sd.scopePermit || 350) * mk), type: 'permit' },
                soakwell:    { desc: 'Soakwell',           qty: 1,      unitCost: sd.scopeSoakwell || 800, unitSell: Math.round((sd.scopeSoakwell || 800) * mk), type: 'soakwell' },
                skip:        { desc: 'Skip Bin',           qty: 1,      unitCost: sd.scopeSkip || 350, unitSell: Math.round((sd.scopeSkip || 350) * mk), type: 'skip' },
                other:       { desc: '',                   qty: 1,      unitCost: 0,   unitSell: 0,   type: 'other' }
            };
            const p = presets[type];
            if (!p) return;
            extrasRows.push({ ...p });
            renderExtras();
            updatePricing();
        }

        function removeExtra(idx) {
            extrasRows.splice(idx, 1);
            renderExtras();
            updatePricing();
        }

        function renderExtras() {
            const container = document.getElementById('extrasRowsContainer');
            if (extrasRows.length === 0) {
                container.innerHTML = '';
                return;
            }
            container.innerHTML = extrasRows.map((r, i) => {
                const totalCost = r.qty * r.unitCost;
                const totalSell = r.qty * r.unitSell;
                return `<div class="extras-row">
                    <div class="ex-desc"><input type="text" class="ex-input desc-input" value="${(r.desc||'').replace(/"/g,'&quot;')}" placeholder="Description" onchange="extrasRows[${i}].desc=this.value"></div>
                    <div class="ex-field">Qty: <input type="number" class="ex-input" style="width:50px" value="${r.qty}" min="1" step="1" onchange="extrasRows[${i}].qty=parseFloat(this.value)||1;renderExtras();updatePricing()"></div>
                    <div class="ex-field">Cost: <input type="number" class="ex-input" value="${totalCost.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitCost=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <div class="ex-field">Sell: <input type="number" class="ex-input" value="${totalSell.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitSell=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <button class="ex-remove" onclick="removeExtra(${i})">&times;</button>
                </div>`;
            }).join('');
        }

        // Legacy addon compat: migrate old addon rows to extras on import
        function addSmartAddon(type) {
            const typeMap = { concrete: 'footings', electrical: 'electrical', downlights: 'downlights', demo: 'demo', fan: 'other', fascia: 'other', posts: 'other', permit: 'other' };
            addExtra(typeMap[type] || 'other');
        }
        function addCustomLine() { addExtra('other'); }
        function removeJobRow(idx) { jobRows.splice(idx, 1); updatePricing(); }

        // Labour â€” read from inline card inputs
        function getLabourFromCard() {
            const trades = parseFloat(document.getElementById('labTrades').value) || 0;
            const labourers = parseFloat(document.getElementById('labLabourers')?.value) || 0;
            const days = parseFloat(document.getElementById('labDays').value) || 0;
            const hoursPerDay = parseFloat(document.getElementById('settingsHoursPerDay')?.value) || 8;
            const tradeCostHr = parseFloat(document.getElementById('settingsTradesCostHr')?.value) || 45;
            const tradeSellHr = parseFloat(document.getElementById('settingsTradesSellHr')?.value) || 110;
            const labCostHr = parseFloat(document.getElementById('settingsLabourerCostHr')?.value) || 35;
            const labSellHr = parseFloat(document.getElementById('settingsLabourerSellHr')?.value) || 90;
            const tradeHours = trades * days * hoursPerDay;
            const labourerHours = labourers * days * hoursPerDay;
            const cost = (tradeHours * tradeCostHr) + (labourerHours * labCostHr);
            const sell = (tradeHours * tradeSellHr) + (labourerHours * labSellHr);
            // Sync hidden compat fields
            var drEl = document.getElementById('labDayRate');
            if (drEl) drEl.value = (trades > 0 && days > 0) ? Math.round(cost / (trades * days)) : 0;
            var slEl = document.getElementById('labSellInput');
            if (slEl) slEl.value = Math.round(sell);
            return { trades, labourers, days, cost, sell, dayRate: drEl ? drEl.value : 0 };
        }

        function updateLabour() {
            var lab = getLabourFromCard();
            var fmtShort = function(v) { return '$' + Math.round(v).toLocaleString(); };
            var costEl = document.getElementById('labCostDisplay');
            if (costEl) costEl.textContent = fmtShort(lab.cost);
            var sellEl = document.getElementById('labSellDisplay');
            if (sellEl) sellEl.textContent = fmtShort(lab.sell);
            updatePricing();
        }

        // Sync labourRows from card for PDF/export compat
        function syncLabourRows() {
            const l = getLabourFromCard();
            labourRows = [{ role: 'Skilled (Patio Install)', trades: l.trades, days: l.days, dayRate: l.dayRate, sell: l.sell }];
        }

        // Kept for export/import compat
        function renderLabourTable() {}
        function addLabourRole() {}
        function matchDayRate(role) {
            const r = role.toLowerCase();
            if (r.includes('electrician')) return storedRates['Electrician'] || 450;
            if (r.includes('labourer')) return storedRates['Labourer'] || 250;
            return storedRates['Skilled Trade'] || 400;
        }

        // Complexity â€” kept for export/import compat (hidden inputs)
        function updateComplexity() {}

        // ==================== MATERIALS MODAL ====================
        function openMaterialsModal() {
            var mk = document.getElementById('globalMarkupPct');
            var mmk = document.getElementById('modalMarkupPct');
            if (mk && mmk) mmk.value = mk.value;
            renderMaterialsModal();
            document.getElementById('materialsModal').style.display = '';
        }

        function closeMaterialsModal() {
            document.getElementById('materialsModal').style.display = 'none';
            updatePricing();
        }

        function renderMaterialsModal() {
            const showCost = document.getElementById('showCostToggle').checked;
            const body = document.getElementById('matModalBody');
            // Show only non-addon material rows
            const matRows = jobRows.filter(r => !r.isAddon);
            let totalSell = 0;

            body.innerHTML = matRows.map((r, realIdx) => {
                const i = jobRows.indexOf(r);
                const mult = (r.unit === 'LM') ? r.length : 1;
                const lineCost = r.qty * mult * r.unitCost;
                const lineSell = r.qty * mult * r.unitSell;
                totalSell += lineSell;
                const markupPct = r.unitCost > 0 ? ((r.unitSell - r.unitCost) / r.unitCost * 100) : 0;
                const globalMk = parseFloat((document.getElementById('modalMarkupPct') || document.getElementById('globalMarkupPct')).value) || 35;
                const isCustom = Math.abs(markupPct - globalMk) > 1;
                let qtyStr;
                if (r.unit === 'stock' && r.stockInfo) {
                    const si = r.stockInfo;
                    qtyStr = r.qty + (si.qty > 1 ? ' \u00D7 ' + si.qty : '') + ' \u00D7 ' + (si.stockLength / 1000).toFixed(1) + 'm stock';
                } else {
                    qtyStr = r.qty + (r.unit === 'LM' && r.length > 0 ? ' \u00D7 ' + r.length.toFixed(1) + 'm' : r.unit !== 'LM' ? ' ' + r.unit : '');
                }

                // Stock info annotation
                let descDisplay = r.desc;
                if (r.stockInfo) {
                    const si = r.stockInfo;
                    const cutLen = Math.round(r.length * 1000);
                    descDisplay += `<br><span style="font-size:10px;color:var(--sw-text-sec)">${cutLen}mm from ${si.stockLength}mm stock, ${si.waste}mm waste${si.needsJoiner ? ' (needs joiner)' : ''}</span>`;
                }

                return `<tr>
                    <td>${descDisplay}</td>
                    <td>${qtyStr}</td>
                    ${showCost ? `<td class="r mono">$${lineCost.toFixed(2)}</td>` : `<td class="r cost-col" style="display:none"></td>`}
                    <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" onchange="updateMatSellFromModal(${i},this.value)" style="width:90px"></td>
                    <td class="r"><span class="markup-badge${isCustom ? ' custom' : ''}">${markupPct.toFixed(0)}%${isCustom ? '*' : ''}</span></td>
                    <td></td>
                </tr>`;
            }).join('');

            // Also show custom addon rows in modal
            const addonRows = jobRows.filter(r => r.isAddon);
            if (addonRows.length > 0) {
                body.innerHTML += `<tr><td colspan="6" style="font-size:11px;font-weight:600;text-transform:uppercase;color:var(--sw-text-sec);padding-top:12px;border-bottom:1px solid var(--sw-border)">Custom Items</td></tr>`;
                body.innerHTML += addonRows.map(r => {
                    const i = jobRows.indexOf(r);
                    const mult = r.unit === 'LM' ? r.length : 1;
                    const lineSell = r.qty * mult * r.unitSell;
                    totalSell += lineSell;
                    return `<tr>
                        <td><input type="text" value="${r.desc}" style="width:160px;padding:4px 6px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px" onchange="jobRows[${i}].desc=this.value"></td>
                        <td><input type="number" value="${r.qty}" min="0" step="1" style="width:50px;padding:4px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px;text-align:center" onchange="jobRows[${i}].qty=parseFloat(this.value)||0;renderMaterialsModal()"></td>
                        ${showCost ? `<td class="r"><input type="number" value="${(r.qty*mult*r.unitCost).toFixed(2)}" min="0" step="1" style="width:80px" onchange="jobRows[${i}].unitCost=parseFloat(this.value)/(jobRows[${i}].qty*(jobRows[${i}].unit==='LM'?jobRows[${i}].length:1)||1);renderMaterialsModal()"></td>` : `<td style="display:none"></td>`}
                        <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" style="width:90px" onchange="updateMatSellFromModal(${i},this.value)"></td>
                        <td class="r"></td>
                        <td><button style="background:none;border:none;color:#ccc;cursor:pointer;font-size:16px" onclick="jobRows.splice(${i},1);renderMaterialsModal()" onmouseover="this.style.color='#FF3B30'" onmouseout="this.style.color='#ccc'">&times;</button></td>
                    </tr>`;
                }).join('');
            }

            // Update cost column visibility (header + all cost cells)
            document.querySelectorAll('.mat-modal-table .cost-col').forEach(el => el.style.display = showCost ? '' : 'none');

            document.getElementById('matModalTotal').textContent = '$' + totalSell.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        function updateMatSellFromModal(idx, val) {
            const r = jobRows[idx];
            const mult = (r.unit === 'LM') ? r.length : 1;
            const totalQty = r.qty * mult;
            r.unitSell = totalQty > 0 ? parseFloat(val) / totalQty : 0;
            renderMaterialsModal();
        }

        // Toggle client-safe view: hides costs, margins, markups
        function toggleClientMode() {
            document.body.classList.toggle('client-mode');
            var isClient = document.body.classList.contains('client-mode');
            var label = isClient ? 'Scoper View' : 'Client View';
            ['clientModeBtn', 'clientModeBtnTop'].forEach(function(id) {
                var b = document.getElementById(id);
                if (b) {
                    b.textContent = label;
                    if (isClient) { b.style.background = 'var(--sw-orange)'; b.style.color = 'white'; b.style.borderColor = 'var(--sw-orange)'; }
                    else { b.style.background = 'white'; b.style.color = 'var(--sw-text-sec)'; b.style.borderColor = 'var(--sw-border)'; }
                }
            });
        }

        function applyMarkupAll(fromModal) {
            var srcId = fromModal ? 'modalMarkupPct' : 'globalMarkupPct';
            const pct = parseFloat(document.getElementById(srcId).value) || 35;
            // Sync both markup inputs
            var gEl = document.getElementById('globalMarkupPct');
            var mEl = document.getElementById('modalMarkupPct');
            if (gEl) gEl.value = pct;
            if (mEl) mEl.value = pct;
            jobRows.forEach(r => {
                if (!r.isAddon) {
                    if (r.unit === 'nested') {
                        r.unitSell = +(r.unitCost * (1 + pct / 100)).toFixed(2);
                    } else {
                        r.unitSell = +(r.unitCost * (1 + pct / 100)).toFixed(2);
                    }
                }
            });
            updatePricing();
        }

        function addCustomMaterialRow() {
            jobRows.push({ desc: 'Custom item', qty: 1, length: 1, unit: 'each', unitCost: 0, unitSell: 0, isAddon: true });
            renderMaterialsModal();
        }

        // ==================== PATIO MATERIALS TABLE ====================
        function categorizeJobRow(desc) {
            var d = desc.toLowerCase();
            if (d.includes('post') || d.includes('beam') || d.includes('truss') || d.includes('rafter') ||
                d.includes('purlin') || d.includes('batten') || d.includes('strut') || d.includes('bracket') ||
                d.includes('riser')) return 'Structure';
            if (d.includes('sheet') || d.includes('solarspan') || d.includes('trimdek') || d.includes('corrugated') ||
                d.includes('ridge cap') || d.includes('polycarb') || d.includes('spanplus')) return 'Roofing';
            if (d.includes('gutter') || d.includes('downpipe') || d.includes('box gutter')) return 'Drainage';
            if (d.includes('barge') || d.includes('infill') || d.includes('flashing') || d.includes('fascia') ||
                d.includes('channel')) return 'Finishing';
            return 'Fixings';
        }

        function pmItemName(desc) {
            var d = desc.toLowerCase();
            if (d.includes('post'))         return 'Posts';
            if (d.includes('rafter bracket')) return 'Rafter Brackets';
            if (d.includes('riser beam gutter')) return 'Riser Beam Gutter';
            if (d.includes('riser beam'))   return 'Riser Beam';
            if (d.includes('riser piece')) return 'Riser Pieces';
            if (d.includes('welded l'))  return 'Risers (Welded L)';
            if (d.includes('flyover beam')) return 'Flyover Beam';
            if (d.includes('flyover post')) return 'Flyover Posts';
            if (d.includes('flyover strut'))return 'Flyover Posts';
            if (d.includes('beam'))         return 'Beams';
            if (d.includes('truss'))        return 'Trusses';
            if (d.includes('rafter'))       return 'Rafters';
            if (d.includes('batten'))       return 'Battens';
            if (d.includes('tubing bracket')) return 'Tubing Brackets';
            if (d.includes('fascia bracket')) return 'Fascia Brackets';
            if (d.includes('purlin'))       return 'Purlins';
            if (d.includes('ridge cap'))    return 'Ridge Cap';
            if (d.includes('downpipe'))     return 'Downpipes';
            if (d.includes('box gutter'))   return 'Box Gutter';
            if (d.includes('gutter'))       return 'Gutter';
            if (d.includes('barge'))        return 'Barge Flashings';
            if (d.includes('back flashing'))return 'Back Flashing';
            if (d.includes('gutter flashing'))return 'Gutter Flashing';
            if (d.includes('infill'))       return 'Gable Infill';
            if (d.includes('fascia board')) return 'Fascia Board (House Wall)';
            if (d.includes('channel'))      return 'Receiving Channel';
            if (d.includes('kwikset'))      return 'Kwikset Concrete';
            if (d.includes('polycarb'))     return 'Polycarb Sheets';
            if (d.includes('sheet'))        return 'Sheets';
            if (d.includes('fixing'))       return 'Fixings';
            if (d.includes('roof plumber')) return 'Roof Plumber';
            return desc;
        }

        function pmSize(desc) {
            var d = desc.toLowerCase();
            if (d.includes('65\u00D765'))    return '65\u00D765\u00D72 SHS';
            if (d.includes('75\u00D775'))    return '75\u00D775\u00D72 SHS';
            if (d.includes('90\u00D790'))    return '90\u00D790\u00D72 SHS';
            if (d.includes('100\u00D7100'))  return '100\u00D7100\u00D72 SHS';
            if (d.includes('125\u00D7125'))  return '125\u00D7125\u00D73 SHS';
            if (d.includes('150\u00D7150'))  return '150\u00D7150\u00D73 SHS';
            if (d.includes('c200'))     return 'C200 Purlin';
            if (d.includes('c150'))     return 'C150 Purlin';
            if (d.includes('150\u00D750\u00D73')) return '150\u00D750\u00D73 RHS';
            if (d.includes('150\u00D750'))   return '150\u00D750\u00D72 RHS';
            if (d.includes('125\u00D750'))   return '125\u00D750\u00D72 RHS';
            if (d.includes('100\u00D750'))   return '100\u00D750\u00D72 RHS';
            if (d.includes('75\u00D750'))    return '75\u00D750\u00D72 RHS';
            if (d.includes('76\u00D738'))    return '76\u00D738\u00D71.6 RHS';
            if (d.includes('solarspan'))return 'Insulated';
            if (d.includes('trimdek'))  return 'Trimdek';
            if (d.includes('corrugated'))return 'Corrugated';
            if (d.includes('spanplus')) return 'SpanPlus';
            if (d.includes('115mm'))    return '115mm Quad';
            return '\u2014';
        }

        function pmColour(desc) {
            var d = desc.toLowerCase();
            if (d.includes('post') || d.includes('beam') || d.includes('purlin') ||
                d.includes('batten') || d.includes('bracket') || d.includes('truss') ||
                d.includes('rafter') || d.includes('strut') || d.includes('riser') ||
                d.includes('barge') || d.includes('gutter') || d.includes('downpipe') ||
                d.includes('ridge') || d.includes('flashing') || d.includes('channel'))
                return steelColor ? steelColor.name : '\u2014';
            if (d.includes('polycarb')) return '\u2014';
            if (d.includes('sheet') || d.includes('infill'))
                return sheetColor ? sheetColor.name : '\u2014';
            return '\u2014';
        }

        function pmNestingTooltip(r) {
            if (r.nestEntry && r.nestEntry.nesting) {
                var n = r.nestEntry.nesting;
                if (n.specialOrder) return 'SPECIAL ORDER required';
                var stockM = (n.stockLength / 1000).toFixed(1);
                var tip = n.totalSticks + '\u00D7 ' + stockM + 'm stock';
                if (n.piecesPerStick > 1) tip += ', ' + n.piecesPerStick + ' pcs/stick';
                tip += ', ' + Math.round(n.totalWaste) + 'mm waste';
                return tip;
            }
            if (r.stockInfo) {
                var si = r.stockInfo;
                return si.qty + '\u00D7 ' + (si.stockLength / 1000).toFixed(1) + 'm stock, ' + si.waste + 'mm waste';
            }
            return '';
        }

        function renderPatioMaterialsTable() {
            var container = document.getElementById('patioMaterialsTable');
            if (!container) return;
            var matRows = jobRows.filter(function(r) { return !r.isAddon; });
            if (matRows.length === 0) {
                container.innerHTML = '<div style="font-size:12px;color:var(--sw-text-sec);padding:8px 0;font-style:italic">No materials calculated yet</div>';
                return;
            }

            // Group by category
            var cats = ['Structure', 'Roofing', 'Drainage', 'Finishing', 'Fixings'];
            var grouped = {};
            cats.forEach(function(c) { grouped[c] = []; });
            matRows.forEach(function(r, idx) {
                var cat = categorizeJobRow(r.desc);
                grouped[cat].push({ row: r, idx: jobRows.indexOf(r) });
            });

            var html = '<table class="pm-table"><thead><tr>' +
                '<th>Item</th><th>Size</th><th class="r">Qty</th><th class="r">Length</th><th>Colour</th>' +
                '<th class="r scoper-only">Cost</th><th class="r">Price</th><th class="r scoper-only">Markup</th><th class="scoper-only" style="width:28px"></th>' +
                '</tr></thead><tbody>';

            cats.forEach(function(cat) {
                if (grouped[cat].length === 0) return;
                html += '<tr class="pm-cat-hdr"><td colspan="9">' + cat + '</td></tr>';
                grouped[cat].forEach(function(item) {
                    var r = item.row;
                    var i = item.idx;
                    var mult = (r.unit === 'LM') ? r.length : 1;
                    var lineCost, lineSell;
                    if (r.unit === 'nested') {
                        lineCost = r.unitCost;
                        lineSell = r.unitSell;
                    } else {
                        lineCost = r.qty * mult * r.unitCost;
                        lineSell = r.qty * mult * r.unitSell;
                    }
                    var markupPct = lineCost > 0 ? ((lineSell - lineCost) / lineCost * 100) : 0;
                    var mClass = markupPct > 30 ? ' high' : markupPct < 20 ? ' low' : '';

                    // Length display
                    var lenStr = '\u2014';
                    if (r.length > 0 && r.unit !== 'sqm' && r.unit !== 'each') {
                        lenStr = Math.round(r.length * 1000) + 'mm';
                    }

                    // Qty with nesting tooltip
                    var tip = pmNestingTooltip(r);
                    var qtyStr = r.qty + '\u00D7';
                    if (tip) qtyStr = '<span title="' + tip.replace(/"/g, '&quot;') + '" style="cursor:help;border-bottom:1px dotted var(--sw-text-sec)">' + qtyStr + '</span>';

                    html += '<tr>' +
                        '<td>' + pmItemName(r.desc) + '</td>' +
                        '<td style="font-size:10px;font-family:\'SF Mono\',monospace">' + pmSize(r.desc) + '</td>' +
                        '<td class="r" style="font-weight:600;color:var(--sw-orange)">' + qtyStr + '</td>' +
                        '<td class="r">' + lenStr + '</td>' +
                        '<td style="font-size:10px;color:var(--sw-text-sec)">' + pmColour(r.desc) + '</td>' +
                        '<td class="r cost-cell scoper-only">$' + lineCost.toFixed(0) + '</td>' +
                        '<td class="r"><input type="number" class="pm-sell-input" value="' + lineSell.toFixed(0) + '" min="0" step="5" onchange="updatePmSell(' + i + ',this.value)"></td>' +
                        '<td class="r scoper-only"><span class="markup-badge' + mClass + '">' + markupPct.toFixed(0) + '%</span></td>' +
                        '<td class="scoper-only"><button class="pm-dupe-btn" onclick="dupeToAdditional(' + i + ')" title="Duplicate to Additional Materials">&#8853;</button></td>' +
                        '</tr>';
                });
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function updatePmSell(idx, val) {
            var r = jobRows[idx];
            if (!r) return;
            var newSell = parseFloat(val) || 0;
            if (r.unit === 'nested') {
                r.unitSell = newSell;
            } else {
                var mult = (r.unit === 'LM') ? r.length : 1;
                var totalQty = r.qty * mult;
                r.unitSell = totalQty > 0 ? newSell / totalQty : 0;
            }
            updatePricing();
        }

        // ==================== ADDITIONAL MATERIALS ====================
        var additionalMaterials = [];

        function dupeToAdditional(jobRowIdx) {
            var r = jobRows[jobRowIdx];
            if (!r) return;
            var mult = (r.unit === 'LM') ? r.length : 1;
            var lineCost, lineSell;
            if (r.unit === 'nested') { lineCost = r.unitCost; lineSell = r.unitSell; }
            else { lineCost = r.qty * mult * r.unitCost; lineSell = r.qty * mult * r.unitSell; }
            additionalMaterials.push({ desc: r.desc, qty: 1, unitCost: Math.round(lineCost), unitSell: Math.round(lineSell) });
            renderAdditionalMaterials();
            updatePricing();
            // Flash the additional materials section briefly
            var amSec = document.getElementById('additionalMaterialsTable');
            if (amSec) { amSec.style.outline = '2px solid var(--sw-orange)'; setTimeout(function() { amSec.style.outline = ''; }, 800); }
        }

        function addAdditionalMaterial(prefill) {
            var m = { desc: '', qty: 1, unitCost: 0, unitSell: 0 };
            if (prefill) { m.desc = prefill.desc || ''; m.qty = prefill.qty || 1; m.unitCost = prefill.unitCost || 0; m.unitSell = prefill.unitSell || 0; }
            additionalMaterials.push(m);
            renderAdditionalMaterials();
            updatePricing();
        }

        function removeAdditionalMaterial(idx) {
            additionalMaterials.splice(idx, 1);
            renderAdditionalMaterials();
            updatePricing();
        }

        function quickAddMaterial(type) {
            var sd = getSettingsDefaults();
            var mk = (sd.markup || 35) / 100 + 1;
            var presets = {
                electrical: { desc: 'Electrical - ', qty: 1, unitCost: sd.scopeElectrical || 0, unitSell: Math.round((sd.scopeElectrical || 0) * mk) },
                post:       { desc: 'Additional post - 90\u00D790\u00D72 SHS', qty: 1, unitCost: 120, unitSell: Math.round(120 * mk) },
                skip:       { desc: 'Skip bin hire', qty: 1, unitCost: sd.scopeSkip || 350, unitSell: Math.round((sd.scopeSkip || 350) * mk) },
                permit:     { desc: 'Council permit application', qty: 1, unitCost: sd.scopePermit || 350, unitSell: Math.round((sd.scopePermit || 350) * mk) },
                other:      { desc: '', qty: 1, unitCost: 0, unitSell: 0 }
            };
            var p = presets[type] || presets.other;
            addAdditionalMaterial(p);
            // Focus the description field of the newly added row
            setTimeout(function() {
                var inputs = document.querySelectorAll('#additionalMaterialsTable .am-table input[type="text"]');
                if (inputs.length > 0) inputs[inputs.length - 1].focus();
            }, 50);
        }

        function ensureMinAdditionalRows() {
            // Ensure at least 5 visible rows in the table
            var minRows = 5;
            while (additionalMaterials.length < minRows) {
                additionalMaterials.push({ desc: '', qty: 1, unitCost: 0, unitSell: 0 });
            }
            // Auto-add row if last row has content
            var last = additionalMaterials[additionalMaterials.length - 1];
            if (last && (last.desc || last.unitCost > 0 || last.unitSell > 0)) {
                additionalMaterials.push({ desc: '', qty: 1, unitCost: 0, unitSell: 0 });
            }
        }

        function renderAdditionalMaterials() {
            var container = document.getElementById('additionalMaterialsTable');
            if (!container) return;

            ensureMinAdditionalRows();

            var html = '<table class="am-table"><thead><tr><th>Description</th><th class="r">Qty</th><th class="r">Cost</th><th class="r">Sell</th><th style="width:20px"></th></tr></thead><tbody>';
            additionalMaterials.forEach(function(m, i) {
                var isEmpty = !m.desc && m.unitCost === 0 && m.unitSell === 0;
                html += '<tr class="' + (isEmpty ? 'am-empty-row' : '') + '">' +
                    '<td><input type="text" data-am-idx="' + i + '" data-am-col="0" value="' + (m.desc || '').replace(/"/g, '&quot;') + '" placeholder="Item description" oninput="amCellUpdate(' + i + ',\'desc\',this.value)" onkeydown="amTabNav(event,' + i + ',0)"></td>' +
                    '<td><input type="number" data-am-idx="' + i + '" data-am-col="1" value="' + m.qty + '" min="1" step="1" style="width:50px" oninput="amCellUpdate(' + i + ',\'qty\',this.value)" onkeydown="amTabNav(event,' + i + ',1)"></td>' +
                    '<td><input type="number" data-am-idx="' + i + '" data-am-col="2" value="' + (m.qty * m.unitCost > 0 ? (m.qty * m.unitCost).toFixed(0) : '') + '" min="0" step="5" placeholder="0" oninput="amCellUpdate(' + i + ',\'cost\',this.value)" onkeydown="amTabNav(event,' + i + ',2)"></td>' +
                    '<td><input type="number" data-am-idx="' + i + '" data-am-col="3" value="' + (m.qty * m.unitSell > 0 ? (m.qty * m.unitSell).toFixed(0) : '') + '" min="0" step="5" placeholder="0" oninput="amCellUpdate(' + i + ',\'sell\',this.value)" onkeydown="amTabNav(event,' + i + ',3)"></td>' +
                    '<td><button class="am-del" onclick="removeAdditionalMaterial(' + i + ')" title="Remove">&times;</button></td>' +
                    '</tr>';
            });
            html += '</tbody></table>';
            container.innerHTML = html;

            // Show subtotal if any real rows
            var hasReal = additionalMaterials.some(function(m) { return m.desc || m.unitCost > 0 || m.unitSell > 0; });
            var sub = document.getElementById('addMatSubtotal');
            if (sub) sub.style.display = hasReal ? '' : 'none';
        }

        function amCellUpdate(idx, field, val) {
            var m = additionalMaterials[idx];
            if (!m) return;
            if (field === 'desc') { m.desc = val; }
            else if (field === 'qty') { m.qty = parseFloat(val) || 1; }
            else if (field === 'cost') { m.unitCost = (parseFloat(val) || 0) / (m.qty || 1); }
            else if (field === 'sell') { m.unitSell = (parseFloat(val) || 0) / (m.qty || 1); }
            // Auto-add row if typing in last row
            if (idx === additionalMaterials.length - 1 && (m.desc || m.unitCost > 0 || m.unitSell > 0)) {
                additionalMaterials.push({ desc: '', qty: 1, unitCost: 0, unitSell: 0 });
                // Re-render but try to preserve focus
                var activeEl = document.activeElement;
                var activeIdx = activeEl ? activeEl.getAttribute('data-am-idx') : null;
                var activeCol = activeEl ? activeEl.getAttribute('data-am-col') : null;
                renderAdditionalMaterials();
                if (activeIdx !== null && activeCol !== null) {
                    var target = document.querySelector('#additionalMaterialsTable input[data-am-idx="' + activeIdx + '"][data-am-col="' + activeCol + '"]');
                    if (target) target.focus();
                }
            }
            updatePricing();
        }

        function amTabNav(e, rowIdx, colIdx) {
            if (e.key !== 'Tab') return;
            var maxCol = 3;
            var nextRow = rowIdx, nextCol = colIdx;
            if (e.shiftKey) {
                // Shift+Tab: go back
                nextCol--;
                if (nextCol < 0) { nextCol = maxCol; nextRow--; }
            } else {
                // Tab: go forward
                nextCol++;
                if (nextCol > maxCol) { nextCol = 0; nextRow++; }
            }
            if (nextRow < 0 || nextRow >= additionalMaterials.length) return; // let default browser behavior handle
            var target = document.querySelector('#additionalMaterialsTable input[data-am-idx="' + nextRow + '"][data-am-col="' + nextCol + '"]');
            if (target) { e.preventDefault(); target.focus(); target.select(); }
        }

        // ==================== MAIN PRICING UPDATE ====================
        function updatePricing() {
            const fmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            const fmtShort = v => '$' + Math.round(v).toLocaleString();

            // Render the patio materials table
            renderPatioMaterialsTable();
            renderAdditionalMaterials();

            // Materials from jobRows
            let matCost = 0, matSell = 0;
            jobRows.forEach(r => {
                if (r.unit === 'nested') {
                    matCost += r.unitCost;
                    matSell += r.unitSell;
                } else {
                    const mult = (r.unit === 'LM') ? r.length : 1;
                    matCost += r.qty * mult * r.unitCost;
                    matSell += r.qty * mult * r.unitSell;
                }
            });

            // Patio materials subtotal display
            const matMarkup = matCost > 0 ? ((matSell - matCost) / matCost * 100) : 0;
            var matSellEl = document.getElementById('matSellDisplay');
            if (matSellEl) matSellEl.textContent = fmtShort(matSell);
            var matCostEl = document.getElementById('matCostDisplay');
            if (matCostEl) matCostEl.textContent = fmtShort(matCost);
            var matMkEl = document.getElementById('matMarkupPct');
            if (matMkEl) matMkEl.textContent = matMarkup.toFixed(0) + '%';

            // Additional materials (only count rows with actual data)
            let addMatCost = 0, addMatSell = 0;
            additionalMaterials.forEach(r => {
                if (r.desc || r.unitCost > 0 || r.unitSell > 0) {
                    addMatCost += r.qty * r.unitCost;
                    addMatSell += r.qty * r.unitSell;
                }
            });
            var hasRealAddMat = additionalMaterials.some(function(r) { return r.desc || r.unitCost > 0 || r.unitSell > 0; });
            var addMatSubEl = document.getElementById('addMatSubtotal');
            if (addMatSubEl) addMatSubEl.style.display = hasRealAddMat ? '' : 'none';
            var addMatSellEl = document.getElementById('addMatSellDisplay');
            if (addMatSellEl) addMatSellEl.textContent = fmtShort(addMatSell);
            var addMatCostEl = document.getElementById('addMatCostDisplay');
            if (addMatCostEl) addMatCostEl.textContent = fmtShort(addMatCost);

            // Labour from card inputs
            const lab = getLabourFromCard();
            const labCost = lab.cost;
            const labSell = lab.sell;
            var labCostEl = document.getElementById('labCostDisplay');
            if (labCostEl) labCostEl.textContent = fmtShort(labCost);
            var labSellEl = document.getElementById('labSellDisplay');
            if (labSellEl) labSellEl.textContent = fmtShort(labSell);
            syncLabourRows();

            // Scope items (extras)
            let extrasCost = 0, extrasSell = 0;
            extrasRows.forEach(r => {
                extrasCost += r.qty * r.unitCost;
                extrasSell += r.qty * r.unitSell;
            });
            var scopeSubEl = document.getElementById('scopeSubtotal');
            if (scopeSubEl) scopeSubEl.style.display = extrasRows.length > 0 ? '' : 'none';
            var scopeSellEl = document.getElementById('scopeSellDisplay');
            if (scopeSellEl) scopeSellEl.textContent = fmtShort(extrasSell);

            // Demo cost
            const demoCost = calculateDemoCost();

            // Totals (include additional materials)
            const totalCost = matCost + addMatCost + labCost + extrasCost + demoCost;
            const totalSell = matSell + addMatSell + labSell + extrasSell + demoCost;
            const gst = totalSell * 0.10;
            const totalIncGST = totalSell + gst;
            const margin = totalSell - totalCost;
            const marginPct = totalSell > 0 ? (margin / totalSell * 100) : 0;

            // Totals table
            var ttEl = function(id, val) { var el = document.getElementById(id); if (el) el.textContent = fmtShort(val); };
            ttEl('ttMatCost', matCost); ttEl('ttMatSell', matSell);
            ttEl('ttAddCost', addMatCost); ttEl('ttAddSell', addMatSell);
            var ttAddRow = document.getElementById('ttAddRow');
            if (ttAddRow) ttAddRow.style.display = hasRealAddMat ? '' : 'none';
            ttEl('ttScopeCost', extrasCost + demoCost); ttEl('ttScopeSell', extrasSell + demoCost);
            var ttScopeRow = document.getElementById('ttScopeRow');
            if (ttScopeRow) ttScopeRow.style.display = (extrasSell + demoCost) > 0 ? '' : 'none';
            ttEl('ttLabCost', labCost); ttEl('ttLabSell', labSell);
            ttEl('ttSubCost', totalCost); ttEl('ttSubSell', totalSell);
            ttEl('ttGst', gst); ttEl('ttTotal', totalIncGST);
            var ttMarginEl = document.getElementById('ttMargin');
            if (ttMarginEl) {
                ttMarginEl.textContent = fmtShort(margin) + ' (' + marginPct.toFixed(1) + '%)';
                ttMarginEl.style.color = marginPct > 20 ? '#34C759' : marginPct >= 10 ? '#FF9500' : '#FF3B30';
            }

            // Total card + breakdown
            var totalAmtEl = document.getElementById('totalAmountDisplay');
            if (totalAmtEl) totalAmtEl.textContent = 'TOTAL ' + fmtShort(totalIncGST) + ' inc GST';
            var bdMatEl = document.getElementById('bdMatVal');
            if (bdMatEl) bdMatEl.textContent = fmtShort(matSell);
            var bdAddEl = document.getElementById('bdAddVal');
            if (bdAddEl) { bdAddEl.textContent = fmtShort(addMatSell); bdAddEl.parentElement.style.display = addMatSell > 0 ? '' : 'none'; }
            var bdScopeEl = document.getElementById('bdScopeVal');
            if (bdScopeEl) { bdScopeEl.textContent = fmtShort(extrasSell + demoCost); bdScopeEl.parentElement.style.display = (extrasSell + demoCost) > 0 ? '' : 'none'; }
            var bdLabEl = document.getElementById('bdLabVal');
            if (bdLabEl) bdLabEl.textContent = fmtShort(labSell);

            // Sticky price card in right panel
            var rpPT = document.getElementById('rpPriceTotal');
            if (rpPT) rpPT.textContent = fmtShort(totalIncGST) + ' inc GST';
            // Sticky margin
            var rpMg = document.getElementById('rpPriceMargin');
            if (rpMg) {
                rpMg.textContent = fmtShort(margin) + ' margin (' + marginPct.toFixed(0) + '%)';
                rpMg.style.color = marginPct > 20 ? '#34C759' : marginPct >= 10 ? '#FF9500' : '#FF3B30';
            }
            // Sticky breakdown
            var allMatSell = matSell + addMatSell;
            var rpBdMat = document.getElementById('rpBdMat');
            if (rpBdMat) rpBdMat.textContent = fmtShort(allMatSell);
            var rpBdLab = document.getElementById('rpBdLab');
            if (rpBdLab) rpBdLab.textContent = fmtShort(labSell);
            var rpBdScopeRow = document.getElementById('rpBdScopeRow');
            var rpBdScope = document.getElementById('rpBdScope');
            if (rpBdScopeRow) rpBdScopeRow.style.display = (extrasSell + demoCost) > 0 ? '' : 'none';
            if (rpBdScope) rpBdScope.textContent = fmtShort(extrasSell + demoCost);
            var rpBdSub = document.getElementById('rpBdSubtotal');
            if (rpBdSub) rpBdSub.textContent = fmtShort(totalSell);
            var rpBdGst = document.getElementById('rpBdGst');
            if (rpBdGst) rpBdGst.textContent = fmtShort(gst);

            const marginEl = document.getElementById('totalMarginDisplay');
            if (marginEl) {
                const marginIcon = marginPct > 20 ? '  \u2713' : marginPct >= 10 ? '' : '  \u2717';
                marginEl.textContent = 'Margin ' + fmtShort(margin) + ' (' + marginPct.toFixed(1) + '%)' + marginIcon;
                if (marginPct > 20) {
                    marginEl.className = 'total-margin margin-green';
                } else if (marginPct >= 10) {
                    marginEl.className = 'total-margin margin-orange';
                } else {
                    marginEl.className = 'total-margin margin-red';
                }
            }

            // Cache pricing state for PDF generators
            pricingState = {
                matCost, matSell, addMatCost, addMatSell, labCost, labSell, extrasCost, extrasSell,
                totalCost, totalSell, gst, totalIncGST, margin, marginPct,
                fmt
            };
        }

        // ==================== COLLAPSIBLE SECTIONS ====================
        const SECTION_IDS = ['sec-job', 'sec-design', 'sec-structure', 'sec-truss', 'sec-battens', 'sec-finishing', 'sec-extras', 'sec-pricing', 'sec-notes'];
        const DEFAULT_COLLAPSED = ['sec-design', 'sec-structure', 'sec-truss', 'sec-battens', 'sec-finishing', 'sec-extras', 'sec-notes', 'sec-pricing'];

        function loadCollapseState() {
            try {
                const saved = localStorage.getItem('patioCollapseState');
                return saved ? JSON.parse(saved) : null;
            } catch(e) { return null; }
        }

        function saveCollapseState() {
            const state = {};
            SECTION_IDS.forEach(id => {
                const hdr = document.querySelector('#' + id + ' > .collapse-header');
                if (hdr) state[id] = hdr.classList.contains('collapsed');
            });
            localStorage.setItem('patioCollapseState', JSON.stringify(state));
        }

        function toggleSection(id) {
            const sec = document.getElementById(id);
            if (!sec) return;
            const hdr = sec.querySelector('.collapse-header');
            const body = sec.querySelector('.collapse-body');
            if (!hdr || !body) return;
            const isCollapsed = hdr.classList.contains('collapsed');
            if (isCollapsed) {
                // Expand
                hdr.classList.remove('collapsed');
                body.style.maxHeight = body.scrollHeight + 'px';
                body.classList.remove('shut');
                setTimeout(() => {
                    body.style.maxHeight = '';
                    if (id === 'sec-truss') { resizeTruss(); if (trussRend) trussRend.render(trussScene, trussCam); }
                    if (id === 'sec-flashings') { updateFlashSummary(); }
                }, 350);
            } else {
                // Collapse
                body.style.maxHeight = body.scrollHeight + 'px';
                requestAnimationFrame(() => {
                    body.style.maxHeight = '0';
                    body.classList.add('shut');
                    hdr.classList.add('collapsed');
                });
            }
            saveCollapseState();
        }

        function initCollapseSections() {
            const saved = loadCollapseState();
            SECTION_IDS.forEach(id => {
                const sec = document.getElementById(id);
                if (!sec) return;
                const hdr = sec.querySelector('.collapse-header');
                const body = sec.querySelector('.collapse-body');
                if (!hdr || !body) return;
                const shouldCollapse = saved ? saved[id] : DEFAULT_COLLAPSED.includes(id);
                if (shouldCollapse) {
                    hdr.classList.add('collapsed');
                    body.classList.add('shut');
                    body.style.maxHeight = '0';
                } else {
                    hdr.classList.remove('collapsed');
                    body.classList.remove('shut');
                }
            });
        }

        // ==================== EDGE PANNING ====================
        function setupEdgePanning2D(canvas, panState, redrawFn) {
            var edgeThreshold = 50;
            var maxPanSpeed = 8;
            var animationId = null;

            function updatePan() {
                if (!panState.isHovering) return;
                var rect = canvas.getBoundingClientRect();
                var mouseX = panState.mouseX - rect.left;
                var mouseY = panState.mouseY - rect.top;
                var panX = 0, panY = 0;

                if (mouseX >= 0 && mouseX < edgeThreshold) {
                    panX = maxPanSpeed * (1 - mouseX / edgeThreshold);
                }
                if (mouseX > rect.width - edgeThreshold && mouseX <= rect.width) {
                    panX = -maxPanSpeed * (1 - (rect.width - mouseX) / edgeThreshold);
                }
                if (mouseY >= 0 && mouseY < edgeThreshold) {
                    panY = maxPanSpeed * (1 - mouseY / edgeThreshold);
                }
                if (mouseY > rect.height - edgeThreshold && mouseY <= rect.height) {
                    panY = -maxPanSpeed * (1 - (rect.height - mouseY) / edgeThreshold);
                }

                if (panX !== 0 || panY !== 0) {
                    panState.offsetX += panX;
                    panState.offsetY += panY;
                    if (redrawFn) redrawFn();
                }

                animationId = requestAnimationFrame(updatePan);
            }

            canvas.addEventListener('mouseenter', function() {
                panState.isHovering = true;
                updatePan();
            });
            canvas.addEventListener('mouseleave', function() {
                panState.isHovering = false;
                if (animationId) cancelAnimationFrame(animationId);
                animationId = null;
            });
            canvas.addEventListener('mousemove', function(e) {
                panState.mouseX = e.clientX;
                panState.mouseY = e.clientY;
            });
        }

        function setupEdgePanning3D(container, camera, controls) {
            var edgeThreshold = 50;
            var maxRotateSpeed = 0.02;
            var animationId = null;
            var mouseX = 0, mouseY = 0;
            var isHovering = false;

            function updatePan() {
                if (!isHovering) return;
                var rect = container.getBoundingClientRect();
                var localX = mouseX - rect.left;
                var localY = mouseY - rect.top;
                var rotateH = 0, rotateV = 0;

                if (localX >= 0 && localX < edgeThreshold) {
                    rotateH = maxRotateSpeed * (1 - localX / edgeThreshold);
                }
                if (localX > rect.width - edgeThreshold && localX <= rect.width) {
                    rotateH = -maxRotateSpeed * (1 - (rect.width - localX) / edgeThreshold);
                }
                if (localY >= 0 && localY < edgeThreshold) {
                    rotateV = maxRotateSpeed * (1 - localY / edgeThreshold);
                }
                if (localY > rect.height - edgeThreshold && localY <= rect.height) {
                    rotateV = -maxRotateSpeed * (1 - (rect.height - localY) / edgeThreshold);
                }

                if ((rotateH !== 0 || rotateV !== 0) && controls && camera) {
                    var spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position.clone().sub(controls.target));
                    spherical.theta += rotateH;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + rotateV));
                    camera.position.setFromSpherical(spherical).add(controls.target);
                    camera.lookAt(controls.target);
                }

                animationId = requestAnimationFrame(updatePan);
            }

            container.addEventListener('mouseenter', function() {
                isHovering = true;
                updatePan();
            });
            container.addEventListener('mouseleave', function() {
                isHovering = false;
                if (animationId) cancelAnimationFrame(animationId);
                animationId = null;
            });
            container.addEventListener('mousemove', function(e) {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
        }

        // ==================== FLASHING PROFILE EDITOR ====================
        let flashingProfiles = [];
        let flashingTemplates = [];
        let flashCurrentPoints = [];
        let flashUndoStack = [];
        // flashTool removed - unified interaction model (pan=click-drag, add point=dbl-click)
        let flashColourSide = 'inside';
        let flashDrawing = false; // legacy compat â€” use flashMode instead
        let flashMode = 'viewing'; // 'viewing' | 'extending' | 'selected'
        let flashSelectedSeg = -1; // selected segment index
        let flashPanOffset = { x: 0, y: 0 };
        let flashZoomLevel = 10; // mm per grid square
        let flashSelectedIdx = -1;
        let flashSelectedLeg = -1;
        let flashEditingId = null;
        let flashDragging = false;
        let flashDragStart = { x: 0, y: 0 };
        let flashPanStart = { x: 0, y: 0 };
        let flashHoverPoint = -1;
        let flashMouseMM = { x: 0, y: 0 };
        let flashSnapAngle = false;
        let flashAutoSnap = false;
        let flashNextId = 1;
        let flashStartTreatment = null; // null or { type: 'miniBreak', size: 10, angle: 45, direction: 'out' } or { type: 'hem' }
        let flashEndTreatment = null;

        const FLASH_GAUGES = [0.42, 0.48, 0.55];

        const FLASH_DEFAULT_TEMPLATES = [
            // Skillion / Flat Roof
            { name: 'Barge', folder: 'Skillion / Flat', points: [{x:0,y:0},{x:0,y:30},{x:15,y:45},{x:15,y:200},{x:165,y:200}], colourSide: 'inside' },
            { name: 'Apron', folder: 'Skillion / Flat', points: [{x:0,y:0},{x:0,y:100},{x:270,y:100},{x:270,y:180}], colourSide: 'inside' },
            // Gable Roof
            { name: 'Barge', folder: 'Gable', points: [{x:0,y:0},{x:0,y:30},{x:15,y:45},{x:15,y:200},{x:165,y:200}], colourSide: 'inside' },
            { name: 'Ridge Cap (Trimdek)', folder: 'Gable', points: [{x:0,y:150},{x:150,y:0},{x:300,y:150}], colourSide: 'inside' },
            { name: 'Ridge Cap (Corrugated)', folder: 'Gable', points: [{x:0,y:140},{x:140,y:0},{x:280,y:140}], colourSide: 'inside' },
            // SolarSpan 50mm
            { name: 'Barge', folder: 'SolarSpan 50mm', points: [{x:0,y:0},{x:0,y:50},{x:60,y:50},{x:60,y:0}], colourSide: 'inside' },
            { name: 'Gutter Flashing', folder: 'SolarSpan 50mm', points: [{x:0,y:0},{x:0,y:50},{x:80,y:50},{x:80,y:130}], colourSide: 'inside' },
            { name: 'Top Flashing', folder: 'SolarSpan 50mm', points: [{x:0,y:0},{x:0,y:50},{x:200,y:50},{x:200,y:130}], colourSide: 'inside' },
            { name: 'Receiver Channel', folder: 'SolarSpan 50mm', points: [{x:0,y:0},{x:0,y:50},{x:25,y:50},{x:25,y:0}], colourSide: 'inside' },
            // SolarSpan 75mm
            { name: 'Barge', folder: 'SolarSpan 75mm', points: [{x:0,y:0},{x:0,y:75},{x:60,y:75},{x:60,y:0}], colourSide: 'inside' },
            { name: 'Gutter Flashing', folder: 'SolarSpan 75mm', points: [{x:0,y:0},{x:0,y:75},{x:80,y:75},{x:80,y:155}], colourSide: 'inside' },
            { name: 'Top Flashing', folder: 'SolarSpan 75mm', points: [{x:0,y:0},{x:0,y:75},{x:200,y:75},{x:200,y:155}], colourSide: 'inside' },
            { name: 'Receiver Channel', folder: 'SolarSpan 75mm', points: [{x:0,y:0},{x:0,y:75},{x:25,y:75},{x:25,y:0}], colourSide: 'inside' },
            // SolarSpan 100mm
            { name: 'Barge', folder: 'SolarSpan 100mm', points: [{x:0,y:0},{x:0,y:100},{x:60,y:100},{x:60,y:0}], colourSide: 'inside' },
            { name: 'Gutter Flashing', folder: 'SolarSpan 100mm', points: [{x:0,y:0},{x:0,y:100},{x:80,y:100},{x:80,y:180}], colourSide: 'inside' },
            { name: 'Top Flashing', folder: 'SolarSpan 100mm', points: [{x:0,y:0},{x:0,y:100},{x:200,y:100},{x:200,y:180}], colourSide: 'inside' },
            { name: 'Receiver Channel', folder: 'SolarSpan 100mm', points: [{x:0,y:0},{x:0,y:100},{x:25,y:100},{x:25,y:0}], colourSide: 'inside' },
            // Custom
            { name: 'Blank', folder: 'Custom', points: [], colourSide: 'inside' }
        ];

        function initFlashingEditor() {
            // Load saved templates from localStorage or use defaults
            var saved = localStorage.getItem('flashingTemplates');
            if (saved) {
                try { flashingTemplates = JSON.parse(saved); } catch(e) { flashingTemplates = []; }
            }
            // Ensure defaults always present (match by name+folder)
            FLASH_DEFAULT_TEMPLATES.forEach(function(dt) {
                if (!flashingTemplates.find(function(t) { return t.name === dt.name && t.folder === dt.folder; })) {
                    flashingTemplates.push(JSON.parse(JSON.stringify(dt)));
                }
            });

            renderFlashTemplates();
            renderFlashJobTable();
        }

        let flashModalOpen = false;
        let flashCanvasInited = false;
        let flashIsPanning = false; // true when a click-drag pan is active (not point drag)
        let flashDrawTool = false; // draw mode toggle
        let flashHoverEndpoint = -1; // index of hovered endpoint (0 or last), or -1
        let flashDragIntent = false; // true when mousedown on point but hasn't moved 4px yet
        let flashDragUndoPushed = false; // whether undo was pushed for this drag
        var flashExtLastClickTime = 0; // timestamp of last click in extending mode (for dblclick detection)
        var flashExtLastClickPos = { x: 0, y: 0 };

        var flashResizeObserver = null;
        function openFlashModal() {
            var overlay = document.getElementById('flashModalOverlay');
            if (!overlay) return;
            overlay.classList.add('open');
            flashModalOpen = true;
            if (!flashCanvasInited) {
                setupFlashCanvas();
                flashCanvasInited = true;
                // Watch for viewport resizes inside modal
                if (typeof ResizeObserver !== 'undefined') {
                    var vp = document.getElementById('flashViewport');
                    if (vp) {
                        flashResizeObserver = new ResizeObserver(function() {
                            if (flashModalOpen) { resizeFlashCanvas(); drawFlashCanvas(); }
                        });
                        flashResizeObserver.observe(vp);
                    }
                }
            }
            setTimeout(function() {
                resizeFlashCanvas();
                drawFlashCanvas();
            }, 50);
        }

        function closeFlashModal() {
            var overlay = document.getElementById('flashModalOverlay');
            if (!overlay) return;
            overlay.classList.remove('open');
            flashModalOpen = false;
            updateFlashSummary();
        }

        // ---- Tab switching ----
        function switchFlashTab(tab) {
            var stdBody = document.getElementById('flashBodyStandard');
            var bgBody = document.getElementById('flashBodyBoxGutter');
            var stdTab = document.getElementById('flashTabStandard');
            var bgTab = document.getElementById('flashTabBoxGutter');
            if (tab === 'boxgutter') {
                if (stdBody) stdBody.style.display = 'none';
                if (bgBody) bgBody.style.display = 'flex';
                if (stdTab) stdTab.classList.remove('active');
                if (bgTab) bgTab.classList.add('active');
                updateBGDesigner();
            } else {
                if (stdBody) stdBody.style.display = '';
                if (bgBody) bgBody.style.display = 'none';
                if (stdTab) stdTab.classList.add('active');
                if (bgTab) bgTab.classList.remove('active');
                setTimeout(function() { resizeFlashCanvas(); drawFlashCanvas(); }, 50);
            }
        }

        function openFlashModalBoxGutter() {
            openFlashModal();
            switchFlashTab('boxgutter');
            // Sync catchment from main form
            var mainCatch = document.getElementById('inBoxGutterCatchment');
            var bgCatch = document.getElementById('bgCatchment');
            if (mainCatch && bgCatch) bgCatch.value = mainCatch.value;
            // Auto-fill length from patio length
            var patioLen = parseInt(document.getElementById('inLength')?.value) || 6000;
            var bgLen = document.getElementById('bgLength');
            if (bgLen) bgLen.value = patioLen + 200;
            updateBGDesigner();
        }

        // ---- Box Gutter calculations (AS/NZS 3500.3) ----
        function calculateBoxGutterWidth(catchmentM2) {
            var intensity = 207; // Perth mm/h
            var flowRequired = (catchmentM2 * intensity) / 3600;
            var designFlow = Math.max(flowRequired, 3.0);
            if (designFlow <= 3.0) return 250;
            if (designFlow <= 5.0) return 300;
            if (designFlow <= 7.0) return 350;
            if (designFlow <= 10.0) return 400;
            if (designFlow <= 14.0) return 450;
            return null; // exceeds standard
        }

        function updateBGDesigner() {
            var catchEl = document.getElementById('bgCatchment');
            var patioCatchEl = document.getElementById('bgPatioCatch');
            if (!catchEl) return;
            var houseCatch = parseFloat(catchEl.value) || 85;
            var addPatio = patioCatchEl && patioCatchEl.value === 'yes';
            var patioCatch = 0;
            if (addPatio) {
                var pw = parseFloat(document.getElementById('inWidth')?.value) || 4000;
                var pl = parseFloat(document.getElementById('inLength')?.value) || 6000;
                patioCatch = Math.round((pw / 1000) * (pl / 1000));
            }
            var totalCatch = houseCatch + patioCatch;
            var summaryEl = document.getElementById('bgCatchSummary');
            if (summaryEl) summaryEl.textContent = 'Total catchment: ' + totalCatch + ' m\u00B2' + (addPatio ? ' (' + houseCatch + ' house + ' + patioCatch + ' patio)' : '');

            var recWidth = calculateBoxGutterWidth(totalCatch);
            var widthRecEl = document.getElementById('bgWidthRec');
            var warnEl = document.getElementById('bgCatchWarn');
            if (recWidth) {
                if (widthRecEl) widthRecEl.textContent = 'Minimum width required: ' + recWidth + 'mm (per AS/NZS 3500.3)';
                if (warnEl) warnEl.style.display = 'none';
                // Auto-set width if user hasn't manually changed it
                var widthEl = document.getElementById('bgWidth');
                if (widthEl && parseInt(widthEl.value) < recWidth) widthEl.value = recWidth;
            } else {
                if (widthRecEl) widthRecEl.textContent = 'Exceeds standard box gutter capacity';
                if (warnEl) { warnEl.textContent = '\u26A0 Catchment exceeds 243m\u00B2 \u2014 engineering review required'; warnEl.style.display = 'block'; }
            }

            // Dimension validation
            var dimWarn = [];
            var width = parseInt(document.getElementById('bgWidth')?.value) || 300;
            var depth = parseInt(document.getElementById('bgDepth')?.value) || 100;
            var backH = parseInt(document.getElementById('bgBackH')?.value) || 70;
            var frontH = parseInt(document.getElementById('bgFrontH')?.value) || 130;
            if (width < 250) dimWarn.push('Width below minimum 250mm');
            if (recWidth && width < recWidth) dimWarn.push('Width ' + width + 'mm may be undersized for ' + totalCatch + 'm\u00B2 catchment (need ' + recWidth + 'mm)');
            if (depth < 75) dimWarn.push('Depth below minimum 75mm for slope');
            if (frontH < depth + 25) dimWarn.push('Insufficient freeboard \u2014 front height should be at least depth + 25mm');
            if (backH !== 70) dimWarn.push('Non-standard back height \u2014 verify fit under house sheets');
            var dimWarnEl = document.getElementById('bgDimWarn');
            if (dimWarnEl) {
                if (dimWarn.length > 0) {
                    dimWarnEl.innerHTML = dimWarn.map(function(w) { return '\u26A0 ' + w; }).join('<br>');
                    dimWarnEl.style.display = 'block';
                } else {
                    dimWarnEl.style.display = 'none';
                }
            }

            drawBGPreview();
        }

        function drawBGPreview() {
            var canvas = document.getElementById('bgPreviewCanvas');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            var cw = canvas.width, ch = canvas.height;
            ctx.clearRect(0, 0, cw, ch);

            var width = parseInt(document.getElementById('bgWidth')?.value) || 300;
            var depth = parseInt(document.getElementById('bgDepth')?.value) || 100;
            var backH = parseInt(document.getElementById('bgBackH')?.value) || 70;
            var frontH = parseInt(document.getElementById('bgFrontH')?.value) || 130;

            // Scale to fit canvas with padding
            var totalW = width + 40; // extra for lip
            var totalH = Math.max(frontH, backH) + depth + 10;
            var scale = Math.min((cw - 80) / totalW, (ch - 60) / totalH);
            var ox = (cw - totalW * scale) / 2;
            var oy = ch - 30;

            // Profile points (bottom-left origin, going clockwise)
            var pts = [
                { x: 0, y: backH + depth }, // top of back wall
                { x: 0, y: depth },          // back wall meets sole
                { x: width, y: depth },      // sole front
                { x: width, y: frontH + depth }, // top of front wall
            ];

            // Draw filled channel (colour side = inside)
            ctx.fillStyle = 'rgba(232, 90, 28, 0.08)';
            ctx.beginPath();
            ctx.moveTo(ox + pts[0].x * scale, oy - pts[0].y * scale);
            for (var i = 1; i < pts.length; i++) {
                ctx.lineTo(ox + pts[i].x * scale, oy - pts[i].y * scale);
            }
            ctx.lineTo(ox + pts[3].x * scale, oy - pts[0].y * scale); // close top
            ctx.closePath();
            ctx.fill();

            // Hatching inside channel
            ctx.strokeStyle = 'rgba(232, 90, 28, 0.15)';
            ctx.lineWidth = 0.5;
            var soleY = oy - depth * scale;
            var topY = oy - Math.max(frontH, backH, depth) * scale - 10;
            for (var hx = ox + 4; hx < ox + width * scale; hx += 8) {
                ctx.beginPath();
                ctx.moveTo(hx, soleY);
                ctx.lineTo(hx, topY);
                ctx.stroke();
            }

            // Draw profile line
            ctx.strokeStyle = '#293C46';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(ox + pts[0].x * scale, oy - pts[0].y * scale);
            for (var j = 1; j < pts.length; j++) {
                ctx.lineTo(ox + pts[j].x * scale, oy - pts[j].y * scale);
            }
            ctx.stroke();

            // Dimension labels
            ctx.font = 'bold 12px Arial, sans-serif';
            ctx.textAlign = 'center';

            // Width (top)
            var dimY = oy - (Math.max(frontH, backH) + depth) * scale - 12;
            ctx.fillStyle = '#1a365d';
            ctx.fillText(width + 'mm', ox + width * scale / 2, dimY);
            // Arrows for width
            ctx.strokeStyle = '#1a365d';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(ox, dimY + 4);
            ctx.lineTo(ox + width * scale, dimY + 4);
            ctx.stroke();

            // Back height (left)
            ctx.save();
            ctx.translate(ox - 16, oy - (depth + backH / 2) * scale);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#1a365d';
            ctx.fillText(backH + 'mm', 0, 0);
            ctx.restore();

            // Front height (right)
            ctx.save();
            ctx.translate(ox + width * scale + 22, oy - (depth + frontH / 2) * scale);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#1a365d';
            ctx.fillText(frontH + 'mm', 0, 0);
            ctx.restore();

            // Depth (bottom)
            ctx.fillStyle = '#1a365d';
            ctx.fillText('depth ' + depth + 'mm', ox + width * scale / 2, oy + 16);

            // Legend
            ctx.font = '10px Arial, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(232, 90, 28, 0.5)';
            ctx.fillRect(10, 10, 12, 12);
            ctx.fillStyle = '#666';
            ctx.fillText('= Colorbond inside', 26, 20);
        }

        function bgAddToJob() {
            var width = parseInt(document.getElementById('bgWidth')?.value) || 300;
            var depth = parseInt(document.getElementById('bgDepth')?.value) || 100;
            var backH = parseInt(document.getElementById('bgBackH')?.value) || 70;
            var frontH = parseInt(document.getElementById('bgFrontH')?.value) || 130;
            var length = parseInt(document.getElementById('bgLength')?.value) || 6200;
            var gauge = parseFloat(document.getElementById('bgGauge')?.value) || 0.55;
            var colour = document.getElementById('bgColour')?.value || 'Deep Ocean';
            var outletPos = document.getElementById('bgOutletPos')?.value || 'right';
            var outletSize = document.getElementById('bgOutletSize')?.value || '100round';

            // Build profile points for the box gutter cross-section
            var pts = [
                { x: 0, y: backH + depth },
                { x: 0, y: depth },
                { x: width, y: depth },
                { x: width, y: frontH + depth }
            ];

            var girth = backH + width + frontH; // total developed width
            var legs = [
                { length: backH, angle: 90 },
                { length: width, angle: 90 },
                { length: frontH, angle: null }
            ];

            var outletLabel = outletSize.replace('round', 'mm round');
            var outletPosLabel = { left: 'left end', right: 'right end', centre: 'centre', both: 'both ends' }[outletPos] || outletPos;

            flashingProfiles.push({
                id: 'flashing_' + String(flashNextId++).padStart(3, '0'),
                name: 'Box Gutter',
                colour: colour,
                gauge: gauge,
                length: length,
                qty: 1,
                colourSide: 'inside',
                points: pts,
                girth: girth,
                legs: legs,
                startTreatment: null,
                endTreatment: null,
                isBoxGutter: true,
                boxGutterData: {
                    width: width, depth: depth, backH: backH, frontH: frontH,
                    outlet: outletPosLabel + ' \u2014 ' + outletLabel,
                    notes: 'Slope sole 1:200 toward ' + outletPosLabel
                }
            });

            renderFlashJobTable();
            updateFlashSummary();
            switchFlashTab('standard');
            alert('Box Gutter added to flashings list.');
        }

        // Update box gutter summary in main form
        function updateBoxGutterSummary() {
            var catchEl = document.getElementById('inBoxGutterCatchment');
            if (!catchEl) return;
            var catchment = parseFloat(catchEl.value) || 85;
            var recWidth = calculateBoxGutterWidth(catchment);
            var widthEl = document.getElementById('boxGutterWidthRec');
            var profileEl = document.getElementById('boxGutterProfileRec');
            var warnEl = document.getElementById('boxGutterWarn');
            var widthInput = document.getElementById('inBoxGutterWidth');
            // Auto-sync width with riser horizontal if available
            var riserLH = document.getElementById('riserLH');
            if (riserLH && parseFloat(riserLH.value) > 0) {
                var riserW = parseFloat(riserLH.value);
                if (widthInput && Math.abs(widthInput.value - riserW) > 10) {
                    widthInput.value = Math.round(riserW);
                }
            }
            var actualWidth = widthInput ? parseFloat(widthInput.value) || 300 : 300;
            if (recWidth) {
                if (widthEl) widthEl.textContent = 'Recommended: ' + recWidth + 'mm (based on ' + catchment + 'm\u00B2 catchment)';
                if (profileEl) profileEl.textContent = 'Profile: 100mm deep x ' + Math.round(actualWidth * 0.23) + 'mm back x ' + Math.round(actualWidth * 0.43) + 'mm front';
                if (warnEl) {
                    if (actualWidth < recWidth) {
                        warnEl.textContent = '\u26A0 Current width (' + actualWidth + 'mm) is less than recommended (' + recWidth + 'mm). May not handle full catchment.';
                        warnEl.style.display = 'block';
                    } else {
                        warnEl.style.display = 'none';
                    }
                }
            } else {
                if (widthEl) widthEl.textContent = 'Catchment exceeds standard capacity';
                if (warnEl) { warnEl.textContent = '\u26A0 Engineering review required for large catchment'; warnEl.style.display = 'block'; }
            }
        }

        function updateFlashSummary() {
            var el = document.getElementById('flashSummaryCount');
            if (el) el.textContent = flashingProfiles.length;
        }

        function setupFlashCanvas() {
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;

            canvas.addEventListener('mousedown', flashMouseDown);
            canvas.addEventListener('mousemove', flashMouseMove);
            canvas.addEventListener('mouseup', flashMouseUp);
            canvas.addEventListener('dblclick', flashDblClick);
            canvas.addEventListener('wheel', flashWheel, { passive: false });
            canvas.addEventListener('contextmenu', function(e) { e.preventDefault(); });

            // Touch support (iPad / mobile)
            canvas.addEventListener('touchstart', flashTouchStart, { passive: false });
            canvas.addEventListener('touchmove', flashTouchMove, { passive: false });
            canvas.addEventListener('touchend', flashTouchEnd, { passive: false });
            canvas.addEventListener('touchcancel', flashTouchEnd, { passive: false });

            document.addEventListener('keydown', flashKeyDown);

            resizeFlashCanvas();
            drawFlashCanvas();
        }

        // ---- Touch state ----
        var flashTouchCount = 0;
        var flashTouchStartTime = 0;
        var flashTouchStartPos = { x: 0, y: 0 };
        var flashLastTapTime = 0;
        var flashLastTapPos = { x: 0, y: 0 };
        var flashPinchStartDist = 0;
        var flashPinchStartZoom = 10;
        var flashPinchMidStart = { x: 0, y: 0 };
        var flashTouchPanStart = { x: 0, y: 0 };
        var flashTouchIsDragging = false;

        function flashGetTouchPos(touch) {
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return { x: 0, y: 0 };
            var rect = canvas.getBoundingClientRect();
            return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
        }

        function flashTouchMidpoint(t1, t2) {
            return { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        }

        function flashTouchDist(t1, t2) {
            var dx = t1.clientX - t2.clientX, dy = t1.clientY - t2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function flashTouchStart(e) {
            e.preventDefault();
            var touches = e.touches;
            flashTouchCount = touches.length;

            if (touches.length === 1) {
                var pos = flashGetTouchPos(touches[0]);
                flashTouchStartPos = pos;
                flashTouchStartTime = Date.now();
                flashTouchIsDragging = false;

                // Check if touching a point for drag
                var nearIdx = flashFindNearPoint(pos, 18);
                if (nearIdx !== -1 && (flashMode === 'viewing' || flashMode === 'selected')) {
                    flashSelectedIdx = nearIdx;
                    flashSelectedSeg = -1;
                    flashDragIntent = true;
                    flashDragUndoPushed = false;
                    flashDragStart = pos;
                    flashIsPanning = false;
                    setFlashMode('selected');
                }
            } else if (touches.length === 2) {
                // Two-finger: pan + pinch-to-zoom
                flashPinchStartDist = flashTouchDist(touches[0], touches[1]);
                flashPinchStartZoom = flashZoomLevel;
                var mid = flashTouchMidpoint(touches[0], touches[1]);
                var canvas = document.getElementById('flashCanvas');
                var rect = canvas.getBoundingClientRect();
                flashPinchMidStart = { x: mid.x - rect.left, y: mid.y - rect.top };
                flashTouchPanStart = { x: flashPanOffset.x, y: flashPanOffset.y };
                // Cancel any single-finger drag
                flashDragIntent = false;
                flashDragging = false;
                flashTouchIsDragging = false;
            }
        }

        function flashTouchMove(e) {
            e.preventDefault();
            var touches = e.touches;

            if (touches.length === 1 && flashTouchCount === 1) {
                var pos = flashGetTouchPos(touches[0]);
                var mm = flashCanvasToMM(pos.x, pos.y);
                var snapped = flashSnapToGrid(mm);

                if ((flashSnapAngle || flashAutoSnap) && flashCurrentPoints.length > 0 && flashMode === 'extending') {
                    snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
                }
                flashMouseMM = snapped;

                var dx = pos.x - flashTouchStartPos.x, dy = pos.y - flashTouchStartPos.y;
                var dist = Math.sqrt(dx * dx + dy * dy);

                if (flashDragIntent && dist > 6) {
                    // Promote to actual drag
                    if (!flashDragUndoPushed) { flashPushUndo(); flashDragUndoPushed = true; }
                    flashDragIntent = false;
                    flashDragging = true;
                    flashTouchIsDragging = true;
                }

                if (flashDragging && flashSelectedIdx >= 0) {
                    var dragSnapped = flashSnapToGrid(mm);
                    if ((flashSnapAngle || flashAutoSnap) && flashSelectedIdx > 0) {
                        dragSnapped = constrainAngle(flashCurrentPoints[flashSelectedIdx - 1], dragSnapped);
                    }
                    flashCurrentPoints[flashSelectedIdx] = { x: dragSnapped.x, y: dragSnapped.y };
                }

                drawFlashCanvas();
            } else if (touches.length === 2) {
                // Two-finger pan + zoom
                var curDist = flashTouchDist(touches[0], touches[1]);
                var mid = flashTouchMidpoint(touches[0], touches[1]);
                var canvas = document.getElementById('flashCanvas');
                var rect = canvas.getBoundingClientRect();
                var curMid = { x: mid.x - rect.left, y: mid.y - rect.top };

                // Pan
                flashPanOffset.x = flashTouchPanStart.x + (curMid.x - flashPinchMidStart.x);
                flashPanOffset.y = flashTouchPanStart.y + (curMid.y - flashPinchMidStart.y);

                // Pinch-to-zoom
                var ratio = curDist / flashPinchStartDist;
                var zoomLevels = [2, 5, 10, 20, 50];
                var startIdx = zoomLevels.indexOf(flashPinchStartZoom);
                if (startIdx === -1) startIdx = 2;
                var steps = Math.round(Math.log2(ratio) * 2);
                var newIdx = Math.max(0, Math.min(zoomLevels.length - 1, startIdx - steps));
                flashZoomLevel = zoomLevels[newIdx];

                drawFlashCanvas();
            }
        }

        function flashTouchEnd(e) {
            e.preventDefault();
            var wasTouching = flashTouchCount;
            flashTouchCount = e.touches.length;

            if (wasTouching === 1 && e.touches.length === 0) {
                var now = Date.now();
                var elapsed = now - flashTouchStartTime;
                var pos = flashTouchStartPos;

                if (flashDragging || flashTouchIsDragging) {
                    // End drag
                    flashDragging = false;
                    flashDragIntent = false;
                    flashTouchIsDragging = false;
                    drawFlashCanvas();
                    return;
                }

                flashDragIntent = false;

                // Double-tap detection
                var tapDx = pos.x - flashLastTapPos.x, tapDy = pos.y - flashLastTapPos.y;
                var tapDist = Math.sqrt(tapDx * tapDx + tapDy * tapDy);
                if (now - flashLastTapTime < 350 && tapDist < 35) {
                    // Double-tap â†’ synthesize dblclick
                    flashLastTapTime = 0;
                    var mm = flashCanvasToMM(pos.x, pos.y);
                    var snapped = flashSnapToGrid(mm);
                    // Reuse dblclick logic
                    var fakeEvent = { preventDefault: function(){}, target: document.getElementById('flashCanvas') };
                    fakeEvent.clientX = pos.x; fakeEvent.clientY = pos.y;
                    // Call dblclick directly with synthesized position
                    flashDblClickAt(pos, mm, snapped);
                    return;
                }

                flashLastTapTime = now;
                flashLastTapPos = { x: pos.x, y: pos.y };

                // Single tap (short press, no drag)
                if (elapsed < 300) {
                    // Check if tapping an endpoint â†’ extend from it
                    var nearPt = flashFindNearPoint(pos, 18);
                    var pts = flashCurrentPoints;
                    if (nearPt !== -1 && pts.length >= 1 && (nearPt === 0 || nearPt === pts.length - 1) && flashMode !== 'extending') {
                        if (nearPt === 0) flashCurrentPoints.reverse();
                        flashSelectedIdx = -1;
                        flashSelectedSeg = -1;
                        setFlashMode('extending');
                    } else {
                        flashMouseDownAt(pos);
                    }
                }
            }

            flashDragging = false;
            flashDragIntent = false;
            flashTouchIsDragging = false;
        }

        function resizeFlashCanvas() {
            var canvas = document.getElementById('flashCanvas');
            var vp = document.getElementById('flashViewport');
            if (!canvas || !vp) return;
            var w = vp.clientWidth || 600;
            var h = vp.clientHeight || 400;
            canvas.width = w;
            canvas.height = h;
        }

        // ---- Coordinate conversion ----
        function flashMMToCanvas(mx, my) {
            var canvas = document.getElementById('flashCanvas');
            var cw = canvas.width, ch = canvas.height;
            var scale = flashZoomLevel; // mm per grid cell, grid cell = 20px on screen
            var pxPerMM = 20 / scale;
            var cx = cw / 2 + flashPanOffset.x + mx * pxPerMM;
            var cy = ch / 2 + flashPanOffset.y - my * pxPerMM; // y inverted
            return { x: cx, y: cy };
        }

        function flashCanvasToMM(cx, cy) {
            var canvas = document.getElementById('flashCanvas');
            var cw = canvas.width, ch = canvas.height;
            var scale = flashZoomLevel;
            var pxPerMM = 20 / scale;
            var mx = (cx - cw / 2 - flashPanOffset.x) / pxPerMM;
            var my = -(cy - ch / 2 - flashPanOffset.y) / pxPerMM;
            return { x: mx, y: my };
        }

        function flashSnapToGrid(mm) {
            var snap = flashZoomLevel;
            return { x: Math.round(mm.x / snap) * snap, y: Math.round(mm.y / snap) * snap };
        }

        // ---- Drawing ----
        function drawFlashCanvas() {
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;
            var ctx = canvas.getContext('2d');
            var cw = canvas.width, ch = canvas.height;
            ctx.clearRect(0, 0, cw, ch);

            // Background
            ctx.fillStyle = '#FAFBFC';
            ctx.fillRect(0, 0, cw, ch);

            var pxPerMM = 20 / flashZoomLevel;
            var gridPx = 20; // grid spacing in pixels

            // Draw grid (light grey)
            ctx.strokeStyle = '#e5e5e5';
            ctx.lineWidth = 0.5;
            var startX = ((cw / 2 + flashPanOffset.x) % gridPx);
            var startY = ((ch / 2 + flashPanOffset.y) % gridPx);
            for (var gx = startX; gx < cw; gx += gridPx) {
                ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, ch); ctx.stroke();
            }
            for (var gy = startY; gy < ch; gy += gridPx) {
                ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(cw, gy); ctx.stroke();
            }

            // Heavier lines every 5 grid squares
            ctx.strokeStyle = '#D0D4DA';
            ctx.lineWidth = 0.8;
            var majorPx = gridPx * 5;
            var mjStartX = ((cw / 2 + flashPanOffset.x) % majorPx);
            var mjStartY = ((ch / 2 + flashPanOffset.y) % majorPx);
            for (var gx2 = mjStartX; gx2 < cw; gx2 += majorPx) {
                ctx.beginPath(); ctx.moveTo(gx2, 0); ctx.lineTo(gx2, ch); ctx.stroke();
            }
            for (var gy2 = mjStartY; gy2 < ch; gy2 += majorPx) {
                ctx.beginPath(); ctx.moveTo(0, gy2); ctx.lineTo(cw, gy2); ctx.stroke();
            }

            // Origin crosshair (red, subtle)
            var o = flashMMToCanvas(0, 0);
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 0.8;
            ctx.setLineDash([4, 4]);
            ctx.beginPath(); ctx.moveTo(o.x, 0); ctx.lineTo(o.x, ch); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, o.y); ctx.lineTo(cw, o.y); ctx.stroke();
            ctx.setLineDash([]);

            // Draw profile
            var pts = flashCurrentPoints;

            // Empty canvas hint
            if (pts.length === 0 && flashMode === 'viewing') {
                ctx.save();
                ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = '#9CA3AF';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Press D or tap \u270E Draw to start', cw / 2, ch / 2);
                ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillText('Or select a template from the sidebar', cw / 2, ch / 2 + 22);
                ctx.restore();
            }

            if (pts.length > 0) {
                // Colour side indicator (thicker line on colour side)
                drawFlashProfile(ctx, pts, true);
                // Draw end treatments (mini break / hem)
                if (flashStartTreatment && pts.length >= 2) drawEndTreatment(ctx, pts, flashStartTreatment, true);
                if (flashEndTreatment && pts.length >= 2) drawEndTreatment(ctx, pts, flashEndTreatment, false);
            }

            // Highlight selected segment (thicker, highlighted)
            if (flashSelectedSeg >= 0 && flashSelectedSeg < pts.length - 1) {
                var ssa = pts[flashSelectedSeg], ssb = pts[flashSelectedSeg + 1];
                var sca = flashMMToCanvas(ssa.x, ssa.y);
                var scb = flashMMToCanvas(ssb.x, ssb.y);
                ctx.strokeStyle = '#F15A29';
                ctx.lineWidth = 5;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(sca.x, sca.y);
                ctx.lineTo(scb.x, scb.y);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Ghost preview line from last point to cursor (EXTEND MODE)
            if (flashMode === 'extending' && pts.length > 0 && !flashIsPanning) {
                var lastPt = pts[pts.length - 1];
                var lp = flashMMToCanvas(lastPt.x, lastPt.y);
                var previewMM = flashSnapToGrid(flashMouseMM);
                var isSnapped = false;
                if (flashSnapAngle || flashAutoSnap) {
                    var unsnapped = previewMM;
                    previewMM = constrainAngle(lastPt, previewMM);
                    isSnapped = (previewMM.x !== unsnapped.x || previewMM.y !== unsnapped.y);
                }
                var mp = flashMMToCanvas(previewMM.x, previewMM.y);

                // Dashed preview line (semi-transparent)
                ctx.setLineDash([8, 5]);
                ctx.strokeStyle = isSnapped ? '#22c55e' : '#60a5fa';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath(); ctx.moveTo(lp.x, lp.y); ctx.lineTo(mp.x, mp.y); ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;

                // Preview dot
                ctx.fillStyle = isSnapped ? '#22c55e' : '#60a5fa';
                ctx.beginPath();
                ctx.arc(mp.x, mp.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Preview length pill badge
                var gdx = previewMM.x - lastPt.x;
                var gdy = previewMM.y - lastPt.y;
                var gDist = Math.round(Math.sqrt(gdx * gdx + gdy * gdy));
                if (gDist > 5) {
                    drawFlashPill(ctx, mp.x + 30, mp.y - 16, gDist + 'mm', '#1a365d', '#fff');
                }

                // Live angle badge at the bend point (if 2+ existing points)
                if (pts.length >= 2) {
                    var prevPt = pts[pts.length - 2];
                    var previewAngle = calcBendAngle(prevPt, lastPt, previewMM);
                    if (gDist > 5) {
                        var anglePill = Math.round(previewAngle) + '\u00B0';
                        var pillColor = isSnapped ? '#22c55e' : '#e85a1c';
                        // Position at the bend point, offset outward
                        var pp3 = flashMMToCanvas(prevPt.x, prevPt.y);
                        var a1 = Math.atan2(pp3.y - lp.y, pp3.x - lp.x);
                        var a2 = Math.atan2(mp.y - lp.y, mp.x - lp.x);
                        var mid = (a1 + a2) / 2;
                        // If angles are more than PI apart, flip
                        if (Math.abs(a1 - a2) > Math.PI) mid += Math.PI;
                        var badgeX = lp.x + Math.cos(mid) * 32;
                        var badgeY = lp.y + Math.sin(mid) * 32;
                        drawFlashPill(ctx, badgeX, badgeY, anglePill, pillColor, '#fff');
                    }
                }

                // Snap indicator flash
                if (isSnapped) {
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(mp.x, mp.y, 12, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }

            // Endpoint hover glow + ghost preview (viewing mode, desktop)
            if (flashHoverEndpoint !== -1 && flashMode === 'viewing' && pts.length >= 2 && !flashDragging) {
                var hei = flashHoverEndpoint;
                var hePt = pts[hei];
                var heCanvas = flashMMToCanvas(hePt.x, hePt.y);
                var heMouse = flashMMToCanvas(flashMouseMM.x, flashMouseMM.y);

                // Faint dashed ghost line from endpoint to cursor
                ctx.save();
                ctx.setLineDash([6, 5]);
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.35;
                ctx.beginPath();
                ctx.moveTo(heCanvas.x, heCanvas.y);
                ctx.lineTo(heMouse.x, heMouse.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // Pulsing ring around endpoint
                var pulseT = (Date.now() % 1500) / 1500;
                var pulseAlpha = 0.25 + 0.2 * Math.sin(pulseT * Math.PI * 2);
                ctx.globalAlpha = pulseAlpha;
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(heCanvas.x, heCanvas.y, 14, 0, Math.PI * 2);
                ctx.stroke();

                // Hint pill
                ctx.globalAlpha = 0.8;
                drawFlashPill(ctx, heCanvas.x, heCanvas.y - 24, 'Dbl-click to extend', '#3b82f6', '#fff');
                ctx.restore();

                // Request animation frame for pulsing
                requestAnimationFrame(function() { if (flashHoverEndpoint !== -1 && flashMode === 'viewing') drawFlashCanvas(); });
            }

            // Drag visual feedback: guide lines + live lengths + angle
            if (flashDragging && flashSelectedIdx >= 0 && !flashIsPanning) {
                var di = flashSelectedIdx;
                var dp = flashMMToCanvas(pts[di].x, pts[di].y);
                ctx.setLineDash([6, 4]);
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = '#22c55e';
                ctx.globalAlpha = 0.7;

                // Guide line to previous neighbor
                if (di > 0) {
                    var prevC = flashMMToCanvas(pts[di - 1].x, pts[di - 1].y);
                    ctx.beginPath(); ctx.moveTo(prevC.x, prevC.y); ctx.lineTo(dp.x, dp.y); ctx.stroke();
                    var dxP = pts[di].x - pts[di - 1].x, dyP = pts[di].y - pts[di - 1].y;
                    var lenP = Math.round(Math.sqrt(dxP * dxP + dyP * dyP));
                    if (lenP > 3) drawFlashPill(ctx, (prevC.x + dp.x) / 2, (prevC.y + dp.y) / 2 - 12, lenP + 'mm', '#16a34a', '#fff');
                }
                // Guide line to next neighbor
                if (di < pts.length - 1) {
                    var nextC = flashMMToCanvas(pts[di + 1].x, pts[di + 1].y);
                    ctx.beginPath(); ctx.moveTo(dp.x, dp.y); ctx.lineTo(nextC.x, nextC.y); ctx.stroke();
                    var dxN = pts[di + 1].x - pts[di].x, dyN = pts[di + 1].y - pts[di].y;
                    var lenN = Math.round(Math.sqrt(dxN * dxN + dyN * dyN));
                    if (lenN > 3) drawFlashPill(ctx, (dp.x + nextC.x) / 2, (dp.y + nextC.y) / 2 - 12, lenN + 'mm', '#16a34a', '#fff');
                }
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;

                // Live angle badge at dragged point
                if (di > 0 && di < pts.length - 1) {
                    var dragAngle = calcBendAngle(pts[di - 1], pts[di], pts[di + 1]);
                    var pp = flashMMToCanvas(pts[di - 1].x, pts[di - 1].y);
                    var np = flashMMToCanvas(pts[di + 1].x, pts[di + 1].y);
                    var a1 = Math.atan2(pp.y - dp.y, pp.x - dp.x);
                    var a2 = Math.atan2(np.y - dp.y, np.x - dp.x);
                    var midA = (a1 + a2) / 2;
                    if (Math.abs(a1 - a2) > Math.PI) midA += Math.PI;
                    drawFlashPill(ctx, dp.x + Math.cos(midA) * 30, dp.y + Math.sin(midA) * 30, Math.round(dragAngle) + '\u00B0', '#16a34a', '#fff');
                }
            }

            // Update info bar
            updateFlashInfo();
        }

        function drawFlashProfile(ctx, pts, showDims) {
            if (pts.length < 2) {
                if (pts.length === 1) {
                    var sp = flashMMToCanvas(pts[0].x, pts[0].y);
                    ctx.beginPath();
                    ctx.arc(sp.x, sp.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = var_sw_orange();
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                return;
            }

            // Draw main profile line
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            var fp = flashMMToCanvas(pts[0].x, pts[0].y);
            ctx.moveTo(fp.x, fp.y);
            for (var i = 1; i < pts.length; i++) {
                var pp = flashMMToCanvas(pts[i].x, pts[i].y);
                ctx.lineTo(pp.x, pp.y);
            }
            ctx.stroke();

            // === Colour side indicator ===
            var csDir = flashColourSide === 'inside' ? -1 : 1; // normal direction multiplier
            var colourName = (document.getElementById('flashColour') || {}).value || 'Monument';
            var csHex = COLORBOND_COLOURS[colourName] || '#F15A29';

            // A) Thick coloured edge on colour side (actual Colorbond colour)
            ctx.save();
            ctx.strokeStyle = csHex;
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = 0.85;
            ctx.beginPath();
            for (var j = 0; j < pts.length - 1; j++) {
                var a = pts[j], b = pts[j + 1];
                var ddx = b.x - a.x, ddy = b.y - a.y;
                var dl = Math.sqrt(ddx * ddx + ddy * ddy);
                if (dl === 0) continue;
                var offPx = 2; // 2px offset toward colour side
                var nx = (-ddy / dl) * csDir * offPx, ny = (ddx / dl) * csDir * offPx;
                var pa = flashMMToCanvas(a.x, a.y);
                var pb = flashMMToCanvas(b.x, b.y);
                if (j === 0) ctx.moveTo(pa.x + nx, pa.y + ny);
                else ctx.lineTo(pa.x + nx, pa.y + ny);
                ctx.lineTo(pb.x + nx, pb.y + ny);
            }
            ctx.stroke();
            ctx.restore();

            // B) Diagonal hatching on back (galv) side
            ctx.save();
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 0.5;
            ctx.globalAlpha = 0.4;
            var hatchSpacing = 4; // px between hatch lines
            var hatchWidth = 10; // px strip width on back side
            for (var jh = 0; jh < pts.length - 1; jh++) {
                var ha = pts[jh], hb = pts[jh + 1];
                var hdx = hb.x - ha.x, hdy = hb.y - ha.y;
                var hLen = Math.sqrt(hdx * hdx + hdy * hdy);
                if (hLen === 0) continue;
                // Unit normal pointing to back side (opposite of colour side)
                var bnx = (-hdy / hLen) * (-csDir), bny = (hdx / hLen) * (-csDir);
                // Unit tangent along segment
                var btx = hdx / hLen, bty = hdy / hLen;
                var cpa = flashMMToCanvas(ha.x, ha.y);
                var cpb = flashMMToCanvas(hb.x, hb.y);
                var segPxLen = Math.sqrt(Math.pow(cpb.x - cpa.x, 2) + Math.pow(cpb.y - cpa.y, 2));
                if (segPxLen < 1) continue; // skip zero-length segments to avoid division by zero
                // Draw diagonal hatch lines along this segment
                for (var ht = -hatchWidth; ht < segPxLen + hatchWidth; ht += hatchSpacing) {
                    var frac = ht / segPxLen;
                    var baseX = cpa.x + (cpb.x - cpa.x) * frac;
                    var baseY = cpa.y + (cpb.y - cpa.y) * frac;
                    ctx.beginPath();
                    ctx.moveTo(baseX + bnx * 2, baseY + bny * 2);
                    ctx.lineTo(baseX + bnx * hatchWidth + (cpb.x - cpa.x) / segPxLen * hatchSpacing, baseY + bny * hatchWidth + (cpb.y - cpa.y) / segPxLen * hatchSpacing);
                    ctx.stroke();
                }
            }
            ctx.restore();

            // C) Labels â€” colour name pill on colour side, "GALV" on back side
            var midIdx = Math.floor(pts.length / 2);
            var midPt = pts[midIdx > 0 ? midIdx - 1 : 0];
            var midPtB = pts[Math.min(midIdx, pts.length - 1)];
            var lmx = (midPt.x + midPtB.x) / 2, lmy = (midPt.y + midPtB.y) / 2;
            var lmdx = midPtB.x - midPt.x, lmdy = midPtB.y - midPt.y;
            var lml = Math.sqrt(lmdx * lmdx + lmdy * lmdy) || 1;
            var csNx = -lmdy / lml * csDir, csNy = lmdx / lml * csDir;
            var lc = flashMMToCanvas(lmx, lmy);

            // Colour name pill badge on colour side
            ctx.save();
            ctx.font = 'bold 8px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            var pillText = colourName;
            var pillW = ctx.measureText(pillText).width + 10;
            var pillH = 14;
            var pillX = lc.x + csNx * 22;
            var pillY = lc.y + csNy * 22;
            // Pill background
            ctx.fillStyle = csHex;
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.roundRect(pillX - pillW / 2, pillY - pillH / 2, pillW, pillH, pillH / 2);
            ctx.fill();
            // Pill text â€” white for dark colours, dark for light colours
            var r = parseInt(csHex.slice(1, 3), 16), g = parseInt(csHex.slice(3, 5), 16), bl = parseInt(csHex.slice(5, 7), 16);
            var luma = (r * 299 + g * 587 + bl * 114) / 1000;
            ctx.fillStyle = luma < 140 ? '#fff' : '#222';
            ctx.globalAlpha = 1;
            ctx.fillText(pillText, pillX, pillY);
            ctx.restore();

            // "GALV" label on back side
            ctx.save();
            ctx.font = 'bold 8px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#999';
            ctx.globalAlpha = 0.7;
            var galvX = lc.x - csNx * 20;
            var galvY = lc.y - csNy * 20;
            ctx.fillText('GALV', galvX, galvY);
            ctx.restore();

            // Draw points â€” visible circles at each vertex
            for (var k = 0; k < pts.length; k++) {
                var pt = flashMMToCanvas(pts[k].x, pts[k].y);
                var isHover = (k === flashHoverPoint);
                var isSel = (k === flashSelectedIdx);
                var radius = isSel ? 7 : (isHover ? 5.5 : 4);
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = isSel ? var_sw_orange() : (isHover ? '#60a5fa' : '#293C46');
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = isSel ? 2 : 1.5;
                ctx.stroke();
            }

            if (!showDims) return;

            // === ALWAYS-VISIBLE DIMENSIONS (pill badges) ===
            for (var m = 0; m < pts.length - 1; m++) {
                var p1 = pts[m], p2 = pts[m + 1];
                var dx2 = p2.x - p1.x, dy2 = p2.y - p1.y;
                var legLen = Math.round(Math.sqrt(dx2 * dx2 + dy2 * dy2));
                if (legLen < 1) continue;
                var c1 = flashMMToCanvas(p1.x, p1.y);
                var c2 = flashMMToCanvas(p2.x, p2.y);
                var mx2 = (c1.x + c2.x) / 2, my2 = (c1.y + c2.y) / 2;

                // Perpendicular offset so label doesn't overlap line
                var segAngle = Math.atan2(c2.y - c1.y, c2.x - c1.x);
                var offsetPx = 16;
                var offsetX = Math.sin(segAngle) * offsetPx;
                var offsetY = -Math.cos(segAngle) * offsetPx;

                var text = legLen + 'mm';
                drawFlashPill(ctx, mx2 + offsetX, my2 + offsetY, text, '#1a365d', '#fff');

                // === ANGLE BADGES at each bend (skip near-straight bends) ===
                if (m > 0) {
                    var prev = pts[m - 1], curr = pts[m], next = pts[m + 1];
                    var ang = calcBendAngle(prev, curr, next);
                    if (ang < 175) {
                        drawFlashAngleBadge(ctx, curr, prev, next, ang);
                    }
                }
            }
            // Angle badge at last internal bend (last segment doesn't draw it in the loop)
            if (pts.length >= 3) {
                var lm = pts.length - 2;
                var lprev = pts[lm - 1], lcurr = pts[lm], lnext = pts[lm + 1];
                var lang = calcBendAngle(lprev, lcurr, lnext);
                // Already drawn in loop above for m > 0
            }
        }

        // Pill-shaped badge for dimensions
        function drawFlashPill(ctx, cx, cy, text, bgColor, textColor) {
            ctx.font = 'bold 11px Arial, sans-serif';
            var tw = ctx.measureText(text).width;
            var pw = tw + 10, ph = 18, pr = 9;
            var px = cx - pw / 2, py = cy - ph / 2;

            // Rounded rect background
            ctx.fillStyle = bgColor;
            ctx.globalAlpha = 0.88;
            ctx.beginPath();
            ctx.moveTo(px + pr, py);
            ctx.lineTo(px + pw - pr, py);
            ctx.arcTo(px + pw, py, px + pw, py + pr, pr);
            ctx.lineTo(px + pw, py + ph - pr);
            ctx.arcTo(px + pw, py + ph, px + pw - pr, py + ph, pr);
            ctx.lineTo(px + pr, py + ph);
            ctx.arcTo(px, py + ph, px, py + ph - pr, pr);
            ctx.lineTo(px, py + pr);
            ctx.arcTo(px, py, px + pr, py, pr);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;

            // Text
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.fillText(text, cx, cy + 4);
            ctx.textAlign = 'left';
        }

        // Angle badge at bends â€” pill with arc indicator
        function drawFlashAngleBadge(ctx, point, prevPoint, nextPoint, includedAngle) {
            var cp = flashMMToCanvas(point.x, point.y);
            var arcRadius = 18;

            // Calculate angles of both legs (canvas space)
            var pp2 = flashMMToCanvas(prevPoint.x, prevPoint.y);
            var np2 = flashMMToCanvas(nextPoint.x, nextPoint.y);
            var angle1 = Math.atan2(pp2.y - cp.y, pp2.x - cp.x);
            var angle2 = Math.atan2(np2.y - cp.y, np2.x - cp.x);

            // Inside of bend (shorter arc)
            var diff = angle2 - angle1;
            while (diff > Math.PI) diff -= 2 * Math.PI;
            while (diff < -Math.PI) diff += 2 * Math.PI;
            var counterclockwise = diff < 0;

            // Draw arc on the interior (short) side of the bend
            ctx.beginPath();
            ctx.arc(cp.x, cp.y, arcRadius, angle1, angle2, counterclockwise);
            ctx.strokeStyle = '#e85a1c';
            ctx.lineWidth = 1.2;
            ctx.stroke();

            // Position label at midpoint of arc, outside
            var midAngle;
            if (counterclockwise) {
                var arcSpan = angle1 - angle2;
                while (arcSpan < 0) arcSpan += 2 * Math.PI;
                midAngle = angle1 - arcSpan / 2;
            } else {
                var arcSpan2 = angle2 - angle1;
                while (arcSpan2 < 0) arcSpan2 += 2 * Math.PI;
                midAngle = angle1 + arcSpan2 / 2;
            }
            var labelRadius = arcRadius + 14;
            var labelX = cp.x + Math.cos(midAngle) * labelRadius;
            var labelY = cp.y + Math.sin(midAngle) * labelRadius;

            var angText = Math.round(includedAngle) + '\u00B0';
            drawFlashPill(ctx, labelX, labelY, angText, '#e85a1c', '#fff');
        }

        function var_sw_orange() { return '#F15A29'; }

        // Generate profile dimension string: "80 Ã— 270 Ã— 100"
        function flashProfileDimString(pts) {
            if (!pts || pts.length < 2) return '--';
            var legs = calcLegs(pts);
            return legs.map(function(l) { return l.length; }).join(' \u00D7 ');
        }

        // List non-90Â° angles in profile
        function flashNon90Angles(pts) {
            if (!pts || pts.length < 3) return [];
            var result = [];
            for (var i = 1; i < pts.length - 1; i++) {
                var ang = Math.round(calcBendAngle(pts[i - 1], pts[i], pts[i + 1]));
                if (ang !== 90) {
                    result.push({ point: i + 1, angle: ang });
                }
            }
            return result;
        }

        // Format colour side for display (maps legacy 'top'/'bottom' to 'Inside'/'Outside')
        function flashColourSideLabel(cs) {
            if (cs === 'inside' || cs === 'top') return 'Inside';
            if (cs === 'outside' || cs === 'bottom') return 'Outside';
            return cs;
        }

        function calcBendAngle(a, b, c) {
            var v1x = a.x - b.x, v1y = a.y - b.y;
            var v2x = c.x - b.x, v2y = c.y - b.y;
            var dot = v1x * v2x + v1y * v2y;
            var cross = v1x * v2y - v1y * v2x;
            var angle = Math.atan2(Math.abs(cross), dot) * 180 / Math.PI;
            return angle;
        }

        function calcGirth(pts) {
            var total = 0;
            for (var i = 0; i < pts.length - 1; i++) {
                var dx = pts[i + 1].x - pts[i].x;
                var dy = pts[i + 1].y - pts[i].y;
                total += Math.sqrt(dx * dx + dy * dy);
            }
            return Math.round(total);
        }

        function calcLegs(pts) {
            var legs = [];
            for (var i = 0; i < pts.length - 1; i++) {
                var dx = pts[i + 1].x - pts[i].x;
                var dy = pts[i + 1].y - pts[i].y;
                var len = Math.round(Math.sqrt(dx * dx + dy * dy));
                var angle = null;
                if (i < pts.length - 2) {
                    angle = Math.round(calcBendAngle(pts[i], pts[i + 1], pts[i + 2]));
                }
                legs.push({ length: len, angle: angle });
            }
            return legs;
        }

        function updateFlashInfo() {
            var gEl = document.getElementById('flashGirth');
            var lEl = document.getElementById('flashLegs');
            var zEl = document.getElementById('flashZoom');
            if (gEl) gEl.textContent = calcGirth(flashCurrentPoints);
            if (lEl) lEl.textContent = Math.max(0, flashCurrentPoints.length - 1);
            if (zEl) zEl.textContent = flashZoomLevel;
        }

        // ---- Mouse handlers ----
        function getFlashCanvasPos(e) {
            var canvas = document.getElementById('flashCanvas');
            var rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function flashFindNearPoint(canvasPos, threshold) {
            threshold = threshold || 10;
            for (var i = 0; i < flashCurrentPoints.length; i++) {
                var cp = flashMMToCanvas(flashCurrentPoints[i].x, flashCurrentPoints[i].y);
                var dx = cp.x - canvasPos.x, dy = cp.y - canvasPos.y;
                if (Math.sqrt(dx * dx + dy * dy) < threshold) return i;
            }
            return -1;
        }

        // ---- Mode management ----
        function setFlashMode(mode) {
            flashMode = mode;
            flashDrawing = (mode === 'extending'); // legacy compat
            if (mode === 'viewing') {
                flashSelectedIdx = -1;
                flashSelectedSeg = -1;
                // Auto-turn off draw tool when finishing
                if (flashDrawTool) {
                    flashDrawTool = false;
                    var btn = document.getElementById('flashDrawToggle');
                    if (btn) btn.classList.remove('active');
                }
            }
            updateFlashStatusBar();
            updateFlashCursor();
            updateFlashInspector();
            drawFlashCanvas();
        }

        function toggleFlashDraw() {
            flashDrawTool = !flashDrawTool;
            var btn = document.getElementById('flashDrawToggle');
            if (btn) btn.classList.toggle('active', flashDrawTool);
            if (flashDrawTool) {
                // If points exist, enter extending mode from last point
                if (flashCurrentPoints.length > 0) {
                    setFlashMode('extending');
                }
                // If no points, wait for first click to place initial point
            } else {
                if (flashMode === 'extending') setFlashMode('viewing');
            }
            updateFlashCursor();
            drawFlashCanvas();
        }

        function updateFlashStatusBar() {
            var modeEl = document.getElementById('flashStatusMode');
            var hintsEl = document.getElementById('flashStatusHints');
            var btnEl = document.getElementById('flashStatusBtn');
            if (!modeEl) return;

            modeEl.className = 'flash-status-mode';
            switch (flashMode) {
                case 'viewing':
                    modeEl.textContent = 'VIEWING';
                    hintsEl.textContent = 'Click "Draw" or press D to start \u2022 Click endpoint to extend \u2022 Drag to pan';
                    btnEl.style.display = 'none';
                    break;
                case 'extending':
                    modeEl.textContent = 'EXTENDING';
                    modeEl.classList.add('extending');
                    hintsEl.textContent = 'Click to place point \u2022 Shift = 45\u00B0 snap \u2022 ESC = cancel';
                    btnEl.style.display = '';
                    btnEl.textContent = 'Cancel';
                    break;
                case 'selected':
                    modeEl.textContent = flashSelectedSeg >= 0 ? 'SEGMENT' : 'POINT';
                    modeEl.classList.add('selected');
                    hintsEl.textContent = flashSelectedSeg >= 0
                        ? 'Segment selected \u2022 Click elsewhere to deselect'
                        : 'Drag to move \u2022 Delete to remove \u2022 Click elsewhere to deselect';
                    btnEl.style.display = '';
                    btnEl.textContent = 'Deselect';
                    break;
            }
        }

        function flashStatusAction() {
            if (flashMode === 'extending') {
                setFlashMode('viewing');
            } else if (flashMode === 'selected') {
                flashSelectedIdx = -1;
                flashSelectedSeg = -1;
                setFlashMode('viewing');
            }
        }

        function updateFlashCursor() {
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;
            switch (flashMode) {
                case 'extending': canvas.style.cursor = 'crosshair'; break;
                case 'selected': canvas.style.cursor = flashHoverPoint !== -1 ? 'pointer' : 'grab'; break;
                default:
                    if (flashDrawTool) canvas.style.cursor = 'crosshair';
                    else if (flashHoverPoint !== -1) canvas.style.cursor = 'pointer';
                    else if (flashHoverEndpoint !== -1) canvas.style.cursor = 'crosshair';
                    else canvas.style.cursor = 'grab';
                    break;
            }
        }

        // ---- Inspector panel ----
        function updateFlashInspector() {
            var panel = document.getElementById('flashInspector');
            var title = document.getElementById('flashInspTitle');
            var body = document.getElementById('flashInspBody');
            if (!panel) return;

            if (flashMode !== 'selected' || (flashSelectedIdx < 0 && flashSelectedSeg < 0)) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = '';

            if (flashSelectedIdx >= 0) {
                // POINT inspector
                var pt = flashCurrentPoints[flashSelectedIdx];
                title.textContent = 'Point ' + (flashSelectedIdx + 1);
                var html = '';
                html += '<div class="flash-insp-row"><label>X:</label><input type="number" id="flashInspX" value="' + Math.round(pt.x) + '" step="1" oninput="flashInspSetPoint(\'x\',this.value)"><span class="flash-insp-unit">mm</span></div>';
                html += '<div class="flash-insp-row"><label>Y:</label><input type="number" id="flashInspY" value="' + Math.round(pt.y) + '" step="1" oninput="flashInspSetPoint(\'y\',this.value)"><span class="flash-insp-unit">mm</span></div>';

                // Editable angle at this point (if between two segments)
                if (flashSelectedIdx > 0 && flashSelectedIdx < flashCurrentPoints.length - 1) {
                    var ang = calcBendAngle(flashCurrentPoints[flashSelectedIdx - 1], pt, flashCurrentPoints[flashSelectedIdx + 1]);
                    html += '<div class="flash-insp-row"><label>Ang:</label><input type="number" id="flashInspAngle" value="' + Math.round(ang) + '" min="1" max="359" step="1" onchange="flashInspSetAngle(this.value)"><span class="flash-insp-unit">\u00B0</span></div>';
                }

                html += '<button class="flash-insp-btn danger" onclick="flashInspDeletePoint()">Delete Point</button>';
                body.innerHTML = html;
            } else if (flashSelectedSeg >= 0) {
                // SEGMENT inspector
                var a = flashCurrentPoints[flashSelectedSeg];
                var b = flashCurrentPoints[flashSelectedSeg + 1];
                title.textContent = 'Segment ' + (flashSelectedSeg + 1) + '\u2192' + (flashSelectedSeg + 2);
                var dx = b.x - a.x, dy = b.y - a.y;
                var len = Math.round(Math.sqrt(dx * dx + dy * dy));
                var segAng = Math.round(Math.atan2(dy, dx) * 180 / Math.PI);

                var html = '';
                html += '<div class="flash-insp-row"><label>Len:</label><input type="number" id="flashInspLen" value="' + len + '" min="1" step="1" oninput="flashInspSetLength(this.value)"><span class="flash-insp-unit">mm</span></div>';
                html += '<div class="flash-insp-info">Direction: ' + segAng + '\u00B0' + (segAng === 0 ? ' (horizontal)' : segAng === 90 || segAng === -90 ? ' (vertical)' : '') + '</div>';
                html += '<button class="flash-insp-btn" onclick="flashInspInsertPoint()">Insert Point</button>';
                html += '<button class="flash-insp-btn danger" onclick="flashInspDeleteSegment()">Delete Segment</button>';
                body.innerHTML = html;
            }
        }

        function flashInspSetPoint(axis, value) {
            if (flashSelectedIdx < 0) return;
            var val = parseInt(value);
            if (isNaN(val)) return;
            flashCurrentPoints[flashSelectedIdx][axis] = val;
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashInspSetAngle(value) {
            var idx = flashSelectedIdx;
            if (idx <= 0 || idx >= flashCurrentPoints.length - 1) return;
            var targetAngle = parseFloat(value);
            if (isNaN(targetAngle) || targetAngle <= 0 || targetAngle >= 360) return;

            flashPushUndo();
            var prev = flashCurrentPoints[idx - 1];
            var curr = flashCurrentPoints[idx];
            var next = flashCurrentPoints[idx + 1];

            // Current outgoing leg
            var outDx = next.x - curr.x, outDy = next.y - curr.y;
            var outLen = Math.sqrt(outDx * outDx + outDy * outDy);
            if (outLen === 0) return;

            // Incoming direction
            var inDx = curr.x - prev.x, inDy = curr.y - prev.y;
            var inAngle = Math.atan2(inDy, inDx);

            // Determine chirality (bend direction) via cross product
            var cross = inDx * outDy - inDy * outDx;
            var sign = cross >= 0 ? 1 : -1;

            // Target bend angle â†’ compute new outgoing angle
            var targetRad = targetAngle * Math.PI / 180;
            var newOutAngle = inAngle + sign * (Math.PI - targetRad);

            flashCurrentPoints[idx + 1] = {
                x: Math.round(curr.x + Math.cos(newOutAngle) * outLen),
                y: Math.round(curr.y + Math.sin(newOutAngle) * outLen)
            };
            drawFlashCanvas();
            updateFlashInfo();
            // Don't call updateFlashInspector here to avoid replacing the input while typing
        }

        function flashFindNearAngleBadge(canvasPos, threshold) {
            threshold = threshold || 18;
            var pts = flashCurrentPoints;
            for (var i = 1; i < pts.length - 1; i++) {
                var cp = flashMMToCanvas(pts[i].x, pts[i].y);
                var pp = flashMMToCanvas(pts[i - 1].x, pts[i - 1].y);
                var np = flashMMToCanvas(pts[i + 1].x, pts[i + 1].y);

                var arcRadius = 18;
                var angle1 = Math.atan2(pp.y - cp.y, pp.x - cp.x);
                var angle2 = Math.atan2(np.y - cp.y, np.x - cp.x);
                var diff = angle2 - angle1;
                while (diff > Math.PI) diff -= 2 * Math.PI;
                while (diff < -Math.PI) diff += 2 * Math.PI;
                var counterclockwise = diff < 0;

                var midAngle;
                if (counterclockwise) {
                    var arcSpan = angle1 - angle2;
                    while (arcSpan < 0) arcSpan += 2 * Math.PI;
                    midAngle = angle1 - arcSpan / 2;
                } else {
                    var arcSpan2 = angle2 - angle1;
                    while (arcSpan2 < 0) arcSpan2 += 2 * Math.PI;
                    midAngle = angle1 + arcSpan2 / 2;
                }
                var labelRadius = arcRadius + 14;
                var labelX = cp.x + Math.cos(midAngle) * labelRadius;
                var labelY = cp.y + Math.sin(midAngle) * labelRadius;

                var dx = canvasPos.x - labelX, dy = canvasPos.y - labelY;
                if (Math.sqrt(dx * dx + dy * dy) < threshold) return i;
            }
            return -1;
        }

        function flashInspSetLength(value) {
            if (flashSelectedSeg < 0) return;
            var newLen = parseInt(value);
            if (isNaN(newLen) || newLen < 1) return;
            var a = flashCurrentPoints[flashSelectedSeg];
            var b = flashCurrentPoints[flashSelectedSeg + 1];
            var dx = b.x - a.x, dy = b.y - a.y;
            var curLen = Math.sqrt(dx * dx + dy * dy);
            if (curLen === 0) return;
            var scale = newLen / curLen;
            flashCurrentPoints[flashSelectedSeg + 1] = {
                x: Math.round(a.x + dx * scale),
                y: Math.round(a.y + dy * scale)
            };
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashInspInsertPoint() {
            if (flashSelectedSeg < 0) return;
            var a = flashCurrentPoints[flashSelectedSeg];
            var b = flashCurrentPoints[flashSelectedSeg + 1];
            var mid = { x: Math.round((a.x + b.x) / 2), y: Math.round((a.y + b.y) / 2) };
            flashPushUndo();
            flashCurrentPoints.splice(flashSelectedSeg + 1, 0, mid);
            flashSelectedIdx = flashSelectedSeg + 1;
            flashSelectedSeg = -1;
            updateFlashInspector();
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashInspDeleteSegment() {
            if (flashSelectedSeg < 0) return;
            // Remove the end point of the segment
            flashPushUndo();
            flashCurrentPoints.splice(flashSelectedSeg + 1, 1);
            flashSelectedSeg = -1;
            setFlashMode('viewing');
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashInspDeletePoint() {
            if (flashSelectedIdx < 0) return;
            flashPushUndo();
            flashCurrentPoints.splice(flashSelectedIdx, 1);
            flashSelectedIdx = -1;
            setFlashMode('viewing');
            drawFlashCanvas();
            updateFlashInfo();
        }

        function closeFlashInspector() {
            flashSelectedIdx = -1;
            flashSelectedSeg = -1;
            setFlashMode('viewing');
        }

        // Find nearest segment (not point) within threshold pixels
        function flashFindNearSegment(canvasPos, threshold) {
            threshold = threshold || 8;
            for (var i = 0; i < flashCurrentPoints.length - 1; i++) {
                var a = flashMMToCanvas(flashCurrentPoints[i].x, flashCurrentPoints[i].y);
                var b = flashMMToCanvas(flashCurrentPoints[i + 1].x, flashCurrentPoints[i + 1].y);
                var dist = pointToSegmentDist(canvasPos, a, b);
                if (dist < threshold) return i;
            }
            return -1;
        }

        function pointToSegmentDist(p, a, b) {
            var dx = b.x - a.x, dy = b.y - a.y;
            var lenSq = dx * dx + dy * dy;
            if (lenSq === 0) return Math.sqrt((p.x - a.x) * (p.x - a.x) + (p.y - a.y) * (p.y - a.y));
            var t = Math.max(0, Math.min(1, ((p.x - a.x) * dx + (p.y - a.y) * dy) / lenSq));
            var projX = a.x + t * dx, projY = a.y + t * dy;
            return Math.sqrt((p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY));
        }

        // ---- Shared click logic (used by both mouse and touch) ----
        function flashMouseDownAt(pos) {
            // Replicates left-click logic for touch
            var mm = flashCanvasToMM(pos.x, pos.y);

            if (flashMode === 'extending') {
                var snapped = flashSnapToGrid(mm);
                if (flashSnapAngle || flashAutoSnap) {
                    if (flashCurrentPoints.length > 0) {
                        snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
                    }
                }
                flashPushUndo();
                flashCurrentPoints.push({ x: snapped.x, y: snapped.y });
                drawFlashCanvas();
                updateFlashInfo();
                return;
            }

            var nearIdx = flashFindNearPoint(pos, 18);
            if (nearIdx !== -1) {
                flashSelectedIdx = nearIdx;
                flashSelectedSeg = -1;
                setFlashMode('selected');
                return;
            }

            var nearBadge = flashFindNearAngleBadge(pos, 22);
            if (nearBadge !== -1) {
                flashSelectedIdx = nearBadge;
                flashSelectedSeg = -1;
                setFlashMode('selected');
                return;
            }

            var nearSeg = flashFindNearSegment(pos, 14);
            if (nearSeg !== -1) {
                flashSelectedIdx = -1;
                flashSelectedSeg = nearSeg;
                setFlashMode('selected');
                drawFlashCanvas();
                return;
            }

            if (flashDrawTool && flashMode === 'viewing') {
                var snapped2 = flashSnapToGrid(mm);
                flashPushUndo();
                flashCurrentPoints.push({ x: snapped2.x, y: snapped2.y });
                setFlashMode('extending');
                updateFlashInfo();
                return;
            }

            if (flashMode === 'selected') {
                flashSelectedIdx = -1;
                flashSelectedSeg = -1;
                setFlashMode('viewing');
            }
            drawFlashCanvas();
        }

        function flashDblClickAt(pos, mm, snapped) {
            if (flashMode === 'extending') {
                flashUndo();
                setFlashMode('viewing');
                return;
            }

            var nearIdx = flashFindNearPoint(pos, 18);
            if (nearIdx !== -1) {
                if (nearIdx === 0) flashCurrentPoints.reverse();
                flashSelectedIdx = -1;
                flashSelectedSeg = -1;
                setFlashMode('extending');
            } else {
                if (flashSnapAngle && flashCurrentPoints.length > 0) {
                    snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
                }
                flashPushUndo();
                flashCurrentPoints.push({ x: snapped.x, y: snapped.y });
                setFlashMode('extending');
            }
            drawFlashCanvas();
            updateFlashInfo();
        }

        // ---- Mouse handlers ----
        function flashMouseDown(e) {
            var canvas = e.target;
            var pos = getFlashCanvasPos(e);
            var mm = flashCanvasToMM(pos.x, pos.y);

            if (e.button === 0) {
                if (flashMode === 'extending') {
                    // EXTEND MODE: click places a point
                    // Detect 2nd click of a double-click â€” suppress point placement
                    var now = Date.now();
                    var cdx = pos.x - flashExtLastClickPos.x, cdy = pos.y - flashExtLastClickPos.y;
                    if (now - flashExtLastClickTime < 400 && Math.sqrt(cdx * cdx + cdy * cdy) < 25) {
                        // This is the 2nd click of a double-click â€” skip placing point
                        flashExtLastClickTime = 0;
                        return;
                    }
                    flashExtLastClickTime = now;
                    flashExtLastClickPos = { x: pos.x, y: pos.y };

                    var snapped = flashSnapToGrid(mm);
                    if (flashSnapAngle || flashAutoSnap) {
                        if (flashCurrentPoints.length > 0) {
                            snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
                        }
                    }
                    flashPushUndo();
                    flashCurrentPoints.push({ x: snapped.x, y: snapped.y });
                    // Stay in extending mode (chaining)
                    drawFlashCanvas();
                    updateFlashInfo();
                    return;
                }

                // VIEWING / SELECTED mode â€” check angle badge first
                var nearBadge = flashFindNearAngleBadge(pos, 18);
                if (nearBadge !== -1) {
                    flashSelectedIdx = nearBadge;
                    flashSelectedSeg = -1;
                    setFlashMode('selected');
                    return;
                }

                var nearIdx = flashFindNearPoint(pos, 12);
                if (nearIdx !== -1) {
                    // Click on point â†’ select it (drag intent, not actual drag yet)
                    flashSelectedIdx = nearIdx;
                    flashSelectedSeg = -1;
                    flashDragIntent = true;
                    flashDragUndoPushed = false;
                    flashIsPanning = false;
                    flashDragStart = pos;
                    setFlashMode('selected');
                    return;
                }

                // Check near segment
                var nearSeg = flashFindNearSegment(pos, 10);
                if (nearSeg !== -1) {
                    flashSelectedIdx = -1;
                    flashSelectedSeg = nearSeg;
                    setFlashMode('selected');
                    drawFlashCanvas();
                    return;
                }

                // Click empty space
                if (flashDrawTool && flashMode === 'viewing') {
                    // Draw tool active: place first point and enter extending
                    var snapped = flashSnapToGrid(mm);
                    flashPushUndo();
                    flashCurrentPoints.push({ x: snapped.x, y: snapped.y });
                    setFlashMode('extending');
                    updateFlashInfo();
                    return;
                }
                if (flashMode === 'selected') {
                    flashSelectedIdx = -1;
                    flashSelectedSeg = -1;
                    setFlashMode('viewing');
                }
                // Left-click drag on whitespace = pan (when not in draw mode)
                if (!flashDrawTool) {
                    flashDragging = true;
                    flashIsPanning = true;
                    flashDragStart = pos;
                    flashPanStart = { x: flashPanOffset.x, y: flashPanOffset.y };
                    canvas.style.cursor = 'grabbing';
                }
            } else if (e.button === 1) {
                // Middle: always pan
                flashDragging = true;
                flashIsPanning = true;
                flashDragStart = pos;
                flashPanStart = { x: flashPanOffset.x, y: flashPanOffset.y };
                canvas.style.cursor = 'grabbing';
            } else if (e.button === 2) {
                // Right-click: exit extending mode
                e.preventDefault();
                if (flashMode === 'extending') {
                    setFlashMode('viewing');
                }
            }
            drawFlashCanvas();
        }

        function flashMouseMove(e) {
            var canvas = e.target;
            var pos = getFlashCanvasPos(e);
            var mm = flashCanvasToMM(pos.x, pos.y);
            var snapped = flashSnapToGrid(mm);

            if ((flashSnapAngle || flashAutoSnap) && flashCurrentPoints.length > 0 && flashMode === 'extending') {
                snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
            }
            flashMouseMM = snapped;

            // Drag threshold: promote intent â†’ actual drag after 4px movement
            if (flashDragIntent && !flashDragging) {
                var ddx = pos.x - flashDragStart.x, ddy = pos.y - flashDragStart.y;
                if (Math.sqrt(ddx * ddx + ddy * ddy) > 4) {
                    if (!flashDragUndoPushed) { flashPushUndo(); flashDragUndoPushed = true; }
                    flashDragging = true;
                    flashDragIntent = false;
                }
            }

            if (flashDragging) {
                if (flashIsPanning) {
                    flashPanOffset.x = flashPanStart.x + (pos.x - flashDragStart.x);
                    flashPanOffset.y = flashPanStart.y + (pos.y - flashDragStart.y);
                } else if (flashSelectedIdx >= 0) {
                    // Dragging a selected point â€” dual-neighbor angle snap
                    var dragSnapped = flashSnapToGrid(mm);
                    if (flashSnapAngle || flashAutoSnap) {
                        dragSnapped = constrainAngleDualNeighbor(flashSelectedIdx, dragSnapped);
                    }
                    flashCurrentPoints[flashSelectedIdx] = { x: dragSnapped.x, y: dragSnapped.y };
                }
            } else if (!flashDragIntent) {
                // Hovering
                flashHoverPoint = flashFindNearPoint(pos, 12);
                // Check angle badge hover for pointer cursor
                var hoverBadge = flashFindNearAngleBadge(pos, 18);
                if (hoverBadge !== -1 && flashHoverPoint === -1) {
                    canvas.style.cursor = 'pointer';
                }
                // Endpoint hover detection (for ghost preview)
                var pts = flashCurrentPoints;
                flashHoverEndpoint = -1;
                if (pts.length >= 2 && flashMode === 'viewing') {
                    var ep0 = flashMMToCanvas(pts[0].x, pts[0].y);
                    var epN = flashMMToCanvas(pts[pts.length - 1].x, pts[pts.length - 1].y);
                    var d0 = Math.sqrt((ep0.x - pos.x) * (ep0.x - pos.x) + (ep0.y - pos.y) * (ep0.y - pos.y));
                    var dN = Math.sqrt((epN.x - pos.x) * (epN.x - pos.x) + (epN.y - pos.y) * (epN.y - pos.y));
                    if (d0 < 24) flashHoverEndpoint = 0;
                    else if (dN < 24) flashHoverEndpoint = pts.length - 1;
                }
                if (hoverBadge === -1) updateFlashCursor();
            }

            drawFlashCanvas();
        }

        function flashMouseUp(e) {
            flashDragging = false;
            flashDragIntent = false;
            flashIsPanning = false;
            // Single-tap on endpoint stays in 'selected' mode (for dragging).
            // Use double-click to extend from an endpoint (handled in flashDblClick).
            updateFlashCursor();
        }

        function flashDblClick(e) {
            e.preventDefault();
            var pos = getFlashCanvasPos(e);
            var mm = flashCanvasToMM(pos.x, pos.y);
            var snapped = flashSnapToGrid(mm);

            if (flashMode === 'extending') {
                // Double-click while extending â†’ finish drawing
                // Undo the point placed by the 1st click of the double-click
                flashUndo();
                setFlashMode('viewing');
                return;
            }

            var nearIdx = flashFindNearPoint(pos, 12);
            if (nearIdx !== -1) {
                // Double-click existing point â†’ enter EXTEND mode from that point
                // Reorder so this becomes the last point (extend from endpoint)
                // Only allow extending from first or last point
                if (nearIdx === 0) {
                    flashCurrentPoints.reverse();
                }
                // Now last point is the extend origin
                flashSelectedIdx = -1;
                flashSelectedSeg = -1;
                setFlashMode('extending');
            } else {
                // Double-click empty canvas â†’ add new start point, enter EXTEND mode
                if (flashSnapAngle && flashCurrentPoints.length > 0) {
                    snapped = constrainAngle(flashCurrentPoints[flashCurrentPoints.length - 1], snapped);
                }
                flashPushUndo();
                flashCurrentPoints.push({ x: snapped.x, y: snapped.y });
                setFlashMode('extending');
            }
            drawFlashCanvas();
            updateFlashInfo();
        }

        var flashWheelAccum = 0;
        var flashWheelThreshold = 80; // accumulated delta before zoom step triggers
        function flashWheel(e) {
            e.preventDefault();
            // Pinch-to-zoom on trackpad sets ctrlKey
            if (e.ctrlKey) {
                // Pinch gesture â†’ zoom
                flashWheelAccum += e.deltaY;
                if (Math.abs(flashWheelAccum) < 20) return;
                var zoomLevels = [2, 5, 10, 20, 50];
                var curIdx = zoomLevels.indexOf(flashZoomLevel);
                if (curIdx === -1) curIdx = 2;
                if (flashWheelAccum < 0) {
                    if (curIdx > 0) flashZoomLevel = zoomLevels[curIdx - 1];
                } else {
                    if (curIdx < zoomLevels.length - 1) flashZoomLevel = zoomLevels[curIdx + 1];
                }
                flashWheelAccum = 0;
                drawFlashCanvas();
                return;
            }
            // Horizontal scroll â†’ pan X (trackpad two-finger, shift+scroll)
            if (Math.abs(e.deltaX) > 2) {
                flashPanOffset.x -= e.deltaX;
            }
            // Vertical scroll â†’ zoom (mouse wheel) or pan Y (trackpad two-finger)
            // Heuristic: deltaMode 0 + small deltaY = trackpad pan, large = wheel zoom
            if (Math.abs(e.deltaY) > 2) {
                if (e.deltaMode === 0 && Math.abs(e.deltaY) < 40) {
                    // Trackpad two-finger scroll â†’ pan vertically
                    flashPanOffset.y -= e.deltaY;
                } else {
                    // Mouse wheel â†’ zoom
                    flashWheelAccum += e.deltaY;
                    if (Math.abs(flashWheelAccum) < flashWheelThreshold) { drawFlashCanvas(); return; }
                    var zoomLevels2 = [2, 5, 10, 20, 50];
                    var curIdx2 = zoomLevels2.indexOf(flashZoomLevel);
                    if (curIdx2 === -1) curIdx2 = 2;
                    if (flashWheelAccum < 0) {
                        if (curIdx2 > 0) flashZoomLevel = zoomLevels2[curIdx2 - 1];
                    } else {
                        if (curIdx2 < zoomLevels2.length - 1) flashZoomLevel = zoomLevels2[curIdx2 + 1];
                    }
                    flashWheelAccum = 0;
                }
            }
            drawFlashCanvas();
        }

        function flashZoomIn() {
            var zoomLevels = [2, 5, 10, 20, 50];
            var curIdx = zoomLevels.indexOf(flashZoomLevel);
            if (curIdx === -1) curIdx = 2;
            if (curIdx > 0) flashZoomLevel = zoomLevels[curIdx - 1];
            drawFlashCanvas();
        }

        function flashZoomOut() {
            var zoomLevels = [2, 5, 10, 20, 50];
            var curIdx = zoomLevels.indexOf(flashZoomLevel);
            if (curIdx === -1) curIdx = 2;
            if (curIdx < zoomLevels.length - 1) flashZoomLevel = zoomLevels[curIdx + 1];
            drawFlashCanvas();
        }

        function flashZoomFit() {
            if (flashCurrentPoints.length < 2) return;
            var canvas = document.getElementById('flashCanvas');
            if (!canvas) return;
            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (var i = 0; i < flashCurrentPoints.length; i++) {
                var p = flashCurrentPoints[i];
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            }
            var spanX = maxX - minX, spanY = maxY - minY;
            var span = Math.max(spanX, spanY, 10);
            var cw = canvas.width, ch = canvas.height;
            var availPx = Math.min(cw, ch) * 0.7;
            var idealMmPerGrid = span / (availPx / 20);
            var zoomLevels = [2, 5, 10, 20, 50];
            var best = zoomLevels[zoomLevels.length - 1];
            for (var z = 0; z < zoomLevels.length; z++) {
                if (zoomLevels[z] >= idealMmPerGrid) { best = zoomLevels[z]; break; }
            }
            flashZoomLevel = best;
            var midX = (minX + maxX) / 2, midY = (minY + maxY) / 2;
            var pxPerMM = 20 / flashZoomLevel;
            flashPanOffset.x = -midX * pxPerMM;
            flashPanOffset.y = midY * pxPerMM;
            drawFlashCanvas();
        }

        function flashKeyDown(e) {
            if (!flashModalOpen) return;

            if (e.key === 'Shift') { flashSnapAngle = true; return; }

            if (e.key === 'Enter') {
                if (flashMode === 'extending') {
                    setFlashMode('viewing');
                }
            }
            if (e.key === 'Escape') {
                if (flashMode === 'extending') {
                    setFlashMode('viewing');
                } else if (flashMode === 'selected') {
                    flashSelectedIdx = -1;
                    flashSelectedSeg = -1;
                    setFlashMode('viewing');
                } else {
                    closeFlashModal();
                }
            }
            if ((e.key === 'Delete' || e.key === 'Backspace') && flashSelectedIdx >= 0) {
                flashPushUndo();
                flashCurrentPoints.splice(flashSelectedIdx, 1);
                flashSelectedIdx = -1;
                setFlashMode('viewing');
                drawFlashCanvas();
                e.preventDefault();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                flashUndo();
                e.preventDefault();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                flashRedo();
                e.preventDefault();
            }
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
            if (e.key === 'd' || e.key === 'D') toggleFlashDraw();
            if (e.key === 'h' || e.key === 'H') flashFlipH();
            if (e.key === 'v' || e.key === 'V') flashFlipV();
        }

        document.addEventListener('keyup', function(e) {
            if (e.key === 'Shift') flashSnapAngle = false;
        });

        function constrainAngle(from, to) {
            var dx = to.x - from.x;
            var dy = to.y - from.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return to;
            var angle = Math.atan2(dy, dx) * 180 / Math.PI;
            // Snap to nearest 45
            var snapAngles = [0, 45, 90, 135, 180, -45, -90, -135, -180];
            var closest = 0, minDiff = 999;
            snapAngles.forEach(function(sa) {
                var diff = Math.abs(angle - sa);
                if (diff < minDiff) { minDiff = diff; closest = sa; }
            });
            // Also snap near 90 (within Â±5Â°)
            if (Math.abs(angle - 90) <= 5) closest = 90;
            if (Math.abs(angle + 90) <= 5) closest = -90;
            if (Math.abs(angle) <= 5) closest = 0;
            if (Math.abs(Math.abs(angle) - 180) <= 5) closest = angle > 0 ? 180 : -180;

            var rad = closest * Math.PI / 180;
            var snappedDist = Math.round(dist / flashZoomLevel) * flashZoomLevel;
            if (snappedDist === 0) snappedDist = flashZoomLevel;
            return {
                x: from.x + Math.round(Math.cos(rad) * snappedDist),
                y: from.y + Math.round(Math.sin(rad) * snappedDist)
            };
        }

        function constrainAngleDualNeighbor(idx, target) {
            var pts = flashCurrentPoints;
            var candidates = [];
            if (idx > 0) candidates.push(constrainAngle(pts[idx - 1], target));
            if (idx < pts.length - 1) candidates.push(constrainAngle(pts[idx + 1], target));
            if (candidates.length === 0) return target;
            // Pick whichever snapped position is closer to original target
            var best = candidates[0], bestDist = Infinity;
            candidates.forEach(function(c) {
                var dx = c.x - target.x, dy = c.y - target.y;
                var d = dx * dx + dy * dy;
                if (d < bestDist) { bestDist = d; best = c; }
            });
            return best;
        }

        // ---- Tool actions ----

        function setColourSide(side) {
            flashColourSide = side;
            var label = document.getElementById('flashColourSideLabel');
            if (label) label.textContent = side === 'inside' ? 'Inside' : 'Outside';
            drawFlashCanvas();
        }

        function flipColourSide() {
            setColourSide(flashColourSide === 'inside' ? 'outside' : 'inside');
        }

        function flashFlipH() {
            if (flashCurrentPoints.length < 2) return;
            flashPushUndo();
            var minX = Infinity, maxX = -Infinity;
            flashCurrentPoints.forEach(function(p) { if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x; });
            var cx = (minX + maxX) / 2;
            flashCurrentPoints.forEach(function(p) { p.x = 2 * cx - p.x; });
            drawFlashCanvas();
        }

        function flashFlipV() {
            if (flashCurrentPoints.length < 2) return;
            flashPushUndo();
            var minY = Infinity, maxY = -Infinity;
            flashCurrentPoints.forEach(function(p) { if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y; });
            var cy = (minY + maxY) / 2;
            flashCurrentPoints.forEach(function(p) { p.y = 2 * cy - p.y; });
            drawFlashCanvas();
        }

        let flashRedoStack = [];

        function flashPushUndo() {
            flashUndoStack.push(JSON.parse(JSON.stringify(flashCurrentPoints)));
            flashRedoStack = []; // new action clears redo
        }

        function flashUndo() {
            if (flashUndoStack.length === 0) return;
            flashRedoStack.push(JSON.parse(JSON.stringify(flashCurrentPoints)));
            flashCurrentPoints = flashUndoStack.pop();
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashRedo() {
            if (flashRedoStack.length === 0) return;
            flashPushUndo();
            flashCurrentPoints = flashRedoStack.pop();
            drawFlashCanvas();
            updateFlashInfo();
        }

        function flashClearConfirm() {
            if (flashCurrentPoints.length === 0) return;
            if (!confirm('Clear entire profile? This can be undone.')) return;
            flashClear();
        }

        function toggleFlashSnap() {
            flashAutoSnap = !flashAutoSnap;
            var btn = document.getElementById('flashSnapToggle');
            if (btn) {
                btn.textContent = 'Snap: ' + (flashAutoSnap ? 'ON' : 'OFF');
                btn.classList.toggle('active', flashAutoSnap);
            }
            drawFlashCanvas();
        }

        function flashClear() {
            flashPushUndo();
            flashCurrentPoints = [];
            flashSelectedIdx = -1;
            flashSelectedSeg = -1;
            setFlashMode('viewing');
            flashEditingId = null;
            flashStartTreatment = null;
            flashEndTreatment = null;
            var stSel = document.getElementById('flashStartTreat');
            var enSel = document.getElementById('flashEndTreat');
            if (stSel) stSel.value = 'none';
            if (enSel) enSel.value = 'none';
            var treatOpts2 = document.getElementById('flashTreatOpts');
            if (treatOpts2) treatOpts2.style.display = 'none';
            drawFlashCanvas();
        }

        // ---- End Treatment functions ----
        function updateFlashTreatment(which) {
            var sel = document.getElementById(which === 'start' ? 'flashStartTreat' : 'flashEndTreat');
            var val = sel.value;
            var treatment = null;
            if (val === 'miniBreak') {
                var size = parseInt(document.getElementById('flashTreatSize').value) || 10;
                var angle = parseInt(document.getElementById('flashTreatAngle').value) || 45;
                var dirOut = document.getElementById('flashTreatDirOut').classList.contains('active');
                treatment = { type: 'miniBreak', size: size, angle: angle, direction: dirOut ? 'out' : 'in' };
            } else if (val === 'hem') {
                treatment = { type: 'hem' };
            }
            if (which === 'start') flashStartTreatment = treatment;
            else flashEndTreatment = treatment;

            // Show/hide treatment options
            var hasMiniBrk = document.getElementById('flashStartTreat').value === 'miniBreak' || document.getElementById('flashEndTreat').value === 'miniBreak';
            document.getElementById('flashTreatOpts').style.display = hasMiniBrk ? 'flex' : 'none';
            drawFlashCanvas();
        }

        function setTreatDir(dir) {
            document.getElementById('flashTreatDirOut').classList.toggle('active', dir === 'out');
            document.getElementById('flashTreatDirIn').classList.toggle('active', dir === 'in');
            // Re-apply to whichever treatments are miniBreak
            if (flashStartTreatment && flashStartTreatment.type === 'miniBreak') flashStartTreatment.direction = dir;
            if (flashEndTreatment && flashEndTreatment.type === 'miniBreak') flashEndTreatment.direction = dir;
            drawFlashCanvas();
        }

        function drawEndTreatment(ctx, pts, treatment, isStart) {
            if (!treatment || pts.length < 2) return;
            var idx, prevIdx;
            if (isStart) { idx = 0; prevIdx = 1; }
            else { idx = pts.length - 1; prevIdx = pts.length - 2; }

            var pt = flashMMToCanvas(pts[idx].x, pts[idx].y);
            var prev = flashMMToCanvas(pts[prevIdx].x, pts[prevIdx].y);

            // Direction along the leg toward the end
            var dx = pt.x - prev.x, dy = pt.y - prev.y;
            var len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) return;
            var ux = dx / len, uy = dy / len; // unit vector along leg toward endpoint
            // Normal (perpendicular)
            var nx = -uy, ny = ux;

            var pxPerMM = 20 / flashZoomLevel;

            if (treatment.type === 'miniBreak') {
                var sz = (treatment.size || 10) * pxPerMM;
                var ang = (treatment.angle || 45) * Math.PI / 180;
                var dirSign = treatment.direction === 'in' ? -1 : 1;
                // Kick goes outward from the endpoint at the given angle
                var kickX = pt.x + (ux * Math.cos(ang) + nx * dirSign * Math.sin(ang)) * sz;
                var kickY = pt.y + (uy * Math.cos(ang) + ny * dirSign * Math.sin(ang)) * sz;

                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y);
                ctx.lineTo(kickX, kickY);
                ctx.strokeStyle = '#293C46';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                var lblX = (pt.x + kickX) / 2 + nx * dirSign * 10;
                var lblY = (pt.y + kickY) / 2 + ny * dirSign * 10;
                ctx.font = '8px SF Mono, monospace';
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.fillText('MB ' + (treatment.size || 10), lblX, lblY);
                ctx.textAlign = 'left';
            } else if (treatment.type === 'hem') {
                // Draw small U-loop at the end
                var hemSize = 6 * pxPerMM;
                var csDir = flashColourSide === 'inside' ? -1 : 1;
                // Hem folds back on itself
                var hemEnd = { x: pt.x - ux * hemSize, y: pt.y - uy * hemSize };
                var hemMid = { x: pt.x + nx * csDir * hemSize * 0.5, y: pt.y + ny * csDir * hemSize * 0.5 };

                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y);
                ctx.quadraticCurveTo(hemMid.x + ux * hemSize * 0.3, hemMid.y + uy * hemSize * 0.3, hemEnd.x + nx * csDir * hemSize * 0.3, hemEnd.y + ny * csDir * hemSize * 0.3);
                ctx.strokeStyle = '#293C46';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.font = '8px SF Mono, monospace';
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.fillText('HEM', pt.x + nx * csDir * 14, pt.y + ny * csDir * 14);
                ctx.textAlign = 'left';
            }
        }

        // ---- Templates ----
        function getTemplateFolderState() {
            try { return JSON.parse(localStorage.getItem('flashFolderState') || '{}'); } catch(e) { return {}; }
        }
        function saveTemplateFolderState(state) {
            localStorage.setItem('flashFolderState', JSON.stringify(state));
        }
        function toggleTemplateFolder(folderId) {
            var state = getTemplateFolderState();
            state[folderId] = !state[folderId]; // true = collapsed
            saveTemplateFolderState(state);
            var contents = document.getElementById('folder-' + folderId);
            var icon = document.getElementById('ficon-' + folderId);
            if (contents) contents.classList.toggle('collapsed', state[folderId]);
            if (icon) icon.textContent = state[folderId] ? '\uD83D\uDCC1' : '\uD83D\uDCC2';
        }

        function renderFlashTemplates() {
            var container = document.getElementById('flashTemplates');
            if (!container) return;
            container.innerHTML = '';
            var folderState = getTemplateFolderState();

            // Group templates by folder
            var folders = {};
            var folderOrder = ['Skillion / Flat', 'Gable', 'SolarSpan 50mm', 'SolarSpan 75mm', 'SolarSpan 100mm', 'Custom'];
            flashingTemplates.forEach(function(tpl, idx) {
                var f = tpl.folder || 'Standard';
                if (!folders[f]) folders[f] = [];
                folders[f].push({ tpl: tpl, idx: idx });
            });

            // Render each folder
            folderOrder.forEach(function(folderName) {
                var items = folders[folderName];
                if (!items || items.length === 0) return;
                var fid = folderName.replace(/\s+/g, '-').toLowerCase();
                var isCollapsed = folderState[fid] || false;

                var folderDiv = document.createElement('div');
                folderDiv.className = 'template-folder';

                var header = document.createElement('div');
                header.className = 'folder-header';
                header.onclick = function() { toggleTemplateFolder(fid); };
                header.innerHTML = '<span class="folder-icon" id="ficon-' + fid + '">' + (isCollapsed ? '\uD83D\uDCC1' : '\uD83D\uDCC2') + '</span> ' + folderName;
                folderDiv.appendChild(header);

                var contents = document.createElement('div');
                contents.className = 'folder-contents' + (isCollapsed ? ' collapsed' : '');
                contents.id = 'folder-' + fid;

                items.forEach(function(item) {
                    var div = document.createElement('div');
                    div.className = 'flash-tpl';
                    div.onclick = function() { loadFlashTemplate(item.idx); };
                    var cvs = document.createElement('canvas');
                    cvs.width = 56; cvs.height = 34;
                    drawMiniProfile(cvs, item.tpl.points);
                    div.appendChild(cvs);
                    var nm = document.createElement('div');
                    nm.className = 'flash-tpl-name';
                    nm.textContent = item.tpl.name;
                    div.appendChild(nm);
                    contents.appendChild(div);
                });

                folderDiv.appendChild(contents);
                container.appendChild(folderDiv);
            });

        }

        function drawMiniProfile(cvs, pts) {
            if (!pts || pts.length < 2) return;
            var ctx = cvs.getContext('2d');
            var w = cvs.width, h = cvs.height;
            var pad = 6;

            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            pts.forEach(function(p) {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
            });
            var rangeX = maxX - minX || 1;
            var rangeY = maxY - minY || 1;
            var scale = Math.min((w - pad * 2) / rangeX, (h - pad * 2) / rangeY);
            var ox = (w - rangeX * scale) / 2;
            var oy = (h - rangeY * scale) / 2;

            ctx.strokeStyle = '#293C46';
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            pts.forEach(function(p, i) {
                var px = ox + (p.x - minX) * scale;
                var py = oy + (maxY - p.y) * scale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();
        }

        function loadFlashTemplate(idx) {
            if (idx < 0 || idx >= flashingTemplates.length) return;
            var tpl = flashingTemplates[idx];
            flashCurrentPoints = JSON.parse(JSON.stringify(tpl.points));
            flashColourSide = tpl.colourSide || 'inside';
            setFlashMode('viewing');
            flashEditingId = null;
            flashUndoStack = [];

            // Update colour side buttons
            document.querySelectorAll('.flash-cs-btn').forEach(function(b) {
                b.classList.toggle('active', b.dataset.cs === flashColourSide);
            });

            // Update template active state
            document.querySelectorAll('.flash-tpl').forEach(function(t, i) {
                t.classList.toggle('active', i === idx);
            });

            // Center view on profile
            centerFlashView();
            drawFlashCanvas();
        }

        function centerFlashView() {
            if (flashCurrentPoints.length === 0) {
                flashPanOffset = { x: 0, y: 0 };
                return;
            }
            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            flashCurrentPoints.forEach(function(p) {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
            });
            var cx = (minX + maxX) / 2;
            var cy = (minY + maxY) / 2;
            var pxPerMM = 20 / flashZoomLevel;
            flashPanOffset = { x: -cx * pxPerMM, y: cy * pxPerMM };
        }

        function saveFlashTemplate() {
            if (flashCurrentPoints.length < 2) { alert('Draw a profile first before saving as template.'); return; }
            var name = prompt('Template name:', document.getElementById('flashName').value || 'Custom');
            if (!name) return;
            flashingTemplates.push({
                name: name,
                folder: 'Custom',
                points: JSON.parse(JSON.stringify(flashCurrentPoints)),
                colourSide: flashColourSide
            });
            localStorage.setItem('flashingTemplates', JSON.stringify(flashingTemplates));
            renderFlashTemplates();
        }

        // ---- Job flashings list ----
        function flashAddToJob() {
            if (flashCurrentPoints.length < 2) { alert('Draw a profile first.'); return; }
            var name = document.getElementById('flashName').value.trim() || 'Unnamed Flashing';
            var colour = document.getElementById('flashColour').value;
            var gauge = parseFloat(document.getElementById('flashGauge').value) || 0.42;
            var length = parseInt(document.getElementById('flashLength').value) || 3000;
            var qty = parseInt(document.getElementById('flashQty').value) || 1;
            var girth = calcGirth(flashCurrentPoints);
            var legs = calcLegs(flashCurrentPoints);

            if (flashEditingId) {
                // Update existing
                var existing = flashingProfiles.find(function(p) { return p.id === flashEditingId; });
                if (existing) {
                    existing.name = name;
                    existing.colour = colour;
                    existing.gauge = gauge;
                    existing.length = length;
                    existing.qty = qty;
                    existing.colourSide = flashColourSide;
                    existing.points = JSON.parse(JSON.stringify(flashCurrentPoints));
                    existing.girth = girth;
                    existing.legs = legs;
                    existing.startTreatment = flashStartTreatment ? JSON.parse(JSON.stringify(flashStartTreatment)) : null;
                    existing.endTreatment = flashEndTreatment ? JSON.parse(JSON.stringify(flashEndTreatment)) : null;
                }
                flashEditingId = null;
            } else {
                flashingProfiles.push({
                    id: 'flashing_' + String(flashNextId++).padStart(3, '0'),
                    name: name,
                    colour: colour,
                    gauge: gauge,
                    length: length,
                    qty: qty,
                    colourSide: flashColourSide,
                    points: JSON.parse(JSON.stringify(flashCurrentPoints)),
                    girth: girth,
                    legs: legs,
                    startTreatment: flashStartTreatment ? JSON.parse(JSON.stringify(flashStartTreatment)) : null,
                    endTreatment: flashEndTreatment ? JSON.parse(JSON.stringify(flashEndTreatment)) : null
                });
            }

            renderFlashJobTable();
            updateFlashSummary();
            // Reset for next
            flashClear();
            document.getElementById('flashName').value = '';
            document.getElementById('flashLength').value = '4500';
            document.getElementById('flashQty').value = '1';
        }

        function renderFlashJobTable() {
            var tbody = document.getElementById('flashJobBody');
            var totalRow = document.getElementById('flashTotalRow');
            var totalArea = document.getElementById('flashTotalArea');
            if (!tbody) return;

            if (flashingProfiles.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align:center;color:var(--sw-text-sec);padding:16px;font-size:12px">No flashings added yet. Click "Open Editor" to draw profiles.</td></tr>';
                if (totalRow) totalRow.style.display = 'none';
                return;
            }

            var totalSqm = 0;
            tbody.innerHTML = flashingProfiles.map(function(p, i) {
                var area = (p.girth / 1000) * (p.length / 1000) * p.qty;
                totalSqm += area;
                return '<tr class="' + (flashEditingId === p.id ? 'selected' : '') + '">' +
                    '<td class="mono">' + (i + 1) + '</td>' +
                    '<td>' + esc(p.name) + '</td>' +
                    '<td class="r mono">' + p.girth + 'mm</td>' +
                    '<td class="r mono">' + p.length + 'mm<br><span style="font-size:9px;color:var(--sw-text-sec)" title="Order length includes +500mm allowance">order: ' + (p.length + 500) + '</span></td>' +
                    '<td class="r mono">' + p.qty + '</td>' +
                    '<td>' + esc(p.colour) + '</td>' +
                    '<td class="mono">' + p.gauge + 'mm</td>' +
                    '<td style="font-size:10px">' + flashColourSideLabel(p.colourSide) + '</td>' +
                    '<td><div class="flash-row-actions">' +
                        '<button class="flash-row-btn" onclick="flashEditRow(' + i + ')" title="Edit">&#9998;</button>' +
                        '<button class="flash-row-btn" onclick="flashDupeRow(' + i + ')" title="Duplicate">&#10697;</button>' +
                        '<button class="flash-row-btn del" onclick="flashDeleteRow(' + i + ')" title="Delete">&times;</button>' +
                    '</div></td>' +
                '</tr>';
            }).join('');

            if (totalRow) {
                totalRow.style.display = '';
                if (totalArea) totalArea.textContent = totalSqm.toFixed(2);
            }
        }

        function esc(str) {
            var div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function flashEditRow(idx) {
            if (idx < 0 || idx >= flashingProfiles.length) return;
            var p = flashingProfiles[idx];
            flashEditingId = p.id;
            flashCurrentPoints = JSON.parse(JSON.stringify(p.points));
            flashColourSide = p.colourSide;
            setFlashMode('viewing');

            // Open modal first so elements are accessible
            openFlashModal();

            // Restore end treatments
            flashStartTreatment = p.startTreatment ? JSON.parse(JSON.stringify(p.startTreatment)) : null;
            flashEndTreatment = p.endTreatment ? JSON.parse(JSON.stringify(p.endTreatment)) : null;
            var stSel = document.getElementById('flashStartTreat');
            var enSel = document.getElementById('flashEndTreat');
            if (stSel) stSel.value = flashStartTreatment ? flashStartTreatment.type : 'none';
            if (enSel) enSel.value = flashEndTreatment ? flashEndTreatment.type : 'none';
            var hasMiniBrk = (flashStartTreatment && flashStartTreatment.type === 'miniBreak') || (flashEndTreatment && flashEndTreatment.type === 'miniBreak');
            var treatOpts = document.getElementById('flashTreatOpts');
            if (treatOpts) treatOpts.style.display = hasMiniBrk ? 'flex' : 'none';
            if (hasMiniBrk) {
                var mb = (flashStartTreatment && flashStartTreatment.type === 'miniBreak') ? flashStartTreatment : flashEndTreatment;
                document.getElementById('flashTreatSize').value = mb.size || 10;
                document.getElementById('flashTreatAngle').value = mb.angle || 45;
                document.getElementById('flashTreatDirOut').classList.toggle('active', mb.direction === 'out');
                document.getElementById('flashTreatDirIn').classList.toggle('active', mb.direction === 'in');
            }

            document.getElementById('flashName').value = p.name;
            document.getElementById('flashColour').value = p.colour;
            document.getElementById('flashGauge').value = p.gauge;
            document.getElementById('flashLength').value = p.length;
            document.getElementById('flashQty').value = p.qty;

            document.querySelectorAll('.flash-cs-btn').forEach(function(b) {
                b.classList.toggle('active', b.dataset.cs === flashColourSide);
            });

            setTimeout(function() {
                centerFlashView();
                drawFlashCanvas();
            }, 100);
            renderFlashJobTable();
        }

        function flashDupeRow(idx) {
            if (idx < 0 || idx >= flashingProfiles.length) return;
            var orig = flashingProfiles[idx];
            var dupe = JSON.parse(JSON.stringify(orig));
            dupe.id = 'flashing_' + String(flashNextId++).padStart(3, '0');
            dupe.name = orig.name + ' (copy)';
            flashingProfiles.splice(idx + 1, 0, dupe);
            renderFlashJobTable();
            updateFlashSummary();
        }

        function flashDeleteRow(idx) {
            if (idx < 0 || idx >= flashingProfiles.length) return;
            flashingProfiles.splice(idx, 1);
            if (flashEditingId && !flashingProfiles.find(function(p) { return p.id === flashEditingId; })) {
                flashEditingId = null;
            }
            renderFlashJobTable();
            updateFlashSummary();
        }

        // ==================== EXPORT / IMPORT JOB DATA ====================
        function gatherJobData() {
            const c = calc;
            return {
                _version: 'PatioDesignerPro_V18',
                _exported: new Date().toISOString(),
                client: {
                    jobRef: (document.getElementById('jobRef')?.value || '').trim(),
                    name: (document.getElementById('customerName')?.value || '').trim(),
                    address: (document.getElementById('customerAddress')?.value || '').trim(),
                    phone: (document.getElementById('customerPhone')?.value || '').trim(),
                    email: (document.getElementById('clientEmail')?.value || '').trim(),
                    salesperson: (document.getElementById('salesperson')?.value || '')
                },
                config: {
                    roofStyle: document.getElementById('inRoofStyle')?.value,
                    orientation: document.getElementById('inOrientation')?.value,
                    projection: document.getElementById('inWidth')?.value,
                    length: document.getElementById('inLength')?.value,
                    pitch: document.getElementById('inPitch')?.value,
                    postHeight: document.getElementById('inPostHeight')?.value,
                    posts: document.getElementById('inPosts')?.value,
                    postQtyOverride: document.getElementById('inPostQty')?.value,
                    trusses: document.getElementById('inTrusses')?.value,
                    rafters: document.getElementById('inRafters')?.value,
                    rafterSize: document.getElementById('inRafterSize')?.value,
                    rafterSpacing: document.getElementById('inRafterSpacing')?.value,
                    rafterQtyOverride: document.getElementById('inRafterQtyOverride')?.value,
                    purlinSize: document.getElementById('inPurlinSize')?.value,
                    gutterBeamSize: document.getElementById('inGutterBeamSize')?.value,
                    riserBeamSize: document.getElementById('inRiserBeamSize')?.value,
                    roofing: document.getElementById('inRoofing')?.value,
                    infill: document.getElementById('inInfill')?.value,
                    connection: document.getElementById('inConnection')?.value,
                    fasciaHeight: document.getElementById('inFasciaHeight')?.value,
                    riserHeight: document.getElementById('inRiserHeight')?.value,
                    riserOffset: document.getElementById('inRiserOffset')?.value,
                    riserQty: document.getElementById('inRiserQty')?.value,
                    houseGutter: document.getElementById('inHouseGutter')?.value,
                    riserGutter: document.getElementById('inRiserGutter')?.value,
                    fasciaBracketQty: document.getElementById('inFasciaBracketQty')?.value,
                    houseRoofPitch: document.getElementById('inHouseRoofPitch')?.value,
                    houseRoofDepth: document.getElementById('inHouseRoofDepth')?.value,
                    flyoverSetback: document.getElementById('inFlyoverSetback')?.value,
                    flyoverClearance: document.getElementById('inFlyoverClearance')?.value,
                    riserSteel: document.getElementById('inRiserSteel')?.value,
                    postFix: document.getElementById('inPostFix')?.value,
                    postSize: document.getElementById('inPostSize')?.value,
                    beamSize: document.getElementById('inBeamSize')?.value,
                    trussBase: document.getElementById('inTrussBase')?.value,
                    trussChord: document.getElementById('inTrussChord')?.value,
                    trussSteel: document.getElementById('inTrussSteel')?.value,
                    overhang: document.getElementById('inOverhang')?.value,
                    trussRiserLeft: {
                        enabled: document.getElementById('trussRiserOn')?.checked || false,
                        length: document.getElementById('riserLH')?.value || '200',
                        height: document.getElementById('riserLV')?.value || '150'
                    },
                    trussRiserRight: {
                        enabled: document.getElementById('trussRiserOn')?.checked || false,
                        length: document.getElementById('riserRH')?.value || '200',
                        height: document.getElementById('riserRV')?.value || '150'
                    },
                    trussRiserLocked: document.getElementById('trussRiserLock')?.checked || true,
                    riserType: document.getElementById('riserTypeSeparate')?.checked ? 'separate' : 'welded',
                    trussExtender: {
                        enabled: document.getElementById('trussExtOn')?.checked || false,
                        length: document.getElementById('trussExtLen')?.value || '300'
                    },
                    sheetColor: sheetColor.name,
                    steelColor: steelColor.name,
                    flashingColor: flashingColor.name,
                    polycarbEnabled: isPolycarbEnabled(),
                    polycarbBrand: document.getElementById('inPolycarbBrand')?.value,
                    polycarbTint: document.getElementById('inPolycarbTint')?.value,
                    polycarbPattern: document.getElementById('inPolycarbPattern')?.value,
                    polycarbCustom: document.getElementById('inPolycarbCustom')?.value,
                    polycarbLevel: document.getElementById('inPolycarbLevel')?.value,
                    ceilingFinish: document.getElementById('inCeilingFinish')?.value,
                    sheetBMT: document.getElementById('inBMT')?.value || '042',
                    extraBattens: parseInt(document.getElementById('extraBattensVal')?.textContent) || 0,
                    bracketType: document.querySelector('input[name="bracketType"]:checked')?.value || 'internal',
                    dpSelection: dpSelection,
                    lShape: document.getElementById('inLShape')?.value || 'none',
                    wraparound: document.getElementById('inWraparound')?.value || 'none',
                    returnLength: document.getElementById('inReturnLength')?.value || '3000',
                    returnPosts: document.getElementById('inReturnPosts')?.value || '2'
                },
                existingSite: {
                    existing: document.getElementById('existingSite')?.value || 'clear',
                    demoNotes: document.getElementById('demoNotes')?.value || '',
                    electrical: document.getElementById('electrical')?.value || 'none'
                },
                pricing: {
                    addonRows: jobRows.filter(r => r.isAddon),
                    extrasRows: extrasRows,
                    additionalMaterials: additionalMaterials,
                    labour: {
                        trades: document.getElementById('labTrades')?.value,
                        days: document.getElementById('labDays')?.value,
                        dayRate: document.getElementById('labDayRate')?.value,
                        sell: document.getElementById('labSellInput')?.value
                    }
                },
                complexity: {
                    build: document.getElementById('cxBuild')?.value,
                    access: document.getElementById('cxAccess')?.value,
                    distance: document.getElementById('cxDistance')?.value,
                    footing: document.getElementById('cxFooting')?.value,
                    height: document.getElementById('cxHeight')?.value
                },
                notes: {
                    pricingNotes: (document.getElementById('pricingNotes')?.value || '').trim(),
                    noteQuote: (document.getElementById('noteQuote')?.value || '').trim(),
                    noteWorkOrder: (document.getElementById('noteWorkOrder')?.value || '').trim(),
                    noteMaterialOrder: (document.getElementById('noteMaterialOrder')?.value || '').trim(),
                    noteInternal: (document.getElementById('noteInternal')?.value || '').trim()
                },
                scope: {
                    elecDownlights: document.getElementById('elecDownlights')?.checked || false,
                    elecDownlightsQty: document.getElementById('elecDownlightsQty')?.value || '4',
                    elecFan: document.getElementById('elecFan')?.checked || false,
                    elecFanQty: document.getElementById('elecFanQty')?.value || '1',
                    elecGPO: document.getElementById('elecGPO')?.checked || false,
                    elecGPOQty: document.getElementById('elecGPOQty')?.value || '1',
                    scopeDemo: document.getElementById('scopeDemo')?.checked || false,
                    scopeSkip: document.getElementById('scopeSkip')?.checked || false,
                    scopePermit: document.getElementById('scopePermit')?.checked || false
                },
                flashings: flashingProfiles.map(function(p) {
                    return { id: p.id, name: p.name, colour: p.colour, gauge: p.gauge, length: p.length, qty: p.qty, colourSide: p.colourSide, points: p.points, girth: p.girth, legs: p.legs, startTreatment: p.startTreatment || null, endTreatment: p.endTreatment || null };
                })
            };
        }

        function exportJobData() {
            const data = gatherJobData();
            const json = JSON.stringify(data, null, 2);

            // Copy to clipboard
            navigator.clipboard.writeText(json).then(() => {
                alert('Job data copied to clipboard!\n\nPaste this into GHL notes, email, or save as a file to reload later.');
            }).catch(() => {
                // Fallback: download as file
                downloadJobJSON(json, data.client.jobRef);
            });
        }

        function saveJobData() {
            updateSiteDetails();
            var base = gatherJobData();
            var jobData = {
                version: '1.0',
                savedAt: new Date().toISOString(),
                customer: customer,
                siteDetails: siteDetails,
                client: base.client,
                config: base.config,
                pricing: base.pricing,
                complexity: base.complexity,
                notes: base.notes,
                specs: {
                    roofType: base.config.roofStyle,
                    width: base.config.length,
                    projection: base.config.projection,
                    height: base.config.postHeight,
                    pitch: base.config.pitch,
                    roofMaterial: base.config.roofing,
                    attachmentType: base.config.connection,
                    roofColour: base.config.sheetColor,
                    frameColour: base.config.steelColor
                },
                truss: {
                    base: base.config.trussBase,
                    chord: base.config.trussChord,
                    steel: base.config.trussSteel,
                    overhang: base.config.overhang,
                    riserLeft: base.config.trussRiserLeft,
                    riserRight: base.config.trussRiserRight,
                    riserLocked: base.config.trussRiserLocked,
                    riserType: base.config.riserType || 'welded',
                    extender: base.config.trussExtender
                },
                polycarb: {
                    enabled: base.config.polycarbEnabled,
                    brand: base.config.polycarbBrand,
                    tint: base.config.polycarbTint,
                    pattern: base.config.polycarbPattern,
                    custom: base.config.polycarbCustom,
                    level: base.config.polycarbLevel
                },
                flashings: flashingProfiles.map(function(p) {
                    return { id: p.id, name: p.name, colour: p.colour, gauge: p.gauge, length: p.length, qty: p.qty, colourSide: p.colourSide, points: p.points, girth: p.girth, legs: p.legs, startTreatment: p.startTreatment || null, endTreatment: p.endTreatment || null };
                }),
                siteMedia: getSiteMediaSummary()
            };
            var json = JSON.stringify(jobData, null, 2);

            navigator.clipboard.writeText(json).then(function() {
                localStorage.setItem('patio-job-' + Date.now(), json);
                alert('Job data copied to clipboard! Paste into GHL notes.');
            }).catch(function() {
                localStorage.setItem('patio-job-' + Date.now(), json);
                alert('Job data saved locally. Clipboard access was blocked.');
            });
        }

        function showLoadJobModal() {
            document.getElementById('loadJobTextarea').value = '';
            document.getElementById('loadJobStatus').textContent = '';
            document.getElementById('loadJobModal').style.display = '';
        }

        function closeLoadJobModal() {
            document.getElementById('loadJobModal').style.display = 'none';
        }

        function loadJobData() {
            var raw = document.getElementById('loadJobTextarea').value.trim();
            var statusEl = document.getElementById('loadJobStatus');
            if (!raw) { statusEl.textContent = 'Please paste JSON data first.'; statusEl.style.color = '#FF3B30'; return; }

            var data;
            try {
                data = JSON.parse(raw);
            } catch(e) {
                statusEl.textContent = 'Invalid JSON. Please check and try again.';
                statusEl.style.color = '#FF3B30';
                return;
            }

            // Restore customer state + DOM
            if (data.customer) {
                customer = { name: data.customer.name || '', address: data.customer.address || '', phone: data.customer.phone || '' };
                document.getElementById('customerName').value = customer.name;
                document.getElementById('customerAddress').value = customer.address;
                document.getElementById('customerPhone').value = customer.phone;
            }

            // Restore siteDetails state + DOM
            if (data.siteDetails) {
                var sd = data.siteDetails;
                siteDetails = {
                    existingSite: sd.existingSite || 'clear',
                    demoScope: sd.demoScope || 'na',
                    electrical: sd.electrical || 'none',
                    siteAccess: sd.siteAccess || 'easy',
                    groundSurface: sd.groundSurface || 'grass',
                    fasciaMaterial: sd.fasciaMaterial || 'timber',
                    wallType: sd.wallType || 'doublebrick',
                    existingRoof: sd.existingRoof || 'tiles'
                };
                // Restore toggle buttons
                var restoreToggle = function(fieldId, val) {
                    var el = document.getElementById(fieldId);
                    if (el) el.value = val;
                    var group = document.getElementById(fieldId + 'Group');
                    if (group) {
                        group.querySelectorAll('.toggle-btn').forEach(function(b) {
                            b.classList.toggle('active', b.getAttribute('data-value') === val);
                        });
                    }
                };
                restoreToggle('siteAccess', siteDetails.siteAccess);
                restoreToggle('groundSurface', siteDetails.groundSurface);
                restoreToggle('fasciaMaterial', siteDetails.fasciaMaterial);
                restoreToggle('wallType', siteDetails.wallType);
                restoreToggle('existingRoof', siteDetails.existingRoof);
                // Migrate old siteNotes â†’ noteWorkOrder
                if (siteDetails.notes && document.getElementById('noteWorkOrder') && !document.getElementById('noteWorkOrder').value) {
                    document.getElementById('noteWorkOrder').value = siteDetails.notes;
                }
            }
            // Restore existing site fields
            if (data.existingSite) {
                var es = data.existingSite;
                if (document.getElementById('existingSite')) document.getElementById('existingSite').value = es.existing || 'clear';
                if (document.getElementById('demoScope')) document.getElementById('demoScope').value = es.demoScope || 'na';
                if (document.getElementById('electrical')) {
                    document.getElementById('electrical').value = es.electrical || 'none';
                    var ev = es.electrical || 'none';
                    if (ev === 'downlights' || ev === 'both') document.getElementById('elecDownlights').checked = true;
                    if (ev === 'fan' || ev === 'both') document.getElementById('elecFan').checked = true;
                }
                updateExistingSite();
            }
            // Legacy: restore old extras format
            if (!data.existingSite && data.extras) {
                var ex = data.extras;
                if (ex.demo === 'yes' && document.getElementById('existingSite')) {
                    document.getElementById('existingSite').value = 'other';
                    updateExistingSite();
                }
            }

            // Restore client info (from existing format)
            if (data.client) {
                var cl = data.client;
                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                if (cl.name) document.getElementById('customerName').value = cl.name;
                if (cl.address) document.getElementById('customerAddress').value = cl.address;
                if (cl.phone) document.getElementById('customerPhone').value = cl.phone;
                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                if (cl.salesperson) document.getElementById('salesperson').value = cl.salesperson;
            }

            // Restore specs â†’ config inputs
            var cfg = data.config || {};
            var specs = data.specs || {};
            var setVal = function(id, val) { var el = document.getElementById(id); if (el && val != null) el.value = val; };
            setVal('inRoofStyle', specs.roofType || cfg.roofStyle);
            setVal('inOrientation', cfg.orientation);
            // Convert legacy mm values to m for dimension inputs
            var projVal = specs.projection || cfg.projection;
            var lenVal = specs.width || cfg.length;
            var heightVal = specs.height || cfg.postHeight;
            if (projVal && parseFloat(projVal) > 100) projVal = (parseFloat(projVal) / 1000).toFixed(1);
            if (lenVal && parseFloat(lenVal) > 100) lenVal = (parseFloat(lenVal) / 1000).toFixed(1);
            if (heightVal && parseFloat(heightVal) > 100) heightVal = (parseFloat(heightVal) / 1000).toFixed(1);
            setVal('inWidth', projVal);
            setVal('inLength', lenVal);
            setVal('inPitch', specs.pitch || cfg.pitch);
            setVal('inPostHeight', heightVal);
            setVal('inPosts', cfg.posts);
            if (cfg.postQtyOverride) { var pqo = document.getElementById('inPostQty'); if (pqo) pqo.value = cfg.postQtyOverride; }
            setVal('inTrusses', cfg.trusses);
            // Mark trusses as user-overridden if imported with a value
            if (cfg.trusses) { var tqf = document.getElementById('inTrusses'); if (tqf) tqf.dataset.userOverride = 'true'; }
            setVal('inRafters', cfg.rafters);
            if (cfg.rafterSize) setVal('inRafterSize', cfg.rafterSize);
            if (cfg.rafterSpacing) setVal('inRafterSpacing', cfg.rafterSpacing);
            if (cfg.rafterQtyOverride) { var rqo = document.getElementById('inRafterQtyOverride'); if (rqo) rqo.value = cfg.rafterQtyOverride; }
            if (cfg.purlinSize) setVal('inPurlinSize', cfg.purlinSize);
            if (cfg.gutterBeamSize) setVal('inGutterBeamSize', cfg.gutterBeamSize);
            if (cfg.riserBeamSize) setVal('inRiserBeamSize', cfg.riserBeamSize);
            if (cfg.riserSteel) setVal('inRiserSteel', cfg.riserSteel);
            // Convert legacy 'insulated' to 'solarspan75'
            var roofVal = specs.roofMaterial || cfg.roofing;
            if (roofVal === 'insulated') roofVal = 'solarspan75';
            setVal('inRoofing', roofVal);
            setVal('inInfill', cfg.infill);
            // Convert legacy 'fasciabeam' to 'riser'
            var connVal = specs.attachmentType || cfg.connection;
            if (connVal === 'fasciabeam') connVal = 'riser';
            // Legacy: old configs with gableAttachment='fascia' under riser â†’ use fascia connection
            if (connVal === 'riser' && cfg.gableAttachment === 'fascia') connVal = 'fascia';
            setVal('inConnection', connVal);
            setVal('inFasciaHeight', cfg.fasciaHeight);
            setVal('inRiserHeight', cfg.riserHeight);
            setVal('inRiserOffset', cfg.riserOffset);
            setVal('inRiserQty', cfg.riserQty);
            setVal('inHouseGutter', cfg.houseGutter);
            setVal('inRiserGutter', cfg.riserGutter);
            if (cfg.fasciaBracketQty) setVal('inFasciaBracketQty', cfg.fasciaBracketQty);
            if (cfg.houseRoofPitch) setVal('inHouseRoofPitch', cfg.houseRoofPitch);
            if (cfg.houseRoofDepth) setVal('inHouseRoofDepth', cfg.houseRoofDepth);
            if (cfg.flyoverSetback) setVal('inFlyoverSetback', cfg.flyoverSetback);
            if (cfg.flyoverClearance) setVal('inFlyoverClearance', cfg.flyoverClearance);
            setVal('inPostFix', cfg.postFix);
            setVal('inPostSize', cfg.postSize || '90x90');
            setVal('inBeamSize', cfg.beamSize || '100x50');
            setVal('inCeilingFinish', cfg.ceilingFinish);
            setVal('inBMT', cfg.sheetBMT || '042');
            if (cfg.extraBattens) { var ebEl = document.getElementById('extraBattensVal'); if (ebEl) ebEl.textContent = cfg.extraBattens; }
            if (cfg.bracketType) { var btRadio = document.querySelector('input[name="bracketType"][value="' + cfg.bracketType + '"]'); if (btRadio) btRadio.checked = true; }

            // Truss
            var truss = data.truss || {};
            // Legacy: map old trussStyle/trussBase values to new 3-option set
            const legacyStyleMap = {king:'kingpost', queen:'kingverticals', verticalwebs:'kingverticals', kingdiagonal:'web', kingfan:'kingverticals', queenpost:'kingverticals', kingstrut:'web', fink:'web', open:'web'};
            const rawBase = truss.base || cfg.trussBase || cfg.trussStyle || 'kingpost';
            const legacyBase = legacyStyleMap[rawBase] || rawBase;
            setVal('inTrussBase', legacyBase);
            setVal('inTrussChord', truss.chord || cfg.trussChord || 'bottom');
            setVal('inTrussSteel', truss.steel || cfg.trussSteel);
            setVal('inOverhang', truss.overhang || cfg.overhang);

            // Truss options: extender + risers (L/R)
            const tExtender = truss.extender || cfg.trussExtender || {};
            const tRiserL = truss.riserLeft || cfg.trussRiserLeft || {};
            const tRiserR = truss.riserRight || cfg.trussRiserRight || {};
            // Legacy: migrate old riser/dogleg data
            const legacyRiser = truss.riser || cfg.trussRiser || {};
            if (tExtender.enabled) {
                document.getElementById('trussExtOn').checked = true;
                setVal('trussExtLen', tExtender.length || '300');
            }
            if (tRiserL.enabled || tRiserR.enabled || legacyRiser.enabled) {
                document.getElementById('trussRiserOn').checked = true;
                setVal('riserLH', tRiserL.length || legacyRiser.rx || '200');
                setVal('riserLV', tRiserL.height || legacyRiser.ry || '150');
                setVal('riserRH', tRiserR.length || legacyRiser.rx || '200');
                setVal('riserRV', tRiserR.height || legacyRiser.ry || '150');
            }
            if (truss.riserLocked !== undefined || cfg.trussRiserLocked !== undefined) {
                document.getElementById('trussRiserLock').checked = truss.riserLocked !== false && cfg.trussRiserLocked !== false;
            }
            // Riser type (welded vs separate)
            const riserType = truss.riserType || cfg.riserType || 'welded';
            document.getElementById(riserType === 'separate' ? 'riserTypeSeparate' : 'riserTypeWelded').checked = true;
            toggleTrussOpt();

            // Existing Site (loaded above in siteDetails restore block)

            // Colours
            var roofColour = specs.roofColour || cfg.sheetColor;
            if (roofColour) {
                var sc = COLORS.find(function(c) { return c.name === roofColour; });
                if (sc) {
                    sheetColor = sc;
                    document.querySelectorAll('#sheetChips .color-chip').forEach(function(ch) { ch.classList.toggle('active', ch.title === sc.name); });
                    document.getElementById('sheetLabel').textContent = sc.name;
                }
            }
            var fColour = specs.frameColour || cfg.steelColor;
            if (fColour) {
                var sc2 = COLORS.find(function(c) { return c.name === fColour; });
                if (sc2) {
                    steelColor = sc2;
                    document.querySelectorAll('#steelChips .color-chip').forEach(function(ch) { ch.classList.toggle('active', ch.title === sc2.name); });
                    document.getElementById('steelLabel').textContent = sc2.name;
                }
            }
            var flColour = cfg.flashingColor;
            if (flColour) {
                var sc3 = COLORS.find(function(c) { return c.name === flColour; });
                if (sc3) {
                    flashingColor = sc3;
                    document.querySelectorAll('#flashingChips .color-chip').forEach(function(ch) { ch.classList.toggle('active', ch.title === sc3.name); });
                    document.getElementById('flashingLabel').textContent = sc3.name;
                }
            }

            // Downpipe selection
            if (cfg.dpSelection && Array.isArray(cfg.dpSelection)) {
                dpSelection = cfg.dpSelection;
            }

            // L-Shape + Wraparound
            if (cfg.lShape) setVal('inLShape', cfg.lShape);
            if (cfg.wraparound) {
                // Backward compat: old 'wraparound' value â†’ default to 'right'
                var wVal = cfg.wraparound === 'wraparound' ? 'right' : cfg.wraparound;
                setVal('inWraparound', wVal);
            }
            if (cfg.returnLength) {
                // Migrate old metre values (< 20) to mm
                var rl = parseFloat(cfg.returnLength);
                if (rl > 0 && rl < 20) rl = Math.round(rl * 1000);
                setVal('inReturnLength', rl);
            }
            if (cfg.returnPosts) setVal('inReturnPosts', cfg.returnPosts);

            // Polycarbonate
            var pc = data.polycarb || {};
            var pcEnabled = pc.enabled || cfg.polycarbEnabled;
            if (pcEnabled) {
                document.querySelector('input[name="polycarb"][value="yes"]').checked = true;
                document.getElementById('polycarbOptions').style.display = 'block';
                if (pc.brand || cfg.polycarbBrand) document.getElementById('inPolycarbBrand').value = pc.brand || cfg.polycarbBrand;
                updatePolycarbTints();
                if (pc.tint || cfg.polycarbTint) document.getElementById('inPolycarbTint').value = pc.tint || cfg.polycarbTint;
                if (pc.pattern || cfg.polycarbPattern) document.getElementById('inPolycarbPattern').value = pc.pattern || cfg.polycarbPattern;
                if (pc.custom || cfg.polycarbCustom) document.getElementById('inPolycarbCustom').value = pc.custom || cfg.polycarbCustom;
                var pcLevel = pc.level || cfg.polycarbLevel;
                if (pcLevel) document.getElementById('inPolycarbLevel').value = pcLevel;
                updatePolycarbLevels();
                updatePolycarbPreview();
            }

            // Pricing
            if (data.pricing) {
                var p = data.pricing;
                if (p.addonRows && Array.isArray(p.addonRows)) {
                    jobRows = jobRows.filter(function(r) { return !r.isAddon; });
                    p.addonRows.forEach(function(a) { a.isAddon = true; if (!a.unit) a.unit = 'each'; jobRows.push(a); });
                }
                if (p.extrasRows && Array.isArray(p.extrasRows)) extrasRows = p.extrasRows;
                if (p.additionalMaterials && Array.isArray(p.additionalMaterials)) additionalMaterials = p.additionalMaterials;
                if (p.labour) {
                    if (p.labour.trades != null) document.getElementById('labTrades').value = p.labour.trades;
                    if (p.labour.days != null) document.getElementById('labDays').value = p.labour.days;
                    if (p.labour.dayRate != null) document.getElementById('labDayRate').value = p.labour.dayRate;
                    if (p.labour.sell != null) document.getElementById('labSellInput').value = p.labour.sell;
                }
            }

            // Complexity
            if (data.complexity) {
                var cx = data.complexity;
                if (cx.build) document.getElementById('cxBuild').value = cx.build;
                if (cx.access) document.getElementById('cxAccess').value = cx.access;
                if (cx.distance) document.getElementById('cxDistance').value = cx.distance;
                if (cx.footing) document.getElementById('cxFooting').value = cx.footing;
                if (cx.height) document.getElementById('cxHeight').value = cx.height;
            }

            // Notes
            if (data.notes) {
                // Migrate old jobNotes â†’ noteInternal
                if (data.notes.jobNotes && !data.notes.noteInternal && document.getElementById('noteInternal')) document.getElementById('noteInternal').value = data.notes.jobNotes;
                if (data.notes.pricingNotes) document.getElementById('pricingNotes').value = data.notes.pricingNotes;
                if (data.notes.noteQuote && document.getElementById('noteQuote')) document.getElementById('noteQuote').value = data.notes.noteQuote;
                if (data.notes.noteWorkOrder && document.getElementById('noteWorkOrder')) document.getElementById('noteWorkOrder').value = data.notes.noteWorkOrder;
                if (data.notes.noteMaterialOrder && document.getElementById('noteMaterialOrder')) document.getElementById('noteMaterialOrder').value = data.notes.noteMaterialOrder;
                if (data.notes.noteInternal && document.getElementById('noteInternal')) document.getElementById('noteInternal').value = data.notes.noteInternal;
            }

            // Scope checkboxes
            if (data.scope) {
                if (data.scope.elecDownlights) { document.getElementById('elecDownlights').checked = true; document.getElementById('elecDownlightsQty').value = data.scope.elecDownlightsQty || '4'; }
                if (data.scope.elecFan) { document.getElementById('elecFan').checked = true; document.getElementById('elecFanQty').value = data.scope.elecFanQty || '1'; }
                if (data.scope.elecGPO) { document.getElementById('elecGPO').checked = true; document.getElementById('elecGPOQty').value = data.scope.elecGPOQty || '1'; }
                if (data.scope.scopeDemo) document.getElementById('scopeDemo').checked = true;
                if (data.scope.scopeSkip) document.getElementById('scopeSkip').checked = true;
                if (data.scope.scopePermit) document.getElementById('scopePermit').checked = true;
                syncElectricalCheckboxes();
            }

            // Flashings
            if (data.flashings && Array.isArray(data.flashings)) {
                flashingProfiles = data.flashings.map(function(f) {
                    return {
                        id: f.id || 'flashing_' + String(flashNextId++).padStart(3, '0'),
                        name: f.name || 'Unnamed',
                        colour: f.colour || 'Monument',
                        gauge: f.gauge || 0.42,
                        length: f.length || 3000,
                        qty: f.qty || 1,
                        colourSide: f.colourSide || 'inside',
                        points: f.points || [],
                        girth: f.girth || calcGirth(f.points || []),
                        legs: f.legs || calcLegs(f.points || [])
                    };
                });
                renderFlashJobTable();
                updateFlashSummary();
            }

            // Rebuild everything
            syncAllToggleButtons();
            updateUI();
            rebuildAll();
            renderExtras();
            updatePricing();
            updateHeaderBadge();

            closeLoadJobModal();
            var custName = (data.customer && data.customer.name) ? data.customer.name : (data.client && data.client.name) ? data.client.name : 'Unknown';
            var custAddr = (data.customer && data.customer.address) ? data.customer.address : (data.client && data.client.address) ? data.client.address : '';
            alert('Job loaded: ' + custName + (custAddr ? ', ' + custAddr : ''));
        }

        function downloadJobJSON(json, ref) {
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (ref || 'PatioJob') + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function showImportModal() {
            document.getElementById('importTextarea').value = '';
            document.getElementById('importStatus').textContent = '';
            document.getElementById('importModal').style.display = '';
        }

        function importJobData() {
            const raw = document.getElementById('importTextarea').value.trim();
            const statusEl = document.getElementById('importStatus');
            if (!raw) { statusEl.textContent = 'Please paste JSON data first.'; statusEl.style.color = '#FF3B30'; return; }
            let data;
            try {
                data = JSON.parse(raw);
            } catch(e) {
                statusEl.textContent = 'Invalid JSON. Check the data and try again.';
                statusEl.style.color = '#FF3B30';
                return;
            }

            // Populate client info
            if (data.client) {
                const cl = data.client;
                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                if (cl.name) document.getElementById('customerName').value = cl.name;
                if (cl.address) document.getElementById('customerAddress').value = cl.address;
                if (cl.phone) document.getElementById('customerPhone').value = cl.phone;
                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                if (cl.salesperson) document.getElementById('salesperson').value = cl.salesperson;
            }

            // Populate config
            if (data.config) {
                const cfg = data.config;
                const setVal = (id, val) => { const el = document.getElementById(id); if (el && val != null) el.value = val; };
                setVal('inRoofStyle', cfg.roofStyle);
                setVal('inOrientation', cfg.orientation);
                setVal('inWidth', cfg.projection);
                setVal('inLength', cfg.length);
                setVal('inPitch', cfg.pitch);
                setVal('inPostHeight', cfg.postHeight);
                setVal('inPosts', cfg.posts);
                if (cfg.postQtyOverride) { var pqo2 = document.getElementById('inPostQty'); if (pqo2) pqo2.value = cfg.postQtyOverride; }
                setVal('inTrusses', cfg.trusses);
                setVal('inRafters', cfg.rafters);
                if (cfg.rafterSize) setVal('inRafterSize', cfg.rafterSize);
                if (cfg.rafterSpacing) setVal('inRafterSpacing', cfg.rafterSpacing);
                if (cfg.rafterQtyOverride) { var rqo2 = document.getElementById('inRafterQtyOverride'); if (rqo2) rqo2.value = cfg.rafterQtyOverride; }
                if (cfg.purlinSize) setVal('inPurlinSize', cfg.purlinSize);
                if (cfg.gutterBeamSize) setVal('inGutterBeamSize', cfg.gutterBeamSize);
                if (cfg.riserBeamSize) setVal('inRiserBeamSize', cfg.riserBeamSize);
                if (cfg.riserSteel) setVal('inRiserSteel', cfg.riserSteel);
                setVal('inRoofing', cfg.roofing);
                setVal('inInfill', cfg.infill);
                setVal('inConnection', cfg.connection);
                setVal('inFasciaHeight', cfg.fasciaHeight);
                setVal('inRiserHeight', cfg.riserHeight);
                setVal('inRiserOffset', cfg.riserOffset);
                setVal('inRiserQty', cfg.riserQty);
                setVal('inHouseGutter', cfg.houseGutter);
                setVal('inRiserGutter', cfg.riserGutter);
                setVal('inPostFix', cfg.postFix);
                setVal('inPostSize', cfg.postSize || '90x90');
                setVal('inBeamSize', cfg.beamSize || '100x50');
                setVal('inBMT', cfg.sheetBMT || '042');
                if (cfg.extraBattens) { var ebEl2 = document.getElementById('extraBattensVal'); if (ebEl2) ebEl2.textContent = cfg.extraBattens; }
                if (cfg.bracketType) { var btR2 = document.querySelector('input[name="bracketType"][value="' + cfg.bracketType + '"]'); if (btR2) btR2.checked = true; }
                const legacyMap2 = {king:'kingpost', queen:'kingverticals', verticalwebs:'kingverticals', kingdiagonal:'web', kingfan:'kingverticals', queenpost:'kingverticals', kingstrut:'web', fink:'web', open:'web'};
                const rawBase2 = cfg.trussBase || cfg.trussStyle || 'kingpost';
                const lb = legacyMap2[rawBase2] || rawBase2;
                setVal('inTrussBase', lb);
                setVal('inTrussChord', cfg.trussChord || 'bottom');
                setVal('inTrussSteel', cfg.trussSteel);
                setVal('inOverhang', cfg.overhang);

                // Truss options (handles both legacy and new format)
                if (cfg.trussExtender && cfg.trussExtender.enabled) {
                    document.getElementById('trussExtOn').checked = true;
                    setVal('trussExtLen', cfg.trussExtender.length || '300');
                }
                // New riser L/R format
                if (cfg.trussRiserLeft && cfg.trussRiserLeft.enabled) {
                    document.getElementById('trussRiserOn').checked = true;
                    setVal('riserLH', cfg.trussRiserLeft.length || '200');
                    setVal('riserLV', cfg.trussRiserLeft.height || '150');
                    setVal('riserRH', (cfg.trussRiserRight || {}).length || '200');
                    setVal('riserRV', (cfg.trussRiserRight || {}).height || '150');
                }
                // Legacy riser format (migrate to both sides)
                else if (cfg.trussRiser && cfg.trussRiser.enabled) {
                    document.getElementById('trussRiserOn').checked = true;
                    setVal('riserLH', cfg.trussRiser.rx || '200');
                    setVal('riserLV', cfg.trussRiser.ry || '150');
                    setVal('riserRH', cfg.trussRiser.rx || '200');
                    setVal('riserRV', cfg.trussRiser.ry || '150');
                }
                if (cfg.trussRiserLocked !== undefined) {
                    document.getElementById('trussRiserLock').checked = cfg.trussRiserLocked !== false;
                }
                // Riser type (welded vs separate)
                if (cfg.riserType === 'separate') {
                    document.getElementById('riserTypeSeparate').checked = true;
                } else {
                    document.getElementById('riserTypeWelded').checked = true;
                }
                toggleTrussOpt();

                // Colours
                if (cfg.sheetColor) {
                    const sc = COLORS.find(c => c.name === cfg.sheetColor);
                    if (sc) {
                        sheetColor = sc;
                        const chips = document.querySelectorAll('#sheetChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('sheetLabel').textContent = sc.name;
                    }
                }
                if (cfg.steelColor) {
                    const sc = COLORS.find(c => c.name === cfg.steelColor);
                    if (sc) {
                        steelColor = sc;
                        const chips = document.querySelectorAll('#steelChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('steelLabel').textContent = sc.name;
                    }
                }
                if (cfg.flashingColor) {
                    const sc = COLORS.find(c => c.name === cfg.flashingColor);
                    if (sc) {
                        flashingColor = sc;
                        const chips = document.querySelectorAll('#flashingChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('flashingLabel').textContent = sc.name;
                    }
                }
                // Polycarbonate
                if (cfg.polycarbEnabled) {
                    document.querySelector('input[name="polycarb"][value="yes"]').checked = true;
                    document.getElementById('polycarbOptions').style.display = 'block';
                    if (cfg.polycarbBrand) document.getElementById('inPolycarbBrand').value = cfg.polycarbBrand;
                    updatePolycarbTints();
                    if (cfg.polycarbTint) document.getElementById('inPolycarbTint').value = cfg.polycarbTint;
                    if (cfg.polycarbPattern) document.getElementById('inPolycarbPattern').value = cfg.polycarbPattern;
                    if (cfg.polycarbCustom) document.getElementById('inPolycarbCustom').value = cfg.polycarbCustom;
                    if (cfg.polycarbLevel) document.getElementById('inPolycarbLevel').value = cfg.polycarbLevel;
                    updatePolycarbLevels();
                    updatePolycarbPreview();
                }
                // Downpipe selection
                if (cfg.dpSelection && Array.isArray(cfg.dpSelection)) {
                    dpSelection = cfg.dpSelection;
                }
                // L-Shape + Wraparound
                if (cfg.lShape) setVal('inLShape', cfg.lShape);
                if (cfg.wraparound) {
                    // Backward compat: old 'wraparound' value â†’ default to 'right'
                    var wVal2 = cfg.wraparound === 'wraparound' ? 'right' : cfg.wraparound;
                    setVal('inWraparound', wVal2);
                }
                if (cfg.returnLength) {
                    var rl2 = parseFloat(cfg.returnLength);
                    if (rl2 > 0 && rl2 < 20) rl2 = Math.round(rl2 * 1000);
                    setVal('inReturnLength', rl2);
                }
                if (cfg.returnPosts) setVal('inReturnPosts', cfg.returnPosts);
            }

            // Populate existing site
            if (data.existingSite) {
                const es = data.existingSite;
                if (document.getElementById('existingSite')) document.getElementById('existingSite').value = es.existing || 'clear';
                if (document.getElementById('demoScope')) document.getElementById('demoScope').value = es.demoScope || 'na';
                if (document.getElementById('electrical')) {
                    document.getElementById('electrical').value = es.electrical || 'none';
                    var ev = es.electrical || 'none';
                    if (ev === 'downlights' || ev === 'both') document.getElementById('elecDownlights').checked = true;
                    if (ev === 'fan' || ev === 'both') document.getElementById('elecFan').checked = true;
                }
                updateExistingSite();
            }
            // Populate siteDetails toggle buttons
            if (data.siteDetails) {
                var sd2 = data.siteDetails;
                var restoreToggle2 = function(fieldId, val) {
                    var el = document.getElementById(fieldId);
                    if (el) el.value = val;
                    var group = document.getElementById(fieldId + 'Group');
                    if (group) {
                        group.querySelectorAll('.toggle-btn').forEach(function(b) {
                            b.classList.toggle('active', b.getAttribute('data-value') === val);
                        });
                    }
                };
                restoreToggle2('siteAccess', sd2.siteAccess || 'easy');
                restoreToggle2('groundSurface', sd2.groundSurface || 'grass');
                restoreToggle2('fasciaMaterial', sd2.fasciaMaterial || 'timber');
                restoreToggle2('wallType', sd2.wallType || 'doublebrick');
                restoreToggle2('existingRoof', sd2.existingRoof || 'tiles');
                // Migrate old siteNotes â†’ noteWorkOrder
                if (sd2.notes && document.getElementById('noteWorkOrder') && !document.getElementById('noteWorkOrder').value) {
                    document.getElementById('noteWorkOrder').value = sd2.notes;
                }
            }

            // Populate pricing
            if (data.pricing) {
                const p = data.pricing;
                if (p.addonRows && Array.isArray(p.addonRows)) {
                    jobRows = jobRows.filter(r => !r.isAddon);
                    p.addonRows.forEach(a => { a.isAddon = true; if (!a.unit) a.unit = 'each'; jobRows.push(a); });
                }
                // New extras format
                if (p.extrasRows && Array.isArray(p.extrasRows)) {
                    extrasRows = p.extrasRows;
                }
                if (p.additionalMaterials && Array.isArray(p.additionalMaterials)) {
                    additionalMaterials = p.additionalMaterials;
                }
                // New labour card format
                if (p.labour) {
                    const l = p.labour;
                    if (l.trades != null) document.getElementById('labTrades').value = l.trades;
                    if (l.days != null) document.getElementById('labDays').value = l.days;
                    if (l.dayRate != null) document.getElementById('labDayRate').value = l.dayRate;
                    if (l.sell != null) document.getElementById('labSellInput').value = l.sell;
                }
                // Legacy: old labourRows format (backward compat)
                if (p.labourRows && Array.isArray(p.labourRows) && p.labourRows.length > 0 && !p.labour) {
                    const first = p.labourRows[0];
                    document.getElementById('labTrades').value = first.trades || 2;
                    document.getElementById('labDays').value = first.days || 1.5;
                    document.getElementById('labDayRate').value = first.dayRate || 400;
                    document.getElementById('labSellInput').value = first.sell || 0;
                }
                // Legacy: delivery as extras (backward compat)
                if (p.deliveryCost != null && parseFloat(p.deliveryCost) > 0 && !p.extrasRows) {
                    extrasRows.push({ desc: 'Delivery', qty: 1, unitCost: parseFloat(p.deliveryCost) || 0, unitSell: parseFloat(p.deliverySell) || 0, type: 'delivery' });
                }
            }

            // Complexity scores (still stored in hidden inputs)
            if (data.complexity) {
                const cx = data.complexity;
                if (cx.build) document.getElementById('cxBuild').value = cx.build;
                if (cx.access) document.getElementById('cxAccess').value = cx.access;
                if (cx.distance) document.getElementById('cxDistance').value = cx.distance;
                if (cx.footing) document.getElementById('cxFooting').value = cx.footing;
                if (cx.height) document.getElementById('cxHeight').value = cx.height;
            }

            // Notes
            if (data.notes) {
                // Migrate old jobNotes â†’ noteInternal
                if (data.notes.jobNotes && !data.notes.noteInternal && document.getElementById('noteInternal')) document.getElementById('noteInternal').value = data.notes.jobNotes;
                if (data.notes.pricingNotes) document.getElementById('pricingNotes').value = data.notes.pricingNotes;
                if (data.notes.noteQuote && document.getElementById('noteQuote')) document.getElementById('noteQuote').value = data.notes.noteQuote;
                if (data.notes.noteWorkOrder && document.getElementById('noteWorkOrder')) document.getElementById('noteWorkOrder').value = data.notes.noteWorkOrder;
                if (data.notes.noteMaterialOrder && document.getElementById('noteMaterialOrder')) document.getElementById('noteMaterialOrder').value = data.notes.noteMaterialOrder;
                if (data.notes.noteInternal && document.getElementById('noteInternal')) document.getElementById('noteInternal').value = data.notes.noteInternal;
            }

            // Scope checkboxes
            if (data.scope) {
                if (data.scope.elecDownlights) { document.getElementById('elecDownlights').checked = true; document.getElementById('elecDownlightsQty').value = data.scope.elecDownlightsQty || '4'; }
                if (data.scope.elecFan) { document.getElementById('elecFan').checked = true; document.getElementById('elecFanQty').value = data.scope.elecFanQty || '1'; }
                if (data.scope.elecGPO) { document.getElementById('elecGPO').checked = true; document.getElementById('elecGPOQty').value = data.scope.elecGPOQty || '1'; }
                if (data.scope.scopeDemo) document.getElementById('scopeDemo').checked = true;
                if (data.scope.scopeSkip) document.getElementById('scopeSkip').checked = true;
                if (data.scope.scopePermit) document.getElementById('scopePermit').checked = true;
                syncElectricalCheckboxes();
            }

            // Flashings
            if (data.flashings && Array.isArray(data.flashings)) {
                flashingProfiles = data.flashings.map(function(f) {
                    return {
                        id: f.id || 'flashing_' + String(flashNextId++).padStart(3, '0'),
                        name: f.name || 'Unnamed',
                        colour: f.colour || 'Monument',
                        gauge: f.gauge || 0.42,
                        length: f.length || 3000,
                        qty: f.qty || 1,
                        colourSide: f.colourSide || 'inside',
                        points: f.points || [],
                        girth: f.girth || calcGirth(f.points || []),
                        legs: f.legs || calcLegs(f.points || [])
                    };
                });
                renderFlashJobTable();
                updateFlashSummary();
            }

            // Rebuild everything
            syncAllToggleButtons();
            updateUI();
            rebuildAll();
            renderExtras();
            updatePricing();
            updateHeaderBadge();

            statusEl.textContent = 'Job loaded successfully! All fields populated.';
            statusEl.style.color = '#34C759';
            setTimeout(() => { document.getElementById('importModal').style.display = 'none'; }, 1200);
        }

        // ==================== JOB REF AUTO-GENERATE ====================
        function generateJobRef() {
            const d = new Date();
            const yy = String(d.getFullYear()).slice(-2);
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const seq = String(Math.floor(Math.random() * 99) + 1).padStart(2, '0');
            return 'SW' + yy + mm + dd + '-' + seq;
        }

        function initJobDetails() {
            const refEl = document.getElementById('jobRef');
            if (!refEl.value.trim()) refEl.value = generateJobRef();
            // Sync header badge on any field change
            ['jobRef', 'customerName'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', updateHeaderBadge);
            });
            updateHeaderBadge();
        }

        function updateHeaderBadge() {
            const ref = (document.getElementById('jobRef')?.value || '').trim();
            const name = (document.getElementById('customerName')?.value || '').trim();
            const badge = document.getElementById('headerBadge');
            if (badge) badge.innerHTML = '<strong>' + (ref || 'SW\u2014') + '</strong>' + (name ? ' &nbsp;' + name : '');
        }

        // ==================== PDF SHARED HELPERS ====================
        function getJobRef() {
            const el = document.getElementById('jobRef');
            return (el && el.value.trim()) || generateJobRef();
        }
        function getClientName() { return (document.getElementById('customerName')?.value || '').trim() || 'Client'; }
        function getSiteAddress() { return (document.getElementById('customerAddress')?.value || '').trim(); }
        function getClientPhone() { return (document.getElementById('customerPhone')?.value || '').trim(); }
        function getClientEmail() { return (document.getElementById('clientEmail')?.value || '').trim(); }
        function getSalesperson() { return (document.getElementById('salesperson')?.value || '').trim(); }
        function safeName(s) { return s.replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_'); }
        function todayStr() {
            const d = new Date();
            return d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();
        }
        function fmtDollars(v) { return '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ','); }

        function connectionLabel(conn) {
            const map = {freestanding:'Freestanding',fascia:'Fascia / Receiving',wall:'Wall Mount',riser:'Riser Beam',flyover:'Flyover'};
            return map[conn] || conn;
        }
        function roofingLabel(r) {
            const map = {corrugated:'Corrugated Colorbond',trimdek:'Trimdek',spandek:'Spandek',solarspan75:'SolarSpan 75mm',solarspan100:'SolarSpan 100mm',spanplus330:'SpanPlus 330'};
            return map[r] || r;
        }

        function buildScopeText() {
            const c = calc;
            const style = c.isGable ? 'Gable' : 'Skillion';
            const Lm = (c.lenInput / 1000).toFixed(1);
            const Wm = (c.projInput / 1000).toFixed(1);
            const conn = connectionLabel(c.connection);
            const roof = roofingLabel(c.roofing);
            let roofDesc = 'Roof: ' + roof + ' (' + sheetColor.name + ')';
            const pc = hasPolycarbMatch(c.roofing) ? getPolycarbConfig() : null;
            if (pc) {
                const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
                roofDesc += ' with ' + brandLabel + ' ' + pc.tint + ' Lv' + pc.level + ' polycarbonate (every ' + pc.patternN + getSuffix(pc.patternN) + ' sheet)';
            }
            return 'Supply and install a ' + style + ' patio, ' + Lm + 'm x ' + Wm + 'm, attached via ' + conn + '. ' +
                   roofDesc + '. Steel: ' + steelColor.name + '. Flashings/gutters: ' + flashingColor.name + '. Including gutters, downpipes and flashings.';
        }
        function getSuffix(n) { return n === 2 ? 'nd' : n === 3 ? 'rd' : 'th'; }

        function capture3DImage() {
            try {
                if (asmRend && asmScene && asmCam) {
                    asmRend.render(asmScene, asmCam);
                    return asmRend.domElement.toDataURL('image/png');
                }
            } catch(e) { /* cross-origin or not ready */ }
            return null;
        }

        // Brand-correct colours from style guide
        const SW_ORANGE = [241, 90, 41];   // #F15A29  <- was #F26522
        const SW_DARK   = [41, 60, 70];    // #293C46
        const SW_MID    = [76, 106, 124];  // #4C6A7C
        const SW_LIGHT  = [240, 244, 247]; // card backgrounds, alt rows
        const SW_RULE   = [210, 218, 224]; // subtle lines, borders
        const SW_BODY   = [50, 50, 50];    // body text
        const SW_MUTED  = [130, 140, 148]; // fine print, captions
        const SW_LOGO_WHITE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABw0AAAE/CAYAAAC0FVztAAAACXBIWXMAACxKAAAsSgF3enRNAAAgAElEQVR4nO3dTVIsR9Yw6KiympO1AlLDHpFaQBto9A0vWsFFKxBagbgrEHcFghUIhj0SWC9AMOqhYAVFruC2ZcmjFEolkPHr7uHPY4ap6n1LkBk//nf8HP/Hly9fKgAAAAAAAKBc/3TvAQAAAAAAoGyChgAAAAAAAFA4QUMAAAAAAAAonKAhAAAAAAAAFE7QEAAAAAAAAAonaAgAAAAAAACFEzQEAAAAAACAwgkaAgAAAAAAQOEEDQEAAAAAAKBwgoYAAAAAAABQOEFDAAAAAAAAKJygIQAAAAAAABRO0BAAAAAAAAAKJ2gIAAAAAAAAhRM0BAAAAAAAgMIJGgIAAAAAAEDhBA0BAAAAAACgcIKGAAAAAAAAUDhBQwAAAAAAACicoCEAAAAAAAAUTtAQAAAAAAAACidoCAAAAAAAAIUTNAQAAAAAAIDCCRoCAAAAAABA4QQNAQAAAAAAoHCChgAAAAAAAFA4QUMAAAAAAAAonKAhAAAAAAAAFE7QEAAAAAAAAAonaAgAAAAAAACFEzQEAAAAAACAwgkaAgAAAAAAQOEEDQEAAAAAAKBwgoblWVVVdVNV1WnpFwIAAAAAAIA/CBqWY1FV1WVVVb9VVfWhqqpfqqq6q6pqWfqFAQAAAAAAKJ2gYRnOqqp6qqrq+61ve1xV1UNVVRelXyAAAAAAAICS/ePLly8egPnaZBFeheDgex6rqjoP2YcAAAAAAAAURKbhPC1C9uDvewYMN46qqvo1lDBdlH4BAQAAAAAASiLTcH5OQ+DvsMc3W4eSpjelX0wAAAAAAIASyDScj2UI8v3SM2C4cRB+z134vQAAAAAAAMyYoOE8bEqRPlRV9WHgb3Mcfu9FqRcWAAAAAACgBMqT5u2kqqqrATIL9/EYSpY+FHy9AQAAAAAAZkmmYZ4WIVj460QBw42jqqp+C+clLuZ2QQEAAAAAAEomaJif86qqnqqq+hjpk38fsg1Pc76IAAAAAAAA/El50nychCy/o4Q+8W0jiAkAAAAAAECmZBqmbxGChb8mFjDc+BCyDs8T+CwAAAAAAAB0JNMwbWchYHiQwWd9DJ/3IYHPAgAAAAAAQAsyDdO0qqrqrqqqnzMJGFYhC/K3EORcJPB5AAAAAAAA2JNMw7QsQqnPHzP/Hs/he9wk8FkAAAAAAAB4h6BhOk5Dlt7hjL7TbQgePiXwWQAAAAAAAHiF8qTxLUMp0l9mFjDc+BDOODxP4LMAAAAAAADwCpmGcV2EgFou5xb28VhV1VkIIgIAAAAAAJAQQcM4TqqqupphZuE+Podg6Uv6HxUAAAAAAKAMgobTWoRg4YeSvvQOzyHr8C65TwYAAAAAAFAgZxpOZ1OG9EnA8L82GZa/VlV1EwKpAAAAAAAARCRoOL6TcI7fT4WcXdjGhxBIPc/nIwMAAAAAAMyP8qTj2WTQXVZV9XGuX3Bg9yF4+DCrbwUAAAAAAJABmYbjOAsZdAKG+zuuquq3qqoulCwFAAAAAACYlkzDYa1CduHxnL5UBM8h8HpX3DcHAAAAAACIQKbhMOpSpL8JGA7isKqqX6uqupF1CAAAAAAAMD5Bw/5Owzl83+f+RRL0IZR5PS/9QgAAAAAAAIxJedLullVVXcksnMx9CB4+FPJ9AQAAAAAAJiPTsJuLqqp+FzCc1HEo/3qhZCkAAAAAAMCwZBq2cxKyCw9z+tAz9FxV1VlVVXelXwgAAAAAAIAhyDTcz6YU6U1VVb8KGCbhMNyLG1mHAAAAAAAA/Qkavu8inKP3IfUPWqDNPXkKWYcAAAAAAAB0pDzp6zalSC+rqjpK9QPyF/chePjksgAAAAAAALQj0/DvFuHcwl8FDLNyXFXV7yEzFAAAAAAAgBZkGv7VeQg6HaT0oWjtOWQd3rl0AAAAAAAA75Np+IdVCDD9JGA4C4chU/QqZI4CAAAAAADwhtKDhotwbuFvobxlCR6rqvohZOPN3cdwxuFZIfcWAAAAAACgk5KDhqchoPR9Ap9lCusQLFyFQOnmn5/n/7X/mzn6c8gkXSbweQAAAAAAAJJT4pmGy1C2spTMwo3bcF7j047/3ypcj6MInyuGT+HcSgAAAAAAAIKSgoaLEDj7MYHPMpXnUJrzbo+/dx6CaSWc6djmugAAAAAAAMxeKeVJN6VIHwoLGH4KWZX7BsbqkqW3I3+uFBxWVfVryLBcFPB9AQAAAAAA3jT3TMNlCIZ9SOCzTOU+ZNHtKkW6r9Nw3Q5nd3X+bh2yLK9S+2AAAAAAAABTmXOm4UXILiwlYLgpufltVVUnPQOGGzch6/DzQJ8tZZtyrD+HjMxlAd8XAAAAAADgb+aYaXgSssZKyJKrfQqZgS8j/O6T8LuPRvjdqVmH73pRwHdlHhYhwL/tYaT2AAAAAACAmZpT0HARAj4fE/gsU7kPpTUfJvh7F+FvHaTx1Uf1GL7rvudBwlCWr/xU4f/eZzPEffjn09aP5xwAAAAAgNkEDc9DUKuEgFYV8Ry+ZfibxxP/3Vg+h+dKxhZjWIVM3lV4t2K+V89h88FDCCIKJAIAAAAAFCb3oOEqBLFKKJ1ZSyGQdRquewlB2k2A9iyc8wh9rMK7c5JJ4P0+BA9vJspmBgAAAAAgolyDhosQOPs+gc8yldRKZpZ2D+5D8PApgc9CPk4bPzkH2Z9D23MlCxEAAAAAYJ5yDBqehbMLSypFehG+c4pOwmcrIdtzHb7rRQKfhXStQoA/90Dha55D9uGlIDoAQC+pbMY6SeAztHWRyOfO8drVrqo/z0+P4c7cGnpZRniHn6wDAMxfTkHD0s7T27gNQdIcztS7CIGSEoK5qWV9koaz8FNaG3XpXQAA6GSz8HqYwKX7RwKfoY1N1Zv/JPJZcrt2tU2w89fIn+Eb8wjo5TJC9a9Pgv0A8/fPDL5hXQbz94IW45/DAPo0k4BhFe7RKpTxnLujMMG6DM8nZavL1v5cWMBw40N4F57CdQAAYH+yNbox7uzvPPLfvxcwhN5WES7hg9sGMH+pZxqehsBMCrsvpzCX8penISu0hKzDdZi03iTwWZjWWXhXS2mf9vEcFiC8DwAA77tLZNNZbtlyqWRoVplmGi7DpuyYZBlCfzEWdP+dUXIDAB2lmmm4DAPIXwpakL8Nu4TmkOZ/E+7h5wQ+y9gOwnN6F/k8CKazCvf7ZwHDvzlsvA85n+8CAECaTozBe4u95iDLEPqLkWX4LGAIUIYUg4YXId29pFKk34bsvDmVp3kJGUffhO84d8fhuVXbfd429/e3AsuQtnUcypZeKeELAPAqgZP2YpfVzN0irD3EZM4M/SlNCsBoUgsabjLUfiykrGUVDhBezbyUX52B9ymBzzK2g/D8Ks04P6swQP6x9AvR0sewGSL2wgQAAPlbhjO16e488nqLLEMYRozKPoKGAIVILWhYSkbKZqD8VdhhV0pq/0X4zvcJfJaxyayal9MwsT0q/UJ0VJfwvfFuAADQw5mL11vsayjLEIYRI9NQwB+gEKmeaThX66qqvgs7guZUinRfT+G7fxeuBaTuIgS8Ssl+HtOHsDMxxuQGACBFJc4J+xA07Ocs8nmQsgxhODE2NXt/AQohaDidz6GcylUpX/gNV+FaXCf7CeGP51Q50mEdhjMhnUUDACBo2MZp5IDXHMQeg8syhGHEKE366N4BlEPQcHybjvXrMEAvpRTpPl7CTsdvqqp6Tv/jUpircB4f4/jJBgoAAFqQZdjPSeTjFmQZwnCcZwjAqAQNx7Mpv/lDKMWnc33dXcg6/JTqB6Q4AobT+Bjef+ccAgDwlmUodU93sgxhPpxnCMCoBA3HcR0mNpdz/HIj2Uwivgo7ECEWAcNpHQscAgAFswi7H6Xt+4kddJVlCMOKETSUDAFQEEHDYT2GcptnSpF28hTKLHwXMjVhSgKGcRwJHAIARBVjAboNpUn7iZ3lJ8sQhrOIdL6roCFAQQQNh7EO5TVXdtAN4irshryewXchD2cChlFtAoc3BX9/AICYUt68tRmnHyTwOXK1ubenET+7LEMYVozzDFUEAyiMoGF/tyFYaPfcsF7CBHGTufk8py9GcjaD7p/dluiOw4YBAICSmOu8TZZhP+eRg66ObIFhOc8QgNEJGnb3HAJap6GsJuO4C1mHn1xfRrCQ4ZaUj86sAQAKYy75umXYWEZ3MYOuz+ZaMLgYmYZKkwIURtCwG6VIp7fJ5PxaWQQGdqPcUXJ+yuBcHQAAxqeaTz9nkc4+q7l/MLwYc2VBQ4DCCBq2swlYfRUGvy85ffCZeAi7qn4I50hCH+d2LifrJvGzdQAAGFfss/jmIGYFj2dHD8DgVhE2PT/LiAcoj6DhfjYBqm9DwEpnGd9lKFVzW/qFoLOFna9JO3R/AIBCqF6z26mKIL1s1i6OIv59Y3kYnixDACYhaPi+zyFApRZ/Wl7CRPKbsPMJ2ri0CJG87yOd1wAAQHzOue5HliHMj6AhAJMQNHzdfThD71wp0qTdhYHTp9IvBHvbPC8fXa4sXJZ+AQAACrSKnCWXu82m5w8Rv4MsQxhHjKChbHiAAv3LTf+bdQgU2hmXj5cwMbkJQQbn1PGWHANRj+E5f9qzRPKiMaHI+X3YLBadaY8BgBlz/MXfyTLsJ2bQTpYhjCfG3F6mIUCBBA3/6lpmYdYeQjnD8zBRUn6SbScZBNGeQwD8ofHT1zIEEVeZXIOmCwsPAMCMCRr+1UJVkF4W4RiPWGQZwjhiHN3xaH0UoEyChn+6Dxkt5O8yTJRkHLIt1Xf8OTy3NyMtHNUZis2zWU8bPykH2A9lGwIAFMOcvJ+ziGN7WYYwHucZAjAZZxoCpVgmuGv5tqqqb8Jnu5x4p/lNWFTY/O3vwiQ/VXYsAwCUQWnSfmJeP2N2GI+gIQCTETQESpHSruX7ECw8TeBg8ZewIzjl4OFhpHIsAABjiz0WTMlJGPfRzVnE6yfLEMYVYz6sfwIolKAhUIoUgobrqqp+CAP+FAfgdfDwUwKfZZtd5wAA44iRwbKL0qT9xLx+sgxhPItIGwJkGgIUStAQKMEqgV3LjyFYeJnB9d5M+r9OLOvwQ5gsAQAwrBTGWCkeJZCTk4hn+ssyhHHF2Nhx754ClEvQECjBaeTvWAcMc9qp9xAmJ48JfJZa7PsIADCGtasqy7AnWYYwXzFKk8oyBCiYoOGfNrvynqqqugll8JyfBfMRM9hUBwxfMryaL+GzpxI4FDQEAObI4qygYR8xszRlGcL4nGcIwKT+5XL/xWH4+dD4Pz6GzvKh8QPkY1Nu6SjSp12HBZAcA4a1l8YZjLGuY+3Dfv8zAAAycprAUQI5i3n2tyxDGF+M8qTWPgEKJmj4vqMdC+X3W4HEpxQ/OPBfMQbYtYuZDLbrwOGmrTuI/FlOQ0Y4AADzIMuwu0XE6yfLEMa3jDAHX1vnBCiboGE3x1uHjD83Aoh30vghKbFKDW/ahcsZPQovYUHil8if40TQEACYmYet+WVJlqpJ9HIWcVOfLEMYnyxDACYnaDiMZlnTH8NvfNwKJOp0IY5YmYZznERvgnW3kRd2YmaOAgCMIedS9n3FLK05B7GunyxDmIbzDAGYnKDheOqyps0Dye+3gojS/WF8y0jXeK7ZcOeRg4al7sIHAJijMUtr3s987HgW8SxIWYYwjRibZgUNAQonaDituqzp9+GvrrdKmj4UvssUxrB9JukUbmf8Lm82O1xvbYiY2qrQ7O3FnpPGJ5tSAIhAP9VdqXPAsUtrXhUQNIxhXchxAatGu7Z4o41rPmOPO97nZptXr/kIyrCvGG2YSmnz1cxcXe6xyX57zKbtgkIIGsZ10Agk1mVNnxsBxAcNMvSyiHT55j7IvoocNFzO9BrXCxGr8B3rRYk+E8XnMMh/afQrTyaCozvZWmRqLjCt3lkgvW/855fGvbLIBGmq3/GTrfd9uSMDqG6TrzIt67fruy56btB6bixIPRXcT5XaL4+dZTjn4PRJxIDo5cwC3cvGGPzklfZ7X7vaw9fuU93+3TXWfmwiz8tJI/BSB2N29YvrxlysTUnhGFmGz57D7DXXFE4GGKvt8rxj3CYRBmZE0DA9h2ExfldZ0+YP8L5Y59/NfVH/LgwSY5VDWs1kd3M9iK9/xrieh43fu11W9n4r290Av5t6gamenPWdkG0vLO0qB/y849xk9w+mc9pou9u883WbnMs4YdX4nquR+6ldi+r3FtNnbTly0GuKwPzzBH/jNTGzDC8j/e2hTDEG38eu9u8xzHNubPJL0kljDNCm/68TBtpuZHCeIftotmdTbSZ5bfz23FhfuFNZAvIlaJiH462GeL21UGgSDUztplFqeWqxzqkcwios8pxGXKCobZfMfgwLbHcWKd512vgZs6zaa+pJ2odGpYLHcO9uMpvs71vOcAw5XKcYi0XVyNdmNXElgKFKYS5DdsDY5RRjO20siqbST9XuG4vpFqHyN+aZeOswphm7DY31HC4jVv3INctw1Ri7xTi+Yl9H4efHsPh+E675HNq8qcc0Q22qW4X+f4hxf9s5Vowxsnlg+haN9mzXBtOYthNh6jUGYzfIjKBhng52TKK3sw7sDgLGdCdouLdlWGQ+S2AB9i2bBYqfwv//OSxQGNz/6aQR8E0xYFAvMn3fOGvoKoPxwGYx5NdIf/sfkf5uG3O8NpcTl9T71DM4sQz/fsyy3GNbNhZEU+6n6vnPT41FqKuZbJ4sbZG2XvAcS51lmPNGs7e0KW84pNyyDBeNMXjKgcLXHIZx3fdh08RFxus8ywhjmq969g9n4V0b8tlpe/9KDxouQnse69iZXdqWmB3SWaKBwrfUawz12K1eY5D4AokTNJyP17IOHrbOSISSzHWhIAUxJ6wpTRrechImFDkN6muHjcH9bRjcl7gZpV7UvEh8IX3bQWOH53OYbM/t/CEY2yK8+7E2yEzhNPRTsc5F66O5CHWdySaJt8Run6ceM4+9AacObM1xLrCIWJo0l7FEvdFrTps9jkPQLdfg4dTBr3WPjY9nI479267JxQh2p/JsLcJnSSngfz9ylvwuizBWO59BpYvNvfw59CWX5qeQtn+6P7N2FAbKm0b5t6qqvoRO9yJM1ARUmDvP+HhewmQshtR3Cp+EtvbXTAOG2z6E7/IUcZFqanWw4Cn0oTkFDLcdhs1E/wmL6tpFeN9JWNiba8DwLLRvv2QaMNz2MfRTdxFL+uZu6r5hzCyN+5lXSYhVIjmHLMPmGHyu2eF18PAmszHd1G1zl8DXKvx7Y43971v+72P0Z20/41hWoR1Pad5/He7JVEGuZZi7/SfM5eZUGv8gfKenMOfOZVM4FEXQsDzHoXHeLBL8Hjq8m9BQn2isYRClvEeyl/+quVAxh0XYbYdhEv00ckmx2OrF9LlNzqqwgPa74CG86SK04zlvFnhNHQzNfTPEa44zDx7G2ow1tdXIC8FXe/xvcharLF7KGSFzH4Pv8iFymcS2ps40bDtPvQgb7cd8ftp+phj9WArz+zp4m9I87POEm2frzau/z7w0ftUIHj7MfH0BsiRoyEGjpOmvYRfLQ5hsndutC52U8t4oJfGH+qyFUhYqDsPGk7uZBZ5WjcX0uQULt30M39XOTvirq0aZ/zlZhk2Cv2Z6rldbuWbilLIZa8wgx3rmQcNY52OnmmW4LDBY2HQQSjTfZTCem/r+7JtpuAxt7xR9v/MM35diwPC7CYPzzc2rJanXF1I7vxKK5kxDdjlqlDat3TfORbzLoORLHfBcTbCblXTdRRpwnWa067OPS9mG/73XVwUEmXY5DjsgP0U422FoFwVOzuqdnWfhp8QzK6GW4rk5QzkPbVyJ/dSHMB+4yKCsYikWI2cT3Mz8OjrL8A8lnDnbxnEjUyfFuVmqwa+T0GZM1T+2vTelBQ3PQluTynhlHcZQU2xEqUuRlrj5oeljeO7PrDNBfIKG7Ot4qwNbNwKId+E/pzSReNjRyax2/JS4gML4DhtlcubsruBAQ51dOIczC/v6MSxSnGZ4hlCdfVPyxpLDsEP/c1iAk0FMia5m2A5YgPpDnYlT91PauLjGPo9vzsHhk0jvc2pZhiehbZtjieU+DhulmVNbbJ86+PW8R1t/FqqLTGXdcp60jPCMryM+O1Pfj/esJ3yXSt7ctctRwm0ZFEV5Uro6aJyPWJc1fQqLr6mWNd0uu7pZ9P+qqqpvQ6bMbRhgwhByz7zidfXB7AKGfzrK8CyCeje2TPQ/fD/DkrOwjzluAKnbt9IDhk3Hoe9OuYR8CYtjY1bieJz5NSw9y3ARPstcz5wdwkEYy8XIUHvL1O3ue5taYwSoZBm+LrWA4eNEAatFWD/9ScDwb1Jty6AogoYM6TAsuvwUBvNfQkd7GQYCKTb4daDzIiywbBZL/11V1TdVVf1QVdV1GDRAW8cOc56ls3BIvoH93x2EswhyCJifhc/qPv5VHfw1QaMU51vl+OfgQvv2qoMwR4kVfHnP3LMgT0YO9sw5y3AZqa1KJcuwPudMOdL3pbjYPvVneSvYcxEpQJXDeYYxKgjFuh+vmSpgWJ+lbxPy6w5saIW4lCdlbEc7sjjuGyVNHxIsZ/fyStlF5U3zE7t05pWyCrNyNcPF5TH8GAb3qS7Kuo9vO1AShkKchI1uc6J928/P4f6n2k/N1ZjXe/3KeYZzWWyMdVZ6ClmGqZ1zloNm4DCFtZapq3q8Nn6N2Ue2XZeIkRU/9bg/tTHLbWhvxm7zTsN316a97yD07Ta0QgSChsSwfT7icyOAmPIZabvOSVzuCCRCzeL7fFiIbae+VqktyLqP+9F2MXeLVwIMuVqEd1a55f2l2E/NOdNwMXL/e/PK9ZtD0HAR6TlNIcvwImxGo716sf0kctsSI/i1az3pLPIcIIfypFOuw6U2J7ueqJ1NrRRrDo5CX+D4H5iY8qSkoC5r+uNWWdP6/MGUA3G7ypumfFZKiWKXl60X35UqzdMitEcCTe19DO14KgQM23GWBHN2M6Md3gKG3aXWT815k8bYmXJzLk16Fqm9ip1leCVg2NtRAgvtU6+N7Jr7xw7UPLd8l2JUtGr7GbtaJDgn+zRRwPBSwLCzH5UphekJGpKqozCQ+CmcH/YlLIhcNoJzsI8USrLUZ71dhYEyebAQ218qC7KXAoadHGi3mKGLrYoXOdNP9Zda4HCuxlyQfRZwHVzMLMO6XTNuG8b3kTc1T735bDtbLoXMrhzOM5yiDU3x3f5uosD6lTNZe5NpCBMTNCQnx6Gj3QRffm+cPXgRBsIWNdklpUWEjyGIeeF5zcKVhdhBxF6QPTNJ6+XIgjozsppR5oqA4XA+RjwzrgSnobLMWOaeZTjmtXtNrCzDul2by8aOVMQcx00dAGvO/U8SyexSmjS9MctmY8S3E70bqt0M46PkEZiWoCE5OwgTirqs6X9CQKYua6pMKFWCZ2QehGf2P+FZVbY0TVehbDLD+BjpPJ5UFgty98GCOjMxpwC4jS3D+imB8w3nmi039nWd88aWks4ytBFiPIeRsnQWEYLedTu6Sujs4rZte4x1rDH7n2WCAcOTiZ6PcwHDQZmPwoT+ldjFvgkDCwNFujoMnXKzY74Pg6DmD+VI+X7Xz+o6tH83CU1uSmZwP46fw8aOqQL5S+/ToC7CwmzM842gj4sZzTFsbBnHZeS5Qsz2dazd+8uRn9XrGfdLJ5Ey7mJkGQoYju88wr2NFfyqn6dUzi5uO/eJ8R6MNT9bJXYvHsNmjCn6+bOwIYlhr2nqgcNFzzWIq4E3Q6X2earQN3TdyNL381wNMOYtJkEptaDhZWNX20noYFbhP8coy8E8HG9NuNZhkHDX+KdF0Pl6CYPDlCehBzsCiHfhn57NaZ0Y3I/qJgzSpniurxKaoM7BQRijxc7EgS7mVJb0zMaW0dTnuJ4UOP4aa64ty7C7WP1tjGsqYDi+g7DYPmXG4dRlNu8TDBg+tvzfx1iMbvsZ95ViwHCq/n2l2s0oDkKlrpQ3Br+E9Y6u46qXgfvhVc8NSE8jjAtOe3ymPpUQlgPNoVJ/BgeTcnnSu8bi1ObG/ruqqm+qqvoUBgPrBD4jeWqWNf2lUdb0pnE+IvOSWonSt9QBxJ/Ds/kQ2kLP5fj67sLifQcTXeML5+GM4qO2iEzN5cyz1czPb0vBUeRrPLc57pgZAc+ZjfHbGGphq63rMC+eklLL0zmf+Fz9qceMdwk+T23bqBjnGY6RdZdawPB2woDhYsZ9UwpymIv2We8Yug3oe73GuN59fmefd2uoo6GKOWIqpzMNX8LDUQd1Ng3xV+Hw2s8hkAhdHYbSOfX5iF/C4OkqBK5jDN4YTs67kDeTnu8bz+V2O8hwbmSmTeJ45EXEOWUUpSjGmTjQx9mMNhHIoJ7Gx4gLAnM6RuFs5Od1n+BurnO4WOXXpu7jr2ROT+pg4mdr6vfvLMHS3TmcZzh0gGtzH35LaLxyHfr0qSoIWFMYVw5Bwz7v1OHAJeP7tsOHI6w7dt3Ycd/zPR6q//tYylpsauVJ23pqZIjVVlulTe1ao6uj8LN9PuJd47yTqXdi0s1D2I08hzLHx41M2SqU2bhr/Chn2s25zLRJXYS+e4w2dM6lylJwHMZZdtCSi7kccTCnMxlzcDVhOe25Gru85j47+XNcuF1EKk06dZahM8TjmKpE6SrC+5dif982aJh7puFZYmU5P028GSK1NYXH0K4/hPHMe/d6Ffqgk0jv8D5yGAv3rax0MuCaxhBtymrAuX+sLMPVwH3EaQnrTrkHDXfZPrx+sSOQ6HxEutp1PuLd1hmJFhfSdDXT7KOjRjZi1SjVVP8IbL9vKXtqcs1zo4Z0blF9EueChjApGdTTc45rP8uRF05vZzzGHTtD8zVTjoVPnSEezUF4xsZe7FSp6Y+1ojYBuUWktcqhgoapBQy/m3hRP4U1hXUIWN1U3TaUb8/vVuG+xuqXXrPKoDLDbY/M56Haz/B8JuwAACAASURBVKHalCE3DPdZ/+kTjB16PC9oOBMvjcXz2rIRQDyRXUIPB6Ej+NBYzLm2wJCkuQYNtx2GXbv1zt31VhBxTmWvhnKZ+E705uaEp61FsoetQeVyq49LeZPM8cCHSC8EfyfzITxnNiXANFI/x/C5sXFzewPda/1UyrvYax/D+HHKTRIPM5mbjl0Ccc4LNTFKk06ZZbjK5P49Nsbe77Vrq8b4O4f3V9BwGjlkGQ51zNNlYxNzbOswx5x6g2PMEvLrcA8uB05ieAh90nkjSzmFcdsyg3Wtux5Bw6E2Vg/VpgzZNnX9bm03YWwb+tiBD2H9adZJQyUEDXd5raxpM5AoU4Guhqw/zXCewoS4tDI4zcB27X4rkFiykwTPvqjCQsXVnoHet+7hMgyQzhLt1y4HDBqeJ774/LxV3nq7RMyiMSA/aYxHUv1O5xHPXIKSpHomY91P7VNq+q1+qm7rzhPd6HI58ULuHBYfxi6v+Tzg2CE1Z5Heg6k2XS0SP5v1tpGl8967ePfKf65L+6V4vl7teILNX4KG7efZuZ5nmNLZpOtwHacOKJ1GHKvdhvZm7PHDZaN9jL2usMpgHHDTI6P+aKCAVGrBxz6/q8/9Ph1pbHWWwcbOXv6Z8Wcf2kPo7M7DQ/yPqqq+qarqh9AIP8/r60KRZCH9oT4T8deqqr6E9u8ydKZFHOjbkNozcR/6nlW4J30nPE+NBc+vQ+A8JYcD3YNFogGs53CWxldhcaYeWO4KBjcrI1w03sdvE7xvlYx6mExq/dR16E/qfqrvonM9BlmG/u92oM85lCPtXWunIweF5pxlOPezDC8T3MT2HNZ8/t0oN9ZnofYlLG6ehvFfimO4aoSsi22qebWfx8UIGvada6YUMHyMWLYyVuDgu/AuT7Xh6Ck8p48T/b2cPfWMIwx1FuEQDgdKjulTYaTPBoex+rvZzw8EDd9211hIX4aB5LdhAfA+7GIB8vGU8MQtpvpMxF+qqvpPuE5XoROcc+ZsSuWpH8Ni6ZD14rc9hHv61YClaIZwPkCwOrUsw3VYgKrPtuizGHfTuG8pLaYfTLDgBKWLlXW0y30IFp6NuCB3F9qVbxLrp6YM3M4h01Bp0m5ijUuner7PEqv48hwW3JcjlPSrPYXv/U2Cm9DHHMPFCH6lqO2cLkZ2Ztf+fBHmKCkFDE8iHZ0Qa6w29ZmNtZdwrWOuh+eyRtVnXWeIdjSFDMGmWOcZjtXfHc290qCgYTv1rrGL8LAvwiLeprH+nNjkFtjtQsD/XfW5iJuDzH9vtH3nMys1k0r2xudwXacqFVvvEPw2kXfhoOcCY2pZhreNBaghPYUBbyr3rRI0hNGl0k99mrjc1134ez8k0t4dTribOPezp1cjZ5JNmRU3tTlnGa4SK+H1aeKzFe/C30tpveh4xAozSpP+ESRuE4heRtgA+dzx/V/0PK9taNdhzBBr002MsdoPkTfQvESef+cSqOkT6OobNFwMHMyOmfn42OP9Phu5bZ31ekhqQcMcBxdPjbKmJ1tlTa+lbUNynuZed3oE9bmIm5rsv20FEXPdWZNKluF3EQfcN6HfTaGf6rNQNvZAsI0fJigRc5PA7s6aoCGMJ4Usw3XYqBAreHmZUBksJe73I8uwm2WkjJ2pnutUzjF8DBnTFxECDHV2TkpVb8bKCBQ0nG9p0jpgmEqZ4euJzvN7zVhnpb3lPpH1rCub8d/VZ1N437WqodvhIdqorr8jxSzDWopH5AzmX4l9nsvwYjyGDqz+mSr7Yih31d8Pw64P+a//merh31CC+ryw1M7UyEUdRKwDic+hI7/KaId8Cp17rJIiTXXW4WXk8jJ1FkeX65HKQG3K+/nQKGUbczxxEPHsEIjlPjzzL43x/sM7C1arRkbHvu9M7LZtPXF24Wua7V3McdvhyCXE52Ax8uLM84yvf4z3faosw4tE5ly3kYMLtfMJMnL3ddJzMfY1uZcnnaqf3/73p9b2My7D85LKGsoPCQTPYrTdKW1iSqlEbYpeQnvSNQDYZ549dJvS9/ctewTYu479FhNkRB/OeT0ktaBh7Sj8NBufnAOJLzsCicutQKKDomFaZwksuM/FYTgT8fuwyHgTBvCpdpzLBMqppBAwrL00Mv1iDvrPO1yTk0TO+4pxPx/C4uyvE//dbaeChszcOrzfdz0WV5vvyD5zmBQWlMc8u7Ctl0QCh+cTzEFzbk/Hzvyfa7bnIlJp0imu56Yt+3GCv/OezwltMntpjJ1iz0PHCO4NXRJvCo+hf99es2ujbT+/LUbQsM3nXCW2dpLCXHoZYR03tc0zD4KG77rp8Zz02bw3dJtyEJ75rpuNun6edY9nfqqqSGdzzTjM6UzDOoj4U1gg+xIenMtwg3IrgfDUKO9XlzX9OnR+yprC+B4iTdDn7iC01b+Fdu4iwRKmse/750TLa51H7nuOOvTlKbzDMe/nXfj7MeW+mxxecx9Kc9bnpo6RjfGa2BPPHyb+vvt4SaBU6YcJxjQxs6D6frcxn9t1gs/kUGKUWZ8qyzCFEnoxjwJ4zVMiQfAxNmHksi63DmPor8JnvogcjImRRLBvMCKlgOE6HAeVwlw6xjENqW0ssnH0fX3alT7z7DHa4j6/s+t36XP9pur7Z3tkS05Bw12OQ2bLz2GBOvdA4kPo/OrPXp+P+CmU03hO4DPCnNyEhTHGcRh2F//eOIctBTEDTY8J70J6SeCsvDb3ZuwyaPtI4X5eRL5nKiUwN49h/D1W2bZ9xGzbUjkrZ5c6Mz5mmzfns1z7BA3Hzvy/SaCs5FjmWt7uLIExQkqVPbZdJrK+k+K5V2Nah/W1ZXj3pgievyfGuuXjnm1qCsch1NaJlQmPsaYgSPeHnCoPPvRo6/u0DWNsCunTvk99nuFywuokh3OdH+QeNNzltUBifYZZahkv79n+7F+FXc+fwqTewbPQz2ViB9LP1YeQJR47w3MVuWRO6tmtL5E/Y5vB1mkCE9gU7udLAoHL3DZpwWs+NXbUxxKzbVtn0E89RM7QmeL65Di/G/u6zLU06VmEcekUWYaLBDYfXCccMKyl8Fyndu7VmOpg4UVimxBiBFr3CT6dhfl7CgHDx8TODZsyIEH+us4rDjvGMNq0KW0CmjGCmFOXJu06Bhc0zNhxyHb5JWS8vGQcSKzLml6EhmDRKGv6WVlT6ORM4HAyR2FTx1OkjjXmYuinTHYH3oRNKTEcthiMxt7J/Dmh+3kVebe6oCG5W4fxdAoLuDEnnReJZF285zLinOdogrljbpkEi5HPNLrP5LnsYq5nGV5EDjTcZnIMxVUCmwSGbs9SzDR8bPTxKWYsxxhHv9fPnIU5ewoew3OVUj8Q6znPLQmGP/SpXNLlWWvTprQZc/Y5m7GLxx7vfdcxQNcxkqDhjBzsCCTmlN68rS5rer5V1vSHEAhR1hTed6ZU6aQOQ/t7N/FEKVZnvk643NsuOWRxxByYrRPMeoi5m17QkJzV5a5SCdTEatueM+unYmZYz7lEaRdjB2dyei7bOIlQvnOKLMNlqPwUy3Nm59bHzoYcMgixTCQrrek6sT5+lxjj6LfWP1MKGNb3L7Vgb6yg4WnYqFO63DZX9Yk3dGkf2vw7bcdYXT7P1OcZrjpmNj6G69FlM8/BHOcHpQYNS9A823EzePt343xEZU1ht8tQ/tf7MZ3jUEr6coIB8DJiadLLzM7iuYuYbbjPoPIk8qLEVYL3U9AQ2kstYBizbcut/ONdxGzD1M/smtqYAdzniGeLjm3OWYYxnWY25o79fA8ZNExtPHgd3rOUn4dFpDKXr417rhILGKZ6/2I96weJbaS5C0krU//kNi546bG2MnamYdvx9JRBw673uev4ql5PmfrvJkvQsBzNkqx1WdOvGmVNYy0OQ2puwjui1O+0vg+TlzEH4DF3/uS4Sz7WZz7aI4Ace8E2xfv5FLHdEjQkV6eJ7VaO1batMzj7a5dYbfGHkX9/TjvoT0fekJXjc7mP5cglXXeZKstw6u/VlMtRAE05V7zaltKGih8yWcCNMYZ+be3vKvL725T6/Yt5nuHHGWfgz1nXQNQ+ayO7/p191FUJ24wNxs58bJr6PMObrX+29WFumcCChmV7apQ1PQk7Q75ulDUVNKFUdfDqkydgUoch63CsCUKsiex1ZjueazcRs27fu1cxFyVuEz5bKdauy9RKUcE+PiW4WBurbcs1MBNzp/mY9yqnMYPSpN3EKK879yzDxwwzpmsxN3APWSI3lU1k1xm1HTH6/V2B9ZQCht8lfv9SCI7XG66VS8/HVCVK2zyfD1v/HPr3V+Gzd1kruO3w71Th83XZzNY8P7HPOtis3klBQ7Y9NMqarrbKmt46H5HCXISMXJm40/p5pAXMWAP8nMtqxfrs792rqc8Aakr5fsYMgCjXR06eE11cjtW25RqYeemxqNCXNu+PrLIxsy5z3XT1nkWEDJr7ArIMY55z2ldu2ZGviTk+r91mViIu9nmGi/DfUwgYrkMSQ+obmYYs6dvHJpvsl9C2Xyb0udjtocd6epsxZ5s2pe572qwhtM2ynfo8w76lSfv+fUFDitIsa3oaOqKvwrlvnwRTKMBT6Oi+8bxP6uPAE4ZYB/OvBQ07eWuwG3uhVtAQ8pdiwDBW2/aYcPb0PmK1e2Mu9OYSKBt7YX6upUnPIoxJ555leJ35GCjnNriWQpbhc4ZnSsW4bnWgoA4YphDsTe2M6bekFpw7DJmHvzcCiI6OSFPXfmrsoGHbPmisz9PUdc2la9Bu+970KVE6mwC+oCFdPIUX6GKrrOl3ypoyY3eCh5MbMnAoy7CbWAswb01eY06C7jNYzI1VEUDWDbl4TjQYEesdyn2zwRyDhrlkHY25OP84440wU2fE3U9wLWNnGeZalrQ2h0zDFIIUZ5llJy9HPhN2l3VYz6sDhjHP5qs9hmuRy3uQ8plldQDxt/AuXIX3YlbnrGWsa1/cJrDfNWjYphznWOVSa88dN9OcdtyU9byj/emzjjebbMN/JfAZmIeH8NNchDkJjUn9z6kHRDCGOni4DJP+GLuFS1IvQPRdmIq12yf3Ba+XMIiK0X6vXpk8xlyUyOF+nkaaGM5hlzxlSLUUZ6y2LffNLbEWGQ9DWzvH8pn7OBt5bJBLydy293/s67bLFAG1mNld18YgSYi9eSzHbNNYWYarsG6XSsDwJLO+NJcsvoOwlvIxHP9Sb8apf0odv8R0E+5FF6+tjWxr8143+86HFsHJfd+Brhsjus5Nuo5Fdv29+giELmX4z+ZyJregIWOqO6P6ZVnsCCQKtpCrpxA0rAOHpyOf61Kyj6HT7rMzWwZHd0+Rgoav7TiNWe4hh/s5l3NxYCypljy0uaW7+0jl1VYFl4UeM0i0zqg0ads+N8ZZhlM8ozGDhrlnGc5FzEDKOtMzLWNcs/r4oRTW4a4zLCebs6Pw8334DvdbQUTG9xKCt10C9vuU723TpmxXTxsjaNi1jevyPC56rMe+Nua86fg7j8K8LvsNTcqTMqWXrbKmi3A+4qas6WclH8nYVQga/ruqqh+U6B3F9z0nFTEWY7uWVUhNaqXfYp67YUIFeUu5xHCMHf9zGXvHuqdjjS1S3/yxHLkvnutZhicRxjBTZRnGqig0lyzDOWz4ipm1dplp1lSMTa0fBAwJNv3Rj1VV/VpV1ZfQDl1GrFpTiq5ZdPu0F11Kk77239+yb3vftY3rco26lgTdVZq0z+eozaJ9EzQktqcwMTxvnI/4TQi8XEc8mwm6eGkcPP3vEBC/dSUHc9ljgS7GYoZSSf3smqzEzDK0GQDyl2rgP1aGxlz6qVgL7mP1SakHQcfO6BmqpFNqZ+3ONcsw5tk9syj/NYMygTHftXXGz0HMjZAxPQoYJqnOQvylqqr/NIKIZ5Hn4HPTNRC1z1yhzXxiew7Qdk6wT7vfpW/ouqFxyNKktZce67mzaOOUJyVF2+nxi62SpifKmpKB+uDperf0afg5cb5nZwehU2+7uBpzIjuHkkmxFrN3/d2YExZBYMhfqkHDWDu6lzPpp2L183NbRNv3+4y5EHI70/522TineypTvNvLiMczPM6oJHsuZ6S9Jubnv8k06Jr7Pe/jqMX5bClqU8YxZ0dbGWXPW+VMzY27eQibHdquaR/uUfKyT6Zh2znSyR7/TpcM9C5B1T4VMN6rbnHXcZxzmHk791+ChuTgZUcgcbkVSCx1lxb5uGl0gMtGAFEQvJ2jsMM9hx2lx9qmwcWcYDsrEPIn0/Cv9FP9jBk07LKgNIWzkT/XXEuTTn3emizDvMQsBThEZScbNNsrOWhYhTYx10yc3DODuzoMm1/qDTDPYX3ryjy5tZuOG4lO3hkntRnT7xojtDlv8b02rGu/0GXsMkZp0trmXv3U8fefZXre7v8oT0qunsLL2yxr+nUoB3kdJtqQqqetevFfh5K8t57dvVy0nFynVp6K/ewa9MZcVLGbEvKWcolhZ8ewLdUFuDEXP557nh+TqkWExfGpAikxF/3n+KzEMMT4NlYA7D7j8Xnp89OYGw76EiD7w2EoZ/pbY32r9GD4vrpu6nnr+ra59q+VAG3zucYIGu4TxNtljNKktacec8jsS5QKGjInD2HXxZmOnMxsHzr9VQiAf3aO2k4Hue/YoTPlSYGuUn6HnRWTp9IWx1YdS03ta06ZY01jZ2dumyrLcDny8/CW24KzfVKziHj0Rs6ZyaUHVw4yXlC31vh3zQDiQ7i3NsS9ruuml7cCcX1Kk773f9/l8J173CVo2GXs0mdsum8f0rWvOch8g4SgIUCCnkLHdB46wU0m7TdVVX2Sjfg/5y0GohZj5yPmvbQ4BXlLeZFHP5Wn0srLj71hS2nSYUyVZRhzIWxuWYY5l9+PmTGX83MQK+CeklwX0/tkHpVg82z/HK5T2wpRpXjp+AwdvXE9pw4avvc3u/RrXdr0rpsP2mQ19ulrBA0BGN1dGHTtykZ8rbzAnLXJNrQYm6+UJhl2lULeBP7JSYw+560d3ouRFz6uZ/qOnk6chTVVlmElWDSomOPdvu9drIBnztmmpZcmrX3IeJ6uPPL7Nus1PwoevqrrM/RamxsjaPhaW7bquLFuyvMM21z/PhsFBA0BmFwzG/GkkY1Yn404xKH2qVOidP62B78CwEBXMg3JSWqL4acjZ1bOuTTplKbKMqzCgn8M9zMMMMs0bC/noE3ppUmbci1ROtfM+DE0g4fZn/E2oKFLlB63+B1vtfttEhJe+yxd+oUufftJj41Zbd/hPiVKs33uBQ0B5uOucTbiMmQjfhvKms4xGzH7GuG0FuvMFIAxadtI3Zgbte5nms2/nDiwNmWWodKkw5Jp2F7Oz4FMwz/lupj+FDLk2d9BKFt6Z7Pcfz10PHZoV/vRph1+b12wzXhsiKzHWpfxyxSlSWt9xlfZrlkKGgLM11OYUF1sZSPOKYi4z0DBoJS+nFsB+VOelDGMtfib0vO6Gvn8rblmbMw5yzBm0GOqwOiU2mSIDK3P9VxGOtv1MfM+Xabhnw4zDqKedwz6lO44BGxs/u62+WFXfzFEadJ9//9NB6+stXV5p7tciylKk9YeelRz+5BreV5BQ4Cy3G0FEb8N5yLmWs50nx3cMjjoS7AB8udcUnKS0vM6ZpbhesZBwynL6E+ZZVhFXORfz7Atj7m5se/8T2nS9hbmpn+Ta7bhi3KbnW2CTb/MuDT5vrr2232OcHmvD237mbY/S5c2rkvf3qdsftdxZ5++J8sguaAhQNluwqJGXc70hwyzquxSAwAY3mLkcdaczzKcMgNryizDauTM07fMMcsw5/MMY332nJ8DpUn/7jTXLJywlvIpgc+Rq+8LPx9yqHMN27Qr77WfTy0zaLf7gamyDKcsTVrr86xmucFA0BCA2lNYvNl0/F+HDMQcSm6YfAEADK/PTu59KE3aXylZhtVMM8YFDdvLOWioNOnfHWS+CfjC+Ya9fCw4cPjSccP+djuyb7uyDmt+72nTN2yPCaY4z3DR48zoPtmCfUqUHud4bJKgIQC7PIQMxE2H/F3i2YcmXwDAnMQIjuz6m2OW2Lzdc/EqN8uJz6ibOsvQeYbDyvl6xjiLMfdz+W123W3Kcs5jOJNx2EvJgcMu7fBy6z/vu7lr37Flm88UI9OwzyaDvs9ZUSVKBQ0BeM9VGAx8k2jwMMaEFQBgLDHO0t3+m6uRy1DOoTTprgW4KYN4zxECaTE3680xaBhzHtNnc0Ks4Ffu2aY2u+52lGMWzpZN2/9tJpWaUvRxBsHjLroEoZr9Rpv3Zt8+tE07e7D1Gdq2cY8dxrwxSpPW+gQNsytRKmgIwL7uwiDghwQHwyZgAADDGXPxLkawawzbC11jnwG5beoswyriwn7XkmApizl/6bJQ26Q0aXttMoJKNIeA0U14N3LPiI3lYgbB47buOq6t1W1wmw0c+wbM2gbWlo1/tm3j2gbh+lRzOKyq6kvPn187/u0qx80RgoblWTQW/gG6qM89TCnrsLTBJQAwbzE3aI0d/JpDluEuY58B2fQcqZzbmNmnb5njeYY5lyaNtZ6U83OgNOnbcj7XsOkp3OvvZB22dlBomdI+JUrbtMX7tp9PLZ/dk61/ttH2u+feTmS1OULQsCx1wPBY4BDoqR4Mp7KLTnsGAMxJzMXxMYNf6xkvCk65GBQjyzBm0GOOQcOYi585Bg3XmZ+Dar76tsMZBQ6r0M8tw1mHgof7Oy4wwN6l5OVq65/vadt+djnXsG0bt+7QF2VX4nNLVm2coGE56oBhvTPwQOAQ6OkldHopZBy+lWk4x3JGAABjGTP4dRPpzMaxnUyYhRcry3AR4W/Wcg4WvSbmeYZ9goaLSBmnuZc0tvb2vtwDAtteGiU3BQ/3F2NTTExd2rY6sHq45/++7d9os1Gna9Cw7Wca+6ztKRzm1BcIGpZhO2BYEzgE+qoDh7EHwG8FDee4yMC09JMAlGLsRZm5LgZOudgd6xrGHA/NbTwfM9vgPtPzDHPPNo0ZJM7Fh8ibE8bSDB5+l9gxLyk6Lmz+/dThmViOdJ5hrU1A7zC8t23buLYZlnPZVJBNiVJBw/l7LWBYEzgE+noqcDcYZZnqfCKgTDLi2WXKBfLm5q8xFzPuZ7qZazPn/jjR34qVZVjJNBxUzKBhl1J4TbFKB+acaeg8w/3NLduw6SW035v116+rqrqWffiqOT8Hu7Rt3w5btitjZhpWHe9XaecZ1rL5Hv9K4DMwnvcChrU6cHgy07MCgPFdhkWmfcsjzN1jboccJ0qfBJTgKUL/qZ8axpj91JQlPOvvsRh5MWOuZxmWkGVYyTQcVM5BQ5mG7eWwSf9zVVXfJ/A5zsPawtw9NPqO08aPzap/OC1snHrT4f1r04+0bT9fwialfecnbe/VY8t+/WRGa40H4d717YtHJ2g4X/sGDGsH4YFdzfSMCcpyF6n8x+3MDu9uq8tAZyhv3e+nSM9D7udupOg+YmmfpVK3TMyudMb0op9ihzEXLGNmyI1tqoXNOV/DksQMDLRdqN0lxvjkMfN1qpSDhutGAsFpAgvz9ZlfJW0evWkEEE7D/UjhXsR0WNj8+y68i236hn3X+587tp8PLZ7Bts9q2znI3DJPswgaKk86T20DhrXD8O/NsYY4TOGtc/VKkGqnF2OgmfsBzfxd6e83MJ4YC6HG++mL8VyMGfyaa7BryoXd2McBxAp8zK2Ec8zFz77v4TJSwDP3AFKqQcPHrYpjqcznS66EcBO+/+Zd+6qqqh/C5vQSy5iWtoFyrM18XdvPMdvdtm3N3JIzTnOYiwkazk/XgGHtSOAQOis9UCRjgbHF3GEsaAiMJcZiaOljlhxM/VysRn4ulCbtJ4Usw1jZcXPKNNmss3yI+PeVJp3eItE+937HEUWptNMlV29qegqlWusAw9eFBRFLm3+PFbTv2n6Oub7X5nfPsWzvQQ7tnKDhvPQNGNYEDqE75eTSEyuYmcPZFbmJuWAgaMjU9CeMzVifpjEzO65nWmJsOWEAKHaWIcOImUF1P8B7KGjYXopzwuswztzekPmQSGbvwQzLEQ7h4ZUg4n3+X22n0tZTxlq36vp7x2p3b1v+7+faFggaMpmhAoY1gUPopvRA0VwHrF0IMs1L6e820zMGK4fNLcS2GHnxYq5ZhlON9ZxlOB85lyatIm5oyrmiTWqbwH545zlMpa0RNHxfHUTcPGP/qKrqm6qqPoeys3NQ2lzoaaR71zX49zLS52nTnsfOzh/Th9Sf8X8l8Bnob+iAYa0OHO7agQQp23S2x5E+30kYuDGtt4KVMRdjkz/cODObe/ljpI8sCDw/q8R3rgvolCPWOHultHjSpmyfxiyd9zjj52yqRW1ZhvNwNuH5l9vWA81LYsyxc9+Umsp4bh0yXd8LCl5FnG81HYf51xyz1Mdy1+hv681AJzMt7zhXQ6/tP/acZzyMMEZs0xf12dB2O9Ha7K89/t3TlDeFCRrmb6yAYU3gkBzFHFiWXk4uVrD2PesIA+XSn4UxxOyHcjn/60ukv/t1xwXumPc09d2rgobliBW89oylbS5zrzlvppsiACTLMN35RVsxg783A7QpSpN2k8KccL3j/MLX1NlOKcx9zmya6Owl9B11/7EK1/PEudZJ27TV3w/4Afu2n5t//+NAn6UKY5o267V9NmddTbRp7b7HOGWfjRzRKE+av5sJGnylSmF/B4JFSYox2bQYO7zYiwapv9sxn7mu9yb3haCxLO0ILk6MUlLGK4xtqOymklkwn4eYWYbVQM+RoGF7KYznHsPnaHMdlSidn4cQoNi8x1+FMrVzKWM6J0MHuYYIGg6pzZhw2SMYN+X4s8/fOUq5opWgYd6uJtx1J3BITmKXQCp1cJtywCLGZPNA4HAUMSc3qS+wK6HaTspjGsGc8sSoknCo3UjeOvPPf6VaTS+yDP+Ue1sVM/h7O1AfE2tsknPQLZkGEQAAGbhJREFUMPZc8LZj1bBUNnscGhOP4ilUAagDiJ9Cf0Mabgf8FH3bz6HXVtv8vj6lSadsw/r+rTHPFO9F0DBfVwOnCO/jyKSFTMSue59soz+ymJOi9yZCsSabdkcOL+bCQervdqx3MNezZlIO6lsgKU+stq3UMUsucs/Gds53P7IM/5Rz0PAicpbhUO9hjHHTOvN2MOZ47nPo47ts3HhKKAvNfHpcT6GN2rSx3yQ2ryu1Is2QgbohfteQbUGbAFufd3/KoGHf9jLZNk7QME8xAoa1DwKHZCB20PCg0MFtzEnRe4Mhi7HzEXPykHT5iIjvYK5ZJCnfS21HeWJVSbAYx1juExiT50yW4V/lWr1jGUoCxnI/YP8S4xy03IMGsZ7b7wZ47lLZ9PFRxbPJ3IX55LeJVDootVLBUAGvoYJ9Q7XDbQLSqx59TozS+H3Ga0epjnEEDfMTM2BY+2gCQwZi75AqcWdwzEXu9xalHiINfJVUGV7s8sMpB3NyPWsmVjmcVIOGp84zLFKsti31zRDkS5ZhP7IM/yrX8fRV5D59qOco1vWPPe7va6rjhJq+GWi9LqXzaMecf22e7S8RflJ+tm/CdYkdOMz9/e/qaaD58VDBvqHuwxyzDIf6m0lu4hQ0zEsKAcOawCGpi70r8bCw3ftnESfE6z13sscadMbcXTxHsd/tVO/nScR3sO+7FSsTJcZCzj5kGZYrVikwwYl05Zpl85zYgnNu1onOtWNuyswxaHgeeawxZJZhrhvTYopxzR4HvOcvA5+t1seY869cs5jH9pDA+LDkagVDjKGGagtiBB9zOc+w1rdEaZLzf0HDfKQUMKwJHJKyFHYlXRRUSiPmgHLfQUysZ+KDLI7BxZzAppo9GnOgmfMu0NTu5TLB8R7TiRVk+aifSlaupbnMEfuRpfl3B5kt7q8SWHAf8u/HGi8JGrYz9Jg8lc0fY5bvM/553VXEbMN9N4bP1RDv8lDt5xC/57nF7znpcQ5wjNKktT73LMk1JkHDPKQYMKwJHJKqFBaxDwuZ9Mc+3H/fQUHMSU+u7eRVouVaYr/fKWblxMpsHiLrIOaEMLVdfTK+yhazbcv12buL1E/JonuboFd364Svn2oP+1mENiJmWdLbgfuUGAGw58yDBjEWgId+R1Pq68aa68g0fN1LxHa/1NKktSHevSHvXd85f5v7mVtp0lrfNb/kKtUJGqYv5YBhTeCQFL0kcK5hFd6POZcp3Qyyf4z8GfYdgAxVG76L4wxLDp5E7H/eG+DGnkQcJ7YTLGZ54CHuhaDhH1ayDIt3F3FH98cMy/+dRiz9N9UiWo6ZhtcZZ0im4DLh6xf7c51mUsXlLvKGymrgAOsi0vfJOcuwihSMGvqapVSidKw1lVIqQ3UVa55WetCw6vnuDb0W2rdtaRPMy600ae2h53pjcuuFgoZpyyFgWBM4JEWp7Iz7eaaBw0UC17hNmYMqgZ1HOU1KYu5yf29y0ndANoSUsnJiti9DvFMxFyFTKgViHEUVuZ+6zKifWkR+Z6ZazM5x0VyWYXcpZxlWCSziHmSQbXgVSinG9GnghX7nGXYT4zkY45qlMj49GGlRPfb7mrpY5VtVdOjX5w7dFvT9fft+l9Mem6Fjliat9fn7Y7VxnQkapiungGFN4JDUpDTQmFvgcJHILtq29zhmG3WQ0eD3MvIEap9BZexreZzIwlXMTJu2QfvXxF4USiEAHPudIx0x27ajjAI+V5FL/9kBv9vjDBb6Y0o5y7BKpFTkecKbG1JYw3keoR2PtbnKmdntjFVl6SZiFYRtc1pPyeUsxRjt7WPh5xnW+swJUgoa3rcY2+RamrTWd71R0JB35RgwrH10Hg8JeUqkRGnt55m8H6twbVNY4G7bKT+EQWgsxxlsrtgMVL6P+Pf3DUSlcB0vIp+DsYi8wD/UwDz2pDB2APgs8jtHWmIvzuUwlt+8Mx8i/v1H5TdfJcuwu9SzDKvQX8cOHhwkOJZeJLSGczZC+yRo2F6Mazbm9Upl4+uHjIJt7znMoLrDItKaj2SUP/Q5XieloOG+bdOi5/g+hXaqb0Wsjym1C/9K4DPwVzkHDGs/hsZNQ08KriJm4ezyY5hEnGW6e+oigTMMa12znDbPxE/jfKS91G18ijslVwm03fsO9uoBWcxs1zp7dBVpAfki8vcfanEzhbbwIkxops6QOQsbSqDpKnIgOeWx/EkC78yU1yWnseLa/K+X1LMMa3eRg/ZV+PvniQRZ6+orKWymvB0pcBRjg1zMTZ5DmMN5hk03Ca1Tns5og8pJ4pWIYq1XKE36p65n+Y7RHnw9wWf5psPvr6Wy0SSX85ff9Y8vX76k9HnuIi7u3ydwps0cAoZN30WcOJb+LPFXL5FLWL3mU0YLBGcJBCi2dW1jNh34f8b9aHu5TixwuAptZ+x35esWA8vzyAHg2mNo96d8l2MHm4bu62L227Wp72Mqz+8u/xjxd8e612N+p6FtdtH/nsDn0E/t9tXEwbykJuxv+JzYeXOb9vzXBD7HPtbhvc9hTpBS3xVzvaFqLPinMM8c6xmK1R+l1v+09RRh3jx235TKmsrzwNmGMfvYlJ/zRXiepr7n1lMhEcqTpmNuAcNqhme4ka9Ud6LVO/kvEi6zUWdE/pxYwLDPIccvYYAe28cQHEvh3p8mshDb9iykVHYhHoXrN9Wu4lUC7drQfz+FM7COwucY+z4uw/OSasCQ+J5CxkhsH8OzmsJu2c145LcE+qlb5+y8KrXxdk6LjrlsIqwSKxkZa72hLg//a0IbU09HeoZivUc5n426iDBvXk/QN6Uy7zqMfDzEkD4m/F0uI7VvypxDIgQN0zDHgGFN4JAUXCZ0ePe2gxA8/D0MxM8SWJw7De3SS4LBwlrfxZVUzmuqgxQxd+ZvrsUviSx6tJ0kPCUSAK4agcOxD69OYeH8eYSFg1QWhw7DfRzjnVyE9+0hsbLZpCmVRZPj0NbGGs/Xi/OplPG1mLWbYGp3OZxl2NT3vJ6h/Ryu31Tzp3pDZUpnEX8eMZgbK6DhPMN2prheKbVTKWW193WVYCnDs0hr1GPMMYGOlCf903Ok0harBM4EmMLnCGXbYgU6pNOnKaWz+PbxGAZMD+FnrIWYZWiHVuG5zWEhe6jyO6lt2HgOz+lUfdFJmPylcAZL1aPUTIrlx+7DZHbIQNgy3K8UxgxjlANLpRxjU/1O3vRsb1ZhXHKWaKnsXZQnTUMKZXub7hvnf06hPrcolc1Lscb4qT0Hu3yb4EJfLmP/TwltZttXipuexxxHL0J7lNpRDVWYM44Z2NNntxej7ZmqHYlRdnWXIcvxpvCdYhx18ZqY7XvsktNAg6AhDE/QME2LsICfYtbcPtbh8780AhEPLQaW9TO5aEwsc21vh5oUpRikqAYMVLzmNAS0Urv/fRYcUx0/3IeJT5/Jz2n4SWVxbuhzRJpSWYjY5TY8Zw/vtL2LxkaMejNGjv2OoGEaUj2T7TEE88bqp+oge2rt+jeRsl9SnyOP2S/0kUPQMKezDJtOQ5WKFD2H9ulqgOt62vhJcdPPOow1xszyjbFgmPt6Sow2e6r+6TKhLNuhAkyp9LHPYewTK8s29obiVMcSUCxBQxieoGG6Up7gsp+hB5MpTXx2uQ2Lsnc9FwROGoseKQYw+rabqS6sN903gk4v4X427+kqBJwWjWDTKsFFqjF3gM65XHtuBA3TcZNwVZJ1o4/q20+dhnYv1Yzc2wnKT78m9TnyD4mW18whaJhjlmEt5Y0+tcfG2OvpjU0/y62fXKqvjJ3huwol8af2OfPyky8R+rF/T7T5INYzsctQ626prQfEqOqQwobiFCsWQNEEDWF4goZp087kbehdlIuwiJBDycD1VpbTdtCptr3wkcPz/vUApTy92+Mbu3+zsSMdgobpWIb2Mad+qu6n91mgXyVUJvs1U2TzvCXlDRUpZ8qlHjTMNcuwltvRD3MzRbB+E0j4KcJ1y7lEYYyg2tQZWiltGPhqgL75LKFzk5vq8/1uRlj/OEksi9oaKiToX24KUJizjBbf+KsxDvl/Cc9EDoGKg7DQPrfA2KeBzv47T2jn61yNves7VjkeSNlTWBjOYXF+rv3URcSAYRX5b79nrBK1JbjM/NpdCRpGcz1Rdu+YZyW+JefxYIxrNvX1SundPx9gfpLq83YYMiDrLMjHRtb0y475c71Rq65eU1ttHZ+QWob4OqzHAIkRNARK85RRkIg/PY5YvukmlB1LtfzbnA15Xx/CIoryluP4PFBw9y0v7iHsdBF2g6eekTdH94mW3kyFa9PNegbX7kmfHcX9hAvsMQJg68Q3SrwnxjUbe3y+LaWg4ekAQcOnkNWXernlo5mOA2NvzAJe8U8XBijQTVgAJw/17rMxd2Ofhb/DdNYjnA917j6O4nnCM5dyLUcFYzvVvk1ujH5qTu4jLFbPRe5ZhjV99rQeJ2yTFpECFLm3KSUEDZ/Cs5iCw4HeCWfpxWFjFiRM0BAo1XlCg13edj5RhpOFwWmdjbCr8GXC4FZJxg7aN92FICXwV0/KN03uJJHATqql0wSMuplDlmHtLiz6Mr7HidskpUm7iVGeO8Y1S6n9H2IOrz+bno1ZkDhBQ6BkJwKHyfs84SD+Lhy8z/g+jbij89IC1qA+RViMEPj9K0FUaiolTOc7WXRvWltk7WwuWYa1sc875o/3bepNDCeRrnvO7W6MaxZrLSOlzLyPW2f4dfFg/ji5VDZmAa8QNARK9hIGK8p9pek6wkLEVfi7jOd6gqCQMn7DGPMs0bdcCZT9zyfnfLDlXD81umsBsXcpJ9bNnLIMaw/apFHFCBhWMg07KaE0aS2lEqXVQJUY9PvTsTELMiBoCJRO4DBN1xHLsJ1Z/BjN40T39UUZv97WEXeZV7IN/+vZwjyv2LRvty7OKGKOP16T4sYBi6vd3Mw0s8KZ0uN4DmOxGIvrMQJgz5m/HzGuWcwga0pj1KGChjYtju87YwjIg6AhwB8TsRODxGSksGAncDi8x4mDUMr49RO7ZMyVMkGTniVJfgQOh3ef6IaT1IKG1zKgO5vrhhhnSg/vMQShYgQMl1VVHUb4u7lnHsXYbBfzmqVUovRooKCtTafj+iRgCPkQNAT4w0MYaDrjMK6UdvgLHA7nMVIQ6tyieieplIw5Kzhz4XPmJboY30soxayfGsZjuJ68z4JfN3MPtjpTejixxs21WKVJcw4aLgoMtL4kNs8aYg3hztxxND/YXAJ5ETQE+FNdqtRAMY4US4KdhQAK3cVe+DizGaCVlErGPBU6ubyPcJ4r+TqTVd1b7H4qJ882NHRWQn/mTOn+rkPQLmZ75DzD9mJcsxSC9CllGw61jlDypsWxfOfIBciPoCHAX9U79z+5LpP6IeFyIJsAyjcmD52ksBBbbwYQOHxfimdMXBaWSSXbiS7Ow/urn2rvOpOAYSoZXLIEuimlpOtL5POQc5fKfCjWPcw5aFhaadJaSkHDg4Henxdj8cGsnWEI+RI0BNjtQqBoEutwnVPfeXanfG1rKeyUrgkcvi/lCd15IffuXrYTPVxp51q7dnZoK+vEFohzUlKw9UGVjtZSmw8dR/ibufddMYKGKQRZUytROlSw7y4E8enuObwXAoaQKUHD8qztRIa93YWD4JUrHcd9uL657Cp9CkEwWajvSzFzVOBwtxx2gJZw73LJdiJtD+E5Uq70fd8lXOEgVTfaqE5KyTJsuhI43NttYvMh5xl2E+O6pXLNUppDfAjv0xBKq3YypPvwTuT+XkPRBA3Lsm7s9DgROIS91OUpvvXODGYdgkq5LpBvdot/Lfi0U+qZoy9hAmMC+Id1RjtA5xw4TLk8M/l5Cdm534Rd3vzVc+jDc9v5nkLQSWnSbkq9bgKHb1uH+eVpYvMh5xm2twylMae0Tmgzwk1i6yRDlhY9M29sLed1HqBB0LAc9cJgvdPjQeAQWrkJEwK79/upd53lfhD2g6zDv0ltp/RbzpSc+V+mb047QOvAYSpne/VVLxjm3h6SprqstnHLnz5nvPM99uLwfYHZckMoMcuwybngu12HMViK5X5lGrZXcpZhLaVn+Xzg33dmLLWX+7Apy7wGZkLQsAzbAcPagwN+oZV69/5Xdpy19hwWx09mtnhyEZ6HuQQxunhOdKf0ey4LzRjNPdO3DhzmHrCvN1A4H4wx1eOWr/VT/w1cnNv53pkzibqRnelc8Kb70BalfJZqjLP5qsyDhqWeZ9iU0nj2cIR7cu6Yp1fVR13sWnMGMiZoOH+vBQxrd8qGQGtPYbInePi+59DGpLqbdghPoZ39prBF2XUI3OQc+GhmjJYwCZxLpm8VFmJzLL/YDNrK2mEqdYWRbwsrWVr3Uzmdn5yiZ0HDTkrPMmwq/Vzw58aieupt0VGEv5n7/ClGpmGKQcOU5lJjlP2/Cve65E1YTc0xljECzJCg4by9FzCsOW8AutkOHtp59qdmsLCUQeRdaHO/K2AycR0mTRczydq4mPlZh3PN9L3LLOh7O6OgLXmqS61/N/PgYXMhay6ZXjEXiC0GdiPL8O8uCst8fsxsPiTLsJvjCH8zxWuW0ibSTQWcxQi/96kx3y917Wd7jKWCA8yUoOF87RswrAkcQnd18LBeiCu5/M5tyP4pecfZ1UwzD9fhPIevwvM+t93zc8wgLiHT9yVMWJcJBw/rcmSnsk5IxFV4Z76dYT9lIWt4Njq0J8vwdQ8FVOio50OrzOZDsc4zzDkTPMY1e060f0uprzgY+Simq8TnHmNoboIwxoICCBrOU9uAYU3gEPp5aZSt+CqUoCshgPgYvuu/w+BcCbA/1JmHX4VgW64TiuYE4byARbBm8DDX+3ZfYKZvM3iYSttbLxrmUI6MMt2E5/PrzCsm1G3ewkLW4K5dz05kGb7vbmbBw+cw/vgq4/mQTMP2YlyzVK/XQ2JVDMYoUdrUnHvMdeP4c5gPf93YBGFMAIX4x5cvX1L6pneRUvvnpGvAsGnTuf5c+oXs4T7igJs0LcPkcfNcfJjJPboNbfaNndStnDZ+DhL+nM/h3l66v/91GvrGk4TvW33PrhxC/z/Lxvs21fjyNtyHG5NqMpVLP/UY2jvjEJiHenPapu05zOQbPTb6fGMvYBXmjDm1Y9sewzqPOSUUTtBwfr4eqGEXOOxO0JD3nISfVeJBiNo6tCt3jR/6O2kEk48iX891495agH3baeMdjn3fTOraqe/bMvz0HXPeh3flodFGwpyk1N6tG33UnX4KZm3VaH9SWh963poPaYeA16waY6iU13wet9o1mx6B/xI0nJfvBi5DJnDYjaAhbdUL2M3F7FWkgeXj1iL4gwnxZJrB5OWIC7TP4Z7ebd1r2ls0JoRT3rcHk7pBbffZq3Bva9vBQMFBSrTd3q1G3EW/3d4Zi0DZTiZqe5rMiYAhLRtt2EkYV025IesxzB3rNYAncxrgLYKG8zF0wLAmcNieoCFDqhevF1sHrXd9xl62AkT1QPFBACJJy62fqvHf39K8n/WkYPveM576HrV9b5v3qPmfTeiAVK0abV0dbN+nn2q2a/opoK1dbU/b+VGzzXna+gGYQnO+uL1xcd827WlrU0Pzv1vnAToRNJyHsQKGtc3hvj8Wdk37EDQEAAAAAACy8k+3K3tjBwyrEDS8LuBaAgAAAAAAFEnQMG9TBAxrZwKHAAAAAAAA8yRomK8pA4Y1gUMAAAAAAIAZSu1MQwAAAAAAAGBiMg0BAAAAAACgcIKGAAAAAAAAUDhBQwAAAAAAACicoCEAAAAAAAAUTtAQAAAAAAAACidoCAAAAAAAAIUTNAQAAAAAAIDCCRoCAAAAAABA4f6V0tf/v/7v/7OqquoygY8Cvfx//+//c+IKAgAAAAAAuUgqaFhV1aKqquMEPgcAAAAAAAAUQ3lSAAAAAAAAKJygIQAAAAAAABRO0BAAAAAAAAAKJ2gIAAAAAAAAhRM0BAAAAAAAgMIJGgIAAAAAAEDhBA0BAAAAAACgcIKGAAAAAAAAUDhBQwAAAAAAACicoCEAAAAAAAAUTtAQAAAAAAAACidoCAAAAAAAAIUTNAQAAAAAAIDCCRoCAAAAAABA4QQNAQAAAAAAoHCChgAAAAAAAFA4QUMAAAAAAAAonKAhAAAAAAAAFE7QEAAAAAAAAAonaAgAAAAAAACFEzQEAAAAAACAwgkaAgAAAAAAQOEEDQEAAAAAAKBwgoYAAAAAAABQOEFDAAAAAAAAKJygIQAAAAAAABRO0BAAAAAAAAAKJ2gIAAAAAAAAhRM0BAAAAAAAgML9K7Gv/1RV1acEPgcAAAAAAAAU4x9fvnxxtwEAAAAAAKBgypMCAAAAAABA4QQNAQAAAAAAoHCChgAAAAAAAFA4QUMAAAAAAAAonKAhAAAAAAAAFE7QEAAAAAAAAAonaAgAAAAAAACFEzQEAAAAAACAwgkaAgAAAAAAQOEEDQEAAAAAAKBwgoYAAAAAAABQOEFDAAAAAAAAKJygIQAAAAAAABRO0BAAAAAAAAAKJ2gIAAAAAAAAhRM0BAAAAAAAgMIJGgIAAAAAAEDhBA0BAAAAAACgcIKGAAAAAAAAUDhBQwAAAAAAACicoCEAAAAAAAAUTtAQAAAAAAAACidoCAAAAAAAAIUTNAQAAAAAAIDCCRoCAAAAAABA4QQNAQAAAAAAoHCChgAAAAAAAFA4QUMAAAAAAAAonKAhAAAAAAAAFE7QEAAAAAAAAAonaAgAAAAAAACFEzQEAAAAAACAwgkaAgAAAAAAQOEEDQEAAAAAAKBkVVX9/zGTU3uarYbMAAAAAElFTkSuQmCC';

        // -- shared PDF helpers --

        function pdfHeader(doc, title, jobRef) {
            const pageW = doc.internal.pageSize.getWidth();

            // 3mm orange accent strip at very top
            doc.setFillColor(...SW_ORANGE);
            doc.rect(0, 0, pageW, 3, 'F');

            // 23mm dark blue band below accent
            doc.setFillColor(...SW_DARK);
            doc.rect(0, 3, pageW, 23, 'F');

            // White logo + "Group" text on dark blue band
            try {
                var logoH = 11, logoW = 62;
                var logoY = 3 + (23 - logoH) / 2;
                doc.addImage(SW_LOGO_WHITE, 'PNG', 14, logoY, logoW, logoH);
                // Add "Group" text to match SecureWorks Group branding
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(11);
                doc.setTextColor(255, 255, 255);
                doc.text('Group', 14 + logoW + 1.5, logoY + logoH - 2.5, { charSpace: 0.3 });
            } catch(e) {
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(16);
                doc.setTextColor(255, 255, 255);
                doc.text('SecureWorks', 14, 17);
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(11);
                doc.text('Group', 62, 17, { charSpace: 0.3 });
            }

            // Job ref + date â€” right aligned, white on dark blue
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(255, 255, 255);
            doc.text(jobRef, pageW - 14, 14, { align: 'right' });
            doc.setFontSize(8);
            doc.setFont('helvetica', 'normal');
            doc.text(todayStr(), pageW - 14, 20, { align: 'right' });

            // Title below band â€” 14pt bold SW_DARK + short orange accent rule
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text(title, 14, 36);
            doc.setDrawColor(...SW_ORANGE);
            doc.setLineWidth(0.8);
            doc.line(14, 39, 44, 39);
            doc.setLineWidth(0.2);

            return 45;
        }

        function pdfFooter(doc) {
            const pageW = doc.internal.pageSize.getWidth();
            const pageH = doc.internal.pageSize.getHeight();
            // Subtle rule line
            doc.setDrawColor(...SW_RULE);
            doc.setLineWidth(0.4);
            doc.line(14, pageH - 16, pageW - 14, pageH - 16);
            doc.setLineWidth(0.2);

            // Company info line â€” SW_MID, 7.5pt, centered
            doc.setFontSize(7.5);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...SW_MID);
            const sp = getSalesperson();
            const footerParts = ['SecureWorks Group', 'ABN: 64 689 223 416', 'Phone: 0489 267 774'];
            if (sp && sp !== 'Other') footerParts.push('Sales: ' + sp);
            doc.text(footerParts.join('  |  '), pageW / 2, pageH - 11, { align: 'center' });
            // Page number line left blank â€” filled by pdfPageNumbers() second pass
        }

        function pdfPageNumbers(doc, jobRef) {
            const totalPages = doc.internal.getNumberOfPages();
            const pageW = doc.internal.pageSize.getWidth();
            const pageH = doc.internal.pageSize.getHeight();
            for (var i = 1; i <= totalPages; i++) {
                doc.setPage(i);
                doc.setFontSize(7);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(...SW_MUTED);
                doc.text('Page ' + i + ' of ' + totalPages + '  |  ' + jobRef, pageW / 2, pageH - 6, { align: 'center' });
            }
        }

        // â”€â”€ Universal document info card â”€â”€
        function pdfInfoCard(doc, y, fields) {
            // fields = array of [label, value] pairs
            const startX = 14, cardW = 182;
            const cols = 2;
            const colW = (cardW - 8) / cols;
            const rowH = 6;
            const rows = Math.ceil(fields.length / cols);
            const cardH = rows * rowH + 6;

            // SW_LIGHT background card with 2mm rounded corners
            doc.setFillColor(...SW_LIGHT);
            doc.roundedRect(startX, y, cardW, cardH, 2, 2, 'F');

            // 2mm orange left accent strip
            doc.setFillColor(...SW_ORANGE);
            doc.rect(startX, y + 2, 2, cardH - 4, 'F');

            // 2-column grid of label/value pairs
            var fy = y + 5;
            fields.forEach(function(f, i) {
                var col = i % cols;
                var row = Math.floor(i / cols);
                var fx = startX + 6 + col * colW;
                var ffy = y + 5 + row * rowH;

                // Label â€” 7.5pt SW_MID
                doc.setFontSize(7.5);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(...SW_MID);
                doc.text(f[0], fx, ffy);

                // Value â€” 9pt bold SW_DARK
                doc.setFontSize(9);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text(String(f[1] || 'â€”'), fx + 26, ffy);
            });

            return y + cardH + 4;
        }

        // â”€â”€ Section title hierarchy â”€â”€
        function pdfSectionL1(doc, y, title) {
            // Major sections â€” SW_DARK bar, 8mm, orange left accent, white text 11pt
            var pageH = doc.internal.pageSize.getHeight();
            if (y + 12 > pageH - 22) { pdfFooter(doc); doc.addPage(); y = 20; }
            doc.setFillColor(...SW_DARK);
            doc.rect(14, y, 182, 8, 'F');
            doc.setFillColor(...SW_ORANGE);
            doc.rect(14, y, 2, 8, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(11);
            doc.setTextColor(255, 255, 255);
            doc.text(title, 19, y + 5.8);
            return y + 10;
        }

        function pdfSectionL2(doc, y, title) {
            // Sub-sections â€” 9pt bold SW_DARK + short orange underline rule
            var pageH = doc.internal.pageSize.getHeight();
            if (y + 10 > pageH - 22) { pdfFooter(doc); doc.addPage(); y = 20; }
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text(title, 14, y + 4);
            doc.setDrawColor(...SW_ORANGE);
            doc.setLineWidth(0.6);
            var tw = doc.getTextWidth(title);
            doc.line(14, y + 6, 14 + Math.min(tw, 40), y + 6);
            doc.setLineWidth(0.2);
            return y + 9;
        }

        function pdfSectionL3(doc, y, title) {
            // Group labels â€” 8pt bold SW_MID uppercase, no decoration
            doc.setFontSize(8);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_MID);
            doc.text(title.toUpperCase(), 14, y + 3);
            return y + 6;
        }

        // â”€â”€ Note/warning callout box â”€â”€
        function pdfCallout(doc, y, text) {
            var pageH = doc.internal.pageSize.getHeight();
            var lines = doc.splitTextToSize(text, 168);
            var boxH = lines.length * 3.8 + 5;
            if (y + boxH > pageH - 22) { pdfFooter(doc); doc.addPage(); y = 20; }
            // Light orange-tinted background
            doc.setFillColor(253, 240, 236);
            doc.rect(14, y, 182, boxH, 'F');
            // 2.5mm orange left border
            doc.setFillColor(...SW_ORANGE);
            doc.rect(14, y, 2.5, boxH, 'F');
            // Text
            doc.setFontSize(8);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...SW_DARK);
            doc.text(lines, 20, y + 4);
            return y + boxH + 3;
        }

        // â”€â”€ Authorisation sign-off block for purchase orders â”€â”€
        function pdfAuthBlock(doc, y) {
            var pageH = doc.internal.pageSize.getHeight();
            if (y + 20 > pageH - 22) { pdfFooter(doc); doc.addPage(); y = 20; }
            y += 4;
            doc.setDrawColor(...SW_RULE);
            doc.setLineWidth(0.4);
            doc.line(14, y, 196, y);
            doc.setLineWidth(0.2);
            y += 6;
            doc.setFontSize(8);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...SW_BODY);
            doc.text('Ordered by: ___________________________   Date: ______________   Signature: __________________________', 14, y);
            return y + 8;
        }

        // Table helper â€” open header, 7.5mm rows, header repeat on page break
        function pdfTable(doc, y, headers, rows, colWidths, opts) {
            opts = opts || {};
            const startX = opts.startX || 14;
            const rowH = opts.rowH || 7.5;
            const fontSize = opts.fontSize || 9;
            const totalW = colWidths.reduce((a, b) => a + b, 0);
            const pageH = doc.internal.pageSize.getHeight();

            function drawHeader(yy) {
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(fontSize - 1.5);
                doc.setTextColor(...SW_MID);
                var cx = startX;
                headers.forEach(function(h, i) {
                    var align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                    var tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                    doc.text(h.toUpperCase(), tx, yy + rowH - 2, { align: align });
                    cx += colWidths[i];
                });
                doc.setDrawColor(...SW_MID);
                doc.setLineWidth(0.5);
                doc.line(startX, yy + rowH - 0.5, startX + totalW, yy + rowH - 0.5);
                doc.setLineWidth(0.2);
                return yy + rowH;
            }

            y = drawHeader(y);

            doc.setFontSize(fontSize);
            rows.forEach(function(row, ri) {
                if (y + rowH > pageH - 22) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                    y = drawHeader(y);
                }
                if (ri > 0) {
                    doc.setDrawColor(...SW_RULE);
                    doc.setLineWidth(0.15);
                    doc.line(startX, y, startX + totalW, y);
                    doc.setLineWidth(0.2);
                }
                var isBold = row._bold;
                doc.setFont('helvetica', isBold ? 'bold' : 'normal');
                doc.setTextColor(...(isBold ? SW_DARK : SW_BODY));
                var cx = startX;
                row.forEach(function(cell, i) {
                    var align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                    var tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                    doc.text(String(cell), tx, y + rowH - 2, { align: align });
                    cx += colWidths[i];
                });
                y += rowH;
            });

            doc.setDrawColor(...SW_MID);
            doc.setLineWidth(0.3);
            doc.line(startX, y, startX + totalW, y);
            doc.setLineWidth(0.2);

            return y + 2;
        }

        function getMaterialRows() {
            const rows = [];
            const els = document.querySelectorAll('#matList .mat-row');
            els.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length >= 2) {
                    const desc = row.dataset.desc || spans[0].textContent.trim();
                    const qty = parseInt(spans[1].textContent.trim().replace('Ã—', '')) || 1;
                    const length = getItemLength(desc);
                    rows.push({ desc, qty, length });
                }
            });
            return rows;
        }


        // -- Improved render capture --

        function captureQuoteRenders() {
            if (!asmRend || !asmScene || !asmCam || !asmControls) return { hero: null, side: null, underside: null };
            var renders = {};
            var origPos = asmCam.position.clone();
            var origTarget = asmControls.target.clone();
            var origFov = asmCam.fov;

            // Compute bounding box of patio + house for framing
            var box = new THREE.Box3();
            if (steelGrp) box.expandByObject(steelGrp);
            if (roofGrp) box.expandByObject(roofGrp);
            if (accGrp) box.expandByObject(accGrp);
            if (houseGrp && houseGrp.visible && houseGrp.children.length) box.expandByObject(houseGrp);
            var center = new THREE.Vector3();
            var size = new THREE.Vector3();
            box.getCenter(center);
            box.getSize(size);
            if (size.length() === 0) { size.set(6, 3, 4); center.set(0, 1.5, 0); }

            // Patio-only bounding for tighter framing on detail shots
            var patioBox = new THREE.Box3();
            if (steelGrp) patioBox.expandByObject(steelGrp);
            if (roofGrp) patioBox.expandByObject(roofGrp);
            if (accGrp) patioBox.expandByObject(accGrp);
            var patioCenter = new THREE.Vector3();
            var patioSize = new THREE.Vector3();
            patioBox.getCenter(patioCenter);
            patioBox.getSize(patioSize);
            if (patioSize.length() === 0) { patioCenter.copy(center); patioSize.copy(size); }

            var maxDim = Math.max(size.x, size.z);
            var houseVisible = houseGrp ? houseGrp.visible : false;

            function captureAngle(camPos, lookTarget, fov) {
                if (fov) { asmCam.fov = fov; asmCam.updateProjectionMatrix(); }
                asmCam.position.copy(camPos);
                asmControls.target.copy(lookTarget);
                asmControls.update();
                asmRend.render(asmScene, asmCam);
                return asmRend.domElement.toDataURL('image/png');
            }

            try {
                // Hero shot: front-right 3/4 angle â€” slightly lower eye level for a more
                // architectural feel, tighter FOV for less distortion, look at patio centre
                var heroTarget = new THREE.Vector3(
                    (center.x + patioCenter.x) / 2,
                    patioCenter.y * 0.6,  // look slightly below centre for grounded feel
                    (center.z + patioCenter.z) / 2
                );
                renders.hero = captureAngle(
                    new THREE.Vector3(
                        patioCenter.x + maxDim * 1.1,
                        patioCenter.y + size.y * 0.55,
                        patioCenter.z + maxDim * 1.2
                    ),
                    heroTarget,
                    42 // tighter FOV â€” less wide-angle distortion, more architectural
                );

                // Side view: front-left 3/4 at eye height â€” shows the patio from
                // a person's perspective standing in the yard
                var sideTarget = new THREE.Vector3(
                    patioCenter.x,
                    patioCenter.y * 0.5,
                    patioCenter.z
                );
                renders.side = captureAngle(
                    new THREE.Vector3(
                        patioCenter.x - maxDim * 0.8,
                        patioCenter.y + size.y * 0.35,
                        patioCenter.z + maxDim * 1.4
                    ),
                    sideTarget,
                    45
                );

                // Underside/entertaining view: from underneath looking outward â€”
                // shows the ceiling and entertaining space
                var underTarget = new THREE.Vector3(
                    patioCenter.x + patioSize.x * 0.2,
                    patioCenter.y * 0.4,
                    patioCenter.z + patioSize.z * 0.3
                );
                renders.underside = captureAngle(
                    new THREE.Vector3(
                        patioCenter.x - patioSize.x * 0.3,
                        patioCenter.y + size.y * 0.15,
                        patioCenter.z - patioSize.z * 0.1
                    ),
                    underTarget,
                    55 // wider for the underside feel
                );
            } catch(e) { /* render failed */ }

            // Restore camera
            asmCam.fov = origFov;
            asmCam.updateProjectionMatrix();
            asmCam.position.copy(origPos);
            asmControls.target.copy(origTarget);
            asmControls.update();
            asmRend.render(asmScene, asmCam);
            if (houseGrp) houseGrp.visible = houseVisible;

            return renders;
        }

        // ==================== PDF 1: QUOTE (Client) ====================
        function generateQuotePDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const ps = pricingState;
            const pFmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            const c = calc;
            const pageW = 210, pageH = 297;
            const margin = 14;
            const contentW = pageW - margin * 2;

            function ensureSpace(needed) {
                if (y + needed > pageH - 22) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
            }

            // PAGE 1 - HERO / VISUAL IMPACT PAGE

            let y = pdfHeader(doc, 'Quote', jobRef);

            const clientName = getClientName();
            const clientPhone = getClientPhone();
            const clientEmail = getClientEmail();
            const siteAddr = getSiteAddress();

            // Client info card
            var quoteFields = [
                ['Prepared For', clientName],
                ['Site Address', siteAddr || '\u2014'],
                ['Phone', clientPhone || '\u2014'],
                ['Email', clientEmail || '\u2014'],
                ['Date', todayStr()],
                ['Valid For', '30 days']
            ];
            y = pdfInfoCard(doc, y, quoteFields);
            y += 2;

            // -- YOUR NEW PATIO --
            y = pdfSectionL2(doc, y, 'YOUR NEW PATIO');

            // 3D Renders â€” architectural presentation layout
            var renders = captureQuoteRenders();
            var heroImg = renders.hero || capture3DImage();

            if (heroImg) {
                try {
                    // Hero render â€” full width, generous aspect
                    var heroW = contentW;
                    var heroH = heroW * 0.52;
                    ensureSpace(heroH + 8);

                    // Subtle shadow effect behind hero
                    doc.setFillColor(220, 222, 226);
                    doc.roundedRect(margin + 0.5, y + 0.5, heroW, heroH, 2.5, 2.5, 'F');
                    // Image card
                    doc.setFillColor(245, 245, 247);
                    doc.roundedRect(margin - 0.5, y - 0.5, heroW + 1, heroH + 1, 2.5, 2.5, 'F');
                    doc.addImage(heroImg, 'PNG', margin, y, heroW, heroH);
                    // Thin border for definition
                    doc.setDrawColor(210, 215, 220);
                    doc.setLineWidth(0.2);
                    doc.roundedRect(margin, y, heroW, heroH, 2, 2, 'S');
                    y += heroH + 3;

                    // Two smaller views side by side with matching treatment
                    var smallW = (contentW - 5) / 2;
                    var smallH = smallW * 0.52;
                    ensureSpace(smallH + 4);

                    if (renders.side) {
                        doc.setFillColor(220, 222, 226);
                        doc.roundedRect(margin + 0.5, y + 0.5, smallW, smallH, 2, 2, 'F');
                        doc.setFillColor(245, 245, 247);
                        doc.roundedRect(margin - 0.5, y - 0.5, smallW + 1, smallH + 1, 2, 2, 'F');
                        doc.addImage(renders.side, 'PNG', margin, y, smallW, smallH);
                        doc.setDrawColor(210, 215, 220);
                        doc.setLineWidth(0.2);
                        doc.roundedRect(margin, y, smallW, smallH, 1.5, 1.5, 'S');
                    }
                    if (renders.underside) {
                        var rx = margin + smallW + 5;
                        doc.setFillColor(220, 222, 226);
                        doc.roundedRect(rx + 0.5, y + 0.5, smallW, smallH, 2, 2, 'F');
                        doc.setFillColor(245, 245, 247);
                        doc.roundedRect(rx - 0.5, y - 0.5, smallW + 1, smallH + 1, 2, 2, 'F');
                        doc.addImage(renders.underside, 'PNG', rx, y, smallW, smallH);
                        doc.setDrawColor(210, 215, 220);
                        doc.setLineWidth(0.2);
                        doc.roundedRect(rx, y, smallW, smallH, 1.5, 1.5, 'S');
                    }
                    if (renders.side || renders.underside) y += smallH + 4;
                } catch(e) { /* skip images on error */ }
            }

            // Page 1 footer
            pdfFooter(doc);

            // PAGE 2 - SPECS / INVESTMENT

            doc.addPage();
            y = pdfHeader(doc, 'Quote', jobRef);

            // -- SPECIFICATIONS --
            // Background panel for specs section
            var Lm = c.lenInput ? (c.lenInput / 1000).toFixed(1) : '?';
            var Wm = c.projInput ? (c.projInput / 1000).toFixed(1) : '?';
            var area = c.lenInput && c.projInput ? ((c.lenInput / 1000) * (c.projInput / 1000)).toFixed(0) : '?';
            var roofStyle = c.roofStyle === 'hip' ? 'Hip roof patio' : (c.isGable ? 'Gable roof patio' : 'Skillion roof patio');
            var roofMat = roofingLabel(c.roofing || 'trimdek');
            var isSolarSpan = c.roofing && c.roofing.indexOf('solarspan') >= 0;
            var qPostFix2 = (document.getElementById('inPostFix')?.value || 'concrete');
            var qIsConc = qPostFix2 === 'concrete';
            var qTotalPosts = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
            var qGutterLabel = (c.houseGutter === 'box') ? 'Box gutter' : 'Quad gutter';

            var specs = [
                ['Dimensions', Lm + 'm \u00D7 ' + Wm + 'm (' + area + 'm\u00B2)'],
                ['Style', roofStyle],
                ['Roofing', roofMat + ' \u2013 ' + sheetColor.name],
            ];
            if (isSolarSpan) specs.push(['Ceiling Finish', 'Smooth white']);
            specs.push(['Frame Colour', steelColor.name + ' (powdercoated steel)']);
            specs.push(['Posts', (c.framePost ? c.framePost.name : '90\u00D790 SHS') + ' \u00D7 ' + qTotalPosts]);
            specs.push(['Attachment', connectionLabel(c.connection || 'fascia')]);
            specs.push(['Guttering', qGutterLabel + ' \u2013 ' + flashingColor.name]);
            var qDpCount = c.dpCount || 2;
            specs.push(['Downpipes', qDpCount + '\u00D7 95\u00D745mm \u2013 ' + flashingColor.name]);
            specs.push(['Footings', qIsConc ? 'Concrete in-ground (450\u00D7450\u00D7600mm)' : 'Baseplate fixings (dynabolt)']);

            // Section heading
            y = pdfSectionL2(doc, y, 'SPECIFICATIONS');

            // Specs in a subtle card
            var specCardH = specs.length * 6 + 4;
            doc.setFillColor(248, 248, 250);
            doc.roundedRect(margin, y - 2, contentW, specCardH, 1.5, 1.5, 'F');

            doc.setFontSize(9);
            specs.forEach(function(s) {
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_MID);
                doc.text(s[0], margin + 4, y + 2);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(50, 50, 50);
                doc.text(s[1], margin + 48, y + 2);
                y += 6;
            });
            y += 8;

            // -- WHAT'S INCLUDED --
            ensureSpace(55);
            y = pdfSectionL2(doc, y, "WHAT'S INCLUDED");

            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(50, 50, 50);

            // Build job-specific inclusions from actual config
            var qc = calc;
            var qL = (qc.L / 1000).toFixed(1);
            var qW = (qc.W / 1000).toFixed(1);
            var qStyle = qc.isGable ? 'Gable' : (document.getElementById('inRoofStyle').value === 'hip' ? 'Hip' : 'Skillion');
            var qRoofLabel = roofingLabel(document.getElementById('inRoofing').value);
            var qSheetClr = sheetColor.name;
            var qSteelClr = steelColor.name;
            var qPostCount = qc.connection === 'freestanding' ? qc.nPosts * 2 : qc.nPosts;
            var qPostFix = (document.getElementById('inPostFix')?.value === 'concrete') ? 'concrete footings' : 'baseplate fixings';

            var inclusions = [
                qL + 'm \u00D7 ' + qW + 'm ' + qStyle + ' patio',
                qRoofLabel + ' roofing in ' + qSheetClr,
                qPostCount + ' powdercoated steel posts (' + qSteelClr + ') with ' + qPostFix,
                ((qc.houseGutter === 'box') ? 'Box gutter' : 'Quad gutter') + ' and ' + (qc.dpCount || 2) + ' downpipe' + ((qc.dpCount || 2) !== 1 ? 's' : '') + ' in ' + qSteelClr,
                'All flashings colour-matched',
                'Professional installation',
                'Site cleanup on completion',
                '10-year structural warranty'
            ];
            var hasPermit = extrasRows.some(function(r) { return r.type === 'permit' || (r.desc && r.desc.toLowerCase().indexOf('permit') >= 0); });
            var hasDemo = extrasRows.some(function(r) { return r.type === 'demo' || (r.desc && r.desc.toLowerCase().indexOf('demo') >= 0); });
            var hasElectrical = extrasRows.some(function(r) { return r.type === 'electrical' || (r.desc && r.desc.toLowerCase().indexOf('electr') >= 0); });
            if (hasPermit) inclusions.push('Council permit application');
            if (hasElectrical) inclusions.push('Electrical work as specified');
            if (hasDemo) inclusions.push('Removal of existing structure');

            inclusions.forEach(function(item) {
                // Orange tick instead of plain check
                doc.setTextColor(...SW_ORANGE);
                doc.setFont('helvetica', 'bold');
                doc.text('\u2713', margin + 3, y);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(50, 50, 50);
                doc.text(item, margin + 10, y);
                y += 5;
            });

            // Quote note
            var quoteNote = (document.getElementById('noteQuote') || {}).value;
            if (quoteNote && quoteNote.trim()) {
                y += 3;
                doc.setFontSize(9);
                doc.setFont('helvetica', 'italic');
                doc.setTextColor(90, 90, 90);
                var noteLines = doc.splitTextToSize(quoteNote.trim(), contentW - 10);
                ensureSpace(noteLines.length * 4 + 4);
                doc.text(noteLines, margin + 4, y);
                y += noteLines.length * 4 + 2;
            }
            y += 8;

            // -- INVESTMENT --
            ensureSpace(60);

            // Dark blue panel for investment - high visual weight
            var investBoxY = y;
            doc.setFillColor(...SW_DARK);
            doc.roundedRect(margin, investBoxY, contentW, 28, 2, 2, 'F');

            var totalSell = ps.totalSell || 0;
            var gst = ps.gst || 0;
            var totalIncGST = ps.totalIncGST || 0;

            // "Your Investment" label - white on dark
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(255, 255, 255);
            doc.text('Your Investment', margin + 8, investBoxY + 12);

            // Price - large, orange on dark
            doc.setFontSize(20);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_ORANGE);
            doc.text(pFmt(totalIncGST), pageW - margin - 8, investBoxY + 14, { align: 'right' });

            // GST note
            doc.setFontSize(8);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(180, 190, 200);
            doc.text('(includes GST)', pageW - margin - 8, investBoxY + 22, { align: 'right' });

            y = investBoxY + 34;

            // -- PAYMENT SCHEDULE --
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('PAYMENT SCHEDULE', margin, y);
            y += 7;

            doc.setFontSize(9);
            var dep20 = totalIncGST * 0.20;
            var mid50 = totalIncGST * 0.50;
            var bal30 = totalIncGST * 0.30;

            var payRows = [
                ['20%', 'Deposit to confirm date & booking (+ planning fee if applicable)', pFmt(dep20)],
                ['50%', 'Due 25 days prior to job start (material ordering)', pFmt(mid50)],
                ['30%', 'Balance on completion', pFmt(bal30)]
            ];
            payRows.forEach(function(pr, i) {
                if (i % 2 === 0) {
                    doc.setFillColor(248, 248, 250);
                    doc.rect(margin, y - 3, contentW, 7, 'F');
                }
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_ORANGE);
                doc.text(pr[0], margin + 4, y);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(60, 60, 60);
                doc.text(pr[1], margin + 20, y);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text(pr[2], pageW - margin, y, { align: 'right' });
                y += 7;
            });

            // Payment note
            doc.setFontSize(7);
            doc.setFont('helvetica', 'italic');
            doc.setTextColor(140, 140, 140);
            doc.text('Payments can be made via bank transfer, credit card, or BPAY. Details provided on invoice.', margin + 4, y + 1);
            y += 10;

            // -- ACCEPTANCE --
            ensureSpace(30);
            doc.setDrawColor(200, 200, 200);
            doc.line(margin, y, pageW - margin, y);
            y += 6;
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('ACCEPTANCE', margin, y);
            y += 6;
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(70, 70, 70);
            var accLines = doc.splitTextToSize(
                'By paying the deposit or providing written confirmation (email, text message, or signed copy), ' +
                'you accept this quote and agree to the Terms & Conditions outlined below. All works will be ' +
                'carried out in accordance with the National Construction Code (NCC) and applicable Australian Standards.',
                contentW - 4
            );
            doc.text(accLines, margin + 2, y);
            y += accLines.length * 4.5 + 8;

            // -- TERMS & CONDITIONS --
            ensureSpace(80);
            // Section header with accent line
            doc.setDrawColor(...SW_ORANGE);
            doc.setLineWidth(0.6);
            doc.line(margin, y, margin + 30, y);
            y += 4;
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('TERMS & CONDITIONS', margin, y);
            y += 6;

            var tcSections = [
                { title: 'QUOTATION', items: [
                    'This quote is valid for 30 days from the date of issue. Pricing is subject to change after this period due to material cost fluctuations.',
                    'This quote is based on the scope of works described above. Any additional works, site conditions not visible at time of quoting, or client-requested changes will be quoted separately as a variation.',
                    'All prices include GST unless otherwise stated.'
                ]},
                { title: 'PAYMENT', items: [
                    '20% deposit is required to confirm your booking date and secure scheduling. A planning/permit fee may also apply if council approval is required (quoted separately if applicable).',
                    'An additional 50% of the total is due 25 days prior to the confirmed job start date. This allows sufficient time for material ordering, fabrication, and delivery coordination.',
                    'The remaining 30% balance is due upon satisfactory completion of all works. We will conduct a final walkthrough with you to ensure you are completely happy before requesting final payment.',
                    'Failure to make progress payments within the agreed timeframes may result in delays to your project start date.'
                ]},
                { title: 'SCOPE OF WORKS', items: [
                    'All structural steel is powder-coated Colorbond steel, engineered to Australian Standards (AS/NZS 1170 & AS 4100) and the National Construction Code (NCC).',
                    'Footings are designed to meet or exceed local engineering requirements for wind region N2 (standard suburban). Coastal or exposed sites (N3+) may require upgraded footings at additional cost.',
                    'Electrical work (downlights, fans, GPOs), plumbing, and any trade work outside of patio construction is excluded unless specifically listed in the scope above.',
                    'Where existing structures (gutters, fascia, roofing) are modified as part of the connection, we take all reasonable care. Minor cosmetic touch-ups to existing surfaces are included; however, pre-existing defects or deterioration are not our responsibility.',
                    'Clean-up of the work area and removal of construction waste is included as standard.'
                ]},
                { title: 'CONSTRUCTION & ACCESS', items: [
                    'The client is responsible for ensuring clear and safe access to the work area for personnel, vehicles, and material deliveries. Any access restrictions must be communicated prior to the job start.',
                    'We require a minimum clear working zone of 1.5 metres around the build area. Temporary relocation of garden furniture, pot plants, or other items is the client\u2019s responsibility unless otherwise arranged.',
                    'Construction timelines provided are estimates and may be affected by weather, material availability, or unforeseen site conditions. We will keep you informed of any changes.',
                    'Standard construction hours are Monday\u2013Friday 7:00am\u20133:30pm, in accordance with local council noise regulations.'
                ]},
                { title: 'WARRANTY & QUALITY', items: [
                    'All workmanship is backed by our 10-year structural warranty covering the steel frame, connections, and footings.',
                    'Roofing materials carry the manufacturer\u2019s warranty (BlueScope Colorbond: up to 36 years; Bondor SolarSpan: 15 years) subject to their terms and conditions.',
                    'Powder coating is warranted against peeling, cracking, or flaking for 10 years under normal conditions. Minor surface scratches from construction are touched up on completion.',
                    'Our warranty does not cover damage caused by third parties, unauthorised modifications, extreme weather events beyond design parameters, or lack of reasonable maintenance.'
                ]},
                { title: 'GENERAL', items: [
                    'All works are designed and constructed in compliance with the National Construction Code (NCC), Australian Standards (AS/NZS 1170, AS 4100), and relevant WA building regulations.',
                    'SecureWorks WA Pty Ltd (ABN 64 689 223 416) is fully licensed and insured for structural patio and outdoor construction in Western Australia.',
                    'We maintain public liability insurance and workers\u2019 compensation coverage for all personnel on site.',
                    'Payment of the deposit or written confirmation (email, SMS, or signed copy) constitutes acceptance of this quote and these Terms & Conditions in full.',
                    'Any dispute will be resolved in good faith through direct communication. If unresolved, mediation under WA consumer protection laws will apply.',
                    'The client confirms they are the property owner or have authority to authorise works, and that any required body corporate, strata, or HOA approvals have been obtained prior to commencement.'
                ]}
            ];

            doc.setFontSize(6.5);
            tcSections.forEach(function(sec) {
                ensureSpace(12);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_MID);
                doc.text(sec.title, margin + 2, y);
                y += 3.5;
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(110, 110, 110);
                sec.items.forEach(function(item) {
                    ensureSpace(8);
                    // Wrap long lines
                    var lines = doc.splitTextToSize(item, contentW - 8);
                    doc.setTextColor(170, 170, 170);
                    doc.text('\u2022', margin + 3, y);
                    doc.setTextColor(110, 110, 110);
                    doc.text(lines, margin + 7, y);
                    y += lines.length * 3;
                });
                y += 2;
            });

            // Footer
            pdfFooter(doc);
            pdfPageNumbers(doc, jobRef);
            doc.save('Quote_' + safeName(clientName) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Quote PDF: ' + e.message); console.error(e); }
        }

        // ==================== EMAIL QUOTE ====================

        async function emailQuotePDF() {
            if (!navigator.canShare) {
                showToast('Sharing not supported on this device â€” downloading PDF instead', 'error');
                generateQuotePDF();
                return;
            }
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }

            try {
                updatePricing();
                const { jsPDF } = window.jspdf;
                const clientName = getClientName();
                const jobRef = getJobRef();

                // Intercept doc.save to capture the PDF document
                const origSave = jsPDF.prototype.save;
                let capturedDoc = null;
                jsPDF.prototype.save = function() { capturedDoc = this; };
                generateQuotePDF();
                jsPDF.prototype.save = origSave;

                if (!capturedDoc) {
                    showToast('Could not generate PDF for sharing', 'error');
                    return;
                }

                const pdfBlob = capturedDoc.output('blob');
                const fileName = 'Quote_' + safeName(clientName) + '_' + jobRef + '.pdf';
                const file = new File([pdfBlob], fileName, { type: 'application/pdf' });

                if (!navigator.canShare({ files: [file] })) {
                    showToast('File sharing not supported â€” downloading PDF instead', 'error');
                    capturedDoc.save(fileName);
                    return;
                }

                // Pre-filled email content
                var roofStyle = calc.isGable ? 'gable' : (calc.roofStyle === 'hip' ? 'hip' : 'skillion');
                var Lm = calc.lenInput ? (calc.lenInput / 1000).toFixed(1) : '?';
                var Wm = calc.projInput ? (calc.projInput / 1000).toFixed(1) : '?';
                var firstName = (clientName !== 'Client') ? clientName.split(' ')[0] : '';

                const subject = 'SecureWorks WA \u2014 Your Patio Quote' + (jobRef ? ' \u2014 ' + jobRef : '');
                const body = 'Hi ' + firstName + ',\n\n'
                    + 'Thank you for the opportunity to quote on your new patio.\n\n'
                    + 'Please find your quote attached for the ' + Lm + 'm \u00d7 ' + Wm + 'm ' + roofStyle + ' patio at your property.\n\n'
                    + 'The quote is valid for 30 days and includes full supply and installation as detailed in the document.\n\n'
                    + 'If you have any questions or would like to discuss, please don\'t hesitate to get in touch.\n\n'
                    + 'Kind regards';

                await navigator.share({
                    title: subject,
                    text: body,
                    files: [file]
                });

                showToast('Quote shared successfully');
            } catch(e) {
                if (e.name === 'AbortError') return; // user cancelled share
                console.error('Share error:', e);
                showToast('Share failed â€” downloading PDF instead', 'error');
                generateQuotePDF();
            }
        }

        // ==================== PDF 2: SUPPLIER ORDERS (Steel / Sheets & Flashings / Fabrication) ====================

        // pdfDeliveryBlock removed â€” replaced by pdfInfoCard

        // Categorise a single material row into supplier groups
        function classifyMaterial(desc) {
            const d = desc.toLowerCase();
            if (/dogleg|fabricat/.test(d)) return 'fabrication';
            if (/riser.?elbow|riser.?shs/i.test(d)) return 'steel';
            if (/sheet|panel|gutter|downpipe|flashing|barge|ridge|channel|foam|infill|stop.?end|outlet/.test(d)) return 'sheets';
            if (/post|beam|rafter|purlin|batten|strut|bracket|joiner|cap|truss/.test(d)) return 'steel';
            return 'steel'; // default structural items to steel
        }

        // Build categorised material rows for supplier orders
        function buildSupplierRows() {
            const mats = getMaterialRows();
            const c = calc;
            const trussName = c.steel ? c.steel.name : '76\u00D738\u00D71.6';
            const beamLabel = c.frameBeam ? c.frameBeam.name : '100Ã—50Ã—2 RHS';
            const postLabel = c.framePost ? c.framePost.name : '90Ã—90Ã—2 SHS';
            const colour = steelColor.name;
            const sheetColour = sheetColor.name;

            const groups = { steel: [], sheets: [], fabrication: [] };

            const nestPlan = c.steelNestingPlan || [];
            mats.forEach(m => {
                const d = m.desc.toLowerCase();
                const lengthM = (m.length).toFixed(2) + 'm';
                const isSheetItem = /sheet|panel|gutter|downpipe|flashing|barge|ridge/.test(d);
                const col = isSheetItem ? sheetColour : colour;
                const group = classifyMaterial(m.desc);

                let size = '';
                if (group === 'steel') {
                    if (d.includes('batten')) size = '76\u00D738\u00D71.6 RHS';
                    else if (d.includes('bracket')) size = '\u2014';
                    else if (d.includes('post') || d.includes('strut') || d.includes('elbow')) size = postLabel;
                    else if (d.includes('beam')) size = beamLabel;
                    else size = trussName;
                } else if (d.includes('sheet') || d.includes('panel')) {
                    size = roofingLabel(c.roofing);
                }

                // Add nesting note for steel items
                let note = '';
                if (group === 'steel') {
                    var entry = null;
                    if (d.includes('post')) entry = nestPlan.find(function(p){return p.label==='Posts';});
                    else if (d.includes('flyover beam')) entry = nestPlan.find(function(p){return p.label==='Flyover Beam';});
                    else if (d.includes('flyover post') || d.includes('flyover strut')) entry = nestPlan.find(function(p){return p.label==='Flyover Posts'||p.label==='Flyover Struts';});
                    else if (d.includes('riser beam')) entry = nestPlan.find(function(p){return p.label==='Riser Beam';});
                    else if (d.includes('welded l')) entry = nestPlan.find(function(p){return p.label==='Risers (Welded L)';});
                    else if (d.includes('beam')) entry = nestPlan.find(function(p){return p.label==='Beams';});
                    else if (d.includes('truss')) entry = nestPlan.find(function(p){return p.label==='Trusses';});
                    else if (d.includes('rafter')) entry = nestPlan.find(function(p){return p.label==='Rafters';});
                    else if (d.includes('batten') || d.includes('purlin')) entry = nestPlan.find(function(p){return p.label==='Battens'||p.label==='Purlins';});
                    if (entry && entry.nesting) {
                        var n = entry.nesting;
                        if (n.specialOrder) {
                            note = 'SPECIAL ORDER';
                        } else {
                            note = 'ORDER: ' + n.totalSticks + '\u00D7 ' + (n.stockLength / 1000).toFixed(1) + 'm';
                        }
                    }
                }

                const row = [m.desc, size, lengthM, String(m.qty), col, note];
                groups[group].push(row);
            });

            return groups;
        }

        // â”€â”€ PDF 2a: STEEL & STRUCTURAL ORDER â”€â”€
        function generateSteelOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'PURCHASE ORDER \u2014 Steel & Structural', jobRef);

            // PO info card
            y = pdfInfoCard(doc, y, [
                ['Supplier', '____________________'],
                ['PO Number', jobRef],
                ['Deliver To', getSiteAddress() || '____________________'],
                ['Required By', '____________________'],
                ['Site Contact', getClientName() + (getClientPhone() ? '  |  ' + getClientPhone() : '')],
                ['Order Date', todayStr()]
            ]);

            const groups = buildSupplierRows();
            const rows = groups.steel;
            const nestPlan = calc.steelNestingPlan || buildSteelNestingPlan();

            if (rows.length === 0) {
                doc.setFontSize(10);
                doc.setTextColor(...SW_MUTED);
                doc.text('No steel / structural items for this job.', 14, y);
            } else {
                const subCats = {
                    'Posts': [],
                    'Beams': [],
                    'Trusses': [],
                    'Battens & Purlins': [],
                    'Brackets & Fixings': []
                };
                rows.forEach(function(row) {
                    const d = row[0].toLowerCase();
                    if (d.includes('post')) subCats['Posts'].push(row);
                    else if (d.includes('beam') || d.includes('fascia')) subCats['Beams'].push(row);
                    else if (d.includes('truss')) subCats['Trusses'].push(row);
                    else if (d.includes('purlin') || d.includes('batten') || d.includes('rafter') || d.includes('strut')) subCats['Battens & Purlins'].push(row);
                    else subCats['Brackets & Fixings'].push(row);
                });

                const colWidths = [10, 44, 34, 22, 14, 28, 30];
                const tableHeaders = ['No.', 'Item', 'Size', 'Cut Length', 'Qty', 'Colour', 'Notes'];
                let lineNum = 0;
                let totalItems = 0;

                Object.entries(subCats).forEach(function(entry) {
                    var cat = entry[0], catRows = entry[1];
                    if (catRows.length === 0) return;
                    y = pdfSectionL2(doc, y, cat);
                    var numberedRows = catRows.map(function(row) {
                        lineNum++;
                        return [String(lineNum), row[0], row[1], row[2], row[3], row[4], row[5]];
                    });
                    y = pdfTable(doc, y, tableHeaders, numberedRows, colWidths, { leftAlignAll: true });
                    y += 2;
                    totalItems += catRows.length;
                });

                y += 2;
                doc.setFontSize(9);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text('Total line items: ' + totalItems, 14, y);
                y += 6;

                if (nestPlan.length > 0) {
                    y = pdfSectionL1(doc, y, 'STOCK ORDER SUMMARY');

                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(...SW_MID);
                    doc.text('ITEM', 14, y);
                    doc.text('SIZE', 44, y);
                    doc.text('CUT', 86, y);
                    doc.text('QTY', 106, y);
                    doc.text('ORDER', 120, y);
                    doc.text('NESTING', 150, y);
                    y += 4;
                    doc.setDrawColor(...SW_RULE);
                    doc.line(14, y - 1, 196, y - 1);

                    var grandTotalSticks = 0;
                    nestPlan.forEach(function(p) {
                        if (y + 6 > doc.internal.pageSize.getHeight() - 22) {
                            pdfFooter(doc); doc.addPage(); y = 20;
                        }
                        var n = p.nesting;
                        grandTotalSticks += n.totalSticks;
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(8);
                        doc.setTextColor(...SW_DARK);
                        doc.text(p.label, 14, y);
                        doc.setFont('helvetica', 'normal');
                        doc.text(p.sizeName, 44, y);
                        doc.text(p.cutMm + 'mm', 86, y);
                        doc.text(String(p.qty), 106, y);
                        if (n.specialOrder) {
                            doc.setTextColor(200, 0, 0);
                            doc.setFont('helvetica', 'bold');
                            doc.text('SPECIAL ORDER', 120, y);
                        } else {
                            doc.text(n.totalSticks + '\u00D7 ' + (n.stockLength / 1000).toFixed(1) + 'm', 120, y);
                            doc.setFontSize(7);
                            doc.setTextColor(...SW_MUTED);
                            if (n.piecesPerStick > 1) {
                                doc.text(n.piecesPerStick + ' pcs/stick, ' + Math.round(n.totalWaste) + 'mm waste', 150, y);
                            } else {
                                doc.text(Math.round(n.totalWaste) + 'mm waste', 150, y);
                            }
                        }
                        y += 5;
                    });

                    doc.setDrawColor(...SW_DARK);
                    doc.line(14, y, 196, y);
                    y += 4;
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(9);
                    doc.setTextColor(...SW_DARK);
                    doc.text('TOTAL: ' + grandTotalSticks + ' sticks to order', 14, y);
                    y += 4;
                }
            }

            var realAdditionalMats = additionalMaterials.filter(function(am) { return am.desc && am.desc.trim() && am.desc.trim() !== 'Item'; });
            if (realAdditionalMats.length > 0) {
                y += 4;
                var addText = realAdditionalMats.map(function(am) { return am.qty + '\u00D7  ' + am.desc; }).join('\n');
                y = pdfCallout(doc, y, 'ADDITIONAL MATERIALS:\n' + addText);
            }

            var matOrderNote = (document.getElementById('noteMaterialOrder') || {}).value;
            if (matOrderNote && matOrderNote.trim()) {
                y += 2;
                y = pdfCallout(doc, y, 'ORDER NOTES: ' + matOrderNote.trim());
            }

            y = pdfAuthBlock(doc, y);
            pdfFooter(doc);
            pdfPageNumbers(doc, jobRef);
            doc.save('SteelOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Steel Order PDF: ' + e.message); console.error(e); }
        }

        // â”€â”€ PDF 2b: SHEET METAL & FLASHINGS ORDER â”€â”€
        function generateSheetsOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'PURCHASE ORDER \u2014 Sheets & Flashings', jobRef);

            // PO info card
            y = pdfInfoCard(doc, y, [
                ['Supplier', '____________________'],
                ['PO Number', jobRef],
                ['Deliver To', getSiteAddress() || '____________________'],
                ['Required By', '____________________'],
                ['Site Contact', getClientName() + (getClientPhone() ? '  |  ' + getClientPhone() : '')],
                ['Order Date', todayStr()]
            ]);

            const groups = buildSupplierRows();
            const rows = groups.sheets;

            if (rows.length === 0) {
                doc.setFontSize(10);
                doc.setTextColor(...SW_MUTED);
                doc.text('No sheet metal / flashing items for this job.', 14, y);
            } else {
                const subCats = {
                    'Roofing Sheets / Panels': [],
                    'Gutters & Downpipes': [],
                    'Flashings': [],
                    'Accessories': []
                };
                rows.forEach(function(row) {
                    const d = row[0].toLowerCase();
                    if (d.includes('sheet') || d.includes('panel')) subCats['Roofing Sheets / Panels'].push(row);
                    else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow')) subCats['Gutters & Downpipes'].push(row);
                    else if (d.includes('flashing') || d.includes('barge') || d.includes('ridge') || d.includes('channel')) subCats['Flashings'].push(row);
                    else subCats['Accessories'].push(row);
                });

                const colWidths = [10, 44, 34, 22, 14, 28, 30];
                const tableHeaders = ['No.', 'Item', 'Product', 'Length', 'Qty', 'Colour', 'Notes'];
                let lineNum = 0;
                let totalItems = 0;

                Object.entries(subCats).forEach(function(entry) {
                    var cat = entry[0], catRows = entry[1];
                    if (catRows.length === 0) return;
                    y = pdfSectionL2(doc, y, cat);
                    var numberedRows = catRows.map(function(row) {
                        lineNum++;
                        return [String(lineNum), row[0], row[1], row[2], row[3], row[4], row[5]];
                    });
                    y = pdfTable(doc, y, tableHeaders, numberedRows, colWidths, { leftAlignAll: true });
                    y += 2;
                    totalItems += catRows.length;
                });

                // Flashing profiles section
                if (flashingProfiles.length > 0) {
                    y += 4;
                    y = pdfSectionL1(doc, y, 'FLASHING PROFILES');

                    flashingProfiles.forEach(function(fp) {
                        var blockH = 45;
                        if (y + blockH > doc.internal.pageSize.getHeight() - 25) {
                            pdfFooter(doc); doc.addPage(); y = 20;
                        }
                        // Name & specs
                        doc.setFontSize(9);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(...SW_DARK);
                        doc.text(fp.name, 14, y);
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(7);
                        doc.setTextColor(...SW_MUTED);
                        var orderLen = fp.length + 500;
                        var profDims = flashProfileDimString(fp.points);
                        var csLabel = flashColourSideLabel(fp.colourSide);
                        doc.text('Profile: ' + profDims + '  |  Girth: ' + fp.girth + 'mm  |  Qty: ' + fp.qty, 14, y + 4);
                        doc.text('Colour: ' + fp.colour + ' \u2014 ' + csLabel.toUpperCase() + ' FACE  |  Gauge: ' + fp.gauge + 'mm  |  Length: ' + orderLen + 'mm (order)', 14, y + 8);
                        var non90 = flashNon90Angles(fp.points);
                        if (non90.length > 0) {
                            var angStr = non90.map(function(a) { return a.angle + '\u00B0 at point ' + a.point; }).join(', ');
                            doc.text('Non-90\u00B0 angles: ' + angStr, 14, y + 12);
                            y += 4;
                        }
                        y += 11;

                        // Draw profile in PDF
                        if (fp.points && fp.points.length >= 2) {
                            var pdfBoxW = 60, pdfBoxH = 28;
                            var bx = 14;
                            doc.setDrawColor(...SW_RULE);
                            doc.setLineWidth(0.2);
                            doc.rect(bx, y, pdfBoxW, pdfBoxH);

                            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                            fp.points.forEach(function(pt) { if(pt.x<minX)minX=pt.x;if(pt.x>maxX)maxX=pt.x;if(pt.y<minY)minY=pt.y;if(pt.y>maxY)maxY=pt.y; });
                            var rX = maxX - minX || 1, rY = maxY - minY || 1;
                            var sc = Math.min((pdfBoxW - 6) / rX, (pdfBoxH - 6) / rY);
                            var ox = bx + (pdfBoxW - rX * sc) / 2;
                            var oy = y + (pdfBoxH - rY * sc) / 2;

                            // Main profile line
                            doc.setDrawColor(41, 60, 70);
                            doc.setLineWidth(0.5);
                            for (var pi = 0; pi < fp.points.length - 1; pi++) {
                                var pa = fp.points[pi], pb = fp.points[pi+1];
                                doc.line(ox + (pa.x - minX)*sc, oy + (maxY - pa.y)*sc, ox + (pb.x - minX)*sc, oy + (maxY - pb.y)*sc);
                            }

                            // Thick colour side edge (offset toward colour side)
                            var fpCsDir = (fp.colourSide === 'inside' || fp.colourSide === 'top') ? -1 : 1;
                            var fpCsHex = COLORBOND_COLOURS[fp.colour] || [241, 90, 41];
                            var fpCsRgb = (typeof fpCsHex === 'string') ? [parseInt(fpCsHex.slice(1,3),16), parseInt(fpCsHex.slice(3,5),16), parseInt(fpCsHex.slice(5,7),16)] : fpCsHex;
                            doc.setDrawColor(fpCsRgb[0], fpCsRgb[1], fpCsRgb[2]);
                            doc.setLineWidth(1.2);
                            for (var ci = 0; ci < fp.points.length - 1; ci++) {
                                var ca = fp.points[ci], cb = fp.points[ci+1];
                                var cdx = cb.x - ca.x, cdy = cb.y - ca.y;
                                var cLen = Math.sqrt(cdx*cdx + cdy*cdy);
                                if (cLen === 0) continue;
                                var cOff = 1.0; // mm offset in PDF coords
                                var cnx = (-cdy / cLen) * fpCsDir * cOff * sc;
                                var cny = (cdx / cLen) * fpCsDir * cOff * sc;
                                var cx1 = ox + (ca.x - minX)*sc + cnx;
                                var cy1 = oy + (maxY - ca.y)*sc - cny;
                                var cx2 = ox + (cb.x - minX)*sc + cnx;
                                var cy2 = oy + (maxY - cb.y)*sc - cny;
                                doc.line(cx1, cy1, cx2, cy2);
                            }

                            // Colour side "C" label at profile midpoint
                            var fpMidI = Math.floor(fp.points.length / 2);
                            var fpMa = fp.points[fpMidI > 0 ? fpMidI - 1 : 0];
                            var fpMb = fp.points[Math.min(fpMidI, fp.points.length - 1)];
                            var fpMmx = ox + (((fpMa.x + fpMb.x)/2 - minX) * sc);
                            var fpMmy = oy + ((maxY - (fpMa.y + fpMb.y)/2) * sc);
                            var fpMdx = fpMb.x - fpMa.x, fpMdy = fpMb.y - fpMa.y;
                            var fpMl = Math.sqrt(fpMdx*fpMdx + fpMdy*fpMdy) || 1;
                            var fpLnx = (-fpMdy / fpMl) * fpCsDir * 4;
                            var fpLny = (fpMdx / fpMl) * fpCsDir * 4;
                            doc.setFontSize(5);
                            doc.setFont('helvetica', 'bold');
                            doc.setTextColor(fpCsRgb[0], fpCsRgb[1], fpCsRgb[2]);
                            doc.text('C', fpMmx + fpLnx, fpMmy - fpLny + 1.5);

                            // Dimension labels on each leg
                            doc.setFontSize(5);
                            doc.setFont('helvetica', 'normal');
                            doc.setTextColor(...SW_BODY);
                            for (var li = 0; li < fp.points.length - 1; li++) {
                                var la = fp.points[li], lb = fp.points[li+1];
                                var ldx = lb.x - la.x, ldy = lb.y - la.y;
                                var llen = Math.round(Math.sqrt(ldx*ldx + ldy*ldy));
                                var lmx = ox + ((la.x + lb.x)/2 - minX)*sc;
                                var lmy = oy + (maxY - (la.y + lb.y)/2)*sc;
                                doc.text(llen + '', lmx + 1, lmy - 1);
                            }

                            y += pdfBoxH + 3;
                        }
                        y += 3;
                    });
                } else {
                    // Fallback: blank sketch boxes
                    if (y + 55 > doc.internal.pageSize.getHeight() - 22) {
                        pdfFooter(doc); doc.addPage(); y = 20;
                    }
                    y += 4;
                    y = pdfSectionL2(doc, y, 'Flashing Sketches');
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(...SW_MUTED);
                    doc.text('Sketch flashing profiles below \u2014 hand draw dimensions and bends', 14, y);
                    y += 5;
                    var boxW = 42, boxH = 32, gap = 4;
                    var labels = ['Back Flashing', 'Barge Flashing L', 'Barge Flashing R', 'Other'];
                    labels.forEach(function(label, i) {
                        var bx2 = 14 + i * (boxW + gap);
                        doc.setDrawColor(...SW_RULE);
                        doc.setLineWidth(0.3);
                        doc.rect(bx2, y, boxW, boxH);
                        doc.setFontSize(7);
                        doc.setTextColor(...SW_MUTED);
                        doc.text(label, bx2 + boxW / 2, y + boxH + 4, { align: 'center' });
                    });
                    y += boxH + 8;
                }

                // Section subtotal
                doc.setFontSize(9);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_DARK);
                doc.text('Total line items: ' + totalItems, 14, y);
            }

            // Material order note
            var matOrderNote2 = (document.getElementById('noteMaterialOrder') || {}).value;
            if (matOrderNote2 && matOrderNote2.trim()) {
                y += 4;
                y = pdfCallout(doc, y, 'ORDER NOTES: ' + matOrderNote2.trim());
            }

            y = pdfAuthBlock(doc, y);
            pdfFooter(doc);
            pdfPageNumbers(doc, jobRef);
            doc.save('SheetsOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Sheets Order PDF: ' + e.message); console.error(e); }
        }

        // â”€â”€ PDF 2c: FABRICATION ORDER â”€â”€
        function generateFabricationOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const c = calc;
            let y = pdfHeader(doc, 'PURCHASE ORDER \u2014 Fabrication', jobRef);

            // PO info card
            y = pdfInfoCard(doc, y, [
                ['Supplier', 'CMI / JBS Patios Malaga'],
                ['PO Number', jobRef],
                ['Deliver To', getSiteAddress() || '____________________'],
                ['Required By', '____________________'],
                ['Site Contact', getClientName() + (getClientPhone() ? '  |  ' + getClientPhone() : '')],
                ['Order Date', todayStr()]
            ]);

            const groups = buildSupplierRows();
            const fabMatRows = groups.fabrication;

            // If gable with truss data, show detailed truss info (reuse exportTrussPDF style)
            if (c.isGable && c.trussData) {
                const td = c.trussData;

                // Truss image
                const img = captureTrussImage();
                if (img) {
                    try {
                        doc.addImage(img, 'PNG', 14, y, 110, 55);
                        y += 58;
                    } catch(e) { /* skip */ }
                }

                const lx = 14;
                const rw = 178;
                const lh = 5.5;

                function fabRow(label, value, bold) {
                    if (y + lh > doc.internal.pageSize.getHeight() - 22) {
                        pdfFooter(doc);
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFont('helvetica', bold ? 'bold' : 'normal');
                    doc.setFontSize(10);
                    doc.setTextColor(...SW_DARK);
                    doc.text(label, lx + 4, y);
                    doc.text(String(value), lx + rw - 4, y, { align: 'right' });
                    y += lh;
                }

                y = pdfSectionL1(doc, y,'TRUSS STEEL');
                fabRow('Profile', td.steelName + ' RHS');
                fabRow('Colour', td.clr);
                fabRow('BMT', td.bmt + 'mm');
                fabRow('Quantity', td.nTruss + ' trusses');
                y += 2;

                y = pdfSectionL1(doc, y,'TRUSS DIMENSIONS');
                fabRow('Span', td.trussSpan + 'mm');
                fabRow('Height', td.rise + 'mm');
                fabRow('Pitch', td.pitch.toFixed(1) + '\u00B0');
                if (td.overhang > 0) fabRow('Overhang', td.overhang + 'mm');
                if (td.extender && td.extender.enabled) {
                    fabRow('Extender', td.extender.length + 'mm (each end)');
                }
                y += 2;

                y = pdfSectionL1(doc, y,'CUT LIST (per truss)');
                fabRow('Chord', '1 \u00D7 ' + td.chordCut + 'mm', true);
                if (td.extender && td.extender.enabled) {
                    fabRow('Extender', '2 \u00D7 ' + Math.round(td.extender.length) + 'mm');
                }
                fabRow('Rafters', '2 \u00D7 ' + td.rafterCut + 'mm', true);
                if (td.webMembers && td.webMembers.length > 0) {
                    for (var wi = 0; wi < td.webMembers.length; wi++) {
                        var wm = td.webMembers[wi];
                        fabRow(wm.type, wm.count + ' \u00D7 ' + wm.length + 'mm');
                    }
                }
                y += 2;

                y = pdfSectionL1(doc, y,'CUT ANGLES');
                fabRow('Apex Mitre', td.apexAngle.toFixed(1) + '\u00B0 (both rafters)');
                fabRow('Heel Mitre', td.heelAngle.toFixed(1) + '\u00B0 (rafter to chord)');
                y += 2;

                y = pdfSectionL1(doc, y,'MATERIAL REQUIRED');
                fabRow('Truss LM (each)', td.totalLM.toFixed(3) + ' LM');
                fabRow('All ' + td.nTruss + ' trusses', td.totalAllLM.toFixed(2) + ' LM', true);
                fabRow('Order length', td.totalSticks + ' \u00D7 6m sticks', true);

                // Risers (separate steel)
                if (td.riserLeft && td.riserLeft.enabled) {
                    y += 2;
                    y = pdfSectionL1(doc, y,'RISERS (separate steel \u2013 bolted to truss ends)');
                    fabRow('Left Riser', Math.round(td.riserLeft.length) + 'mm horiz + ' + Math.round(td.riserLeft.height) + 'mm vert');
                    fabRow('Right Riser', Math.round(td.riserRight.length) + 'mm horiz + ' + Math.round(td.riserRight.height) + 'mm vert');
                    fabRow('Riser steel (per pair)', (td.riserLeft.lm + td.riserRight.lm).toFixed(2) + ' LM');
                    fabRow('Riser steel (all)', td.riserTotalLM.toFixed(2) + ' LM (' + td.nTruss + ' sets)', true);
                }
                y += 4;
            }

            // Any other fabrication material rows (custom items etc.)
            if (fabMatRows.length > 0) {
                y = pdfSectionL2(doc, y, 'Other Fabricated Items');
                const colWidths = [50, 36, 22, 16, 30, 28];
                const tableHeaders = ['Item', 'Size', 'Length', 'Qty', 'Colour', 'Notes'];
                y = pdfTable(doc, y, tableHeaders, fabMatRows, colWidths, { leftAlignAll: true });
            }

            if (!c.isGable && fabMatRows.length === 0) {
                doc.setFontSize(10);
                doc.setTextColor(...SW_MUTED);
                doc.text('No fabrication items for this job (skillion roof \u2013 no trusses).', 14, y);
            }

            y = pdfAuthBlock(doc, y);
            pdfFooter(doc);
            pdfPageNumbers(doc, jobRef);
            doc.save('FabOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Fabrication Order PDF: ' + e.message); console.error(e); }
        }

        // Legacy wrapper - keep for any external calls
        function generateMaterialsOrderPDF() {
            generateSteelOrderPDF();
        }

        // ==================== PDF 3: WORK ORDER (Crew) ====================
        async function generateWorkOrderPDF() {
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            if (!calc || !calc.W) { alert('Configure patio first before generating work order.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const c = calc;
            const pageW = 210, pageH = 297;
            const mx = 14, mr = 196;
            const cw = mr - mx;

            // â”€â”€ Helpers â”€â”€
            const mm = v => Math.round(v) + 'mm';
            const styleLabel = c.roofStyle === 'hip' ? 'HIP' : (c.isGable ? 'GABLE' : 'SKILLION');
            const roofLbl = roofingLabel(c.roofing);
            const sheetClr = sheetColor.name;
            const steelClr = steelColor.name;
            const Lmm = c.lenInput, Wmm = c.projInput;
            const Lm = Lmm / 1000, Wm = Wmm / 1000;
            const postHmm = c.postH;
            const actualPostH = c.connection === 'freestanding' ? Math.round(c.postH) : Math.round(c.frontBeamY);
            const frontBeamH = Math.round(c.frontBeamY);
            const backBeamH = Math.round(c.backBeamY);
            const ridgeH = Math.round(c.frontBeamY + c.rise);
            const nPosts = c.nPosts;
            const nTruss = c.nTruss;
            const postFix = (document.getElementById('inPostFix')?.value || 'concrete');
            const isConc = postFix === 'concrete';
            const postCut = isConc ? actualPostH + 300 : actualPostH;
            const postSpacing = Math.round(Lmm / (nPosts - 1));
            const trussSpacing = c.nTruss > 1 ? Math.round(Lmm / (c.nTruss - 1)) : Lmm;
            const diagonal = Math.round(Math.sqrt(Lmm * Lmm + Wmm * Wmm));
            const cosP = Math.cos(c.pitchRad);
            const sheetLen = c.isGable ? Math.round((Wmm / 2) / cosP + 50) : Math.round(Wmm / cosP + 50);
            const infill = c.infill || 'none';
            const electricalVal = document.getElementById('electrical')?.value || 'none';
            const hasElectrical = electricalVal !== 'none';
            const downlights = (electricalVal === 'downlights' || electricalVal === 'both') ? 4 : 0;
            const beamName = c.frameBeam ? c.frameBeam.name : '100\u00D750\u00D72 RHS';
            const postName = c.framePost ? c.framePost.name : '90\u00D790\u00D72 SHS';
            const totalPosts = c.connection === 'freestanding' ? nPosts * 2 : nPosts;
            const sheetsPerSide = c.sheetCalc ? c.sheetCalc.totalSheets : Math.ceil(Lmm / (c.sheetCoverage || 762));
            const totalSheets = c.isGable ? sheetsPerSide * 2 : sheetsPerSide;
            const woNotes = (document.getElementById('noteWorkOrder')?.value || '').trim();
            const riserQty = c.riserQty || parseInt(document.getElementById('inRiserQty')?.value) || Math.max(2, Math.ceil(Lmm / 1200));
            const riserSpacing = riserQty > 1 ? Math.round(Lmm / (riserQty - 1)) : 0;
            var hasDemoScope = extrasRows.some(function(er) { return (er.desc || '').toLowerCase().includes('demo'); });

            function woSectionTitle(title, yp) {
                return pdfSectionL1(doc, yp, title);
            }
            function woCheckRow(text, yp, nestNote) {
                doc.setDrawColor(...SW_MID);
                doc.setLineWidth(0.3);
                doc.rect(mx + 1, yp - 2.8, 4, 4);
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(8);
                doc.setTextColor(50, 50, 50);
                var lines = doc.splitTextToSize(text, cw - 10);
                doc.text(lines, mx + 7.5, yp);
                var rowH = lines.length * 3.8 + 1;
                // Nesting note on same line, right-aligned in muted colour
                if (nestNote) {
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(7);
                    doc.setTextColor(...SW_MUTED);
                    doc.text(nestNote, mr - 2, yp, { align: 'right' });
                }
                return yp + rowH;
            }
            function ensureSpace(needed) {
                if (y + needed > pageH - 22) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
            }
            function addImageSafe(imgData, x, yi, w, h) {
                if (!imgData) return;
                try { doc.addImage(imgData, 'PNG', x, yi, w, h); } catch(e) { /* skip */ }
            }

            // â”€â”€ Capture 3D views â”€â”€
            var views = null;
            try { views = await exportWorkOrderViews(); } catch(e) { console.warn('Could not capture 3D views:', e); }
            if (!views) views = window._workOrderViews || {};

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 1: MATERIALS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let y = pdfHeader(doc, 'WORK ORDER \u2014 Materials', jobRef);

            // Job header â€” compact one-liner
            var cName = getClientName(), cAddr = getSiteAddress(), cPhone = getClientPhone();
            y = pdfInfoCard(doc, y, [
                ['Client', cName],
                ['Site', cAddr || '\u2014'],
                ['Phone', cPhone || '\u2014'],
                ['Job Ref', jobRef]
            ]);

            // Job summary line â€” keep as orange quick-reference
            doc.setFont('helvetica', 'bold'); doc.setFontSize(10); doc.setTextColor(...SW_ORANGE);
            doc.text(styleLabel + ' PATIO  ' + Lm.toFixed(1) + 'm \u00D7 ' + Wm.toFixed(1) + 'm  |  ' + roofLbl + ' \u2014 ' + sheetClr + '  |  Steel \u2014 ' + steelClr, mx, y);
            y += 3;
            doc.setDrawColor(...SW_ORANGE); doc.setLineWidth(0.5); doc.line(mx, y, mr, y); doc.setLineWidth(0.2);
            y += 5;

            // Notes if present
            if (woNotes) {
                y = pdfCallout(doc, y, '\u26A0 ' + woNotes);
            }

            // MATERIALS CHECKLIST
            doc.setFont('helvetica', 'bold'); doc.setFontSize(8); doc.setTextColor(...SW_ORANGE);
            doc.text('CHECK OFF ON ARRIVAL', mx, y); y += 5;

            const mats = getMaterialRows();
            var matGroups = { 'STEEL': [], 'ROOFING': [], 'GUTTERS & DRAINAGE': [], 'FLASHINGS': [], 'OTHER': [] };
            mats.forEach(function(m) {
                var d = m.desc.toLowerCase();
                if (d.includes('post') || d.includes('beam') || d.includes('truss') || d.includes('purlin') || d.includes('rafter') || d.includes('riser') || d.includes('bracket') || d.includes('strut') || d.includes('batten'))
                    matGroups['STEEL'].push(m);
                else if (d.includes('sheet') || d.includes('ridge') || d.includes('solarspan') || d.includes('spanplus') || d.includes('trimdek') || d.includes('corrugat'))
                    matGroups['ROOFING'].push(m);
                else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow') || d.includes('dp '))
                    matGroups['GUTTERS & DRAINAGE'].push(m);
                else matGroups['OTHER'].push(m);
            });
            if (flashingProfiles.length > 0) {
                flashingProfiles.forEach(function(fp) {
                    matGroups['FLASHINGS'].push({ desc: fp.name + ' \u2014 ' + fp.girth + 'mm girth \u00D7 ' + mm(fp.length) + ' (' + fp.colour + ')', qty: fp.qty, length: fp.length / 1000 });
                });
            }
            var woNestPlan = c.steelNestingPlan || [];
            Object.entries(matGroups).forEach(function(entry) {
                var cat = entry[0], items = entry[1];
                if (!items.length) return;
                if (y + 8 > pageH - 22) { pdfFooter(doc); doc.addPage(); y = 20; }
                y = pdfSectionL3(doc, y, cat);
                items.forEach(function(m) {
                    if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                    var lenStr = m.length >= 0.1 ? Math.round(m.length * 1000) + 'mm' : '';
                    var nestNote = '';
                    if (cat === 'STEEL' && woNestPlan.length > 0) {
                        var dl = m.desc.toLowerCase(); var ne = null;
                        if (dl.includes('post')) ne = woNestPlan.find(function(p){return p.label==='Posts';});
                        else if (dl.includes('flyover beam')) ne = woNestPlan.find(function(p){return p.label==='Flyover Beam';});
                        else if (dl.includes('beam') && !dl.includes('riser')) ne = woNestPlan.find(function(p){return p.label==='Beams';});
                        else if (dl.includes('riser beam')) ne = woNestPlan.find(function(p){return p.label==='Riser Beam';});
                        else if (dl.includes('truss')) ne = woNestPlan.find(function(p){return p.label==='Trusses';});
                        else if (dl.includes('rafter')) ne = woNestPlan.find(function(p){return p.label==='Rafters';});
                        else if (dl.includes('batten') || dl.includes('purlin')) ne = woNestPlan.find(function(p){return p.label==='Battens'||p.label==='Purlins';});
                        if (ne && ne.nesting && !ne.nesting.specialOrder) { nestNote = ne.nesting.totalSticks + 'x ' + (ne.nesting.stockLength / 1000).toFixed(1) + 'm sticks'; }
                    }
                    var cutNote = '';
                    if (cat === 'ROOFING' && m.desc.toLowerCase().includes('sheet') && sheetLen) {
                        cutNote = '  (cut to ' + mm(sheetLen) + ')';
                    }
                    var mainText = m.qty + 'x  ' + m.desc + (lenStr ? '  ' + lenStr : '') + cutNote;
                    y = woCheckRow(mainText, y, nestNote || undefined);
                });
                y += 2;
            });
            // BRING FROM STOCK
            y += 2;
            ensureSpace(25);
            y = woSectionTitle('BRING FROM STOCK', y);
            ['Tek screws 14g \u00D7 50mm (1 box)', 'Dome head screws \u2014 ' + sheetClr, 'Rivets \u2014 ' + steelClr,
             'Silicone \u2014 clear + colour match', 'Foam closure strips', 'Rafter brackets'].forEach(function(si) {
                if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                y = woCheckRow(si, y);
            });
            if (isInsulated(c.roofing) && hasElectrical) y = woCheckRow('Electrical cable (as per lighting plan)', y);
            var woRealAddMats = additionalMaterials.filter(function(am) { return am.desc && am.desc.trim() && am.desc.trim() !== 'Item'; });
            if (woRealAddMats.length > 0) {
                woRealAddMats.forEach(function(am) {
                    if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                    y = woCheckRow(am.qty + '\u00D7  ' + am.desc, y);
                });
            }
            pdfFooter(doc);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 2: 3D RENDERS + KEY DIMENSIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 What To Build', jobRef);

            // Hero render â€” big, with card treatment
            if (views.hero) {
                var heroW = cw, heroH = heroW * 0.5;
                // Shadow + card
                doc.setFillColor(220, 222, 226);
                doc.roundedRect(mx + 0.5, y + 0.5, heroW, heroH, 2.5, 2.5, 'F');
                doc.setFillColor(245, 245, 247);
                doc.roundedRect(mx - 0.5, y - 0.5, heroW + 1, heroH + 1, 2.5, 2.5, 'F');
                addImageSafe(views.hero, mx, y, heroW, heroH);
                doc.setDrawColor(210, 215, 220); doc.setLineWidth(0.2);
                doc.roundedRect(mx, y, heroW, heroH, 2, 2, 'S');
                y += heroH + 3;
            }
            // Two smaller views side by side
            var hasSmall = views.frontElevation || views.sideElevation || views.sitePlan;
            if (hasSmall) {
                var smW = (cw - 5) / 2, smH = smW * 0.5;
                ensureSpace(smH + 4);
                if (views.frontElevation) {
                    doc.setFillColor(220, 222, 226);
                    doc.roundedRect(mx + 0.5, y + 0.5, smW, smH, 2, 2, 'F');
                    doc.setFillColor(245, 245, 247);
                    doc.roundedRect(mx - 0.5, y - 0.5, smW + 1, smH + 1, 2, 2, 'F');
                    addImageSafe(views.frontElevation, mx, y, smW, smH);
                    doc.setDrawColor(210, 215, 220); doc.setLineWidth(0.2);
                    doc.roundedRect(mx, y, smW, smH, 1.5, 1.5, 'S');
                }
                var smView2 = views.sideElevation || views.sitePlan;
                if (smView2) {
                    var smRx = mx + smW + 5;
                    doc.setFillColor(220, 222, 226);
                    doc.roundedRect(smRx + 0.5, y + 0.5, smW, smH, 2, 2, 'F');
                    doc.setFillColor(245, 245, 247);
                    doc.roundedRect(smRx - 0.5, y - 0.5, smW + 1, smH + 1, 2, 2, 'F');
                    addImageSafe(smView2, smRx, y, smW, smH);
                    doc.setDrawColor(210, 215, 220); doc.setLineWidth(0.2);
                    doc.roundedRect(smRx, y, smW, smH, 1.5, 1.5, 'S');
                }
                y += smH + 5;
            }

            // KEY DIMENSIONS â€” compact two-column layout
            ensureSpace(50);
            y = woSectionTitle('KEY DIMENSIONS', y);
            var dims = [
                ['Length', mm(Lmm)],
                ['Projection', mm(Wmm)],
                ['Pitch', c.pitch.toFixed(1) + '\u00B0'],
                ['Front beam', mm(frontBeamH) + ' FFL'],
                ['Back beam', mm(backBeamH) + ' FFL'],
                ['Post height', mm(actualPostH) + ' FFL'],
                ['Post cut', mm(postCut) + (isConc ? ' (inc 300 footing)' : '')],
                ['Post spacing', mm(postSpacing) + ' c/c'],
                ['Sheet cut', mm(sheetLen)],
                ['Beam', beamName],
                ['Posts', postName],
                ['Diagonal', mm(diagonal)]
            ];
            if (c.isGable) {
                dims.splice(5, 0, ['Ridge', mm(ridgeH) + ' FFL']);
                dims.push(['Truss spacing', mm(trussSpacing) + ' c/c']);
            }
            if (c.connection === 'riser') {
                dims.push(['Riser height', mm(Math.round(c.riserH || 0))]);
                dims.push(['Risers', riserQty + ' at ' + mm(riserSpacing) + ' c/c']);
            }
            // Subtle background card for dimensions
            var dimRows = Math.ceil(dims.length / 2);
            var dimCardH = dimRows * 5 + 4;
            doc.setFillColor(248, 248, 250);
            doc.roundedRect(mx, y - 2, cw, dimCardH, 1.5, 1.5, 'F');

            var colW = cw / 2 - 2;
            var labelCol1 = mx + 4;
            var valCol1 = mx + 36;
            var labelCol2 = mx + colW + 4;
            var valCol2 = mx + colW + 36;
            for (var di = 0; di < dims.length; di += 2) {
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7.5);
                doc.setTextColor(100, 100, 100);
                doc.text(dims[di][0] + ':', labelCol1, y);
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(8);
                doc.setTextColor(...SW_DARK);
                doc.text(dims[di][1], valCol1, y);
                if (di + 1 < dims.length) {
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(7.5);
                    doc.setTextColor(100, 100, 100);
                    doc.text(dims[di + 1][0] + ':', labelCol2, y);
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(8);
                    doc.setTextColor(...SW_DARK);
                    doc.text(dims[di + 1][1], valCol2, y);
                }
                y += 5;
            }
            y += 2;
            pdfFooter(doc);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAGE 3: INSTALLATION STEPS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            doc.addPage();
            y = pdfHeader(doc, 'WORK ORDER \u2014 How To Build', jobRef);

            var steps = [];

            if (hasDemoScope) {
                steps.push({ title: 'DEMO', items: ['Remove existing structure', 'Check for asbestos before cutting', 'Clear site'] });
            }

            // Steel cutting â€” simplified
            var woPlan = c.steelNestingPlan || buildSteelNestingPlan();
            if (woPlan.length > 0) {
                var cutItems = [];
                woPlan.forEach(function(p) {
                    var n = p.nesting;
                    if (n.specialOrder) { cutItems.push(p.label + ': ' + p.qty + '\u00D7 ' + p.cutMm + 'mm \u2014 SPECIAL ORDER'); return; }
                    var line = p.label + ': ' + p.qty + '\u00D7 ' + p.cutMm + 'mm from ' + n.totalSticks + '\u00D7 ' + (n.stockLength/1000).toFixed(1) + 'm';
                    if (n.piecesPerStick > 1) line += ' (' + n.piecesPerStick + '/stick)';
                    cutItems.push(line);
                });
                steps.push({ title: 'CUT STEEL', items: cutItems });
            }

            steps.push({ title: 'SET OUT', items: [
                'Front posts ' + mm(Wmm) + ' from house, ' + mm(postSpacing) + ' centres',
                'Check square: diagonal = ' + mm(diagonal),
                'Laser level all post positions'
            ]});

            if (isConc) {
                steps.push({ title: 'FOOTINGS & POSTS', items: [
                    totalPosts + '\u00D7 holes: 450\u00D7450\u00D7600mm',
                    'Set posts plumb, top at ' + mm(postHmm) + ' FFL',
                    'Pour concrete, brace, wait 24hrs min'
                ]});
            } else {
                steps.push({ title: 'BASEPLATES & POSTS', items: [
                    totalPosts + '\u00D7 baseplates, dynabolt to slab',
                    'Posts plumb, top at ' + mm(postHmm) + ' FFL'
                ]});
            }

            steps.push({ title: 'FRONT BEAM', items: [
                beamName + ' \u00D7 ' + mm(Lmm),
                'Weld all round, height ' + mm(frontBeamH) + ' FFL'
            ]});

            if (c.isAttached) {
                var backItems = [];
                if (c.connection === 'riser') {
                    backItems = [
                        riserQty + ' welded L risers at ' + mm(riserSpacing) + ' c/c to fascia',
                        'Riser beam: ' + beamName + ' at ' + mm(backBeamH) + ' FFL'
                    ];
                } else if (c.connection === 'flyover') {
                    var flyPostCount = Math.max(2, Math.ceil(Lmm / 1200));
                    var flyPostSpacing = Math.round(Lmm / (flyPostCount - 1));
                    backItems = [
                        'FLYOVER POSTS: ' + flyPostCount + '\u00D7 ' + (c.framePost ? c.framePost.name : '90\u00D790 SHS') + ' at ' + mm(flyPostSpacing) + ' centres',
                        'Post setback: ' + (c.flyoverSetback || 600) + 'mm from fascia up roof slope',
                        'Remove roof sheets at post locations',
                        'Locate house rafters \u2014 posts bolt directly to rafters',
                        'Install flashing boots around each post penetration',
                        'Seal all penetrations with silicone + lead flashing',
                        'Flyover beam: ' + (c.frameBeam ? c.frameBeam.name : '150\u00D750\u00D72 RHS') + ' \u00D7 ' + mm(Lmm),
                        'Beam height: ' + mm(backBeamH) + ' above FFL'
                    ];
                } else {
                    backItems = ['Fix to house at ' + mm(backBeamH) + ' FFL'];
                }
                steps.push({ title: 'BACK BEAM', items: backItems });
            }

            if (c.isGable) {
                steps.push({ title: 'TRUSSES', items: [
                    nTruss + '\u00D7 trusses at ' + mm(trussSpacing) + ' c/c',
                    'Ridge height ' + mm(ridgeH) + ' FFL'
                ]});
            }

            var bc = c.battenCalc;
            if (!c.isGable && bc && bc.battensNeeded > 0) {
                steps.push({ title: 'BATTENS', items: [
                    bc.battensNeeded + '\u00D7 battens at ' + mm(bc.spanDistance) + ' c/c',
                    'Cut to ' + mm(Math.round(bc.battenLength))
                ]});
            }

            var gutterLabel = (c.houseGutter === 'box') ? 'Box gutter' : 'Quad gutter';
            steps.push({ title: 'GUTTERS', items: [
                gutterLabel + ' \u2014 brackets at 600mm c/c, fall 1:500',
                (c.dpCount || 2) + '\u00D7 downpipes (1800mm nested + strap)'
            ]});

            var sheetItems = [
                totalSheets + '\u00D7 ' + roofLbl + ' cut to ' + mm(sheetLen),
                'Install from LOW side, 50mm gutter overhang'
            ];
            if (isInsulated(c.roofing)) sheetItems.push('Run cables in chase first, colour side DOWN');
            if (c.isGable) sheetItems.push('Ridge cap with foam closure');
            steps.push({ title: 'SHEETING', items: sheetItems });

            if (c.isGable && infill !== 'none') {
                steps.push({ title: 'GABLE INFILL', items: [infill.charAt(0).toUpperCase() + infill.slice(1) + ' \u2014 cut to pitch, fix to end trusses'] });
            }

            var flashItems = ['Apron flashing to house first', 'Barge flashings + fascia flashings', 'Seal all joints with silicone'];
            if (flashingProfiles.length > 0) {
                flashingProfiles.forEach(function(fp) { flashItems.push(fp.name + ' \u2014 ' + fp.girth + 'mm \u00D7 ' + fp.qty); });
            }
            steps.push({ title: 'FLASHINGS', items: flashItems });

            if (hasElectrical && downlights > 0) {
                steps.push({ title: 'ELECTRICAL', items: [downlights + '\u00D7 downlights \u2014 electrician to connect'] });
            }

            steps.push({ title: 'FINISH', items: ['Touch up paint, clean site, take photos, customer walkthrough'] });

            // Render steps â€” compact numbered list
            steps.forEach(function(step, si) {
                var needed = 9 + step.items.length * 4.5;
                if (y + needed > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                // Number badge (rounded pill)
                doc.setFillColor(...SW_ORANGE);
                doc.roundedRect(mx, y, 7.5, 6, 1.2, 1.2, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(8);
                doc.setTextColor(255, 255, 255);
                doc.text(String(si + 1), mx + 3.75, y + 4.2, { align: 'center' });
                // Title
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                doc.setTextColor(...SW_DARK);
                doc.text(step.title, mx + 11, y + 4.2);
                // Done checkbox (slightly larger, right aligned)
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.3);
                doc.rect(mr - 8, y + 0.8, 4, 4);
                y += 8;
                // Items â€” indented bullet points
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(7.5);
                doc.setTextColor(60, 60, 60);
                step.items.forEach(function(item) {
                    if (y + 5 > pageH - 25) { pdfFooter(doc); doc.addPage(); y = 20; }
                    var wrapped = doc.splitTextToSize(item, cw - 16);
                    doc.text('\u2022', mx + 11, y);
                    doc.text(wrapped, mx + 14, y);
                    y += wrapped.length * 3.8;
                });
                y += 3;
            });

            // Sign-off at bottom of last page
            y += 4;
            ensureSpace(25);
            doc.setDrawColor(...SW_RULE); doc.line(mx, y, mr, y); y += 5;
            doc.setFont('helvetica', 'normal'); doc.setFontSize(8); doc.setTextColor(...SW_BODY);
            doc.text('Installer: ___________________________   Sign: ______________   Date: __________', mx, y); y += 8;
            doc.text('Customer: ___________________________   Sign: ______________   Date: __________', mx, y);

            pdfFooter(doc);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SITE PHOTOS PAGES (if any photos captured)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (sitePhotos.length > 0) {
                var photosPerPage = 4; // 2Ã—2 grid
                var photoPages = Math.ceil(sitePhotos.length / photosPerPage);
                for (var pg = 0; pg < photoPages; pg++) {
                    doc.addPage();
                    y = pdfHeader(doc, 'WORK ORDER \u2014 Site Photos' + (photoPages > 1 ? ' (' + (pg + 1) + '/' + photoPages + ')' : ''), jobRef);

                    var startIdx = pg * photosPerPage;
                    var endIdx = Math.min(startIdx + photosPerPage, sitePhotos.length);
                    var cellW = (cw - 6) / 2;  // 2 columns with 6mm gap
                    var cellH = cellW * 0.75;   // 4:3 aspect
                    var labelH = 6;

                    for (var pi = startIdx; pi < endIdx; pi++) {
                        var photo = sitePhotos[pi];
                        var col = (pi - startIdx) % 2;
                        var row = Math.floor((pi - startIdx) / 2);
                        var px = mx + col * (cellW + 6);
                        var py = y + row * (cellH + labelH + 8);

                        // Photo card background
                        doc.setFillColor(245, 245, 247);
                        doc.roundedRect(px, py, cellW, cellH, 2, 2, 'F');

                        // Add image
                        try {
                            doc.addImage(photo.dataUrl, 'JPEG', px + 1, py + 1, cellW - 2, cellH - 2);
                        } catch(imgErr) { /* skip broken image */ }

                        // Border
                        doc.setDrawColor(210, 215, 220);
                        doc.setLineWidth(0.2);
                        doc.roundedRect(px, py, cellW, cellH, 2, 2, 'S');

                        // Label below photo
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(7);
                        doc.setTextColor(...SW_DARK);
                        doc.text((pi + 1) + '. ' + photo.label, px + 2, py + cellH + 4);
                    }

                    pdfFooter(doc);
                }
            }

            pdfPageNumbers(doc, jobRef);

            doc.save('WorkOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Work Order PDF: ' + e.message); console.error(e); }
        }

        // ==================== PDF: TRUSS ORDER ====================
        function exportTrussPDF() {
            if (!calc.isGable || !calc.trussData) {
                alert('Truss data only available for Gable roofs. Switch to Gable first.');
                return;
            }
            if (!window.jspdf) { alert('PDF library not loaded. Check internet connection and reload.'); return; }
            try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const td = calc.trussData;
            let y = pdfHeader(doc, 'Truss Fabrication Order', jobRef);

            // Info card
            y = pdfInfoCard(doc, y, [
                ['Client', getClientName()],
                ['Site', getSiteAddress() || '\u2014'],
                ['Phone', getClientPhone() || '\u2014'],
                ['Job Ref', jobRef]
            ]);

            // Truss image capture
            const img = captureTrussImage();
            if (img) {
                try {
                    doc.addImage(img, 'PNG', 14, y, 110, 55);
                    y += 58;
                } catch(e) { /* skip */ }
            }

            const lx = 14;
            const rw = 178;
            const lh = 5.5;

            function fabRow(label, value, bold) {
                if (y + lh > doc.internal.pageSize.getHeight() - 22) {
                    pdfFooter(doc); doc.addPage(); y = 20;
                }
                doc.setFont('helvetica', bold ? 'bold' : 'normal');
                doc.setFontSize(10);
                doc.setTextColor(...SW_DARK);
                doc.text(label, lx + 4, y);
                doc.text(String(value), lx + rw - 4, y, { align: 'right' });
                y += lh;
            }

            y = pdfSectionL1(doc, y, 'STEEL');
            fabRow('Profile', td.steelName + ' RHS');
            fabRow('Colour', td.clr);
            fabRow('BMT', td.bmt + 'mm');
            fabRow('Quantity', td.nTruss + ' trusses');
            y += 2;

            y = pdfSectionL1(doc, y, 'DIMENSIONS');
            fabRow('SP (Span)', td.trussSpan + 'mm');
            fabRow('HT (Height)', td.rise + 'mm');
            fabRow('Pitch', td.pitch.toFixed(1) + '\u00B0');
            if (td.overhang > 0) fabRow('Overhang', td.overhang + 'mm');
            if (td.extender && td.extender.enabled) {
                fabRow('Extender', td.extender.length + 'mm (each end)');
            }
            y += 2;

            y = pdfSectionL1(doc, y, 'CUT LIST (per truss)');
            fabRow('Chord', '1 \u00D7 ' + td.chordCut + 'mm', true);
            if (td.extender && td.extender.enabled) {
                fabRow('Extender', '2 \u00D7 ' + Math.round(td.extender.length) + 'mm');
            }
            fabRow('Rafters', '2 \u00D7 ' + td.rafterCut + 'mm', true);
            if (td.webMembers && td.webMembers.length > 0) {
                for (var wi = 0; wi < td.webMembers.length; wi++) {
                    var wm = td.webMembers[wi];
                    fabRow(wm.type, wm.count + ' \u00D7 ' + wm.length + 'mm');
                }
            }
            y += 2;

            y = pdfSectionL1(doc, y, 'CUT ANGLES');
            fabRow('Apex Mitre', td.apexAngle.toFixed(1) + '\u00B0 (both rafters)');
            fabRow('Heel Mitre', td.heelAngle.toFixed(1) + '\u00B0 (rafter to chord)');
            y += 2;

            y = pdfSectionL1(doc, y, 'MATERIAL REQUIRED');
            fabRow('Truss LM (each)', td.totalLM.toFixed(3) + ' LM');
            fabRow('All ' + td.nTruss + ' trusses', td.totalAllLM.toFixed(2) + ' LM', true);
            fabRow('Order length', td.totalSticks + ' \u00D7 6m sticks', true);

            // Risers (separate steel, bolted to truss ends)
            if (td.riserLeft && td.riserLeft.enabled) {
                y += 2;
                y = pdfSectionL1(doc, y, 'RISERS (separate steel \u2013 bolted to truss ends)');
                fabRow('Left Riser', Math.round(td.riserLeft.length) + 'mm horiz + ' + Math.round(td.riserLeft.height) + 'mm vert');
                fabRow('Right Riser', Math.round(td.riserRight.length) + 'mm horiz + ' + Math.round(td.riserRight.height) + 'mm vert');
                fabRow('Riser steel (per pair)', (td.riserLeft.lm + td.riserRight.lm).toFixed(2) + ' LM');
                fabRow('Riser steel (all)', td.riserTotalLM.toFixed(2) + ' LM (' + td.nTruss + ' sets)', true);
            }

            pdfFooter(doc);
            pdfPageNumbers(doc, jobRef);
            doc.save('TrussOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
            } catch(e) { alert('Error generating Truss Order PDF: ' + e.message); console.error(e); }
        }

        function captureTrussImage() {
            try {
                if (trussRend && trussScene && trussCam) {
                    trussRend.render(trussScene, trussCam);
                    return trussRend.domElement.toDataURL('image/png');
                }
            } catch(e) {}
            return null;
        }

        function initPricing() {
            loadRates();
            renderRatesPanel();
            buildJobRows();
            // Set default labour day rate from stored rates
            const drEl = document.getElementById('labDayRate');
            if (drEl && storedRates['Skilled Trade']) drEl.value = storedRates['Skilled Trade'];
            updatePricing();
        }

        // ==================== POST UI ====================
        function adjustPostQty(delta) {
            var el = document.getElementById('inPostQty');
            var cur = parseInt(el.value);
            if (isNaN(cur) || cur < 2) {
                cur = parseInt(document.getElementById('inPosts').value) || 3;
            }
            var next = Math.max(2, cur + delta);
            el.value = next;
            rebuildAll();
        }
        function onPostQtyChange() {
            rebuildAll();
        }
        function clearPostQtyOverride() {
            document.getElementById('inPostQty').value = '';
            rebuildAll();
        }
        function updatePostUI() {
            var c = calc;
            if (!c || !c.L) return;

            // Post size display
            document.getElementById('postSizeDisplay').textContent = c.framePost.name;

            // Calculate values
            var totalPosts = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
            var spacing = c.postSpacing;
            var postFix = document.getElementById('inPostFix')?.value || 'concrete';
            var isConc = postFix === 'concrete';
            var cutLen = isConc ? c.postH + 300 : c.postH;
            var totalLineal = (totalPosts * cutLen / 1000).toFixed(1);

            // Result display
            var sideLabel = c.connection === 'freestanding' ? ' (' + c.nPosts + ' front + ' + c.nPosts + ' back)' : ' (front beam)';
            document.getElementById('postResultTitle').textContent = totalPosts + ' post' + (totalPosts !== 1 ? 's' : '') + ' required' + sideLabel + (c.postQtyOverride ? ' (manual)' : '');
            document.getElementById('postResultSpacing').textContent = 'Spacing: ' + spacing + 'mm centres (span: ' + Math.round(c.L) + 'mm)';
            document.getElementById('postResultLineal').textContent = 'Total lineal: ' + totalLineal + 'm of ' + c.framePost.name + ' (' + cutLen + 'mm cut length' + (isConc ? ', incl. 300mm footing' : '') + ')';
            document.getElementById('postResultFootings').textContent = 'Footings: ' + totalPosts + ' Ã— ' + (isConc ? 'concrete footing' : 'baseplate');

            // Warnings
            var warnEl = document.getElementById('postWarnings');
            var warnings = [];
            if (spacing > 3000) warnings.push('Spacing exceeds 3000mm \u2014 check beam size can span this distance');
            if (spacing < 1500 && c.nPosts > 2) warnings.push('Spacing under 1500mm \u2014 consider reducing posts for a cleaner look');
            if (warnings.length > 0) {
                warnEl.innerHTML = warnings.map(function(w) {
                    return '<div style="background:#FEF9E7;border:1px solid #F39C12;border-radius:6px;padding:6px 10px;font-size:11px;color:#7D6608;margin-bottom:4px">\u26A0 ' + w + '</div>';
                }).join('');
                warnEl.style.display = 'block';
            } else {
                warnEl.style.display = 'none';
            }
        }

        // ==================== DOWNPIPE UI ====================
        var dpSelection = [];  // boolean per front post: true = downpipe here

        function updateDownpipeMap() {
            var nPosts = calc ? calc.nPosts : 3;
            // If selection length doesn't match post count, reset to defaults (edges)
            if (dpSelection.length !== nPosts) {
                dpSelection = new Array(nPosts).fill(false);
                dpSelection[0] = true;
                if (nPosts > 1) dpSelection[nPosts - 1] = true;
            }
            var container = document.getElementById('dpPostMap');
            if (!container) return;
            container.innerHTML = '';
            for (var i = 0; i < nPosts; i++) {
                if (i > 0) {
                    var line = document.createElement('div');
                    line.style.cssText = 'flex:1;height:2px;background:var(--sw-border);min-width:8px';
                    container.appendChild(line);
                }
                var dot = document.createElement('button');
                dot.type = 'button';
                dot.dataset.idx = i;
                dot.textContent = i + 1;
                dot.style.cssText = 'width:26px;height:26px;border-radius:50%;border:2px solid ' + (dpSelection[i] ? 'var(--sw-accent)' : 'var(--sw-border)') + ';background:' + (dpSelection[i] ? 'var(--sw-accent)' : '#fff') + ';cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:9px;font-weight:700;color:' + (dpSelection[i] ? '#fff' : 'var(--sw-text-sec)') + ';flex-shrink:0;padding:0;transition:all 0.15s;position:relative';
                dot.title = 'Post ' + (i + 1) + (dpSelection[i] ? ' (downpipe)' : '');
                dot.onclick = (function(idx) { return function() { toggleDp(idx); }; })(i);
                container.appendChild(dot);
            }
            var count = dpSelection.filter(Boolean).length;
            var badge = document.getElementById('dpCountBadge');
            if (badge) badge.textContent = count;
            var summary = document.getElementById('dpSummary');
            if (summary) {
                var positions = [];
                dpSelection.forEach(function(v, i) { if (v) positions.push('Post ' + (i + 1)); });
                summary.textContent = count === 0 ? 'No downpipes â€” add at least one' : positions.join(', ');
                summary.style.color = count === 0 ? '#c53030' : 'var(--sw-text-sec)';
            }
            // Sync calc object with updated selection
            if (calc) {
                calc.dpSelection = dpSelection.slice();
                calc.dpCount = count;
                calc.dpPostIndices = getDpPostIndices();
            }
        }

        function toggleDp(idx) {
            if (idx < 0 || idx >= dpSelection.length) return;
            dpSelection[idx] = !dpSelection[idx];
            updateDownpipeMap();
            getInputs();
            buildAsm3D();
            updateMatList();
            buildJobRows();
            updatePricing();
        }

        function getDpCount() {
            return dpSelection.filter(Boolean).length;
        }

        function getDpPostIndices() {
            var indices = [];
            dpSelection.forEach(function(v, i) { if (v) indices.push(i); });
            return indices;
        }

        // ==================== RAFTER UI ====================
        function setRafterSpacing(val) {
            document.getElementById('inRafterSpacing').value = val;
            document.getElementById('inRafterQtyOverride').value = '';
            rebuildAll();
        }
        function onRafterSpacingChange() {
            document.getElementById('inRafterQtyOverride').value = '';
            rebuildAll();
        }
        function onRafterQtyChange() {
            rebuildAll();
        }
        function adjustRafterQty(delta) {
            var el = document.getElementById('inRafterQtyOverride');
            var cur = parseInt(el.value);
            if (isNaN(cur) || cur < 2) {
                // Read the current calculated value from the hidden field
                cur = parseInt(document.getElementById('inRafters').value) || 5;
            }
            var next = Math.max(2, cur + delta);
            el.value = next;
            rebuildAll();
        }
        function clearRafterQtyOverride() {
            document.getElementById('inRafterQtyOverride').value = '';
            rebuildAll();
        }
        function updateRafterUI() {
            var c = calc;
            if (!c || c.isGable) return;
            var rc = c.rafterCalc;
            if (!rc) return;

            var rafterLen = Math.round(c.rafter);
            var totalLineal = (rc.rafterCount * rafterLen / 1000).toFixed(1);

            document.getElementById('rafterResultTitle').textContent = rc.rafterCount + ' rafter' + (rc.rafterCount !== 1 ? 's' : '') + ' required' + (rc.isOverride ? ' (manual)' : '');
            document.getElementById('rafterResultSpacing').textContent = 'Actual spacing: ' + rc.spacing + 'mm centres (span: ' + Math.round(c.L) + 'mm)';
            document.getElementById('rafterResultLineal').textContent = 'Total lineal: ' + totalLineal + 'm of ' + c.rafterSize.name + ' (' + rafterLen + 'mm each)';
        }

        // ==================== STRUCTURAL SIZING UI ====================
        var _structBeamQtys = { fascia: 1, gutter: 1, riser: 1 };

        function adjustStructPurlinQty(delta) {
            // Purlins use the existing extra battens mechanism
            var c = calc;
            if (!c) return;
            if (c.isGable) {
                var el = document.getElementById('gableExtraBattensVal');
                var cur = parseInt(el.textContent) || 0;
                el.textContent = Math.max(0, cur + delta);
            } else {
                var el = document.getElementById('extraBattensVal');
                var cur = parseInt(el.textContent) || 0;
                el.textContent = Math.max(0, cur + delta);
            }
            rebuildAll();
        }

        function adjustStructBeamQty(type, delta) {
            var cur = _structBeamQtys[type] || 1;
            _structBeamQtys[type] = Math.max(1, Math.min(4, cur + delta));
            var el = document.getElementById('struct' + type.charAt(0).toUpperCase() + type.slice(1) + 'BeamQty');
            if (el) el.textContent = _structBeamQtys[type];
            rebuildAll();
        }

        function adjustStructTrussQty(delta) {
            var el = document.getElementById('inTrussesOverride');
            var cur = parseInt(el.value);
            if (isNaN(cur) || cur < 2) {
                cur = parseInt(document.getElementById('inTrusses').value) || 3;
            }
            var next = Math.max(2, cur + delta);
            el.value = next;
            onTrussQtyOverride();
        }

        function onTrussQtyOverride() {
            var el = document.getElementById('inTrussesOverride');
            var trussField = document.getElementById('inTrusses');
            var val = parseInt(el.value);
            if (val >= 2) {
                trussField.value = val;
                trussField.dataset.userOverride = 'true';
            }
            rebuildAll();
        }

        function scrollToTrussSection() {
            var sec = document.getElementById('sec-truss');
            if (!sec) return;
            // Expand it if collapsed
            var body = sec.querySelector('.collapse-body');
            if (body && body.classList.contains('shut')) {
                toggleSection('sec-truss');
            }
            sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function updateStructSizing() {
            var c = calc;
            if (!c || !c.L) return;
            var isGable = c.isGable;
            var conn = c.connection || 'riser';
            var isFlyover = conn === 'flyover';
            var isRiser = conn === 'riser';
            var isFreestanding = conn === 'freestanding';

            // Row visibility
            document.getElementById('structRowPurlins').style.display = isGable ? 'none' : ''; // gable uses sec-battens purlin calculator
            document.getElementById('structRowFasciaBeam').style.display = '';
            // Relabel beam row based on connection type
            var beamLabel = document.querySelector('#structRowFasciaBeam .struct-label');
            if (beamLabel) beamLabel.textContent = isFreestanding ? 'Beams' : 'Fascia Beam';
            document.getElementById('structRowGutterBeam').style.display = isFlyover ? 'none' : '';
            document.getElementById('structRowRiserBeam').style.display = isRiser ? '' : 'none';
            document.getElementById('structRowRiserSteel').style.display = isRiser ? '' : 'none';
            document.getElementById('structRowRafters').style.display = isGable ? 'none' : '';
            document.getElementById('structRowTrusses').style.display = isGable ? '' : 'none';

            // Update purlin qty display
            var purlinQty = 0;
            if (isGable && c.gableBattenCalc) {
                purlinQty = c.gableBattenCalc.totalBattens || 0;
            } else if (c.battenCalc) {
                purlinQty = c.battenCalc.battensNeeded || 0;
            }
            document.getElementById('structPurlinQty').textContent = purlinQty || '--';

            // Update post qty display (show auto-calculated value if no override)
            var postQtyEl = document.getElementById('inPostQty');
            if (!postQtyEl.value) {
                postQtyEl.placeholder = c.nPosts;
            }

            // Update rafter qty display (show auto-calculated value if no override)
            var rafterQtyEl = document.getElementById('inRafterQtyOverride');
            if (rafterQtyEl && !rafterQtyEl.value) {
                rafterQtyEl.placeholder = c.nRafters || parseInt(document.getElementById('inRafters').value) || 5;
            }

            // Update truss qty display
            var trussOverrideEl = document.getElementById('inTrussesOverride');
            if (trussOverrideEl) {
                var trussField = document.getElementById('inTrusses');
                if (!trussOverrideEl.value && trussField) {
                    trussOverrideEl.placeholder = trussField.value;
                }
            }

            // Beam qty display
            var beamLen = Math.round(c.L);
            var fasciaQtyEl = document.getElementById('structFasciaBeamQty');
            var gutterQtyEl = document.getElementById('structGutterBeamQty');
            var riserQtyEl = document.getElementById('structRiserBeamQty');
            // Auto-set beam qty: need 2 if span > 6000mm (typical max beam length)
            var autoBeamQty = beamLen > 6000 ? 2 : 1;
            if (fasciaQtyEl && _structBeamQtys.fascia === 1 && autoBeamQty > 1) {
                _structBeamQtys.fascia = autoBeamQty;
                fasciaQtyEl.textContent = autoBeamQty;
            }
            // Gutter beam is always qty 1 (no +/- control)
            _structBeamQtys.gutter = 1;

            // Validation warnings
            updateStructSizingWarnings();
        }

        function updateStructSizingWarnings() {
            var c = calc;
            if (!c) return;
            var warnEl = document.getElementById('structSizingWarnings');
            var warnings = [];
            var spanMm = Math.round(c.W * 1000); // rafter/truss span in mm

            // Post spacing check
            var postSpacing = c.postSpacing;
            if (postSpacing > 3000) {
                warnings.push('Post spacing ' + postSpacing + 'mm exceeds 3000mm \u2014 check beam can span');
                document.getElementById('structRowPosts').classList.add('warn');
            } else {
                document.getElementById('structRowPosts').classList.remove('warn');
            }

            // Beam span check (post spacing = beam span between posts)
            var beamKey = document.getElementById('inBeamSize').value;
            var beam = FRAME_BEAMS[beamKey];
            if (beam && postSpacing > 3000) {
                var beamH = beam.h * 1000;
                if (beamH < 100 && postSpacing > 2400) {
                    warnings.push('Beam ' + beam.label + ' may be undersized for ' + (postSpacing/1000).toFixed(1) + 'm post span');
                }
            }

            if (warnings.length > 0) {
                warnEl.innerHTML = warnings.map(function(w) {
                    return '<div style="background:#FEF9E7;border:1px solid #F39C12;border-radius:6px;padding:6px 10px;font-size:10px;color:#7D6608;margin-bottom:4px">\u26A0 ' + w + '</div>';
                }).join('');
            } else {
                warnEl.innerHTML = '';
            }
        }

        // ==================== BATTEN UI ====================
        function adjustExtraBattens(delta) {
            var el = document.getElementById('extraBattensVal');
            var cur = parseInt(el.textContent) || 0;
            el.textContent = Math.max(0, cur + delta);
            rebuildAll();
        }

        function adjustGableExtraBattens(delta) {
            var el = document.getElementById('gableExtraBattensVal');
            var cur = parseInt(el.textContent) || 0;
            el.textContent = Math.max(0, cur + delta);
            rebuildAll();
        }

        function updateGableBattenUI() {
            var c = calc;
            if (!c || !c.isGable) return;
            var gb = c.gableBattenCalc;
            if (!gb) return;

            var spanTable = SPAN_TABLES[c.roofing];
            var sheetLabel = (ROOFING_TYPES[c.roofing] || {}).name || c.roofing;
            document.getElementById('gableBattenSheet').textContent = sheetLabel;
            document.getElementById('gableBattenMaxSpan').textContent = spanTable ? spanTable.maxSpan + 'mm' : 'N/A';
            document.getElementById('gableBattenRafter').textContent = Math.round(c.rafter) + 'mm';
            document.getElementById('gableBattenPitch').textContent = c.pitch.toFixed(1) + '\u00B0';

            if (gb.totalBattens === 0) {
                document.getElementById('gableBattenResultTitle').textContent = '\u2713 ' + gb.message;
                document.getElementById('gableBattenResultBreakdown').textContent = '';
                document.getElementById('gableBattenResultSpacing').textContent = '';
                document.getElementById('gableBattenResultLineal').textContent = '';
                document.getElementById('gableBattenDiagram').textContent = '';
                return;
            }

            document.getElementById('gableBattenResultTitle').textContent = gb.totalBattens + ' purlins required (' + gb.battensPerSide + ' per side)';
            document.getElementById('gableBattenResultBreakdown').textContent = 'Apex pair: 2 (straddling ridge, ' + gb.apexGap + 'mm gap)  |  End battens: 2 (at eaves)  |  Intermediate: ' + Math.max(0, gb.totalBattens - 4);
            document.getElementById('gableBattenResultSpacing').textContent = 'Spacing: ' + gb.spacing + 'mm centres along rafter (max span: ' + gb.maxSpan + 'mm)';
            var totalLineal = (gb.totalBattens * gb.battenLength / 1000).toFixed(1);
            document.getElementById('gableBattenResultLineal').textContent = 'Total lineal: ' + totalLineal + 'm of ' + c.steel.name + ' (' + gb.battenLength + 'mm each)';

            // Cross-section diagram
            var diag = '';
            var rLen = gb.rafterLength;
            var positions = gb.positionsPerSide;
            diag += '              RIDGE\n';
            diag += '               /\\\n';
            // Build left + right side indicators
            var maxW = 30;
            for (var i = positions.length - 1; i >= 0; i--) {
                var frac = positions[i] / rLen;
                var indent = Math.round((1 - frac) * maxW / 2);
                var width = maxW - indent * 2;
                var spaces = '';
                for (var s = 0; s < indent; s++) spaces += ' ';
                var label = '';
                if (i === positions.length - 1) label = '  \u2190 Apex purlins (\u00D72)';
                else if (i === 0) label = '  \u2190 End purlins (\u00D72)';
                else label = '  \u2190 ' + positions[i] + 'mm';
                diag += '  ' + spaces + '\u2550';
                for (var w = 0; w < width - 2; w++) diag += (i === positions.length - 1 || i === 0) ? '\u2550' : '\u2500';
                diag += '\u2550' + label + '\n';
                if (i > 0) {
                    diag += '  ' + spaces + '/';
                    for (var w = 0; w < width - 2; w++) diag += ' ';
                    diag += '\\\n';
                }
            }
            diag += '  ';
            for (var w = 0; w < maxW; w++) diag += '\u2501';
            diag += '  BOTTOM CHORD';
            diag += '\n\n  ' + c.steel.name + ' \u00D7 ' + gb.totalBattens + ' purlins';
            diag += '\n  Cut to: ' + gb.battenLength + 'mm (patio length)';
            document.getElementById('gableBattenDiagram').textContent = diag;
        }

        function updateBattenUI() {
            var c = calc;
            if (!c) return;
            if (c.isGable) { updateGableBattenUI(); return; }

            // For insulated roofs, show simple no-battens message
            if (isInsulated(c.roofing)) {
                document.getElementById('battenSheetLabel').textContent = c.roofing === 'solarspan75' ? 'SolarSpan 75mm' : 'SolarSpan 100mm';
                document.getElementById('battenMaxSpan').textContent = 'Self-spanning';
                document.getElementById('battenProjection').textContent = Math.round(c.W) + 'mm';
                document.getElementById('battenPitch').textContent = c.pitch.toFixed(1) + '\u00B0';
                document.getElementById('battenResultTitle').textContent = '\u2713 Self-spanning \u2014 no battens required';
                document.getElementById('battenResultSpacing').textContent = '';
                document.getElementById('battenResultPositions').textContent = '';
                document.getElementById('battenResultBrackets').textContent = '';
                document.getElementById('battenBracketType').style.display = 'none';
                document.getElementById('battenWarnings').style.display = 'none';
                document.getElementById('battenDiagram').textContent = '';
                return;
            }

            var bc = c.battenCalc;
            var bk = c.bracketCalc;
            var bv = c.battenValidation;
            var sheet = SHEET_SPANS[c.sheetSpanKey];
            if (!sheet) return;

            // Summary
            document.getElementById('battenSheetLabel').textContent = sheet.label;
            document.getElementById('battenMaxSpan').textContent = sheet.maxSpan + 'mm';
            document.getElementById('battenProjection').textContent = Math.round(c.W) + 'mm';
            document.getElementById('battenPitch').textContent = c.pitch.toFixed(1) + '\u00B0';

            // Warnings
            var warnEl = document.getElementById('battenWarnings');
            if (bv.errors.length > 0 || bv.warnings.length > 0) {
                var html = '';
                bv.errors.forEach(function(e) { html += '<div style="background:#FDEDEC;border:1px solid #E74C3C;border-radius:6px;padding:6px 10px;font-size:11px;color:#C0392B;margin-bottom:4px">\u2716 ' + e + '</div>'; });
                bv.warnings.forEach(function(w) { html += '<div style="background:#FEF9E7;border:1px solid #F39C12;border-radius:6px;padding:6px 10px;font-size:11px;color:#7D6608;margin-bottom:4px">\u26A0 ' + w + '</div>'; });
                warnEl.innerHTML = html;
                warnEl.style.display = 'block';
            } else {
                warnEl.style.display = 'none';
            }

            // Result
            if (bc.battensNeeded === 0) {
                var noBattenMsg = bc.message;
                if (c.roofing === 'spanplus330') noBattenMsg = 'SpanPlus spans full projection \u2014 no battens required';
                document.getElementById('battenResultTitle').textContent = '\u2713 ' + noBattenMsg;
                document.getElementById('battenResultSpacing').textContent = '';
                document.getElementById('battenResultPositions').textContent = '';
                document.getElementById('battenResultBrackets').textContent = '';
                document.getElementById('battenBracketType').style.display = 'none';
            } else {
                document.getElementById('battenResultTitle').textContent = bc.battensNeeded + ' batten row' + (bc.battensNeeded > 1 ? 's' : '') + ' required';
                document.getElementById('battenResultSpacing').textContent = 'Spacing: ' + bc.spanDistance + 'mm centres';
                document.getElementById('battenResultPositions').textContent = 'Positions from back beam: ' + bc.battenPositions.join('mm, ') + 'mm';
                document.getElementById('battenResultBrackets').textContent = 'Brackets: ' + bk.bracketsNeeded + ' total (' + bk.perBatten + ' per batten)';
                document.getElementById('battenBracketType').style.display = 'block';
            }

            // Bracket powdercoat warning
            var extRadio = document.querySelector('input[name="bracketType"][value="external"]');
            document.getElementById('battenPowdercoatWarn').style.display = (extRadio && extRadio.checked && bc.battensNeeded > 0) ? 'block' : 'none';

            // Diagram
            var diag = '';
            var projMm = Math.round(c.W);
            diag += '  HOUSE\n';
            diag += '    \u2502\n';
            diag += '  Back \u2502';
            var items = [{pos: 0, label: 'Back Beam'}];
            bc.battenPositions.forEach(function(p, i) { items.push({pos: p, label: 'Batten ' + (i + 1)}); });
            items.push({pos: projMm, label: 'Front Beam'});

            // Build horizontal layout
            var line1 = '  ';
            var line2 = '  ';
            var line3 = '  ';
            for (var i = 0; i < items.length; i++) {
                if (i === 0) {
                    line1 += items[i].pos + 'mm';
                    line2 += '\u2550\u2550\u2550\u2550';
                    line3 += items[i].label;
                } else {
                    var gap = items[i].pos - items[i-1].pos;
                    var pad = Math.max(2, Math.round(gap / 300));
                    var spacer = '';
                    for (var s = 0; s < pad; s++) spacer += '\u2500';
                    line1 += spacer + items[i].pos + 'mm';
                    line2 += spacer + '\u2550\u2550\u2550\u2550';
                    line3 += spacer + items[i].label;
                }
            }
            diag += '\n' + line1 + '\n' + line2 + '\n' + line3;
            if (bc.battensNeeded > 0) {
                diag += '\n\n  76\u00D738\u00D71.6 RHS patio tubing \u00D7 ' + bc.battensNeeded;
                diag += '\n  Cut to: ' + Math.round(bc.battenLength) + 'mm';
            }
            document.getElementById('battenDiagram').textContent = diag;
        }

        function rebuildAll() {
            autoCalculatePostsAndTrusses();
            getInputs();
            updateDownpipeMap();
            draw2DPlan();
            buildTruss3D();
            updateCutListPanel();
            buildAsm3D();
            updateBattenUI();
            updateRafterUI();
            updatePostUI();
            buildJobRows();
            updatePricing();
            updateEstimate();
            updateRightPanelSummary();
            updateEngGroupSummary();
            updatePatioCatchment();
            updatePurlinValidation();
            updateStructSizing();
        }

        function exportOrder() {
            exportAllOutputs();
        }

        // ==================== CONSOLIDATED OUTPUT FUNCTIONS ====================

        function showToast(message, type) {
            type = type || 'success';
            var toast = document.createElement('div');
            toast.className = 'toast toast-' + type;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(function() { toast.classList.add('show'); }, 10);
            setTimeout(function() {
                toast.classList.remove('show');
                setTimeout(function() { toast.remove(); }, 300);
            }, 2500);
        }

        function formatDateStr(date) {
            return date.toISOString().split('T')[0];
        }

        async function exportAllOutputs() {
            if (!window.jspdf) {
                showToast('PDF library not loaded. Check internet connection and reload.', 'error');
                return;
            }
            var c = calc;
            if (!c.roofStyle) {
                showToast('No design loaded. Configure a patio design first.', 'error');
                return;
            }
            generateQuotePDF();
            downloadMaterialOrderPDF();
            await generateWorkOrderPDF();
            showToast('All documents generated');
        }

        function generateMaterialOrder() {
            var optionsEl = document.getElementById('materialOrderOptions');
            optionsEl.style.display = optionsEl.style.display === 'none' ? 'flex' : 'none';

            // Hide fab button if no fab items
            var groups = buildSupplierRows();
            var hasFab = groups.fabrication && groups.fabrication.length > 0;
            var fabBtn = document.getElementById('copyFabBtn');
            if (fabBtn) fabBtn.style.display = hasFab ? 'inline-block' : 'none';

            showToast('Material order ready - copy sections or download PDF');
        }

        function copySectionToClipboard(section) {
            var groups = buildSupplierRows();
            var rows = [];
            if (section === 'steel') rows = groups.steel || [];
            else if (section === 'sheets') rows = groups.sheets || [];
            else if (section === 'fab') rows = groups.fabrication || [];

            if (rows.length === 0) {
                showToast('No items in ' + section + ' section', 'error');
                return;
            }

            var text = section.toUpperCase() + ' ORDER - ' + getJobRef() + ' - ' + getClientName() + '\n';
            text += 'Date: ' + formatDateStr(new Date()) + '\n';
            text += 'Deliver to: ' + getSiteAddress() + '\n\n';
            text += 'Item | Size | Length | Qty | Colour | Notes\n';
            text += '---|---|---|---|---|---\n';
            rows.forEach(function(r) {
                text += r.join(' | ') + '\n';
            });
            // Append additional materials for steel section
            if (section === 'steel' && additionalMaterials.length > 0) {
                text += '\nADDITIONAL MATERIALS\n';
                additionalMaterials.forEach(function(am) {
                    text += (am.desc || 'Item') + ' | - | - | ' + am.qty + ' | - | -\n';
                });
            }

            navigator.clipboard.writeText(text).then(function() {
                showToast(section.charAt(0).toUpperCase() + section.slice(1) + ' order copied to clipboard');
            }).catch(function() {
                showToast('Failed to copy to clipboard', 'error');
            });
        }

        function downloadMaterialOrderPDF() {
            if (!window.jspdf) { showToast('PDF library not loaded', 'error'); return; }
            try {
                var jobRef = getJobRef();

                // Generate Steel Order PDF
                generateSteelOrderPDF();

                // Generate Sheets & Flashings PDF
                generateSheetsOrderPDF();

                // Generate Fabrication PDF if applicable
                var groups = buildSupplierRows();
                if (groups.fabrication && groups.fabrication.length > 0) {
                    generateFabricationOrderPDF();
                }

                showToast('Material Order PDFs downloaded');
            } catch(e) {
                showToast('Error generating Material Order: ' + e.message, 'error');
                console.error(e);
            }
        }

        function exportRawData() {
            var base = gatherJobData();
            var data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                customer: typeof customer !== 'undefined' ? customer : {},
                siteDetails: typeof siteDetails !== 'undefined' ? siteDetails : {},
                client: base.client,
                config: base.config,
                pricing: base.pricing,
                complexity: base.complexity,
                notes: base.notes,
                truss: {
                    base: base.config.trussBase,
                    chord: base.config.trussChord,
                    steel: base.config.trussSteel,
                    overhang: base.config.overhang,
                    riserLeft: base.config.trussRiserLeft,
                    riserRight: base.config.trussRiserRight,
                    riserLocked: base.config.trussRiserLocked,
                    riserType: base.config.riserType || 'welded',
                    extender: base.config.trussExtender
                },
                flashings: flashingProfiles.map(function(p) {
                    return { id: p.id, name: p.name, colour: p.colour, gauge: p.gauge, length: p.length, qty: p.qty, colourSide: p.colourSide, points: p.points, girth: p.girth, legs: p.legs, startTreatment: p.startTreatment || null, endTreatment: p.endTreatment || null };
                })
            };

            var json = JSON.stringify(data, null, 2);
            var blob = new Blob([json], { type: 'application/json' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'PatioData_' + safeName(getClientName()) + '_' + formatDateStr(new Date()) + '.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Raw data exported');
        }

        function loadRawData(file) {
            if (!file) return;
            var reader = new FileReader();
            reader.onload = function(e) {
                try {
                    var data = JSON.parse(e.target.result);
                    // Use existing import logic
                    if (data.client || data.config) {
                        // Populate via the import system
                        var textarea = document.getElementById('importTextarea');
                        if (textarea) {
                            textarea.value = e.target.result;
                            importJobData();
                            document.getElementById('importModal').style.display = 'none';
                        } else {
                            // Direct population
                            if (data.client) {
                                var cl = data.client;
                                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                                if (cl.name) document.getElementById('customerName').value = cl.name;
                                if (cl.address) document.getElementById('customerAddress').value = cl.address;
                                if (cl.phone) document.getElementById('customerPhone').value = cl.phone;
                                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                            }
                        }
                        showToast('Job data loaded successfully');
                    } else {
                        showToast('Invalid job data file', 'error');
                    }
                } catch(err) {
                    showToast('Error loading file: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // ==================== SITE MEDIA (Photos & Video) ====================
        var sitePhotos = [];    // Array of { id, file, dataUrl, label, caption, originalSize, compressedSize }
        var siteVideo = null;   // { file, dataUrl, label, originalSize }
        var photoIdCounter = 0;

        var PHOTO_LABELS = [
            'Overall site',
            'House attachment / fascia',
            'Roofline',
            'Post locations',
            'Ground / slab condition',
            'Obstruction (downpipe/AC/meter)',
            'Existing structure (demo)',
            'Access / driveway',
            'Boundary / setback',
            'Weep holes / DPC',
            'Measurements on-site',
            'Other'
        ];

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1048576) return (bytes / 1024).toFixed(0) + ' KB';
            return (bytes / 1048576).toFixed(1) + ' MB';
        }

        async function handlePhotoCapture(files) {
            if (!files || files.length === 0) return;
            var progressEl = document.getElementById('photoCompressProgress');
            var progressText = document.getElementById('compressProgressText');
            progressEl.style.display = 'flex';

            // Process sequentially to avoid iPad memory issues
            for (var i = 0; i < files.length; i++) {
                var file = files[i];
                if (!file.type.startsWith('image/')) continue;
                progressText.textContent = 'Compressing photo ' + (i + 1) + ' of ' + files.length + '...';

                try {
                    var compressed = await imageCompression(file, {
                        maxWidthOrHeight: 2048,
                        maxSizeMB: 0.5,
                        useWebWorker: true,
                        preserveExif: true,
                        fileType: 'image/jpeg'
                    });
                    var dataUrl = await readFileAsDataUrl(compressed);
                    sitePhotos.push({
                        id: ++photoIdCounter,
                        file: compressed,
                        dataUrl: dataUrl,
                        label: suggestPhotoLabel(sitePhotos.length),
                        caption: '',
                        originalSize: file.size,
                        compressedSize: compressed.size
                    });
                } catch (err) {
                    console.warn('Photo compression failed, using original:', err);
                    // Fallback: use original file
                    try {
                        var dataUrl2 = await readFileAsDataUrl(file);
                        sitePhotos.push({
                            id: ++photoIdCounter,
                            file: file,
                            dataUrl: dataUrl2,
                            label: suggestPhotoLabel(sitePhotos.length),
                            caption: '',
                            originalSize: file.size,
                            compressedSize: file.size
                        });
                    } catch (e2) { console.error('Failed to read photo:', e2); }
                }
            }

            progressEl.style.display = 'none';
            renderPhotoGrid();
            updatePhotoCount();
            // Reset file inputs so same files can be re-selected
            document.querySelectorAll('#sec-photos input[type=file]').forEach(function(inp) { inp.value = ''; });
        }

        function readFileAsDataUrl(file) {
            return new Promise(function(resolve, reject) {
                var reader = new FileReader();
                reader.onload = function() { resolve(reader.result); };
                reader.onerror = function() { reject(reader.error); };
                reader.readAsDataURL(file);
            });
        }

        function suggestPhotoLabel(index) {
            // Cycle through labels for first batch, then default to 'Other'
            return index < PHOTO_LABELS.length - 1 ? PHOTO_LABELS[index] : 'Other';
        }

        function renderPhotoGrid() {
            var grid = document.getElementById('photoGrid');
            if (!grid) return;
            if (sitePhotos.length === 0) {
                grid.innerHTML = '<div style="text-align:center;padding:24px;color:var(--sw-text-sec);font-size:11px">' +
                    '<div style="font-size:28px;margin-bottom:6px;opacity:0.4">&#128247;</div>' +
                    'No photos yet. Take or upload site photos above.</div>';
                return;
            }
            var html = '';
            sitePhotos.forEach(function(photo, idx) {
                var labelOpts = PHOTO_LABELS.map(function(lbl) {
                    return '<option value="' + lbl + '"' + (photo.label === lbl ? ' selected' : '') + '>' + lbl + '</option>';
                }).join('');
                html += '<div class="photo-card" data-photo-id="' + photo.id + '">' +
                    '<img src="' + photo.dataUrl + '" onclick="openPhotoLightbox(' + idx + ')" loading="lazy">' +
                    '<span class="photo-compress-badge">' + formatFileSize(photo.compressedSize) + '</span>' +
                    '<button class="photo-delete" onclick="deletePhoto(' + photo.id + ')" title="Remove">&times;</button>' +
                    '<select class="photo-label-sel" onchange="updatePhotoLabel(' + photo.id + ',this.value)">' + labelOpts + '</select>' +
                    '</div>';
            });
            grid.innerHTML = html;
        }

        function deletePhoto(id) {
            sitePhotos = sitePhotos.filter(function(p) { return p.id !== id; });
            renderPhotoGrid();
            updatePhotoCount();
        }

        function updatePhotoLabel(id, newLabel) {
            var photo = sitePhotos.find(function(p) { return p.id === id; });
            if (photo) photo.label = newLabel;
        }

        function updatePhotoCount() {
            var badge = document.getElementById('photoCountBadge');
            var info = document.getElementById('photoCountInfo');
            var n = sitePhotos.length;
            if (n === 0) {
                if (badge) badge.innerHTML = '';
                if (info) info.style.display = 'none';
                return;
            }
            var totalSize = sitePhotos.reduce(function(sum, p) { return sum + p.compressedSize; }, 0);
            var savedSize = sitePhotos.reduce(function(sum, p) { return sum + (p.originalSize - p.compressedSize); }, 0);
            var txt = '<strong>' + n + '</strong> photo' + (n !== 1 ? 's' : '');
            if (badge) badge.innerHTML = txt;
            if (info) {
                info.style.display = 'block';
                info.innerHTML = txt + ' &middot; ' + formatFileSize(totalSize) + ' total' +
                    (savedSize > 0 ? ' <span style="color:#22C55E">(' + formatFileSize(savedSize) + ' saved by compression)</span>' : '');
            }
        }

        // â”€â”€ Photo Lightbox â”€â”€
        var lightboxIdx = 0;
        function openPhotoLightbox(idx) {
            lightboxIdx = idx;
            var lb = document.getElementById('photoLightbox');
            if (!lb) createPhotoLightbox();
            lb = document.getElementById('photoLightbox');
            updateLightboxImage();
            lb.classList.add('active');
        }
        function createPhotoLightbox() {
            var div = document.createElement('div');
            div.id = 'photoLightbox';
            div.className = 'photo-lightbox';
            div.innerHTML = '<button class="lb-close" onclick="closePhotoLightbox()">&times;</button>' +
                '<button class="lb-nav prev" onclick="event.stopPropagation();navLightbox(-1)">&#8249;</button>' +
                '<img id="lbImage" src="">' +
                '<button class="lb-nav next" onclick="event.stopPropagation();navLightbox(1)">&#8250;</button>' +
                '<div class="lb-caption" id="lbCaption"></div>';
            div.addEventListener('click', function(e) { if (e.target === div) closePhotoLightbox(); });
            document.body.appendChild(div);
        }
        function closePhotoLightbox() {
            var lb = document.getElementById('photoLightbox');
            if (lb) lb.classList.remove('active');
        }
        function navLightbox(dir) {
            lightboxIdx = (lightboxIdx + dir + sitePhotos.length) % sitePhotos.length;
            updateLightboxImage();
        }
        function updateLightboxImage() {
            var photo = sitePhotos[lightboxIdx];
            if (!photo) return;
            var img = document.getElementById('lbImage');
            var cap = document.getElementById('lbCaption');
            if (img) img.src = photo.dataUrl;
            if (cap) cap.textContent = (lightboxIdx + 1) + ' / ' + sitePhotos.length + ' â€” ' + photo.label;
        }

        // â”€â”€ Video Upload â”€â”€
        async function handleVideoUpload(files) {
            if (!files || files.length === 0) return;
            var file = files[0];
            if (!file.type.startsWith('video/')) {
                showToast('Please select a video file', 'error');
                return;
            }
            var dataUrl = URL.createObjectURL(file);
            siteVideo = {
                file: file,
                objectUrl: dataUrl,
                label: 'Site Walkthrough',
                originalSize: file.size
            };
            renderVideoPreview();
            updateVideoBadge();
            // Reset input
            document.querySelectorAll('#sec-video input[type=file]').forEach(function(inp) { inp.value = ''; });
        }

        function renderVideoPreview() {
            var area = document.getElementById('videoPreviewArea');
            if (!area) return;
            if (!siteVideo) {
                area.innerHTML = '';
                return;
            }
            area.innerHTML = '<div class="video-preview-card">' +
                '<video src="' + siteVideo.objectUrl + '" controls preload="metadata" playsinline></video>' +
                '<button class="photo-delete" onclick="deleteVideo()" title="Remove">&times;</button>' +
                '<div class="video-info">' +
                    '<span>' + siteVideo.label + '</span>' +
                    '<span>' + formatFileSize(siteVideo.originalSize) + '</span>' +
                '</div>' +
                '</div>';
        }

        function deleteVideo() {
            if (siteVideo && siteVideo.objectUrl) {
                URL.revokeObjectURL(siteVideo.objectUrl);
            }
            siteVideo = null;
            renderVideoPreview();
            updateVideoBadge();
        }

        function updateVideoBadge() {
            var badge = document.getElementById('videoBadge');
            if (badge) {
                badge.innerHTML = siteVideo ? '&#127909; ' + formatFileSize(siteVideo.originalSize) : '';
            }
        }

        // â”€â”€ Get media data for save/export â”€â”€
        function getSiteMediaSummary() {
            return {
                photoCount: sitePhotos.length,
                hasVideo: !!siteVideo,
                videoSize: siteVideo ? siteVideo.originalSize : 0,
                photos: sitePhotos.map(function(p) {
                    return { label: p.label, caption: p.caption, compressedSize: p.compressedSize };
                })
            };
        }

        // ==================== SAVE & SUBMIT ====================
        var SCOPE_DB_NAME = 'SecureWorksScopes';
        var SCOPE_DB_VERSION = 1;
        var SCOPE_STORE = 'scopes';

        function openScopeDB() {
            return new Promise(function(resolve, reject) {
                var req = indexedDB.open(SCOPE_DB_NAME, SCOPE_DB_VERSION);
                req.onupgradeneeded = function(e) {
                    var db = e.target.result;
                    if (!db.objectStoreNames.contains(SCOPE_STORE)) {
                        var store = db.createObjectStore(SCOPE_STORE, { keyPath: 'jobRef' });
                        store.createIndex('status', 'status', { unique: false });
                        store.createIndex('savedAt', 'savedAt', { unique: false });
                    }
                };
                req.onsuccess = function() { resolve(req.result); };
                req.onerror = function() { reject(req.error); };
            });
        }

        function generateJobRef() {
            var existing = (document.getElementById('jobRef')?.value || '').trim();
            if (existing) return existing;
            var d = new Date();
            var dateStr = String(d.getFullYear()).slice(2) +
                String(d.getMonth() + 1).padStart(2, '0') +
                String(d.getDate()).padStart(2, '0');
            var seq = String(Math.floor(Math.random() * 900) + 100); // 3-digit random
            return 'SW' + dateStr + '-' + seq;
        }

        function validateScope() {
            var errors = [];
            var warnings = [];
            var w = parseInt(document.getElementById('inWidth')?.value) || 0;
            var l = parseInt(document.getElementById('inLength')?.value) || 0;
            var name = (document.getElementById('customerName')?.value || '').trim();
            var addr = (document.getElementById('customerAddress')?.value || '').trim();

            if (!name) errors.push('Customer name is required');
            if (!addr) errors.push('Site address is required');
            if (w < 500) errors.push('Projection must be at least 500mm');
            if (l < 500) errors.push('Length must be at least 500mm');
            if (sitePhotos.length === 0) warnings.push('No site photos captured');
            else if (sitePhotos.length < 5) warnings.push('Only ' + sitePhotos.length + ' photos â€” recommend at least 5');
            if (!siteVideo) warnings.push('No site walkthrough video');

            return { errors: errors, warnings: warnings, valid: errors.length === 0 };
        }

        function showSaveSubmit() {
            var validation = validateScope();
            var overlay = document.getElementById('saveOverlay');
            var body = document.getElementById('saveOverlayBody');
            var actions = document.getElementById('saveOverlayActions');
            var title = document.getElementById('saveOverlayTitle');

            // Generate ref if needed
            var jobRef = generateJobRef();
            var refEl = document.getElementById('jobRef');
            if (refEl && !refEl.value.trim()) refEl.value = jobRef;

            title.textContent = 'Save Scope';

            if (!validation.valid) {
                // Show errors
                body.innerHTML = '<div style="margin-bottom:12px;padding:10px;background:#FEF2F2;border-radius:6px;border-left:3px solid #EF4444">' +
                    '<div style="font-weight:600;font-size:12px;color:#991B1B;margin-bottom:4px">Cannot save â€” fix these issues:</div>' +
                    validation.errors.map(function(e) { return '<div style="font-size:11px;color:#991B1B;padding:2px 0">&bull; ' + e + '</div>'; }).join('') +
                    '</div>';
                actions.innerHTML = '<button class="btn btn-secondary" onclick="closeSaveOverlay()">Close</button>';
                overlay.classList.add('active');
                return;
            }

            // Build summary
            var c = calc || {};
            var name = (document.getElementById('customerName')?.value || '').trim();
            var addr = (document.getElementById('customerAddress')?.value || '').trim();
            var roofStyle = (document.getElementById('inRoofStyle')?.value || 'skillion');
            var roofing = roofingLabel(c.roofing || 'solarspan50');
            var connection = (document.getElementById('inConnection')?.value || 'fascia');
            var W = parseInt(document.getElementById('inWidth')?.value) || 0;
            var L = parseInt(document.getElementById('inLength')?.value) || 0;
            var quoteTotal = document.getElementById('rpPriceTotal')?.textContent || '$0';

            var warningsHtml = '';
            if (validation.warnings.length > 0) {
                warningsHtml = '<div style="margin-bottom:10px;padding:8px;background:#FFFBEB;border-radius:6px;border-left:3px solid #F59E0B">' +
                    validation.warnings.map(function(w) { return '<div style="font-size:10px;color:#92400E;padding:1px 0">&bull; ' + w + '</div>'; }).join('') +
                    '</div>';
            }

            body.innerHTML = warningsHtml +
                '<div style="margin-bottom:12px">' +
                makeSummaryRow('Job Ref', jobRef) +
                makeSummaryRow('Customer', name) +
                makeSummaryRow('Address', addr) +
                makeSummaryRow('Dimensions', L + ' &times; ' + W + 'mm') +
                makeSummaryRow('Roof', roofStyle.charAt(0).toUpperCase() + roofStyle.slice(1) + ' â€” ' + roofing) +
                makeSummaryRow('Attachment', connection) +
                makeSummaryRow('Photos', sitePhotos.length + (siteVideo ? ' + video' : '')) +
                makeSummaryRow('Quote', quoteTotal) +
                '</div>';

            actions.innerHTML = '<button class="btn btn-secondary" onclick="closeSaveOverlay()">Cancel</button>' +
                '<button class="btn btn-primary" onclick="executeSaveScope()">Save Scope</button>';

            overlay.classList.add('active');
        }

        function makeSummaryRow(label, value) {
            return '<div class="save-summary-row"><span class="label">' + label + '</span><span class="value">' + value + '</span></div>';
        }

        function closeSaveOverlay() {
            document.getElementById('saveOverlay')?.classList.remove('active');
        }

        async function executeSaveScope() {
            var body = document.getElementById('saveOverlayBody');
            var actions = document.getElementById('saveOverlayActions');
            var title = document.getElementById('saveOverlayTitle');
            title.textContent = 'Saving...';
            actions.innerHTML = ''; // Remove buttons during save

            var steps = [
                { id: 'config', label: 'Saving scope configuration' },
                { id: 'photos', label: 'Saving ' + sitePhotos.length + ' photos' },
                { id: 'video', label: siteVideo ? 'Saving video' : 'No video to save' },
                { id: 'done', label: 'Complete' }
            ];

            function renderProgress(activeIdx, error) {
                body.innerHTML = steps.map(function(step, i) {
                    var status = i < activeIdx ? 'done' : (i === activeIdx ? (error ? 'error' : 'active') : 'pending');
                    var icon = status === 'done' ? '&#10003;' : (status === 'active' ? '<div class="spinner" style="width:12px;height:12px;border-width:1.5px"></div>' : (status === 'error' ? '&#10007;' : '&#9675;'));
                    return '<div class="save-progress-step ' + status + '"><span class="step-icon">' + icon + '</span><span>' + step.label + '</span></div>';
                }).join('') + (error ? '<div style="margin-top:8px;padding:8px;background:#FEF2F2;border-radius:4px;font-size:11px;color:#991B1B">' + error + '</div>' : '');
            }

            try {
                // Step 1: Save config
                renderProgress(0);
                var jobRef = (document.getElementById('jobRef')?.value || '').trim() || generateJobRef();
                var jobData = gatherJobData();
                jobData.siteMedia = getSiteMediaSummary();
                jobData._savedAt = new Date().toISOString();
                jobData._status = 'saved_locally';

                await new Promise(function(r) { setTimeout(r, 300); }); // Brief pause for UI

                // Step 2: Save photos
                renderProgress(1);
                var photoBlobs = [];
                for (var i = 0; i < sitePhotos.length; i++) {
                    photoBlobs.push({
                        id: sitePhotos[i].id,
                        label: sitePhotos[i].label,
                        caption: sitePhotos[i].caption,
                        dataUrl: sitePhotos[i].dataUrl,
                        compressedSize: sitePhotos[i].compressedSize
                    });
                }

                // Step 3: Save video reference
                renderProgress(2);
                var videoBlob = null;
                if (siteVideo) {
                    // Store as ArrayBuffer for IndexedDB efficiency
                    var vFile = siteVideo.file;
                    var vBuf = await vFile.arrayBuffer();
                    videoBlob = {
                        label: siteVideo.label,
                        originalSize: siteVideo.originalSize,
                        type: vFile.type,
                        name: vFile.name,
                        buffer: vBuf
                    };
                }

                // Write to IndexedDB
                var db = await openScopeDB();
                var tx = db.transaction(SCOPE_STORE, 'readwrite');
                var store = tx.objectStore(SCOPE_STORE);
                await new Promise(function(resolve, reject) {
                    var record = {
                        jobRef: jobRef,
                        status: 'saved_locally',
                        savedAt: new Date().toISOString(),
                        config: jobData,
                        photos: photoBlobs,
                        video: videoBlob
                    };
                    var req = store.put(record);
                    req.onsuccess = function() { resolve(); };
                    req.onerror = function() { reject(req.error); };
                });
                db.close();

                // Also save to localStorage as lightweight backup (config only, no media)
                localStorage.setItem('scope-' + jobRef, JSON.stringify(jobData));

                // Step 4: Done
                renderProgress(4);
                title.textContent = 'Scope Saved';
                body.innerHTML = '<div style="text-align:center;padding:16px">' +
                    '<div style="font-size:36px;margin-bottom:8px">&#10003;</div>' +
                    '<div style="font-size:14px;font-weight:600;color:var(--sw-blue-dark);margin-bottom:4px">Scope saved locally</div>' +
                    '<div style="font-size:11px;color:var(--sw-text-sec);margin-bottom:12px">Job: ' + jobRef + '</div>' +
                    '<div style="font-size:10px;color:var(--sw-text-sec);padding:8px;background:var(--sw-bg);border-radius:6px">' +
                    sitePhotos.length + ' photos' + (siteVideo ? ' + video' : '') + ' saved to device storage.<br>' +
                    'Will sync to cloud when backend is connected.</div>' +
                    '</div>';
                actions.innerHTML = '<button class="btn btn-secondary" onclick="closeSaveOverlay()">Close</button>' +
                    '<button class="btn btn-primary" onclick="closeSaveOverlay()">Continue Editing</button>';

                updatePendingBadge();
                showToast('Scope saved: ' + jobRef);

            } catch (err) {
                console.error('Save failed:', err);
                renderProgress(steps.length - 1, 'Save failed: ' + err.message);
                actions.innerHTML = '<button class="btn btn-secondary" onclick="closeSaveOverlay()">Close</button>' +
                    '<button class="btn btn-primary" onclick="executeSaveScope()">Retry</button>';
            }
        }

        // â”€â”€ Pending scopes badge â”€â”€
        async function updatePendingBadge() {
            try {
                var db = await openScopeDB();
                var tx = db.transaction(SCOPE_STORE, 'readonly');
                var store = tx.objectStore(SCOPE_STORE);
                var countReq = store.count();
                countReq.onsuccess = function() {
                    var n = countReq.result;
                    var badge = document.getElementById('pendingBadge');
                    if (badge) {
                        if (n > 0) {
                            badge.style.display = 'block';
                            badge.textContent = n + ' scope' + (n !== 1 ? 's' : '') + ' saved locally';
                        } else {
                            badge.style.display = 'none';
                        }
                    }
                    db.close();
                };
            } catch(e) { /* IndexedDB not available */ }
        }

        async function showPendingScopes() {
            try {
                var db = await openScopeDB();
                var tx = db.transaction(SCOPE_STORE, 'readonly');
                var store = tx.objectStore(SCOPE_STORE);
                var getAll = store.getAll();
                getAll.onsuccess = function() {
                    var scopes = getAll.result;
                    db.close();
                    if (scopes.length === 0) { showToast('No saved scopes'); return; }

                    var overlay = document.getElementById('saveOverlay');
                    var body = document.getElementById('saveOverlayBody');
                    var actions = document.getElementById('saveOverlayActions');
                    var title = document.getElementById('saveOverlayTitle');
                    title.textContent = 'Saved Scopes (' + scopes.length + ')';

                    body.innerHTML = scopes.map(function(s) {
                        var cfg = s.config || {};
                        var client = cfg.client || {};
                        var photoCount = (s.photos || []).length;
                        var hasVideo = !!s.video;
                        var savedDate = s.savedAt ? new Date(s.savedAt).toLocaleDateString('en-AU', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' }) : '?';
                        return '<div style="padding:10px;margin-bottom:6px;background:var(--sw-bg);border-radius:8px;border:1px solid var(--sw-border)">' +
                            '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">' +
                                '<span style="font-weight:600;font-size:12px">' + s.jobRef + '</span>' +
                                '<span style="font-size:9px;color:var(--sw-text-sec)">' + savedDate + '</span>' +
                            '</div>' +
                            '<div style="font-size:11px;color:var(--sw-text-sec)">' +
                                (client.name || 'No name') + ' â€” ' + (client.address || 'No address') +
                            '</div>' +
                            '<div style="display:flex;gap:12px;margin-top:4px;font-size:10px;color:var(--sw-text-sec)">' +
                                '<span>' + photoCount + ' photos</span>' +
                                (hasVideo ? '<span>+ video</span>' : '') +
                                '<span style="margin-left:auto">' +
                                    '<button class="btn-small" style="font-size:9px;padding:2px 6px" onclick="loadSavedScope(\'' + s.jobRef + '\')">Load</button>' +
                                    ' <button class="btn-small" style="font-size:9px;padding:2px 6px;color:#EF4444;border-color:#EF4444" onclick="deleteSavedScope(\'' + s.jobRef + '\')">Delete</button>' +
                                '</span>' +
                            '</div>' +
                        '</div>';
                    }).join('');

                    actions.innerHTML = '<button class="btn btn-secondary" onclick="closeSaveOverlay()">Close</button>';
                    overlay.classList.add('active');
                };
            } catch(e) { showToast('Error reading saved scopes', 'error'); }
        }

        async function loadSavedScope(jobRef) {
            try {
                var db = await openScopeDB();
                var tx = db.transaction(SCOPE_STORE, 'readonly');
                var store = tx.objectStore(SCOPE_STORE);
                var req = store.get(jobRef);
                req.onsuccess = function() {
                    var record = req.result;
                    db.close();
                    if (!record) { showToast('Scope not found', 'error'); return; }

                    // Load config using existing import system
                    if (record.config) {
                        var cfgStr = JSON.stringify(record.config);
                        // Trigger import
                        try {
                            var data = record.config;
                            if (data.client) {
                                if (data.client.jobRef) document.getElementById('jobRef').value = data.client.jobRef;
                                if (data.client.name) document.getElementById('customerName').value = data.client.name;
                                if (data.client.address) document.getElementById('customerAddress').value = data.client.address;
                                if (data.client.phone) document.getElementById('customerPhone').value = data.client.phone;
                                if (data.client.email) document.getElementById('clientEmail').value = data.client.email;
                                if (data.client.salesperson) document.getElementById('salesperson').value = data.client.salesperson;
                            }
                            // Use existing importJobData for config fields
                            if (typeof importJobFromJSON === 'function') {
                                importJobFromJSON(cfgStr);
                            }
                        } catch(e) { console.warn('Config load partial:', e); }
                    }

                    // Load photos
                    if (record.photos && record.photos.length > 0) {
                        sitePhotos = record.photos.map(function(p, i) {
                            return {
                                id: ++photoIdCounter,
                                file: null, // No file handle after reload
                                dataUrl: p.dataUrl,
                                label: p.label || 'Other',
                                caption: p.caption || '',
                                originalSize: p.compressedSize,
                                compressedSize: p.compressedSize
                            };
                        });
                        renderPhotoGrid();
                        updatePhotoCount();
                    }

                    // Load video
                    if (record.video) {
                        var blob = new Blob([record.video.buffer], { type: record.video.type || 'video/mp4' });
                        var url = URL.createObjectURL(blob);
                        siteVideo = {
                            file: blob,
                            objectUrl: url,
                            label: record.video.label || 'Site Walkthrough',
                            originalSize: record.video.originalSize || blob.size
                        };
                        renderVideoPreview();
                        updateVideoBadge();
                    }

                    closeSaveOverlay();
                    showToast('Scope loaded: ' + jobRef);
                };
            } catch(e) { showToast('Error loading scope: ' + e.message, 'error'); }
        }

        async function deleteSavedScope(jobRef) {
            if (!confirm('Delete saved scope ' + jobRef + '? This cannot be undone.')) return;
            try {
                var db = await openScopeDB();
                var tx = db.transaction(SCOPE_STORE, 'readwrite');
                var store = tx.objectStore(SCOPE_STORE);
                store.delete(jobRef);
                tx.oncomplete = function() {
                    db.close();
                    updatePendingBadge();
                    showPendingScopes(); // Refresh the list
                    showToast('Scope deleted: ' + jobRef);
                };
            } catch(e) { showToast('Error deleting scope', 'error'); }
        }

        // Auto-save config to localStorage periodically (crash recovery)
        var autoSaveTimer = null;
        function scheduleAutoSave() {
            if (autoSaveTimer) clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(function() {
                try {
                    var data = gatherJobData();
                    localStorage.setItem('patio-autosave', JSON.stringify(data));
                } catch(e) { /* silent */ }
            }, 5000); // Save 5 seconds after last change
        }

        // Hook auto-save into rebuild
        var _origRebuildAll = typeof rebuildAll === 'function' ? rebuildAll : null;
        if (_origRebuildAll) {
            // We'll attach auto-save via a listener approach instead
        }
        // Use MutationObserver on key inputs as a universal trigger
        document.addEventListener('input', function(e) {
            if (e.target.closest('.panel-left')) scheduleAutoSave();
        });

        // ==================== INIT ====================
        function resizeAsm() {
            const ac = document.getElementById('asmViewport');
            if (asmRend && ac && !ac.classList.contains('fullscreen') && !ac.classList.contains('fullscreen-mode')) {
                var w = ac.clientWidth, h = ac.clientHeight;
                if (w > 0 && h > 0) {
                    if (asmCam) {
                        asmCam.aspect = w / h;
                        asmCam.updateProjectionMatrix();
                    }
                    if (asmOrthoCamera) {
                        var aspect = w / h;
                        var halfH = (asmOrthoCamera.top - asmOrthoCamera.bottom) / 2;
                        asmOrthoCamera.left = -halfH * aspect;
                        asmOrthoCamera.right = halfH * aspect;
                        asmOrthoCamera.updateProjectionMatrix();
                    }
                    asmRend.setSize(w, h);
                }
            }
        }
        function resizeTruss() {
            const tc = document.getElementById('trussViewport');
            if (trussCam && trussRend && tc) {
                var w = tc.clientWidth, h = tc.clientHeight;
                if (w > 0 && h > 0) {
                    var aspect = w / h;
                    var halfH = (trussCam.top - trussCam.bottom) / 2;
                    trussCam.left = -halfH * aspect;
                    trussCam.right = halfH * aspect;
                    trussCam.updateProjectionMatrix();
                    trussRend.setSize(w, h);
                }
            }
        }
        window.addEventListener('resize', () => {
            resizeTruss();
            resizeAsm();
            draw2DPlan();
            if (flashModalOpen) { resizeFlashCanvas(); drawFlashCanvas(); }
        });
        document.addEventListener('fullscreenchange', () => { setTimeout(resizeTruss, 100); });
        // ResizeObserver for container-specific resize (layout changes, panel toggle)
        if (typeof ResizeObserver !== 'undefined') {
            var ro = new ResizeObserver(function() {
                resizeAsm();
                resizeTruss();
                draw2DPlan();
                if (flashModalOpen) { resizeFlashCanvas(); drawFlashCanvas(); }
            });
            var asmEl = document.getElementById('asmViewport');
            var trussEl = document.getElementById('trussViewport');
            var rpEl = document.getElementById('panelRight');
            if (asmEl) ro.observe(asmEl);
            if (trussEl) ro.observe(trussEl);
            if (rpEl) ro.observe(rpEl);
        }

        // ==================== LAYOUT TOGGLE ====================
        function toggleLayout() {
            var main = document.getElementById('mainLayout');
            var btn = document.getElementById('layoutToggle');
            var isFullWidth = main.classList.toggle('full-width');
            btn.innerHTML = isFullWidth ? '&#9704; Show Preview' : '&#9703; Full Width';
            localStorage.setItem('patioLayout', isFullWidth ? 'full' : 'split');
            // Resize canvases after layout change â€” multiple delays for CSS transition
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 50);
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 200);
            setTimeout(function() { resizeAsm(); resizeTruss(); draw2DPlan(); }, 500);
        }

        function initLayout() {
            var pref = localStorage.getItem('patioLayout');
            if (pref === 'full') {
                document.getElementById('mainLayout').classList.add('full-width');
                document.getElementById('layoutToggle').innerHTML = '&#9704; Show Preview';
            }
        }

        // initRightPanel3D removed â€” single renderer now in right panel via initAsm3D

        function updateRightPanelSummary() {
            var c = calc;
            if (!c || !c.L) return;
            var rpDims = document.getElementById('rpDims');
            var rpRoof = document.getElementById('rpRoofType');
            var rpMat = document.getElementById('rpMaterial');
            var rpClr = document.getElementById('rpColour');
            if (rpDims) rpDims.textContent = (c.lenInput / 1000).toFixed(1) + 'm Ã— ' + (c.projInput / 1000).toFixed(1) + 'm';
            if (rpRoof) rpRoof.textContent = c.roofStyle === 'hip' ? 'Hip' : (c.isGable ? 'Gable' : 'Skillion');
            if (rpMat) rpMat.textContent = (ROOFING_TYPES[c.roofing] || ROOFING_TYPES.corrugated).name;
            if (rpClr) rpClr.textContent = sheetColor.name;

            // Estimate now writes directly to rpEstSqm/rpEstRange via updateEstimate()
        }

        function updateEngGroupSummary() {
            var c = calc;
            var parts = [];
            if (c && c.rafterQty) parts.push(c.rafterQty + ' rafters');
            if (c && c.battenQty) parts.push(c.battenQty + ' battens');
            var flashCount = document.querySelectorAll('#flashJobBody tr').length;
            if (flashCount > 0) parts.push(flashCount + ' flashing' + (flashCount > 1 ? 's' : ''));
            if (c && c.isGable && c.trussQty) parts.push(c.trussQty + ' truss' + (c.trussQty > 1 ? 'es' : ''));
            var el = document.getElementById('sgEngSummary');
            if (el) el.textContent = parts.length ? parts.join(' \u00B7 ') : '';
        }

        // ==================== CUSTOMER PREVIEW (AI IMAGE GENERATION) ====================

        // Capture screenshot of 3D viewer
        function capture3DScreenshot() {
            var canvas = document.getElementById('asmCanvas');
            if (!canvas) {
                alert('Could not find 3D canvas');
                return;
            }

            // Force a render to ensure current state is captured
            if (asmRend && asmScene && asmCam) {
                asmRend.render(asmScene, asmCam);
            }

            var dataUrl = canvas.toDataURL('image/png');

            // Show preview
            var preview = document.getElementById('screenshotPreview');
            var img = document.getElementById('screenshotImg');
            img.src = dataUrl;
            preview.style.display = 'block';

            // Also copy to clipboard if supported
            canvas.toBlob(function(blob) {
                if (navigator.clipboard && navigator.clipboard.write) {
                    navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': blob })
                    ]).then(function() {
                        console.log('Screenshot copied to clipboard');
                    }).catch(function(err) {
                        console.log('Could not copy to clipboard:', err);
                    });
                }
            });

            alert('Screenshot captured!\n\nRight-click the image to save it, or it may be copied to your clipboard.');
        }

        // Generate prompt and open Gemini
        function generateGeminiPrompt() {
            var c = calc;
            if (!c) { alert('No patio configuration found. Build the patio first.'); return; }

            var length = (c.lenInput / 1000).toFixed(1);
            var projection = (c.projInput / 1000).toFixed(1);
            var height = (c.postH / 1000).toFixed(1);
            var roofStyle = c.roofStyle;
            var attachment = c.connection;
            var roofMaterial = c.roofing;
            var pitch = c.userPitch;
            var isInsul = roofMaterial.indexOf('solarspan') === 0;
            var roofingName = (ROOFING_TYPES[roofMaterial] || {}).name || roofMaterial;

            var roofColourName = sheetColor ? sheetColor.name : 'Surfmist';
            var steelColourName = steelColor ? steelColor.name : 'Monument';

            // Roof style description
            var roofStyleText = {
                skillion: 'single-slope skillion roof (flat, angled away from the house)',
                gable: 'peaked gable roof with a central ridge line running perpendicular to the house',
                hip: 'hip roof',
                flat: 'flat roof'
            }[roofStyle] || roofStyle;

            // Attachment description
            var attachmentText = {
                fascia: 'attached to the existing house fascia board via a receiving channel â€” the patio roof tucks under the house gutter line',
                riser: 'attached via steel riser brackets that sit above the existing house Colorbond roof â€” the patio roof starts above the house roofline with a box gutter or flashing transition',
                flyover: 'flyover style â€” steel posts bolt through the existing house roof via flashing boots, and the patio roof flies over the top of the house roof with clearance',
                freestanding: 'completely freestanding structure with steel posts on all sides â€” not touching the house',
                wall: 'wall-mounted directly to the brick/render house wall via a receiving channel'
            }[attachment] || attachment;

            // Sheeting profile description
            var sheetDesc = '';
            if (isInsul) {
                var thickness = roofMaterial === 'solarspan100' ? '100mm' : '75mm';
                var ceilingFinish = c.ceilingFinish || 'plain';
                var ceilingDesc = {plain: 'smooth flat', vj: 'V-groove (VJ) lined', cedar: 'Western Red Cedar look timber-grain'}[ceilingFinish] || 'smooth flat';
                sheetDesc = 'Bondor SolarSpan ' + thickness + ' insulated roof panels. ' +
                    'Top surface: ' + roofColourName + ' Colorbond steel. ' +
                    'Underside (ceiling visible from below): ' + ceilingDesc + ' finish in Surfmist/off-white. ' +
                    'These are wide flat panels with no visible ribs â€” the ceiling appears as a seamless flat surface with clean join lines.';
            } else {
                var profileDesc = {
                    trimdek: 'Trimdek profile (5-rib trapezoidal) â€” distinct angular ribs spaced evenly',
                    corrugated: 'Custom Orb corrugated profile â€” classic sinusoidal wave pattern',
                    spandek: 'Spandek profile â€” wide pans with sharp narrow ribs',
                    spanplus330: 'SpanPlus 330 profile â€” narrow 330mm panels with standing seam look'
                }[roofMaterial] || roofMaterial;
                sheetDesc = profileDesc + ' in ' + roofColourName + ' Colorbond steel. ' +
                    'The sheeting profile should be clearly visible from the camera angle. ' +
                    'The underside shows exposed steel sheeting (not a flat ceiling).';
            }

            // Steel frame description
            var postSize = c.framePost ? c.framePost.label : '90Ã—90 SHS';
            var beamSize = c.frameBeam ? c.frameBeam.label : '100Ã—50 RHS';
            var postCount = c.nPosts;
            var steelDesc = steelColourName + ' powder-coated steel frame:\n' +
                '  - ' + postCount + ' posts (' + postSize + ' square hollow section)\n' +
                '  - Beams: ' + beamSize + ' rectangular hollow section\n' +
                '  - Gutters and downpipes matching in ' + steelColourName;

            // Scene context
            var isCarport = currentScenePreset === 'carport';
            var sceneDesc = isCarport
                ? 'This is a CARPORT (vehicle cover) at the front of the house over the driveway. ' +
                  'Show a concrete or exposed aggregate driveway underneath, the front of a suburban house with a garage door, ' +
                  'and the street/kerb visible in the background.'
                : 'This is a PATIO / ALFRESCO area at the rear of the house. ' +
                  'Show paved or tiled flooring underneath, a sliding glass door on the house wall leading inside, ' +
                  'green lawn beyond the patio, and established garden beds along the fence lines.';

            // L-shape context
            var lShapeDesc = '';
            if (c.lShape && c.lShape !== 'none') {
                lShapeDesc = '\n\nL-SHAPED HOUSE: The house forms an L-shape and the patio is built into the internal corner. ' +
                    'One side of the patio (' + c.lShape + ' when facing the house) is flush against the perpendicular wing of the house, ' +
                    'with a translucent polycarbonate twin-wall infill panel filling the gap between the patio roof edge and the house gutter on that wing.';
            }

            // Wraparound context (independent of L-shape)
            var wrapDesc = '';
            if (c.wrapSide && c.wrapSide !== 'none') {
                wrapDesc = '\n\nWRAPAROUND PATIO: The patio wraps around the ' + c.wrapSide + ' end of the house (external corner). ' +
                    'A return section extends along the house side wall, with a hip rafter running diagonally from the house corner. ' +
                    'The return roof sheets are clipped at the hip line where they meet the main patio roof.';
            }

            // Build the prompt â€” handles both with-photo and without-photo
            var prompt = 'TASK: Generate a photorealistic image of a custom-built patio/alfresco structure.\n\n' +
                'ATTACHMENTS:\n' +
                '- Image 1: A 3D structural model screenshot showing the exact patio design (steel frame, roof, posts, beams)\n' +
                '- Image 2 (if provided): A photo of the actual house/site where this patio will be built\n\n' +
                'INSTRUCTIONS:\n' +
                'If a site photo is provided: composite the patio design onto the actual house, matching the perspective, lighting and surroundings from the photo.\n' +
                'If NO site photo is provided: generate a typical Perth, Western Australia suburban home as the backdrop and show the patio built onto it.\n\n' +
                'PATIO SPECIFICATIONS â€” match the 3D model exactly:\n' +
                '- Overall size: ' + length + 'm long Ã— ' + projection + 'm deep projection from house, ' + height + 'm post/ceiling height\n' +
                '- Roof style: ' + roofStyleText + '\n' +
                '- Roof pitch: ' + pitch + ' degrees\n' +
                '- House connection: ' + attachmentText + '\n\n' +
                'ROOFING:\n' + sheetDesc + '\n\n' +
                'STEEL FRAME:\n' + steelDesc + '\n\n' +
                'SCENE:\n' + sceneDesc + lShapeDesc + wrapDesc + '\n\n' +
                'COLORBOND COLOUR ACCURACY (CRITICAL):\n' +
                'These are specific Australian BlueScope Colorbond colours. Get them right:\n' +
                '- Roof sheets: "' + roofColourName + '" â€” search for the real swatch if unsure\n' +
                '- Steel frame + gutters: "' + steelColourName + '" â€” search for the real swatch if unsure\n' +
                'Colorbond steel has a subtle satin/matte sheen. It is NOT glossy or mirror-like.\n\n' +
                'PHOTOREALISM REQUIREMENTS:\n' +
                '- Must look like a REAL PHOTOGRAPH taken with a DSLR camera, NOT a 3D render or CGI\n' +
                '- Lighting: late afternoon golden hour (Perth summer, ~5pm, warm light from the west)\n' +
                '- Camera: ' + (isCarport ? 'standing on the street/driveway looking toward the house' : 'standing in the backyard looking back toward the house at a 30-degree angle') + '\n' +
                '- The underside of the patio roof (the ceiling) must be clearly visible from this angle\n' +
                '- Show realistic cast shadows from the patio structure onto the ground\n' +
                '- Blue sky with a few wispy clouds\n' +
                '- Style: professional architectural photography, like an Australian home renovation magazine\n' +
                '- Resolution: high detail, sharp focus on the patio structure';

            // Copy to clipboard
            navigator.clipboard.writeText(prompt).then(function() {
                document.getElementById('promptInstructions').style.display = 'block';
                window.open('https://gemini.google.com/app', '_blank');
            }).catch(function(err) {
                // Fallback: show in a textarea for manual copy
                var ta = document.createElement('textarea');
                ta.value = prompt;
                ta.style.cssText = 'position:fixed;top:10%;left:10%;width:80%;height:60%;z-index:99999;font-size:12px;padding:12px';
                document.body.appendChild(ta);
                ta.select();
                alert('Could not copy to clipboard automatically. The prompt is shown in a text box â€” select all and copy manually.');
            });
        }

        // Initialize
        initLayout();
        initCollapseSections();
        initJobDetails();
        updateUI();
        initTruss3D();
        initAsm3D();
        initPricing();
        initFlashingEditor();
        rebuildAll();
        // Deferred resize to ensure renderers sync after DOM settles
        function deferredResize() {
            resizeAsm(); resizeTruss(); draw2DPlan();
        }
        requestAnimationFrame(deferredResize);
        setTimeout(deferredResize, 200);
        setTimeout(deferredResize, 500);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // QA VERIFICATION: Scope + Material Review System (Patio)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        var patioQA = {
            _acknowledgedFlags: new Set(),
            _signOffTimer: null,
            _currentFlags: [],
            _currentMode: 'scope',
            _verificationState: null, // stored on job data

            // â”€â”€ Helper: get pricing snapshot from DOM â”€â”€
            _getPricingSnapshot: function() {
                var matSell = 0, matCost = 0, labSell = 0, labCost = 0;
                jobRows.forEach(function(r) {
                    if (r.unit === 'nested') { matCost += r.unitCost; matSell += r.unitSell; }
                    else { var mult = (r.unit === 'LM') ? r.length : 1; matCost += r.qty * mult * r.unitCost; matSell += r.qty * mult * r.unitSell; }
                });
                var addMatCost = 0, addMatSell = 0;
                additionalMaterials.forEach(function(r) { if (r.desc || r.unitCost > 0 || r.unitSell > 0) { addMatCost += r.qty * r.unitCost; addMatSell += r.qty * r.unitSell; } });
                var lab = getLabourFromCard();
                labCost = lab.cost; labSell = lab.sell;
                var extrasCost = 0, extrasSell = 0;
                extrasRows.forEach(function(r) { extrasCost += r.qty * r.unitCost; extrasSell += r.qty * r.unitSell; });
                var demoCost = calculateDemoCost();
                var totalCost = matCost + addMatCost + labCost + extrasCost + demoCost;
                var totalSell = matSell + addMatSell + labSell + extrasSell + demoCost;
                var gst = totalSell * 0.10;
                var totalIncGST = totalSell + gst;
                var margin = totalSell - totalCost;
                var marginPct = totalSell > 0 ? (margin / totalSell * 100) : 0;
                return { matCost: matCost, matSell: matSell, addMatCost: addMatCost, addMatSell: addMatSell, labCost: labCost, labSell: labSell, extrasSell: extrasSell, demoCost: demoCost, totalCost: totalCost, totalSell: totalSell, gst: gst, totalIncGST: totalIncGST, margin: margin, marginPct: marginPct };
            },

            // â”€â”€ Run scoper verification checks (8 cards) â”€â”€
            runScopeChecks: function() {
                var flags = [];
                var c = calc;
                var jobData = gatherJobData();
                var pricing = this._getPricingSnapshot();

                // Card 1: Job & Client
                if (!jobData.client.name) flags.push({ id: 'P-J1', card: 'job', severity: 'red', message: 'Customer name is missing', field: 'customerName' });
                if (!jobData.client.address) flags.push({ id: 'P-J2', card: 'job', severity: 'red', message: 'Site address is missing', field: 'customerAddress' });
                if (!jobData.client.phone && !jobData.client.email) flags.push({ id: 'P-J3', card: 'job', severity: 'amber', message: 'No phone or email â€” need at least one contact method', field: 'customerPhone' });

                // Card 2: Design & Structure
                var sheetSpanKey = c.sheetSpanKey;
                var sheet = sheetSpanKey ? SHEET_SPANS[sheetSpanKey] : null;
                if (sheet && c.pitch < sheet.minPitch) flags.push({ id: 'P-D1', card: 'design', severity: 'red', message: roofingLabel(c.roofing) + ' requires min ' + sheet.minPitch + 'Â° pitch. Current: ' + c.pitch.toFixed(1) + 'Â°', field: 'inPitch' });
                if (sheet && sheet.battensRequired === false && c.W > sheet.maxSpan) flags.push({ id: 'P-D2', card: 'design', severity: 'red', message: 'Projection ' + c.W + 'mm exceeds max span ' + sheet.maxSpan + 'mm for ' + roofingLabel(c.roofing) + ' without battens', field: 'inWidth' });
                if (c.connection === 'flyover' && (c.roofing === 'solarspan75' || c.roofing === 'solarspan100')) {
                    // Flyover + insulated is unusual but not always wrong - just flag it
                }
                if (c.W > 6000) flags.push({ id: 'P-D3', card: 'design', severity: 'amber', message: 'Projection ' + c.W + 'mm exceeds 6m â€” verify structural design', field: 'inWidth' });
                if (c.postH < 2100) flags.push({ id: 'P-D4', card: 'design', severity: 'amber', message: 'Post height ' + c.postH + 'mm is below 2.1m â€” check clearance', field: 'inPostHeight' });
                if (c.postH > 3500) flags.push({ id: 'P-D5', card: 'design', severity: 'amber', message: 'Post height ' + c.postH + 'mm exceeds 3.5m â€” may need engineering', field: 'inPostHeight' });

                // Card 3: Rafters, Trusses & Battens
                if (c.battenCalc && c.battenCalc.battensNeeded >= 3) flags.push({ id: 'P-B1', card: 'battens', severity: 'amber', message: c.battenCalc.battensNeeded + ' batten rows needed â€” consider a longer-spanning sheet', field: 'inRoofing' });
                if (c.nTruss > 0) {
                    var trussSpacing = c.nTruss > 1 ? Math.round(c.L / (c.nTruss - 1)) : c.L;
                    if (trussSpacing > 3000) flags.push({ id: 'P-B2', card: 'battens', severity: 'amber', message: 'Truss spacing ' + trussSpacing + 'mm exceeds 3m', field: 'inTrusses' });
                    if (trussSpacing < 600) flags.push({ id: 'P-B3', card: 'battens', severity: 'amber', message: 'Truss spacing ' + trussSpacing + 'mm is very tight (<600mm)', field: 'inTrusses' });
                }

                // Card 4: Colours & Finish
                if (sheetColor.name !== steelColor.name && sheetColor.name !== flashingColor.name) {
                    // All three different â€” might be intentional but flag it
                }
                if (sheetColor.name !== flashingColor.name) flags.push({ id: 'P-C1', card: 'colours', severity: 'amber', message: 'Sheet colour (' + sheetColor.name + ') differs from flashing colour (' + flashingColor.name + ')', field: null });

                // Card 5: Sheets & Coverage
                if (c.sheetCalc) {
                    var coverage = c.sheetCalc.totalSheets * c.sheetCalc.coverWidth;
                    if (coverage < c.L && c.sheetCalc.totalSheets > 0) flags.push({ id: 'P-S1', card: 'sheets', severity: 'red', message: 'Sheet coverage ' + coverage + 'mm is less than patio length ' + c.L + 'mm', field: null });
                }
                var area = (c.W * c.L) / 1000000; // mÂ²
                var minDP = Math.ceil(area / 47);
                var actualDP = c.dpCount || 0;
                if (actualDP < minDP) flags.push({ id: 'P-S2', card: 'sheets', severity: 'amber', message: 'Only ' + actualDP + ' downpipes for ' + area.toFixed(1) + 'mÂ² â€” recommend at least ' + minDP + ' (area Ã· 47)', field: null });

                // Card 6: Flashings
                flashingProfiles.forEach(function(fp, i) {
                    if (fp.length && c.frameBeam) {
                        var beamLen = c.L;
                        if (fp.length < beamLen && fp.name && fp.name.toLowerCase().indexOf('beam') >= 0) {
                            flags.push({ id: 'P-F' + i + '-1', card: 'flashings', severity: 'amber', message: 'Flashing "' + fp.name + '" (' + fp.length + 'mm) shorter than beam (' + beamLen + 'mm)', field: null });
                        }
                    }
                    if (fp.colour && fp.colour !== flashingColor.name) {
                        flags.push({ id: 'P-F' + i + '-2', card: 'flashings', severity: 'amber', message: 'Flashing "' + fp.name + '" colour (' + fp.colour + ') differs from flashing colour setting (' + flashingColor.name + ')', field: null });
                    }
                });

                // Card 7: Site Documentation & Extras
                if (sitePhotos.length < 5) flags.push({ id: 'P-DOC1', card: 'docs', severity: 'amber', message: 'Only ' + sitePhotos.length + ' photos â€” recommend at least 5', field: null });
                if (!siteVideo) flags.push({ id: 'P-DOC2', card: 'docs', severity: 'blue', message: 'No video walkthrough attached', field: null });
                if (jobData.existingSite.electrical && jobData.existingSite.electrical !== 'none') {
                    var hasElecCost = extrasRows.some(function(r) { return r.desc && r.desc.toLowerCase().indexOf('elec') >= 0 && r.unitSell > 0; });
                    if (!hasElecCost) flags.push({ id: 'P-DOC3', card: 'docs', severity: 'amber', message: 'Electrical work selected but no electrical cost in extras', field: null });
                }

                // Card 8: Pricing
                if (pricing.totalSell < pricing.matCost + pricing.addMatCost) flags.push({ id: 'P-PR1', card: 'pricing', severity: 'red', message: 'Sell price is below material cost â€” job will lose money', field: null });
                if (pricing.marginPct > 0 && pricing.marginPct < 20) flags.push({ id: 'P-PR2', card: 'pricing', severity: 'amber', message: 'Margin is ' + pricing.marginPct.toFixed(1) + '% â€” below 20% target', field: null });
                var labTrades = parseInt(document.getElementById('labTrades')?.value) || 1;
                var labDays = parseFloat(document.getElementById('labDays')?.value) || 1;
                var labDayRate = parseFloat(document.getElementById('labDayRate')?.value) || 0;
                if (labDayRate > 0 && labDayRate < 300) flags.push({ id: 'P-PR3', card: 'pricing', severity: 'amber', message: 'Labour day rate $' + labDayRate + ' is below $300/day/trade minimum', field: 'labDayRate' });

                return flags;
            },

            // â”€â”€ Run material review checks (4 cards) â”€â”€
            runMaterialChecks: function() {
                var flags = [];
                var c = calc;
                var groups = buildSupplierRows();

                // Card M1: Steel Order
                if (c.frameBeam) {
                    // Basic beam span check â€” flag if beam seems undersized
                    var beamSpan = c.nPosts > 1 ? Math.round(c.L / (c.nPosts - 1)) : c.L;
                    if (beamSpan > 5600 && c.frameBeam.label && c.frameBeam.label.indexOf('150x50') >= 0) {
                        flags.push({ id: 'P-MS1', card: 'msteel', severity: 'red', message: 'Beam span ' + beamSpan + 'mm may exceed capacity for ' + c.frameBeam.name + '. Check engineering tables.', field: null });
                    }
                }

                // Card M2: Sheets & Flashings
                if (c.sheetCalc) {
                    var coverage = c.sheetCalc.totalSheets * c.sheetCalc.coverWidth;
                    if (coverage < c.L && c.sheetCalc.totalSheets > 0) flags.push({ id: 'P-MS2', card: 'msheets', severity: 'red', message: 'Sheet coverage ' + coverage + 'mm is less than patio length ' + c.L + 'mm', field: null });
                }
                flashingProfiles.forEach(function(fp, i) {
                    if (fp.colour && fp.colour !== flashingColor.name) flags.push({ id: 'P-MF' + i, card: 'msheets', severity: 'amber', message: 'Flashing "' + fp.name + '" colour (' + fp.colour + ') differs from flashing colour setting', field: null });
                    if (fp.length && fp.length < c.L && fp.name && fp.name.toLowerCase().indexOf('beam') >= 0) flags.push({ id: 'P-MFL' + i, card: 'msheets', severity: 'amber', message: 'Flashing "' + fp.name + '" length (' + fp.length + 'mm) shorter than beam length (' + c.L + 'mm)', field: null });
                });

                // Card M3: Gutters, Downpipes & Fixings
                var area = (c.W * c.L) / 1000000;
                var minDP = Math.ceil(area / 47);
                var actualDP = c.dpCount || 0;
                if (actualDP < minDP) flags.push({ id: 'P-MGD1', card: 'mgutter', severity: 'amber', message: 'Only ' + actualDP + ' downpipes for ' + area.toFixed(1) + 'mÂ² â€” recommend ' + minDP, field: null });

                return flags;
            },

            // â”€â”€ Render a QA card â”€â”€
            renderCard: function(title, kvRows, flags, options) {
                options = options || {};
                var cardFlags = flags || [];
                var reds = cardFlags.filter(function(f) { return f.severity === 'red'; }).length;
                var ambers = cardFlags.filter(function(f) { return f.severity === 'amber'; }).length;
                var blues = cardFlags.filter(function(f) { return f.severity === 'blue'; }).length;

                var severity = 'green';
                if (reds > 0) severity = 'red';
                else if (ambers > 0) severity = 'amber';
                else if (blues > 0) severity = 'blue';

                var badgeClass = 'pass', badgeText = 'âœ“ Pass';
                if (reds > 0) { badgeClass = 'fail'; badgeText = 'âœ— ' + reds + ' issue' + (reds > 1 ? 's' : ''); }
                else if (ambers > 0) { badgeClass = 'warn'; badgeText = 'âš  ' + ambers + ' warning' + (ambers > 1 ? 's' : ''); }
                else if (blues > 0) { badgeClass = 'info'; badgeText = 'â„¹ ' + blues + ' note' + (blues > 1 ? 's' : ''); }

                var kvHtml = '';
                (kvRows || []).forEach(function(kv) {
                    var valueHtml = kv.value;
                    if (kv.swatch) valueHtml = '<span class="qa-swatch" style="background:' + kv.swatch + '"></span>' + valueHtml;
                    kvHtml += '<div class="qa-kv"><span class="qa-kv-label">' + kv.label + '</span><span class="qa-kv-value">' + valueHtml + '</span></div>';
                });

                var flagHtml = '';
                var self = this;
                cardFlags.forEach(function(f) {
                    if (f.severity === 'red') {
                        var fixAttr = f.field ? ' onclick="patioQA.fixIssue(\'' + f.field + '\')"' : '';
                        flagHtml += '<div class="qa-flag red"><span class="qa-flag-text">' + f.message + '</span>' + (f.field ? '<button class="qa-fix-btn"' + fixAttr + '>Fix</button>' : '') + '</div>';
                    } else if (f.severity === 'amber') {
                        var checked = self._acknowledgedFlags.has(f.id) ? ' checked' : '';
                        flagHtml += '<div class="qa-flag amber"><span class="qa-flag-text">' + f.message + '</span><label class="qa-ack-label"><input type="checkbox"' + checked + ' onchange="patioQA.acknowledgeFlag(\'' + f.id + '\', this.checked)">Noted</label></div>';
                    } else if (f.severity === 'blue') {
                        flagHtml += '<div class="qa-flag blue"><span class="qa-flag-text">' + f.message + '</span></div>';
                    }
                });

                var extraHtml = options.extraHtml || '';
                return '<div class="qa-card severity-' + severity + '">' +
                    '<div class="qa-card-header"><span class="qa-card-title">' + title + '</span><span class="qa-card-badge ' + badgeClass + '">' + badgeText + '</span></div>' +
                    '<div class="qa-card-body">' + kvHtml + flagHtml + extraHtml + '</div>' +
                    '</div>';
            },

            // â”€â”€ Show scope verification overlay (8 cards) â”€â”€
            showScopeVerification: function() {
                this._acknowledgedFlags = new Set();
                var flags = this.runScopeChecks();
                this._currentFlags = flags;
                this._currentMode = 'scope';

                var c = calc;
                var jobData = gatherJobData();
                var pricing = this._getPricingSnapshot();
                var cardsEl = document.getElementById('qaScopeCards');
                var html = '';

                // Card 1: Job & Client
                html += this.renderCard('Job & Client', [
                    { label: 'Job Ref', value: jobData.client.jobRef || 'â€”' },
                    { label: 'Name', value: jobData.client.name || 'â€”' },
                    { label: 'Address', value: jobData.client.address || 'â€”' },
                    { label: 'Phone', value: jobData.client.phone || 'â€”' },
                    { label: 'Email', value: jobData.client.email || 'â€”' },
                    { label: 'Salesperson', value: jobData.client.salesperson || 'â€”' }
                ], flags.filter(function(f) { return f.card === 'job'; }));

                // Card 2: Design & Structure
                var connLabel = c.connection ? (c.connection.charAt(0).toUpperCase() + c.connection.slice(1)) : 'â€”';
                var postName = c.framePost ? c.framePost.name : 'â€”';
                var beamName = c.frameBeam ? c.frameBeam.name : 'â€”';
                html += this.renderCard('Design & Structure', [
                    { label: 'Roof Style', value: c.roofStyle || 'â€”' },
                    { label: 'Dimensions', value: c.L + ' Ã— ' + c.W + 'mm' },
                    { label: 'Post Height', value: c.postH + 'mm' },
                    { label: 'Pitch', value: c.pitch.toFixed(1) + 'Â°' },
                    { label: 'Connection', value: connLabel },
                    { label: 'Roofing', value: roofingLabel(c.roofing) },
                    { label: 'BMT', value: c.sheetBMT || 'â€”' },
                    { label: 'Posts', value: c.nPosts + 'Ã— ' + postName },
                    { label: 'Beams', value: beamName },
                    { label: 'Post Fix', value: c.postFix || 'concrete' }
                ], flags.filter(function(f) { return f.card === 'design'; }));

                // Card 3: Rafters, Trusses & Battens
                var battenMsg = c.battenCalc ? c.battenCalc.message : 'N/A';
                var rafterQty = c.rafterCalc ? c.rafterCalc.rafterCount : c.nRafters;
                var rafterSpacing = c.rafterSpacing || 'â€”';
                html += this.renderCard('Rafters, Trusses & Battens', [
                    { label: 'Rafters', value: rafterQty + 'Ã— ' + (c.rafterSize ? c.rafterSize.name : 'â€”') },
                    { label: 'Rafter Spacing', value: rafterSpacing + 'mm' },
                    { label: 'Trusses', value: c.nTruss + 'Ã— ' + (c.steel ? c.steel.name : 'â€”') },
                    { label: 'Battens', value: battenMsg },
                    { label: 'Purlins', value: c.purlinSize ? c.purlinSize.name : 'N/A' }
                ], flags.filter(function(f) { return f.card === 'battens'; }));

                // Card 4: Colours & Finish
                html += this.renderCard('Colours & Finish', [
                    { label: 'Sheet Colour', value: sheetColor.name, swatch: sheetColor.hex },
                    { label: 'Steel Colour', value: steelColor.name, swatch: steelColor.hex },
                    { label: 'Flashing Colour', value: flashingColor.name, swatch: flashingColor.hex },
                    { label: 'Ceiling Finish', value: c.ceilingFinish || 'â€”' }
                ], flags.filter(function(f) { return f.card === 'colours'; }));

                // Card 5: Sheets & Coverage
                var sheetQty = c.sheetCalc ? c.sheetCalc.totalSheets : 'â€”';
                var sheetLen = c.rafter ? Math.round(c.rafter) : 'â€”';
                var dpCount = c.dpCount || 0;
                var sheetCoverage = c.sheetCalc ? (c.sheetCalc.totalSheets * c.sheetCalc.coverWidth) : 'â€”';
                html += this.renderCard('Sheets & Coverage', [
                    { label: 'Sheet Type', value: roofingLabel(c.roofing) },
                    { label: 'Sheets', value: sheetQty + 'Ã— @ ' + sheetLen + 'mm rafter length' },
                    { label: 'Cover Width', value: c.sheetCalc ? c.sheetCalc.coverWidth + 'mm per sheet' : 'â€”' },
                    { label: 'Total Coverage', value: sheetCoverage + 'mm (patio length: ' + c.L + 'mm)' },
                    { label: 'Downpipes', value: dpCount + '' }
                ], flags.filter(function(f) { return f.card === 'sheets'; }));

                // Card 6: Flashings
                var flashKV = [];
                flashingProfiles.forEach(function(fp) {
                    flashKV.push({ label: fp.name || 'Flashing', value: (fp.qty || 1) + 'Ã— ' + (fp.girth || 'â€”') + 'mm girth, ' + (fp.length || 'â€”') + 'mm L, ' + (fp.gauge || 'â€”') + ' gauge, ' + (fp.colour || 'â€”') });
                });
                if (flashKV.length === 0) flashKV.push({ label: 'Flashings', value: 'None defined' });
                html += this.renderCard('Flashings', flashKV, flags.filter(function(f) { return f.card === 'flashings'; }));

                // Card 7: Site Documentation & Extras
                var docKV = [
                    { label: 'Photos', value: sitePhotos.length + ' captured' },
                    { label: 'Video', value: siteVideo ? 'Yes' : 'None' }
                ];
                if (jobData.existingSite.electrical && jobData.existingSite.electrical !== 'none') docKV.push({ label: 'Electrical', value: jobData.existingSite.electrical });
                if (jobData.scope.scopeDemo) docKV.push({ label: 'Demolition', value: 'Yes' });
                if (jobData.scope.scopePermit) docKV.push({ label: 'Permit Required', value: 'Yes' });
                var photoStripHtml = '';
                if (sitePhotos.length > 0) {
                    photoStripHtml = '<div class="qa-photo-strip">';
                    sitePhotos.forEach(function(p) { photoStripHtml += '<img src="' + p.dataUrl + '" alt="' + (p.label || 'Site photo') + '" title="' + (p.label || '') + '">'; });
                    photoStripHtml += '</div>';
                }
                html += this.renderCard('Site Documentation & Extras', docKV, flags.filter(function(f) { return f.card === 'docs'; }), { extraHtml: photoStripHtml });

                // Card 8: Pricing
                var fmtS = function(v) { return '$' + Math.round(v).toLocaleString(); };
                html += this.renderCard('Pricing', [
                    { label: 'Materials', value: fmtS(pricing.matSell + pricing.addMatSell) },
                    { label: 'Labour', value: fmtS(pricing.labSell) },
                    { label: 'Extras', value: fmtS(pricing.extrasSell + pricing.demoCost) },
                    { label: 'Subtotal (ex GST)', value: fmtS(pricing.totalSell) },
                    { label: 'GST', value: fmtS(pricing.gst) },
                    { label: 'Total (inc GST)', value: fmtS(pricing.totalIncGST) },
                    { label: 'Margin', value: pricing.marginPct.toFixed(1) + '%' }
                ], flags.filter(function(f) { return f.card === 'pricing'; }));

                cardsEl.innerHTML = html;
                this._updateOverlayState('scope');
                var overlay = document.getElementById('qaScopeOverlay');
                overlay.classList.add('active');
                overlay.querySelector('.qa-overlay-inner').scrollTop = 0;
                document.body.classList.add('qa-body-locked');
            },

            // â”€â”€ Show material review overlay (4 cards) â”€â”€
            showMaterialReview: function() {
                this._acknowledgedFlags = new Set();
                var flags = this.runMaterialChecks();
                this._currentFlags = flags;
                this._currentMode = 'material';

                var c = calc;
                var groups = buildSupplierRows();
                var cardsEl = document.getElementById('qaMaterialCards');
                var html = '';

                // Card M1: Steel Order
                var steelKV = [];
                if (c.framePost) steelKV.push({ label: 'Posts', value: c.nPosts + 'Ã— ' + c.framePost.name });
                if (c.frameBeam) steelKV.push({ label: 'Beams', value: c.frameBeam.name });
                if (c.rafterSize) steelKV.push({ label: 'Rafters', value: (c.rafterCalc ? c.rafterCalc.rafterCount : c.nRafters) + 'Ã— ' + c.rafterSize.name });
                if (c.nTruss > 0 && c.steel) steelKV.push({ label: 'Trusses', value: c.nTruss + 'Ã— ' + c.steel.name });
                if (c.purlinSize) steelKV.push({ label: 'Purlins', value: c.purlinSize.name });
                steelKV.push({ label: 'Steel Colour', value: steelColor.name, swatch: steelColor.hex });
                if (groups.steel && groups.steel.length > 0) {
                    groups.steel.forEach(function(row) {
                        // row = [desc, size, lengthM, qty, colour, note]
                        steelKV.push({ label: row[0] || '', value: row[3] + 'Ã— ' + (row[1] || '') + ' @ ' + (row[2] || '') + (row[5] ? ' (' + row[5] + ')' : '') });
                    });
                }
                html += this.renderCard('Steel Order', steelKV, flags.filter(function(f) { return f.card === 'msteel'; }));

                // Card M2: Sheets & Flashings
                var sheetKV = [
                    { label: 'Sheet Type', value: roofingLabel(c.roofing) },
                    { label: 'Sheet Colour', value: sheetColor.name, swatch: sheetColor.hex }
                ];
                if (c.sheetCalc) {
                    sheetKV.push({ label: 'Sheets', value: c.sheetCalc.totalSheets + 'Ã— @ ' + Math.round(c.rafter || 0) + 'mm rafter length' });
                    sheetKV.push({ label: 'Cover Width', value: c.sheetCalc.coverWidth + 'mm per sheet' });
                }
                flashingProfiles.forEach(function(fp) {
                    sheetKV.push({ label: fp.name || 'Flashing', value: (fp.qty || 1) + 'Ã— ' + (fp.girth || 'â€”') + 'mm girth, ' + (fp.length || 'â€”') + 'mm, ' + (fp.colour || 'â€”') + ', ' + (fp.gauge || 'â€”') + 'ga' });
                });
                html += this.renderCard('Sheets & Flashings', sheetKV, flags.filter(function(f) { return f.card === 'msheets'; }));

                // Card M3: Gutters, Downpipes & Fixings
                var gutterKV = [];
                gutterKV.push({ label: 'Downpipes', value: (c.dpCount || 0) + '' });
                if (c.battenCalc && c.battenCalc.battensNeeded > 0) {
                    gutterKV.push({ label: 'Batten Brackets', value: (c.bracketCalc ? c.bracketCalc.bracketsNeeded : 'â€”') + '' });
                }
                html += this.renderCard('Gutters, Downpipes & Fixings', gutterKV, flags.filter(function(f) { return f.card === 'mgutter'; }));

                // Card M4: Order Preview â€” only if no reds
                var unresolvedReds = flags.filter(function(f) { return f.severity === 'red'; }).length;
                if (unresolvedReds === 0) {
                    var orderText = this._buildOrderPreviewText(groups, c);
                    html += this.renderCard('Order Preview', [], [], {
                        extraHtml: '<div class="qa-order-preview">' + orderText + '</div>' +
                            '<div class="qa-order-actions">' +
                            '<button class="qa-copy-btn" onclick="patioQA.copySection(\'steel\')">Copy Steel</button>' +
                            '<button class="qa-copy-btn" onclick="patioQA.copySection(\'sheets\')">Copy Sheets</button>' +
                            '<button class="qa-copy-btn" onclick="patioQA.copySection(\'fab\')">Copy Fab</button>' +
                            '<button class="qa-pdf-btn" onclick="downloadMaterialOrderPDF()">Download PDF</button>' +
                            '</div>'
                    });
                } else {
                    html += this.renderCard('Order Preview', [
                        { label: 'Status', value: 'Fix red issues above to preview order' }
                    ], [{ id: 'P-M4-LOCKED', card: 'morder', severity: 'red', message: unresolvedReds + ' issue' + (unresolvedReds > 1 ? 's' : '') + ' must be resolved before order can be previewed' }]);
                }

                cardsEl.innerHTML = html;
                this._updateOverlayState('material');
                var overlay = document.getElementById('qaMaterialOverlay');
                overlay.classList.add('active');
                overlay.querySelector('.qa-overlay-inner').scrollTop = 0;
                document.body.classList.add('qa-body-locked');
            },

            // â”€â”€ Build plain-text order preview â”€â”€
            _buildOrderPreviewText: function(groups, c) {
                var jobRef = (document.getElementById('jobRef')?.value || '').trim() || 'â€”';
                var name = (document.getElementById('customerName')?.value || '').trim() || 'â€”';
                var txt = '';
                txt += 'SECUREWORKS WA â€” Material Order\n';
                txt += 'Job: ' + jobRef + ' | ' + name + '\n';
                txt += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
                txt += 'STEEL:\n';
                // Each row = [desc, size, lengthM, qty, colour, note]
                if (groups.steel) groups.steel.forEach(function(r) { txt += '  ' + r[3] + 'Ã— ' + r[0] + ' ' + r[1] + ' @ ' + r[2] + (r[5] ? ' (' + r[5] + ')' : '') + '\n'; });
                txt += '\nSHEETS & FLASHINGS:\n';
                if (groups.sheets) groups.sheets.forEach(function(r) { txt += '  ' + r[3] + 'Ã— ' + r[0] + ' ' + r[2] + ' ' + r[4] + '\n'; });
                if (groups.fabrication && groups.fabrication.length > 0) {
                    txt += '\nFABRICATION:\n';
                    groups.fabrication.forEach(function(r) { txt += '  ' + r[3] + 'Ã— ' + r[0] + ' ' + r[2] + '\n'; });
                }
                return txt;
            },

            // â”€â”€ Copy section to clipboard â”€â”€
            copySection: function(section) {
                copySectionToClipboard(section);
            },

            // â”€â”€ Acknowledge an amber flag â”€â”€
            acknowledgeFlag: function(id, checked) {
                if (checked) this._acknowledgedFlags.add(id);
                else this._acknowledgedFlags.delete(id);
                this._updateOverlayState(this._currentMode);
            },

            // â”€â”€ Fix issue: close overlay, scroll to field â”€â”€
            fixIssue: function(field) {
                this.closeOverlay(this._currentMode);
                setTimeout(function() {
                    var el = document.getElementById(field);
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        el.focus();
                        el.style.outline = '3px solid #EF4444';
                        setTimeout(function() { el.style.outline = ''; }, 3000);
                    }
                }, 300);
            },

            // â”€â”€ Update overlay header summary and sign-off button state â”€â”€
            _updateOverlayState: function(mode) {
                var flags = this._currentFlags || [];
                var reds = flags.filter(function(f) { return f.severity === 'red'; }).length;
                var ambers = flags.filter(function(f) { return f.severity === 'amber'; }).length;
                var self = this;
                var unacknowledgedAmbers = flags.filter(function(f) { return f.severity === 'amber' && !self._acknowledgedFlags.has(f.id); }).length;

                var summaryEl = document.getElementById(mode === 'scope' ? 'qaScopeSummary' : 'qaMaterialSummary');
                var btnEl = document.getElementById(mode === 'scope' ? 'qaScopeSignOffBtn' : 'qaMaterialSignOffBtn');
                var infoEl = document.getElementById(mode === 'scope' ? 'qaScopeFooterInfo' : 'qaMaterialFooterInfo');

                if (reds > 0) {
                    summaryEl.innerHTML = '<span class="qa-count-red">' + reds + ' issue' + (reds > 1 ? 's' : '') + ' need fixing</span>' + (ambers > 0 ? ' Â· <span class="qa-count-amber">' + ambers + ' warning' + (ambers > 1 ? 's' : '') + '</span>' : '');
                } else if (unacknowledgedAmbers > 0) {
                    summaryEl.innerHTML = '<span class="qa-count-amber">' + unacknowledgedAmbers + ' warning' + (unacknowledgedAmbers > 1 ? 's' : '') + ' need acknowledgment</span>';
                } else {
                    summaryEl.innerHTML = '<span class="qa-count-green">All clear â€” ready to sign off</span>';
                }

                var canSignOff = reds === 0 && unacknowledgedAmbers === 0;
                btnEl.className = 'qa-signoff-btn ' + (canSignOff ? 'enabled' : 'disabled');
                btnEl.disabled = !canSignOff;
                infoEl.textContent = canSignOff ? '' : (reds > 0 ? 'Fix ' + reds + ' red issue' + (reds > 1 ? 's' : '') + ' to continue' : 'Acknowledge ' + unacknowledgedAmbers + ' warning' + (unacknowledgedAmbers > 1 ? 's' : ''));

                if (canSignOff) {
                    btnEl.disabled = true;
                    btnEl.className = 'qa-signoff-btn disabled';
                    clearTimeout(this._signOffTimer);
                    this._signOffTimer = setTimeout(function() {
                        btnEl.disabled = false;
                        btnEl.className = 'qa-signoff-btn enabled';
                    }, 1500);
                }
            },

            // â”€â”€ Scope sign-off â”€â”€
            scopeSignOff: function() {
                var btn = document.getElementById('qaScopeSignOffBtn');
                if (btn.disabled) return;

                var scoperName = prompt('Your name (for sign-off record):');
                if (!scoperName || !scoperName.trim()) return;

                this._verificationState = this._verificationState || {};
                this._verificationState.scoper = {
                    signedOff: true,
                    by: scoperName.trim(),
                    at: new Date().toISOString(),
                    amberAcknowledged: Array.from(this._acknowledgedFlags),
                    checksRun: this._currentFlags.reduce(function(acc, f) { acc[f.id] = { severity: f.severity, message: f.message }; return acc; }, {})
                };
                if (!this._verificationState.materialReview) {
                    this._verificationState.materialReview = { signedOff: false, by: null, at: null, checksRun: null };
                }

                // Save verification state to localStorage
                var jobRef = (document.getElementById('jobRef')?.value || '').trim() || 'draft';
                localStorage.setItem('patio-verification-' + jobRef, JSON.stringify(this._verificationState));

                // Also trigger save scope
                this.closeOverlay('scope');
                executeSaveScope();
                this._updateButtonStates();
                showToast('Scope signed off by ' + scoperName.trim() + '. Quote export unlocked.');
            },

            // â”€â”€ Material sign-off â”€â”€
            materialSignOff: function() {
                var btn = document.getElementById('qaMaterialSignOffBtn');
                if (btn.disabled) return;

                var reviewerName = prompt('Your name (for material review record):');
                if (!reviewerName || !reviewerName.trim()) return;

                this._verificationState = this._verificationState || {};
                this._verificationState.materialReview = {
                    signedOff: true,
                    by: reviewerName.trim(),
                    at: new Date().toISOString(),
                    checksRun: this._currentFlags.reduce(function(acc, f) { acc[f.id] = { severity: f.severity, message: f.message }; return acc; }, {})
                };

                var jobRef = (document.getElementById('jobRef')?.value || '').trim() || 'draft';
                localStorage.setItem('patio-verification-' + jobRef, JSON.stringify(this._verificationState));

                this.closeOverlay('material');
                this._updateButtonStates();
                showToast('Material order approved by ' + reviewerName.trim() + '. Export unlocked.');
            },

            // â”€â”€ Close overlay â”€â”€
            closeOverlay: function(mode) {
                var id = mode === 'scope' ? 'qaScopeOverlay' : 'qaMaterialOverlay';
                document.getElementById(id).classList.remove('active');
                document.body.classList.remove('qa-body-locked');
                clearTimeout(this._signOffTimer);
            },

            // â”€â”€ Update button lock/unlock states â”€â”€
            _updateButtonStates: function() {
                var v = this._verificationState || {};
                var scopeOk = v.scoper && v.scoper.signedOff;
                var materialOk = v.materialReview && v.materialReview.signedOff;

                // Quote buttons â€” locked until scope signed off
                var quoteBtn = document.getElementById('btnPatioQuotePDF');
                if (quoteBtn) {
                    if (scopeOk) {
                        quoteBtn.classList.remove('qa-locked-btn');
                    } else {
                        quoteBtn.classList.add('qa-locked-btn');
                    }
                }
                var emailBtn = document.getElementById('btnPatioEmailQuote');
                if (emailBtn) {
                    if (scopeOk) {
                        emailBtn.classList.remove('qa-locked-btn');
                    } else {
                        emailBtn.classList.add('qa-locked-btn');
                    }
                }

                var woBtn = document.getElementById('btnPatioWorkOrder');
                if (woBtn) {
                    if (materialOk) {
                        woBtn.classList.remove('qa-locked-btn');
                        woBtn.removeAttribute('data-tooltip');
                        woBtn.onclick = function() { generateWorkOrderPDF(); };
                    } else {
                        woBtn.classList.add('qa-locked-btn');
                        woBtn.setAttribute('data-tooltip', 'Pending material review');
                        woBtn.onclick = function(e) { e.preventDefault(); showToast('Work order locked â€” pending material review sign-off'); };
                    }
                }

                var matBtn = document.getElementById('btnPatioMaterialOrder');
                if (matBtn) {
                    if (materialOk) {
                        matBtn.classList.remove('qa-locked-btn');
                        matBtn.removeAttribute('data-tooltip');
                        matBtn.onclick = function() { generateMaterialOrder(); };
                    } else {
                        matBtn.classList.add('qa-locked-btn');
                        matBtn.setAttribute('data-tooltip', 'Pending material review');
                        matBtn.onclick = function(e) { e.preventDefault(); patioQA.showDraftPreview(); };
                    }
                }

                var reviewBtn = document.getElementById('btnPatioReviewMaterials');
                if (reviewBtn) {
                    reviewBtn.style.display = scopeOk && !materialOk ? 'inline-block' : 'none';
                }

                var banner = document.getElementById('patioQABanner');
                if (banner) {
                    if (scopeOk && !materialOk) {
                        banner.className = 'qa-review-banner';
                        banner.style.display = 'flex';
                        banner.innerHTML = '<span class="qa-banner-icon">âš </span><span class="qa-banner-text">Scope signed off by ' + v.scoper.by + ' on ' + new Date(v.scoper.at).toLocaleDateString('en-AU') + '. Material order pending review.</span><button class="qa-banner-btn" onclick="patioQA.showMaterialReview()">Review Materials</button>';
                    } else if (materialOk) {
                        banner.className = 'qa-approved-banner';
                        banner.style.display = 'block';
                        banner.innerHTML = 'âœ“ Materials approved by ' + v.materialReview.by + ' on ' + new Date(v.materialReview.at).toLocaleDateString('en-AU') + '. Orders unlocked.';
                    } else {
                        banner.style.display = 'none';
                    }
                }
            },

            // â”€â”€ Show draft material order preview with watermark â”€â”€
            showDraftPreview: function() {
                var v = this._verificationState || {};
                var materialOk = v.materialReview && v.materialReview.signedOff;
                if (materialOk) {
                    generateMaterialOrder();
                    return;
                }
                // Show the material order options but with draft notice
                generateMaterialOrder();
                showToast('DRAFT preview â€” material order locked until reviewed and approved');
            },

            // â”€â”€ Initialize: load verification state â”€â”€
            init: function() {
                var jobRef = (document.getElementById('jobRef')?.value || '').trim();
                if (jobRef) {
                    var saved = localStorage.getItem('patio-verification-' + jobRef);
                    if (saved) {
                        try { this._verificationState = JSON.parse(saved); } catch(e) {}
                    }
                }
                this._updateButtonStates();
                var self = this;
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape' && self._currentMode) {
                        self.closeOverlay(self._currentMode);
                        self._currentMode = null;
                    }
                });
            }
        };

        // Initialize QA after DOM loads
        setTimeout(function() { patioQA.init(); }, 100);
    </script>

    <!-- QA Scope Verification Overlay -->
    <div class="qa-overlay" id="qaScopeOverlay" role="dialog" aria-modal="true" aria-labelledby="qaScopeTitle">
        <div class="qa-overlay-inner">
            <div class="qa-header">
                <div>
                    <h2 id="qaScopeTitle">Scope Verification</h2>
                    <div class="qa-header-summary" id="qaScopeSummary"></div>
                </div>
                <button class="qa-header-close" onclick="patioQA.closeOverlay('scope')" aria-label="Close">&times;</button>
            </div>
            <div class="qa-cards" id="qaScopeCards"></div>
        </div>
        <div class="qa-footer">
            <button class="qa-cancel-btn" onclick="patioQA.closeOverlay('scope')">Cancel</button>
            <div class="qa-footer-info" id="qaScopeFooterInfo"></div>
            <button class="qa-signoff-btn disabled" id="qaScopeSignOffBtn" onclick="patioQA.scopeSignOff()">Sign Off &amp; Save</button>
        </div>
    </div>

    <!-- QA Material Review Overlay -->
    <div class="qa-overlay" id="qaMaterialOverlay" role="dialog" aria-modal="true" aria-labelledby="qaMaterialTitle">
        <div class="qa-overlay-inner">
            <div class="qa-header">
                <div>
                    <h2 id="qaMaterialTitle">Material Order Review</h2>
                    <div class="qa-header-summary" id="qaMaterialSummary"></div>
                </div>
                <button class="qa-header-close" onclick="patioQA.closeOverlay('material')" aria-label="Close">&times;</button>
            </div>
            <div class="qa-cards" id="qaMaterialCards"></div>
        </div>
        <div class="qa-footer">
            <button class="qa-cancel-btn" onclick="patioQA.closeOverlay('material')">Cancel</button>
            <div class="qa-footer-info" id="qaMaterialFooterInfo"></div>
            <button class="qa-signoff-btn disabled" id="qaMaterialSignOffBtn" onclick="patioQA.materialSignOff()">Approve &amp; Unlock Orders</button>
        </div>
    </div>

    <!-- Save & Submit Overlay -->
    <div class="save-overlay" id="saveOverlay">
        <div class="save-overlay-card">
            <div class="save-overlay-hdr">
                <h3 id="saveOverlayTitle">Save Scope</h3>
                <button onclick="closeSaveOverlay()" style="background:none;border:none;font-size:18px;cursor:pointer;color:#999">&times;</button>
            </div>
            <div class="save-overlay-body" id="saveOverlayBody"></div>
            <div class="save-overlay-actions" id="saveOverlayActions"></div>
        </div>
    </div>

    <!-- Pending uploads badge -->
    <div class="pending-badge" id="pendingBadge" onclick="showPendingScopes()"></div>

<!-- â•â•â• Cloud Integration (Supabase) â•â•â• -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
  window.SUPABASE_URL = 'https://kevgrhcjxspbxgovpmfl.supabase.co';
  window.SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtldmdyaGNqeHNwYnhnb3ZwbWZsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIzNTQxMDUsImV4cCI6MjA4NzkzMDEwNX0.lPUEvx8u98WL86PcMNv8yfLnd6OQKzTUOCsRewfQiZc';
</script>
<script src="tools/shared/cloud.js"></script>
<script src="tools/shared/integration.js"></script>

</body>
</html>
