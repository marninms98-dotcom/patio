
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureWorks WA - Patio Designer Pro V18</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --sw-orange: #F15A29;
            --sw-blue-dark: #293C46;
            --sw-white: #FFFFFF;
            --sw-bg: #F5F5F7;
            --sw-border: #E5E5E5;
            --sw-text: #1D1D1F;
            --sw-text-sec: #86868B;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: var(--sw-bg);
            color: var(--sw-text);
        }
        .header {
            background: var(--sw-white);
            border-bottom: 1px solid var(--sw-border);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo { display: flex; align-items: center; gap: 8px; }
        .logo-icon {
            width: 32px; height: 32px;
            background: var(--sw-orange);
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
        }
        .logo-icon svg { width: 18px; height: 18px; fill: white; }
        .logo-text { font-size: 16px; font-weight: 600; }
        .logo-text span { color: var(--sw-orange); }
        .job-badge { background: var(--sw-bg); padding: 6px 14px; border-radius: 16px; font-size: 13px; }
        .job-badge strong { color: var(--sw-orange); }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }
        .btn-primary { background: var(--sw-orange); color: white; }
        .btn-secondary { background: var(--sw-bg); color: var(--sw-text); border: 1px solid var(--sw-border); }
        .main { max-width: 1400px; margin: 0 auto; padding: 24px; }
        .section {
            background: var(--sw-white);
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 1px 8px rgba(0,0,0,0.04);
            overflow: hidden;
        }
        .section-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--sw-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .section-title { font-size: 16px; font-weight: 600; }
        .section-subtitle { font-size: 12px; color: var(--sw-text-sec); }
        .section-body { padding: 20px; }

        .setup-grid { display: grid; grid-template-columns: 320px 1fr 280px; gap: 20px; }
        .options-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 16px; }
        .setup-card { background: var(--sw-bg); border-radius: 10px; padding: 14px; }
        .setup-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 10px; }
        .field { margin-bottom: 10px; }
        .field-label { display: flex; justify-content: space-between; font-size: 12px; font-weight: 500; margin-bottom: 3px; }
        .field-unit { font-size: 10px; color: var(--sw-text-sec); }
        .field-input { width: 100%; padding: 7px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; }
        .field-input:focus { outline: none; border-color: var(--sw-orange); }
        .field-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .plan-2d { background: #EEF1F4; border-radius: 8px; height: 220px; }
        .plan-2d canvas { width: 100%; height: 100%; }
        .color-chips { display: flex; flex-wrap: wrap; gap: 5px; }
        .color-chip { width: 24px; height: 24px; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
        .color-chip.active { border-color: var(--sw-text); }
        .color-label { font-size: 11px; color: var(--sw-text-sec); margin-top: 6px; }
        .calc-display { background: var(--sw-blue-dark); border-radius: 8px; padding: 10px; margin-top: 10px; color: white; }
        .calc-row { display: flex; justify-content: space-between; font-size: 11px; padding: 3px 0; }
        .calc-label { opacity: 0.7; }
        .calc-value { font-weight: 600; font-family: 'SF Mono', monospace; color: var(--sw-orange); }

        .truss-grid { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .truss-viewport { background: linear-gradient(180deg, #E0E4E8 0%, #CED4DA 100%); border-radius: 10px; height: 420px; position: relative; }
        .truss-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .truss-viewport canvas:active { cursor: grabbing; }
        .truss-view-btns { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.9); padding: 3px; border-radius: 6px; }
        .truss-view-btn { padding: 5px 10px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .truss-view-btn.active { background: var(--sw-blue-dark); color: white; }
        .truss-panel { display: flex; flex-direction: column; gap: 12px; }
        .truss-card { background: var(--sw-bg); border-radius: 10px; padding: 12px; }
        .truss-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .spec-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .spec-item { background: white; border-radius: 6px; padding: 8px; text-align: center; }
        .spec-label { font-size: 9px; color: var(--sw-text-sec); }
        .spec-value { font-size: 15px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .spec-value.hl { color: var(--sw-orange); }
        .fab-box { background: var(--sw-blue-dark); border-radius: 10px; padding: 12px; color: white; }
        .fab-box h4 { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; margin-bottom: 8px; }
        .fab-line { font-family: 'SF Mono', monospace; font-size: 11px; padding: 4px 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-bottom: 2px; }

        .asm-viewport { height: 520px; background: linear-gradient(180deg, #D4D9E0 0%, #BCC4CC 100%); border-radius: 10px; position: relative; }
        .asm-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .asm-viewport canvas:active { cursor: grabbing; }
        .asm-viewport.fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100vw; height: 100vh; z-index: 1000; border-radius: 0; }
        .layer-panel { position: absolute; top: 12px; left: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; min-width: 140px; }
        .layer-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .layer-item { display: flex; align-items: center; gap: 6px; padding: 4px 0; cursor: pointer; font-size: 11px; }
        .layer-check { width: 14px; height: 14px; border: 2px solid var(--sw-border); border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 9px; color: white; }
        .layer-item.active .layer-check { background: var(--sw-orange); border-color: var(--sw-orange); }
        .layer-item.active .layer-check::after { content: '✓'; }
        .mat-panel { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; width: 200px; }
        .mat-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .mat-row { display: flex; justify-content: space-between; font-size: 10px; padding: 3px 0; border-bottom: 1px solid var(--sw-border); }
        .mat-row:last-child { border-bottom: none; }
        .mat-qty { font-weight: 600; color: var(--sw-orange); }
        .view-panel { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.95); padding: 3px; border-radius: 6px; }
        .view-btn { padding: 5px 12px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .view-btn.active { background: var(--sw-blue-dark); color: white; }
        .fullscreen-btn { position: absolute; top: 12px; right: 230px; background: rgba(255,255,255,0.95); border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; font-size: 11px; }
        .tooltip { position: absolute; background: rgba(41,60,70,0.95); color: white; padding: 10px 14px; border-radius: 8px; font-size: 11px; pointer-events: none; opacity: 0; transition: opacity 0.15s; z-index: 50; max-width: 240px; }
        .tooltip.visible { opacity: 1; }
        .tooltip-title { font-weight: 600; font-size: 12px; color: var(--sw-orange); margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .tooltip-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .tooltip-label { opacity: 0.7; }
        .tooltip-value { font-weight: 500; font-family: 'SF Mono', monospace; }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon"><svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg></div>
            <div class="logo-text">Secure<span>Works</span> WA</div>
        </div>
        <div class="job-badge"><strong>SW1772</strong> &nbsp;Stefan Botha • Rockingham</div>
        <button class="btn btn-primary" onclick="exportOrder()">Export Order</button>
    </header>

    <main class="main">
        <!-- SECTION 1: JOB SETUP -->
        <div class="section">
            <div class="section-header">
                <div><div class="section-title">Job Setup</div><div class="section-subtitle">Configure patio dimensions</div></div>
            </div>
            <div class="section-body">
                <div class="setup-grid">
                    <div class="setup-card">
                        <h4>Patio Type</h4>
                        <div class="field">
                            <label class="field-label">Roof Style</label>
                            <select class="field-input" id="inRoofStyle" onchange="updateUI(); rebuildAll()">
                                <option value="gable">Gable</option>
                                <option value="skillion">Skillion</option>
                            </select>
                        </div>
                        <div class="field" id="orientationField">
                            <label class="field-label">Ridge Direction</label>
                            <select class="field-input" id="inOrientation" onchange="rebuildAll()">
                                <option value="lengthways">Along House (Ridge || House)</option>
                                <option value="perpendicular">Away from House (Ridge ⊥ House)</option>
                            </select>
                        </div>
                        <h4 style="margin-top:10px">Dimensions</h4>
                        <div class="field-row">
                            <div class="field">
                                <label class="field-label">Projection<span class="field-unit">mm</span></label>
                                <input type="number" class="field-input" id="inWidth" value="3000" oninput="rebuildAll()">
                            </div>
                            <div class="field">
                                <label class="field-label">Length<span class="field-unit">mm</span></label>
                                <input type="number" class="field-input" id="inLength" value="6000" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field" id="pitchField">
                                <label class="field-label">Pitch<span class="field-unit">°</span></label>
                                <input type="number" class="field-input" id="inPitch" value="10" step="0.5" oninput="rebuildAll()">
                            </div>
                            <div class="field">
                                <label class="field-label">Post Height<span class="field-unit">mm</span></label>
                                <input type="number" class="field-input" id="inPostHeight" value="2400" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field">
                                <label class="field-label">Posts (per side)</label>
                                <input type="number" class="field-input" id="inPosts" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="field" id="trussField">
                                <label class="field-label">Trusses</label>
                                <input type="number" class="field-input" id="inTrusses" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="field" id="rafterField" style="display:none">
                                <label class="field-label">Rafters</label>
                                <input type="number" class="field-input" id="inRafters" value="5" min="2" oninput="rebuildAll()">
                            </div>
                        </div>
                        <!-- Calculated values display -->
                        <div class="calc-display" id="calcDisplay">
                            <div class="calc-row"><span class="calc-label">Rise:</span><span class="calc-value" id="calcRise">--</span></div>
                            <div class="calc-row"><span class="calc-label">Rafter TRUE:</span><span class="calc-value" id="calcRafter">--</span></div>
                            <div class="calc-row" id="calcPitchRow" style="display:none"><span class="calc-label">Actual Pitch:</span><span class="calc-value" id="calcPitch">--</span></div>
                        </div>
                    </div>
                    <div class="setup-card">
                        <h4>2D Site Plan</h4>
                        <div class="plan-2d"><canvas id="plan2d"></canvas></div>
                    </div>
                    <div class="setup-card">
                        <h4>Materials</h4>
                        <div class="field">
                            <label class="field-label">Roof Sheeting</label>
                            <select class="field-input" id="inRoofing" onchange="rebuildAll()">
                                <option value="corrugated">Corrugated</option>
                                <option value="trimdek">Trimdek</option>
                                <option value="insulated">Insulated Panel (Bondor)</option>
                            </select>
                        </div>
                        <div class="field" id="gableInfillField">
                            <label class="field-label">Gable Infill</label>
                            <select class="field-input" id="inInfill" onchange="rebuildAll()">
                                <option value="colorbond">Colorbond</option>
                                <option value="twinwall">10mm Twinwall</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                        <div class="field">
                            <label class="field-label">Steel Size</label>
                            <select class="field-input" id="inTrussSteel" onchange="rebuildAll()">
                                <option value="76x38">76 × 38 × 1.6mm RHS</option>
                                <option value="100x50">100 × 50 × 2mm RHS</option>
                            </select>
                        </div>
                        <h4 style="margin-top:12px">Colours</h4>
                        <div style="font-size:11px; color: var(--sw-text-sec); margin-bottom:4px;">Sheets</div>
                        <div class="color-chips" id="sheetChips"></div>
                        <div class="color-label" id="sheetLabel">Monument</div>
                        <div style="font-size:11px; color: var(--sw-text-sec); margin-top:8px; margin-bottom:4px;">Steel</div>
                        <div class="color-chips" id="steelChips"></div>
                        <div class="color-label" id="steelLabel">Monument</div>
                    </div>
                </div>
                <div class="options-grid">
                    <div class="setup-card">
                        <h4>House Connection</h4>
                        <div class="field">
                            <label class="field-label">Type</label>
                            <select class="field-input" id="inConnection" onchange="updateUI(); rebuildAll()">
                                <option value="freestanding">Freestanding</option>
                                <option value="fascia">Receiving Channel (Fascia)</option>
                                <option value="wall">Receiving Channel (Wall)</option>
                                <option value="riser">Riser Beam</option>
                                <option value="flyover">Flyover</option>
                            </select>
                        </div>
                        <div class="field" id="fasciaHeightField" style="display:none">
                            <label class="field-label">House Fascia Height<span class="field-unit">mm</span></label>
                            <input type="number" class="field-input" id="inFasciaHeight" value="2700" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="riserHeightField" style="display:none">
                            <label class="field-label">Riser Height<span class="field-unit">mm</span></label>
                            <input type="number" class="field-input" id="inRiserHeight" value="400" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="riserOffsetField" style="display:none">
                            <label class="field-label">Riser Offset<span class="field-unit">mm</span></label>
                            <input type="number" class="field-input" id="inRiserOffset" value="150" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="houseGutterField" style="display:none">
                            <label class="field-label">House Gutter</label>
                            <select class="field-input" id="inHouseGutter" onchange="rebuildAll()">
                                <option value="quad">Existing Quad Gutter</option>
                                <option value="box">Replace with Box Gutter</option>
                            </select>
                        </div>
                    </div>
                    <div class="setup-card">
                        <h4>Construction</h4>
                        <div class="field">
                            <label class="field-label">Post Fixing</label>
                            <select class="field-input" id="inPostFix">
                                <option value="concrete">Concrete Footing (600mm)</option>
                                <option value="baseplate">Base Plate + Dynabolts</option>
                            </select>
                        </div>
                        <div class="field" id="trussStyleField">
                            <label class="field-label">Truss Style</label>
                            <select class="field-input" id="inTrussStyle" onchange="rebuildAll()">
                                <option value="open">Open (no web)</option>
                                <option value="king">King Post</option>
                                <option value="queen">Queen Post</option>
                            </select>
                        </div>
                    </div>
                    <div class="setup-card">
                        <h4>Notes</h4>
                        <textarea class="field-input" id="jobNotes" rows="4" placeholder="Job notes..."></textarea>
                    </div>
                </div>
            </div>
        </div>

        <!-- SECTION 2: TRUSS CALCULATOR (GABLE ONLY) -->
        <div class="section" id="section2">
            <div class="section-header">
                <div><div class="section-title">Gable Truss Calculator</div><div class="section-subtitle">Interactive 3D truss with fabrication specs</div></div>
            </div>
            <div class="section-body">
                <div class="truss-grid">
                    <div class="truss-viewport" id="trussViewport">
                        <canvas id="trussCanvas"></canvas>
                        <div class="truss-view-btns">
                            <button class="truss-view-btn active" onclick="setTrussView('3d',this)">3D</button>
                            <button class="truss-view-btn" onclick="setTrussView('front',this)">Front</button>
                            <button class="truss-view-btn" onclick="setTrussView('side',this)">Side</button>
                        </div>
                    </div>
                    <div class="truss-panel">
                        <div class="truss-card">
                            <h4>Truss Dimensions</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">A: Span (out-out)</div><div class="spec-value" id="specA">3000</div></div>
                                <div class="spec-item"><div class="spec-label">B: Rise</div><div class="spec-value" id="specB">264</div></div>
                                <div class="spec-item"><div class="spec-label">C: Rafter TRUE</div><div class="spec-value hl" id="specC">1523</div></div>
                                <div class="spec-item"><div class="spec-label">D: Pitch</div><div class="spec-value" id="specD">10°</div></div>
                            </div>
                        </div>
                        <div class="truss-card">
                            <h4>Cut Angles</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">Apex Cut</div><div class="spec-value" id="angleApex">80°</div></div>
                                <div class="spec-item"><div class="spec-label">Heel Cut</div><div class="spec-value" id="angleBase">10°</div></div>
                                <div class="spec-item"><div class="spec-label">Plumb Cut</div><div class="spec-value" id="anglePlumb">80°</div></div>
                                <div class="spec-item"><div class="spec-label">Level Cut</div><div class="spec-value" id="angleLevel">10°</div></div>
                            </div>
                        </div>
                        <div class="truss-card" id="webCard" style="display:none">
                            <h4>Web Members</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">King Post</div><div class="spec-value" id="webKing">--</div></div>
                                <div class="spec-item"><div class="spec-label">Queen Posts</div><div class="spec-value" id="webQueen">--</div></div>
                            </div>
                        </div>
                        <div class="fab-box">
                            <h4>✓ FABRICATOR CUT LIST</h4>
                            <div class="fab-line" id="fabSteel">Steel: 76×38×1.6 RHS</div>
                            <div class="fab-line" id="fabThick">Wall: 1.6mm BMT</div>
                            <div class="fab-line" style="margin-top:6px; border-top:1px solid rgba(255,255,255,0.2); padding-top:6px" id="fabChord">Bottom Chord: 3000mm</div>
                            <div class="fab-line" id="fabRafterOut">Rafter (out): 1523mm</div>
                            <div class="fab-line" id="fabRafterIn">Rafter (in): 1447mm</div>
                            <div class="fab-line" id="fabApexCut">Apex Mitre: 80°</div>
                            <div class="fab-line" id="fabHeelCut">Heel Mitre: 10°</div>
                            <div class="fab-line" id="fabWeb" style="display:none">Web: --</div>
                            <div class="fab-line" style="margin-top:6px; border-top:1px solid rgba(255,255,255,0.2); padding-top:6px" id="fabQty">Qty: 3 trusses</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SECTION 3: FULL ASSEMBLY -->
        <div class="section">
            <div class="section-header">
                <div><div class="section-title">Full Patio Assembly</div><div class="section-subtitle">Hover for dimensions • Toggle layers</div></div>
            </div>
            <div class="section-body" style="padding:0">
                <div class="asm-viewport" id="asmViewport">
                    <canvas id="asmCanvas"></canvas>
                    <button class="fullscreen-btn" onclick="toggleFullscreen()">⛶ Fullscreen</button>
                    <div class="layer-panel">
                        <div class="layer-title">Layers</div>
                        <div class="layer-item active" data-layer="steel" onclick="toggleLayer('steel',this)"><span class="layer-check"></span>Steel</div>
                        <div class="layer-item active" data-layer="roof" onclick="toggleLayer('roof',this)"><span class="layer-check"></span>Roofing</div>
                        <div class="layer-item active" data-layer="acc" onclick="toggleLayer('acc',this)"><span class="layer-check"></span>Gutters/DP</div>
                    </div>
                    <div class="mat-panel">
                        <div class="mat-title">Materials</div>
                        <div id="matList"></div>
                    </div>
                    <div class="tooltip" id="tooltip"><div class="tooltip-title" id="ttTitle"></div><div id="ttContent"></div></div>
                    <div class="view-panel">
                        <button class="view-btn active" onclick="setAsmView('3d',this)">3D</button>
                        <button class="view-btn" onclick="setAsmView('front',this)">Front</button>
                        <button class="view-btn" onclick="setAsmView('side',this)">Side</button>
                        <button class="view-btn" onclick="setAsmView('top',this)">Top</button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        /*
         * V18 FIXES:
         * 1. Downpipes - now extend from ground to actual gutter height (not postH)
         * 2. Gable sheets perpendicular - complete rotation rewrite for proper roof alignment
         * 3. Carry beam condition - removed for gable+fascia (trusses sit on fascia beam directly)
         * 4. Gable+riser beam stacking - riser beam now sits ON TOP of risers correctly
         */

        // ==================== CONFIG ====================
        const COLORS = [
            {name:'Monument',hex:'#2D3436'},{name:'Woodland Grey',hex:'#4B5D52'},{name:'Paperbark',hex:'#C4BAA2'},
            {name:'Surfmist',hex:'#E8E6E0'},{name:'Basalt',hex:'#5C5C5C'},{name:'Manor Red',hex:'#6B2D2D'},
            {name:'Deep Ocean',hex:'#1E3A4C'},{name:'Windspray',hex:'#7D8B8A'}
        ];
        const STEEL = {'76x38':{w:0.076,h:0.038,name:'76×38×1.6'},'100x50':{w:0.1,h:0.05,name:'100×50×2'}};

        const SHEET_COVERAGE = {
            corrugated: 762,
            trimdek: 762,
            spandek: 762,
            insulated: 1000
        };

        const SPAN_TABLES = {
            corrugated: { maxSpan: 1100, endSpan: 900, needsPurlins: true },
            trimdek: { maxSpan: 2100, endSpan: 1500, needsPurlins: true },
            spandek: { maxSpan: 2400, endSpan: 1800, needsPurlins: true },
            insulated: { maxSpan: 6000, endSpan: 6000, needsPurlins: false }
        };

        let sheetColor = COLORS[0];
        let steelColor = COLORS[0];
        let calc = {};

        // ==================== COLOR CHIPS ====================
        function initColorChips(containerId, labelId, setFn) {
            const container = document.getElementById(containerId);
            COLORS.forEach((c,i) => {
                const el = document.createElement('div');
                el.className = 'color-chip' + (i===0?' active':'');
                el.style.background = c.hex;
                el.title = c.name;
                el.onclick = () => {
                    setFn(c);
                    container.querySelectorAll('.color-chip').forEach(x=>x.classList.remove('active'));
                    el.classList.add('active');
                    document.getElementById(labelId).textContent = c.name;
                    rebuildAll();
                };
                container.appendChild(el);
            });
        }
        initColorChips('sheetChips', 'sheetLabel', c => sheetColor = c);
        initColorChips('steelChips', 'steelLabel', c => steelColor = c);

        // ==================== UI UPDATES ====================
        function updateUI() {
            const style = document.getElementById('inRoofStyle').value;
            const connSelect = document.getElementById('inConnection');
            let conn = connSelect.value;
            const isGable = style === 'gable';
            const isAttached = conn !== 'freestanding';

            document.getElementById('section2').style.display = isGable ? 'block' : 'none';
            document.getElementById('orientationField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussField').style.display = isGable ? 'block' : 'none';
            document.getElementById('rafterField').style.display = isGable ? 'none' : 'block';
            document.getElementById('gableInfillField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussStyleField').style.display = isGable ? 'block' : 'none';

            const showPitchInput = isGable || !isAttached;
            document.getElementById('pitchField').style.display = showPitchInput ? 'block' : 'none';
            document.getElementById('calcPitchRow').style.display = (!isGable && isAttached) ? 'flex' : 'none';

            // Fascia height needed for all attached types (sets connection height)
            document.getElementById('fasciaHeightField').style.display = isAttached ? 'block' : 'none';
            const showRiserOptions = conn === 'riser';
            document.getElementById('riserHeightField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserOffsetField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('houseGutterField').style.display = showRiserOptions ? 'block' : 'none';
        }

        // ==================== GET INPUTS & CALCULATE ====================
        function getInputs() {
            const roofStyle = document.getElementById('inRoofStyle').value;
            const orientation = document.getElementById('inOrientation').value;
            const projInput = parseFloat(document.getElementById('inWidth').value) || 3000;
            const lenInput = parseFloat(document.getElementById('inLength').value) || 6000;
            const userPitch = parseFloat(document.getElementById('inPitch').value) || 10;
            const postH = parseFloat(document.getElementById('inPostHeight').value) || 2400;
            const nPosts = parseInt(document.getElementById('inPosts').value) || 3;
            const nTruss = parseInt(document.getElementById('inTrusses').value) || 3;
            const nRafters = parseInt(document.getElementById('inRafters').value) || 5;
            const trussStyle = document.getElementById('inTrussStyle').value;
            const trussSteel = document.getElementById('inTrussSteel').value;
            const roofing = document.getElementById('inRoofing').value;
            const infill = document.getElementById('inInfill').value;
            const connection = document.getElementById('inConnection').value;
            const fasciaH = parseFloat(document.getElementById('inFasciaHeight').value) || 2700;
            const riserH = parseFloat(document.getElementById('inRiserHeight').value) || 400;
            const riserOffset = parseFloat(document.getElementById('inRiserOffset').value) || 150;
            const houseGutter = document.getElementById('inHouseGutter').value;

            const isGable = roofStyle === 'gable';
            const isAttached = connection !== 'freestanding';
            const hasFascia = (connection === 'fascia' || connection === 'riser' || connection === 'flyover');

            let W, L;
            if (isGable && orientation === 'perpendicular') {
                W = lenInput;
                L = projInput;
            } else {
                W = projInput;
                L = lenInput;
            }

            // ========== V18 FIX: BEAM HEIGHTS - Proper stacking for gable+riser ==========
            let frontBeamY = postH;
            const beamH = 50;  // 50mm beam height
            const riserMemberSize = 75;  // 75mm SHS riser members

            let backBeamY, fasciaBeamY;
            if (isGable) {
                if (connection === 'riser') {
                    // Gable + Riser: both beams at elevated riser height, posts extend to match
                    fasciaBeamY = fasciaH;
                    const elevatedBeamY = fasciaH + beamH + riserMemberSize + riserH;
                    frontBeamY = elevatedBeamY;
                    backBeamY = elevatedBeamY;
                } else if (connection === 'fascia' || connection === 'wall') {
                    // Gable + Fascia/Wall: both beams at fascia height, trusses sit flat
                    fasciaBeamY = connection === 'fascia' ? fasciaH : null;
                    frontBeamY = fasciaH;
                    backBeamY = fasciaH;
                } else if (connection === 'flyover') {
                    // Gable + Flyover: beams above existing house roof
                    fasciaBeamY = fasciaH;
                    const flyoverClearance = 100; // 100mm above house roof
                    const flyoverBeamY = fasciaH + 300 + flyoverClearance; // roof height estimate + clearance
                    frontBeamY = flyoverBeamY;
                    backBeamY = flyoverBeamY;
                } else {
                    // Freestanding - back beam at post height
                    backBeamY = postH;
                    fasciaBeamY = null;
                }
            } else {
                // SKILLION
                if (connection === 'freestanding') {
                    const rise = W * Math.tan(userPitch * Math.PI / 180);
                    backBeamY = postH + rise;
                    fasciaBeamY = null;
                } else if (connection === 'riser') {
                    fasciaBeamY = fasciaH;
                    backBeamY = fasciaH + beamH + riserMemberSize + riserH;
                } else if (connection === 'flyover') {
                    fasciaBeamY = fasciaH;
                    const flyoverClearance = 100;
                    backBeamY = fasciaH + 300 + flyoverClearance;
                } else {
                    // fascia or wall
                    fasciaBeamY = connection === 'fascia' ? fasciaH : null;
                    backBeamY = fasciaH;
                }
            }

            // ========== PITCH & RISE CALCULATION ==========
            let pitch, pitchRad, rise, rafter, trussSpan;

            if (isGable) {
                pitch = userPitch;
                pitchRad = pitch * Math.PI / 180;
                trussSpan = W;
                rise = (W / 2) * Math.tan(pitchRad);
                rafter = Math.sqrt((W / 2) ** 2 + rise ** 2);
            } else {
                rise = backBeamY - frontBeamY;
                pitch = Math.atan(rise / W) * 180 / Math.PI;
                pitchRad = pitch * Math.PI / 180;
                rafter = Math.sqrt(W ** 2 + rise ** 2);
                trussSpan = W;
            }

            calc = {
                roofStyle, orientation, W, L, projInput, lenInput, userPitch, pitch, pitchRad,
                postH, nPosts, nTruss, nRafters, trussStyle, trussSteel, trussSpan,
                roofing, infill, connection, fasciaH, riserH, riserOffset, houseGutter,
                rise, rafter, isGable, isAttached, hasFascia,
                frontBeamY, backBeamY, fasciaBeamY,
                steel: STEEL[trussSteel],
                sheetCoverage: SHEET_COVERAGE[roofing]
            };

            document.getElementById('calcRise').textContent = Math.round(rise) + 'mm';
            document.getElementById('calcRafter').textContent = Math.round(rafter) + 'mm';
            document.getElementById('calcPitch').textContent = pitch.toFixed(1) + '°';

            if (isGable) {
                const steelW = STEEL[trussSteel].w * 1000;
                const steelH = STEEL[trussSteel].h * 1000;
                const rafterInside = rafter - steelH;
                const apexAngle = 90 - pitch;
                const heelAngle = pitch;
                const kingPostH = rise - steelH;
                const queenPostH = rise * 0.6;
                const queenSpacing = trussSpan * 0.2;

                document.getElementById('specA').textContent = Math.round(trussSpan);
                document.getElementById('specB').textContent = Math.round(rise);
                document.getElementById('specC').textContent = Math.round(rafter);
                document.getElementById('specD').textContent = pitch + '°';

                document.getElementById('angleApex').textContent = apexAngle.toFixed(1) + '°';
                document.getElementById('angleBase').textContent = heelAngle.toFixed(1) + '°';
                document.getElementById('anglePlumb').textContent = (90 - pitch).toFixed(1) + '°';
                document.getElementById('angleLevel').textContent = pitch.toFixed(1) + '°';

                const showWeb = trussStyle === 'king' || trussStyle === 'queen';
                document.getElementById('webCard').style.display = showWeb ? 'block' : 'none';
                document.getElementById('fabWeb').style.display = showWeb ? 'block' : 'none';

                if (trussStyle === 'king') {
                    document.getElementById('webKing').textContent = Math.round(kingPostH) + 'mm';
                    document.getElementById('webQueen').textContent = '--';
                    document.getElementById('fabWeb').textContent = 'King Post: ' + Math.round(kingPostH) + 'mm';
                } else if (trussStyle === 'queen') {
                    document.getElementById('webKing').textContent = '--';
                    document.getElementById('webQueen').textContent = Math.round(queenPostH) + 'mm × 2';
                    document.getElementById('fabWeb').textContent = 'Queen Posts: ' + Math.round(queenPostH) + 'mm × 2 @ ±' + Math.round(queenSpacing) + 'mm';
                }

                document.getElementById('fabSteel').textContent = 'Steel: ' + STEEL[trussSteel].name + ' RHS';
                document.getElementById('fabThick').textContent = 'Wall: ' + (trussSteel === '76x38' ? '1.6' : '2.0') + 'mm BMT';
                document.getElementById('fabChord').textContent = 'Bottom Chord: ' + Math.round(trussSpan) + 'mm (out-out)';
                document.getElementById('fabRafterOut').textContent = 'Rafter (out): ' + Math.round(rafter) + 'mm TRUE';
                document.getElementById('fabRafterIn').textContent = 'Rafter (in): ' + Math.round(rafterInside) + 'mm';
                document.getElementById('fabApexCut').textContent = 'Apex Mitre: ' + apexAngle.toFixed(1) + '°';
                document.getElementById('fabHeelCut').textContent = 'Heel Mitre: ' + heelAngle.toFixed(1) + '°';
                document.getElementById('fabQty').textContent = 'Qty: ' + nTruss + ' trusses';
            }

            return calc;
        }

        // ==================== 2D PLAN ====================
        function draw2DPlan() {
            const canvas = document.getElementById('plan2d');
            const p = canvas.parentElement;
            canvas.width = p.clientWidth; canvas.height = p.clientHeight;
            const ctx = canvas.getContext('2d');
            const c = calc;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            const planL = c.lenInput;
            const planW = c.projInput;

            const scale = Math.min((canvas.width-60)/planL, (canvas.height-60)/planW) * 0.85;
            const ox = (canvas.width - planL*scale)/2;
            const oy = (canvas.height - planW*scale)/2 + 10;

            if (c.connection !== 'freestanding') {
                ctx.fillStyle = '#D4C4B0';
                ctx.fillRect(ox-5, oy-20, planL*scale+10, 18);
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('HOUSE', ox+planL*scale/2, oy-6);
            }

            ctx.strokeStyle = steelColor.hex;
            ctx.lineWidth = 2;
            ctx.strokeRect(ox, oy, planL*scale, planW*scale);

            ctx.strokeStyle = '#F15A29';
            ctx.lineWidth = 2;
            if (c.isGable) {
                if (c.orientation === 'lengthways') {
                    ctx.beginPath();
                    ctx.moveTo(ox, oy + planW*scale/2);
                    ctx.lineTo(ox + planL*scale, oy + planW*scale/2);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.fillText('RIDGE', ox + planL*scale/2, oy + planW*scale/2 - 5);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(ox + planL*scale/2, oy);
                    ctx.lineTo(ox + planL*scale/2, oy + planW*scale);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.save();
                    ctx.translate(ox + planL*scale/2 + 12, oy + planW*scale/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.fillText('RIDGE', 0, 0);
                    ctx.restore();
                }
            } else {
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2, oy + 15);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2 - 6, oy + planW*scale - 25);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.lineTo(ox + planL*scale/2 + 6, oy + planW*scale - 25);
                ctx.stroke();
                ctx.fillStyle = '#F15A29';
                ctx.font = '9px sans-serif';
                ctx.fillText('FALL ' + calc.pitch.toFixed(1) + '°', ox + planL*scale/2 + 30, oy + planW*scale/2);
            }

            ctx.fillStyle = steelColor.hex;
            for (let i = 0; i < c.nPosts; i++) {
                const x = ox + (planL*scale/(c.nPosts-1)) * i;
                ctx.fillRect(x-4, oy + planW*scale - 4, 8, 8);
            }

            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = ox + (planL*scale/(c.nPosts-1)) * i;
                    ctx.fillRect(x-4, oy - 4, 8, 8);
                }
            }

            if (c.isAttached) {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.lineTo(ox + planL*scale, oy);
                ctx.stroke();
                ctx.fillStyle = '#666';
                ctx.font = '8px sans-serif';
                ctx.fillText('FASCIA', ox + planL*scale/2, oy + 10);
            }

            ctx.fillStyle = '#333';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(planL + 'mm', ox + planL*scale/2, oy + planW*scale + 20);
            ctx.save();
            ctx.translate(ox - 15, oy + planW*scale/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText(planW + 'mm', 0, 0);
            ctx.restore();
        }

        // ==================== TRUSS 3D (Section 2) ====================
        let trussScene, trussCam, trussRend, trussGroup;
        let tCamT = 0.4, tCamP = 0.3, tCamD = 3;
        let tDrag = false, tLast = {x:0,y:0};

        function initTruss3D() {
            const container = document.getElementById('trussViewport');
            const canvas = document.getElementById('trussCanvas');
            trussScene = new THREE.Scene();
            trussScene.background = new THREE.Color(0xD8DCE0);
            trussCam = new THREE.PerspectiveCamera(40, container.clientWidth/container.clientHeight, 0.01, 50);
            updateTrussCam();
            trussRend = new THREE.WebGLRenderer({canvas, antialias: true});
            trussRend.setSize(container.clientWidth, container.clientHeight);
            trussRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            trussScene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(2, 4, 3);
            trussScene.add(light);

            trussGroup = new THREE.Group();
            trussScene.add(trussGroup);

            canvas.addEventListener('mousedown', e => { tDrag = true; tLast = {x:e.clientX,y:e.clientY}; });
            canvas.addEventListener('mousemove', e => {
                if (!tDrag) return;
                tCamT -= (e.clientX - tLast.x) * 0.01;
                tCamP = Math.max(0.1, Math.min(1.4, tCamP - (e.clientY - tLast.y) * 0.008));
                updateTrussCam();
                tLast = {x:e.clientX, y:e.clientY};
            });
            canvas.addEventListener('mouseup', () => tDrag = false);
            canvas.addEventListener('mouseleave', () => tDrag = false);
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                tCamD = Math.max(1, Math.min(8, tCamD + e.deltaY * 0.003));
                updateTrussCam();
            }, {passive: false});

            buildTruss3D();
            animateTruss();
        }

        function updateTrussCam() {
            trussCam.position.set(
                tCamD * Math.sin(tCamT) * Math.cos(tCamP),
                tCamD * Math.sin(tCamP),
                tCamD * Math.cos(tCamT) * Math.cos(tCamP)
            );
            trussCam.lookAt(0, 0.2, 0);
        }

        function buildTruss3D() {
            while (trussGroup.children.length) trussGroup.remove(trussGroup.children[0]);
            if (!calc.isGable) return;

            const c = calc;
            const span = c.trussSpan / 1000;
            tCamD = Math.max(3, span * 0.7);
            updateTrussCam();
            const rise = c.rise / 1000;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;
            const th = c.steel.h;
            const mat = new THREE.MeshStandardMaterial({color: new THREE.Color(steelColor.hex), metalness: 0.8, roughness: 0.3});

            const chord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, span), mat.clone());
            chord.position.set(0, th/2, 0);
            trussGroup.add(chord);

            const leftGeo = new THREE.BoxGeometry(tw, th, rafter);
            leftGeo.translate(0, 0, rafter/2);
            const leftRafter = new THREE.Mesh(leftGeo, mat.clone());
            leftRafter.position.set(0, th, -span/2);
            leftRafter.rotation.x = -c.pitchRad;
            trussGroup.add(leftRafter);

            const rightGeo = new THREE.BoxGeometry(tw, th, rafter);
            rightGeo.translate(0, 0, -rafter/2);
            const rightRafter = new THREE.Mesh(rightGeo, mat.clone());
            rightRafter.position.set(0, th, span/2);
            rightRafter.rotation.x = c.pitchRad;
            trussGroup.add(rightRafter);

            if (c.trussStyle === 'king') {
                const kingH = rise - th;
                if (kingH > 0) {
                    const king = new THREE.Mesh(new THREE.BoxGeometry(tw, kingH, th), mat.clone());
                    king.position.set(0, th + kingH/2, 0);
                    trussGroup.add(king);
                }
            } else if (c.trussStyle === 'queen') {
                const qH = rise * 0.6;
                const qZ = span * 0.2;
                [-1, 1].forEach(s => {
                    const q = new THREE.Mesh(new THREE.BoxGeometry(tw, qH, th), mat.clone());
                    q.position.set(0, th + qH/2, s * qZ);
                    trussGroup.add(q);
                });
                const topChord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, span * 0.4), mat.clone());
                topChord.position.set(0, th + qH, 0);
                trussGroup.add(topChord);
            }

            const dimMat = new THREE.LineBasicMaterial({color: 0xF15A29, linewidth: 2});
            const spanLineY = -0.08;
            addDimensionLine(-span/2, spanLineY, 0, span/2, spanLineY, 0, dimMat);
            addTrussLabel('A: ' + Math.round(c.trussSpan) + 'mm', 0, spanLineY - 0.06, 0);

            const riseX = span/2 + 0.12;
            addDimensionLine(riseX, th, 0, riseX, th + rise, 0, dimMat);
            addTrussLabel('B: ' + Math.round(c.rise) + 'mm', riseX + 0.1, th + rise/2, 0);

            addTrussLabel('C: ' + Math.round(c.rafter) + 'mm TRUE', -0.08, th + rise*0.5, -span*0.25);

            addAngleArc(span/2, th, 0, 0.15, c.pitchRad, dimMat);
            addTrussLabel('D: ' + c.pitch.toFixed(1) + '°', span/2 + 0.05, th + 0.06, 0);

            addCutMarker(0, th + rise, 0, (90 - c.pitch), 'APEX');
            addCutMarker(-span/2, th, 0, c.pitch, 'HEEL');
            addCutMarker(span/2, th, 0, c.pitch, 'HEEL');

            const rafterIn = c.rafter - (c.steel.h / Math.cos(c.pitchRad) * 1000);
            addSmallLabel('In: ' + Math.round(rafterIn) + 'mm', 0.08, th + rise*0.35, -span*0.15);
        }

        function addDimensionLine(x1, y1, z1, x2, y2, z2, mat) {
            const points = [new THREE.Vector3(x1, y1, z1), new THREE.Vector3(x2, y2, z2)];
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeo, mat);
            trussGroup.add(line);

            const tickSize = 0.03;
            const isVertical = Math.abs(y2 - y1) > Math.abs(x2 - x1);
            if (isVertical) {
                addTick(x1, y1, z1, tickSize, 0, mat);
                addTick(x2, y2, z2, tickSize, 0, mat);
            } else {
                addTick(x1, y1, z1, 0, tickSize, mat);
                addTick(x2, y2, z2, 0, tickSize, mat);
            }
        }

        function addTick(x, y, z, dx, dy, mat) {
            const pts = [new THREE.Vector3(x-dx, y-dy, z), new THREE.Vector3(x+dx, y+dy, z)];
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            trussGroup.add(new THREE.Line(geo, mat));
        }

        function addAngleArc(x, y, z, radius, angle, mat) {
            const segments = 16;
            const pts = [];
            for (let i = 0; i <= segments; i++) {
                const a = (i / segments) * angle;
                pts.push(new THREE.Vector3(x - radius * Math.cos(a), y + radius * Math.sin(a), z));
            }
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            trussGroup.add(new THREE.Line(geo, mat));
        }

        function addCutMarker(x, y, z, angle, label) {
            const markerMat = new THREE.MeshBasicMaterial({color: 0xFF6B35, transparent: true, opacity: 0.7});
            const markerGeo = new THREE.CircleGeometry(0.025, 8);
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.set(x, y, z + 0.01);
            trussGroup.add(marker);
        }

        function addSmallLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            canvas.width = 120; canvas.height = 24;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(102, 102, 102, 0.9)';
            ctx.beginPath();
            ctx.roundRect(0, 2, 120, 20, 3);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(text, 60, 16);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
            sprite.scale.set(0.18, 0.04, 1);
            sprite.position.set(x, y, z);
            trussGroup.add(sprite);
        }

        function addTrussLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            canvas.width = 200; canvas.height = 40;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#F15A29';
            ctx.beginPath();
            ctx.roundRect(0, 5, 200, 30, 4);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 13px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(text, 100, 26);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
            sprite.scale.set(0.32, 0.08, 1);
            sprite.position.set(x, y, z);
            trussGroup.add(sprite);
        }

        function setTrussView(v, btn) {
            document.querySelectorAll('.truss-view-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const span = calc.trussSpan / 1000;
            const baseDist = Math.max(3, span * 0.7);
            if (v === '3d') { tCamT = 0.4; tCamP = 0.3; tCamD = baseDist; }
            else if (v === 'front') { tCamT = 0; tCamP = 0.05; tCamD = baseDist * 0.9; }
            else if (v === 'side') { tCamT = Math.PI/2; tCamP = 0.1; tCamD = baseDist * 0.8; }
            updateTrussCam();
        }

        function animateTruss() {
            requestAnimationFrame(animateTruss);
            if (trussRend && trussScene && trussCam) {
                trussRend.render(trussScene, trussCam);
            }
        }

        // ==================== ASSEMBLY 3D (Section 3) ====================
        let asmScene, asmCam, asmRend, asmRay, asmMouse;
        let steelGrp, roofGrp, accGrp;
        let compData = new Map();
        let hovered = null;
        let aCamT = 0.5, aCamP = 0.4, aCamD = 12;
        let aDrag = false, aLast = {x:0,y:0};

        function initAsm3D() {
            const container = document.getElementById('asmViewport');
            const canvas = document.getElementById('asmCanvas');
            asmScene = new THREE.Scene();
            asmScene.background = new THREE.Color(0xC4CCD4);
            asmCam = new THREE.PerspectiveCamera(35, container.clientWidth/container.clientHeight, 0.1, 100);
            updateAsmCam();
            asmRend = new THREE.WebGLRenderer({canvas, antialias: true});
            asmRend.setSize(container.clientWidth, container.clientHeight);
            asmRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            asmRend.shadowMap.enabled = true;

            asmRay = new THREE.Raycaster();
            asmMouse = new THREE.Vector2();

            asmScene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(5, 10, 7);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            asmScene.add(sun);

            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshStandardMaterial({color: 0xA8A090, roughness: 0.9})
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            asmScene.add(ground);

            steelGrp = new THREE.Group();
            roofGrp = new THREE.Group();
            accGrp = new THREE.Group();
            asmScene.add(steelGrp);
            asmScene.add(roofGrp);
            asmScene.add(accGrp);

            canvas.addEventListener('mousedown', e => { aDrag = true; aLast = {x:e.clientX,y:e.clientY}; });
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                asmMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                asmMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                checkHover(e.clientX - rect.left, e.clientY - rect.top);
                if (aDrag) {
                    aCamT -= (e.clientX - aLast.x) * 0.008;
                    aCamP = Math.max(0.1, Math.min(1.4, aCamP - (e.clientY - aLast.y) * 0.006));
                    updateAsmCam();
                    aLast = {x:e.clientX, y:e.clientY};
                }
            });
            canvas.addEventListener('mouseup', () => { aDrag = false; });
            canvas.addEventListener('mouseleave', () => { aDrag = false; clearHover(); });
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                aCamD = Math.max(4, Math.min(30, aCamD + e.deltaY * 0.01));
                updateAsmCam();
            }, {passive: false});

            buildAsm3D();
            animateAsm();
        }

        function updateAsmCam() {
            asmCam.position.set(
                aCamD * Math.sin(aCamT) * Math.cos(aCamP),
                aCamD * Math.sin(aCamP),
                aCamD * Math.cos(aCamT) * Math.cos(aCamP)
            );
            asmCam.lookAt(0, 1.5, 0);
        }

        function createCorrugatedGeometry(width, length, segments = 20) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const waveHeight = 0.012;
            const waveFreq = 15;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                pos.setZ(i, Math.sin(x * waveFreq * Math.PI) * waveHeight);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createTrimdekGeometry(width, length, segments = 30) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const ribHeight = 0.025;
            const ribWidth = 0.04;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const phase = ((x / ribWidth) % 1 + 1) % 1;
                let z = 0;
                if (phase < 0.3) z = ribHeight * (phase / 0.3);
                else if (phase < 0.7) z = ribHeight;
                else z = ribHeight * (1 - (phase - 0.7) / 0.3);
                pos.setZ(i, z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createInsulatedGeometry(width, length) {
            return new THREE.BoxGeometry(width, length, 0.05);
        }

        function buildAsm3D() {
            [steelGrp, roofGrp, accGrp].forEach(g => { while(g.children.length) g.remove(g.children[0]); });
            compData.clear();

            const c = calc;
            const W = c.W / 1000;
            const L = c.L / 1000;
            const postH = c.postH / 1000;
            const rise = c.rise / 1000;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;
            const th = c.steel.h;
            const frontBeamY = c.frontBeamY / 1000;
            const backBeamY = c.backBeamY / 1000;
            const fasciaBeamY = c.fasciaBeamY ? c.fasciaBeamY / 1000 : null;

            const steelCol = new THREE.Color(steelColor.hex);
            const sheetCol = new THREE.Color(sheetColor.hex);
            const sMat = () => new THREE.MeshStandardMaterial({color: steelCol, metalness: 0.8, roughness: 0.3});
            const rMat = () => new THREE.MeshStandardMaterial({color: sheetCol, metalness: 0.5, roughness: 0.4, side: THREE.DoubleSide});

            const fasciaCol = new THREE.Color(steelColor.hex).offsetHSL(0, -0.1, 0.15);
            const fasciaMat = () => new THREE.MeshStandardMaterial({color: fasciaCol, metalness: 0.7, roughness: 0.4});

            const riserCol = new THREE.Color(0x8B4513);
            const riserMat = () => new THREE.MeshStandardMaterial({color: riserCol, metalness: 0.6, roughness: 0.5});

            const beamW = 0.1, beamH = 0.05, postW = 0.09;

            const isPerpendicular = c.isGable && c.orientation === 'perpendicular';

            // ===== FRONT POSTS (Gutter side) =====
            const fpostH = frontBeamY;  // May be elevated for gable+riser
            for (let i = 0; i < c.nPosts; i++) {
                const x = -L/2 + (L / (c.nPosts - 1)) * i;
                const post = new THREE.Mesh(new THREE.BoxGeometry(postW, fpostH, postW), sMat());
                if (isPerpendicular) {
                    post.position.set(W/2, fpostH/2, x);
                } else {
                    post.position.set(x, fpostH/2, W/2);
                }
                post.castShadow = true;
                steelGrp.add(post);
                regComp(post, 'Front Post ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(fpostH*1000) + 'mm'});
            }

            // ===== BACK POSTS (freestanding only) =====
            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = -L/2 + (L / (c.nPosts - 1)) * i;
                    const bpostH = backBeamY;
                    const post = new THREE.Mesh(new THREE.BoxGeometry(postW, bpostH, postW), sMat());
                    if (isPerpendicular) {
                        post.position.set(-W/2, bpostH/2, x);
                    } else {
                        post.position.set(x, bpostH/2, -W/2);
                    }
                    post.castShadow = true;
                    steelGrp.add(post);
                    regComp(post, 'Back Post ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(bpostH*1000) + 'mm'});
                }
            }

            // ===== GUTTER BEAM (Front beam on posts) =====
            const gutterBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamH, beamW), sMat());
            if (isPerpendicular) {
                gutterBeam.rotation.y = Math.PI / 2;
                gutterBeam.position.set(W/2, frontBeamY + beamH/2, 0);
            } else {
                gutterBeam.position.set(0, frontBeamY + beamH/2, W/2);
            }
            gutterBeam.castShadow = true;
            steelGrp.add(gutterBeam);
            regComp(gutterBeam, 'Gutter Beam', {'Size': '100×50×2 RHS', 'Length': c.L + 'mm'});

            // ===== FASCIA BEAM (on house - for attached only) =====
            if (c.isAttached && fasciaBeamY !== null) {
                const fasciaBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamH * 1.2, beamW * 1.1), fasciaMat());
                if (isPerpendicular) {
                    fasciaBeam.rotation.y = Math.PI / 2;
                    fasciaBeam.position.set(-W/2, fasciaBeamY + beamH/2, 0);
                } else {
                    fasciaBeam.position.set(0, fasciaBeamY + beamH/2, -W/2);
                }
                fasciaBeam.castShadow = true;
                steelGrp.add(fasciaBeam);
                regComp(fasciaBeam, 'Fascia Beam', {'Size': '100×50×2 RHS', 'Length': c.L + 'mm', 'Height': c.fasciaH + 'mm', 'Note': 'House connection'});
            }

            // ===== RAFTER BRACKETS (for fascia connections only) =====
            if (c.connection === 'fascia') {
                const bracketLen = 0.5;
                const bracketH = 0.006;
                const bracketW = 0.05;
                const bracketCount = Math.max(3, Math.ceil(L / 1.0));
                for (let i = 0; i < bracketCount; i++) {
                    const x = -L/2 + (L / (bracketCount - 1)) * i;
                    const bracket = new THREE.Mesh(
                        new THREE.BoxGeometry(bracketW, bracketH, bracketLen),
                        sMat()
                    );
                    if (isPerpendicular) {
                        bracket.rotation.y = Math.PI / 2;
                        bracket.position.set(-W/2 - bracketLen/2 - 0.08, fasciaBeamY + beamH + 0.1, x);
                    } else {
                        bracket.position.set(x, fasciaBeamY + beamH + 0.1, -W/2 - bracketLen/2 - 0.08);
                    }
                    steelGrp.add(bracket);
                }
            }

            // ===== V18 FIX: RISERS with correct stacking =====
            if (c.connection === 'riser') {
                // V18: Riser beam sits ON TOP of risers
                const riserOff = c.riserOffset / 1000;
                const riserSize = 0.075;
                const count = Math.max(2, Math.ceil(L / 1.2));

                // Calculate actual vertical rise of risers
                // For gable: risers go from fascia beam top to just below the riser beam
                // For skillion: use user-specified riser height
                const actualRiserH = c.riserH / 1000;

                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;

                    // HORIZONTAL piece (comes out from fascia beam)
                    const horizPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, riserSize, riserOff),
                        riserMat()
                    );

                    // VERTICAL piece (rises up)
                    const vertPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, actualRiserH, riserSize),
                        riserMat()
                    );

                    if (isPerpendicular) {
                        horizPiece.rotation.y = Math.PI / 2;
                        horizPiece.position.set(-W/2 + riserOff/2, fasciaBeamY + beamH + riserSize/2, x);
                        vertPiece.position.set(-W/2 + riserOff, fasciaBeamY + beamH + riserSize + actualRiserH/2, x);
                    } else {
                        horizPiece.position.set(x, fasciaBeamY + beamH + riserSize/2, -W/2 + riserOff/2);
                        vertPiece.position.set(x, fasciaBeamY + beamH + riserSize + actualRiserH/2, -W/2 + riserOff);
                    }

                    horizPiece.castShadow = true;
                    vertPiece.castShadow = true;
                    steelGrp.add(horizPiece);
                    steelGrp.add(vertPiece);
                    regComp(vertPiece, 'Riser Elbow ' + (i+1), {
                        'Size': '75×75×2 SHS',
                        'Offset': c.riserOffset + 'mm',
                        'Rise': Math.round(actualRiserH * 1000) + 'mm',
                        'Note': '90° elbow clears house gutter'
                    });
                }

                // Box gutter (if selected) - sits in gap between house wall and riser beam
                if (c.houseGutter === 'box') {
                    // Width sized to fit the gap between house fascia and riser beam
                    const boxGutterW = riserOff;
                    const boxGutterD = 0.1;       // inner wall height (house side)
                    const boxGutterOuter = 0.12;  // outer wall height (riser side, taller to catch water)
                    const wallT = 0.01;

                    // U-shaped cross-section: X=0 is house side, X=boxGutterW is riser side
                    const gutterShape = new THREE.Shape();
                    gutterShape.moveTo(0, 0);
                    gutterShape.lineTo(boxGutterW, 0);
                    gutterShape.lineTo(boxGutterW, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, wallT);
                    gutterShape.lineTo(wallT, wallT);
                    gutterShape.lineTo(wallT, boxGutterD);
                    gutterShape.lineTo(0, boxGutterD);
                    gutterShape.closePath();

                    const extrudeSettings = { depth: L, bevelEnabled: false };
                    const gutterGeo = new THREE.ExtrudeGeometry(gutterShape, extrudeSettings);
                    const boxGutter = new THREE.Mesh(gutterGeo, sMat());

                    // Y: top of taller wall aligns with bottom of riser horizontal piece
                    // (fascia beam top = fasciaBeamY + beamH, that's where horiz piece sits)
                    const boxGutterY = fasciaBeamY + beamH - boxGutterOuter;

                    if (isPerpendicular) {
                        // House wall at X = -W/2, riser beam at X = -W/2 + riserOff
                        // rotation.y = π: local X → world -X, local +Z → world -Z
                        // Shape X=0 (house side) → world X = position.x (riser beam)
                        // Shape X=gutterW (riser side) → world X = position.x - gutterW = -W/2 (house)
                        // So we need to flip: position at -W/2, no extra rotation for X direction
                        // Use rotation.y = 0: local X → world +X, local Z → world +Z
                        // Shape X=0 (house side) at world X = -W/2, X=gutterW at -W/2 + riserOff
                        boxGutter.rotation.y = 0;
                        boxGutter.position.set(-W/2, boxGutterY, -L/2);
                    } else {
                        // House wall at Z = -W/2, riser beam at Z = -W/2 + riserOff
                        // rotation.y = -π/2: local X → world +Z, local +Z → world -X
                        // Shape X=0 (house side) at world Z = -W/2
                        // Shape X=gutterW (riser side) at world Z = -W/2 + riserOff
                        // Extrusion goes -X, so position at X = +L/2
                        boxGutter.rotation.y = -Math.PI / 2;
                        boxGutter.position.set(L/2, boxGutterY, -W/2);
                    }
                    accGrp.add(boxGutter);
                    regComp(boxGutter, 'Box Gutter', {'Width': Math.round(riserOff*1000)+'mm', 'Inner Depth': '100mm', 'Outer Depth': '120mm'});
                }
            }

            // ===== CARRY / BACK BEAM - For freestanding, riser, wall, flyover (NOT fascia - uses fascia beam) =====
            if (c.connection !== 'fascia') {
                const isRiser = c.connection === 'riser';
                const beamHeight = isRiser ? 0.1 : beamH;
                const beamWidth = isRiser ? 0.05 : beamW;
                const riserOff = isRiser ? c.riserOffset/1000 : 0;

                const carryBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamHeight, beamWidth), sMat());
                if (isPerpendicular) {
                    carryBeam.rotation.y = Math.PI / 2;
                    carryBeam.position.set(-W/2 + riserOff, backBeamY + beamHeight/2, 0);
                } else {
                    carryBeam.position.set(0, backBeamY + beamHeight/2, -W/2 + riserOff);
                }
                carryBeam.castShadow = true;
                steelGrp.add(carryBeam);
                const beamName = isRiser ? 'Riser Beam' : (c.connection === 'flyover' ? 'Flyover Beam' : 'Back Beam');
                const beamSpec = isRiser ? '100×50×2 RHS (on edge)' : '100×50×2 RHS';
                regComp(carryBeam, beamName, {'Size': beamSpec, 'Length': c.L + 'mm', 'Height': Math.round(backBeamY*1000) + 'mm'});
            }

            // ===== ROOF STRUCTURE =====
            const frontTop = frontBeamY + beamH;
            const backTop = backBeamY + beamH;
            const sheetW = c.sheetCoverage / 1000;

            // V18: Calculate actual gutter height for downpipes
            let gutterY;

            if (c.isGable) {
                // ========== GABLE ROOF ==========
                const trussBaseY = (frontTop + backTop) / 2;
                const tiltAngle = Math.atan2(backTop - frontTop, W);
                gutterY = frontTop - 0.04;

                // Trusses (peak from internal geometry; tilt spans between beams when heights differ)
                for (let i = 0; i < c.nTruss; i++) {
                    const x = -L/2 + (L / (c.nTruss - 1)) * i;
                    const truss = createTrussUnit(W, rise, rafter, tw, th, sMat(), c.trussStyle, c.pitchRad);
                    if (isPerpendicular) {
                        truss.rotation.order = 'ZYX';
                        truss.rotation.y = Math.PI / 2;
                        truss.rotation.z = -tiltAngle;
                        truss.position.set(0, trussBaseY, x);
                    } else {
                        truss.rotation.x = tiltAngle;
                        truss.position.set(x, trussBaseY, 0);
                    }
                    steelGrp.add(truss);
                    regComp(truss, 'Truss ' + (i+1), {'Span': Math.round(c.trussSpan) + 'mm', 'Rise': Math.round(c.rise) + 'mm'});

                    // Gable infill
                    if ((i === 0 || i === c.nTruss - 1) && c.infill !== 'none') {
                        const shape = new THREE.Shape();
                        shape.moveTo(-W/2, th);
                        shape.lineTo(0, rise + th);
                        shape.lineTo(W/2, th);
                        shape.closePath();
                        const infillMat = new THREE.MeshStandardMaterial({
                            color: c.infill === 'twinwall' ? 0xDDEEEE : sheetCol,
                            transparent: c.infill === 'twinwall',
                            opacity: c.infill === 'twinwall' ? 0.6 : 1,
                            side: THREE.DoubleSide
                        });
                        const infillMesh = new THREE.Mesh(new THREE.ShapeGeometry(shape), infillMat);

                        if (isPerpendicular) {
                            infillMesh.rotation.y = x > 0 ? Math.PI : 0;
                            infillMesh.position.set(0, trussBaseY, x);
                        } else {
                            infillMesh.rotation.y = Math.PI / 2;
                            infillMesh.position.set(x, trussBaseY, 0);
                        }
                        roofGrp.add(infillMesh);
                        regComp(infillMesh, 'Gable Infill', {'Material': c.infill === 'twinwall' ? '10mm Twinwall' : 'Colorbond'});
                    }
                }

                // Purlins
                const purlinCount = Math.max(2, Math.ceil(rafter / 0.8));
                for (let side = -1; side <= 1; side += 2) {
                    for (let p = 1; p <= purlinCount; p++) {
                        const frac = p / (purlinCount + 1);
                        const zPos = (W/2) * frac * side;
                        const yPos = trussBaseY + th + rise * (1 - frac);
                        const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                        if (isPerpendicular) {
                            purlin.rotation.y = Math.PI / 2;
                            purlin.position.set(zPos, yPos, 0);
                        } else {
                            purlin.position.set(0, yPos, zPos);
                        }
                        steelGrp.add(purlin);
                    }
                }

                // V18 FIX: Roof sheets - corrected rotation for perpendicular mode
                const numSheets = Math.ceil(L / sheetW);
                for (let side = -1; side <= 1; side += 2) {
                    for (let s = 0; s < numSheets; s++) {
                        const sheetPos = -L/2 + sheetW/2 + s * sheetW;
                        let sheetGeo;
                        if (c.roofing === 'corrugated') {
                            sheetGeo = createCorrugatedGeometry(sheetW, rafter + 0.05);
                        } else if (c.roofing === 'trimdek') {
                            sheetGeo = createTrimdekGeometry(sheetW, rafter + 0.05);
                        } else {
                            sheetGeo = createInsulatedGeometry(sheetW, rafter + 0.05);
                        }

                        const sheet = new THREE.Mesh(sheetGeo, rMat());

                        if (isPerpendicular) {
                            // Perpendicular: same X rotation as lengthways, then Y=π/2 to turn 90°
                            // YXZ order: Rx applied to point first (slope tilt), then Ry (90° turn)
                            sheet.rotation.order = 'YXZ';
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                            sheet.rotation.y = Math.PI / 2;

                            const midHeight = trussBaseY + th + rise/2;
                            sheet.position.set(side * W/4, midHeight + 0.02, sheetPos);
                        } else {
                            // Lengthways - ridge along X, slopes in Z direction
                            sheet.position.set(sheetPos, trussBaseY + th + rise/2 + 0.01, side * W/4);
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                        }
                        sheet.castShadow = true;
                        roofGrp.add(sheet);
                    }
                }

                // Ridge capping
                const ridge = new THREE.Mesh(new THREE.BoxGeometry(L, 0.04, 0.3), rMat());
                if (isPerpendicular) {
                    ridge.rotation.y = Math.PI / 2;
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                } else {
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                }
                accGrp.add(ridge);
                regComp(ridge, 'Ridge Cap', {'Length': c.L + 'mm'});

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                if (isPerpendicular) {
                    gutter.rotation.y = Math.PI / 2;
                    gutter.position.set(W/2 + 0.07, gutterY, 0);
                } else {
                    gutter.position.set(0, gutterY, W/2 + 0.07);
                }
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.L + 'mm'});

                // Gable barges
                const bargeThick = 0.003;
                const bargeWidth = 0.15;
                const bargeLen = rafter + 0.05;

                if (isPerpendicular) {
                    [-L/2, L/2].forEach((zEnd) => {
                        const bargeL = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeL.position.set(-W/4, trussBaseY + th + rise/2, zEnd);
                        bargeL.rotation.z = c.pitchRad;
                        accGrp.add(bargeL);

                        const bargeR = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeR.position.set(W/4, trussBaseY + th + rise/2, zEnd);
                        bargeR.rotation.z = -c.pitchRad;
                        accGrp.add(bargeR);
                    });
                } else {
                    [-L/2, L/2].forEach((xEnd) => {
                        const bargeHouse = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeHouse.position.set(xEnd, trussBaseY + th + rise/2, -W/4);
                        bargeHouse.rotation.x = -c.pitchRad;
                        accGrp.add(bargeHouse);

                        const bargeGutter = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeGutter.position.set(xEnd, trussBaseY + th + rise/2, W/4);
                        bargeGutter.rotation.x = c.pitchRad;
                        accGrp.add(bargeGutter);
                    });
                }

            } else {
                // ========== SKILLION ROOF ==========
                gutterY = frontTop - 0.04;  // V18: Store gutter Y for downpipes

                const riserOff = c.connection === 'riser' ? c.riserOffset / 1000 : 0;
                const backEdgeZ = -W/2 + riserOff;

                // Rafters
                for (let i = 0; i < c.nRafters; i++) {
                    const x = -L/2 + (L / (c.nRafters - 1)) * i;
                    const rafterGeo = new THREE.BoxGeometry(tw, th, rafter);
                    rafterGeo.translate(0, 0, rafter/2);
                    const raft = new THREE.Mesh(rafterGeo, sMat());
                    raft.position.set(x, backTop + th/2, backEdgeZ);
                    raft.rotation.x = c.pitchRad;
                    steelGrp.add(raft);
                    regComp(raft, 'Rafter ' + (i+1), {'Size': c.steel.name, 'Length': Math.round(c.rafter) + 'mm'});
                }

                // Purlins
                const effectiveW = W - riserOff;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9));
                for (let p = 0; p <= purlinCount; p++) {
                    const frac = p / purlinCount;
                    const zPos = backEdgeZ + effectiveW * frac;
                    const yPos = backTop + th - (backTop - frontTop) * frac;
                    const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                    purlin.position.set(0, yPos, zPos);
                    steelGrp.add(purlin);
                }

                // Roof sheets
                const numSheets = Math.ceil(L / sheetW);
                for (let s = 0; s < numSheets; s++) {
                    const xPos = -L/2 + sheetW/2 + s * sheetW;
                    let sheetGeo;
                    if (c.roofing === 'corrugated') {
                        sheetGeo = createCorrugatedGeometry(sheetW, rafter);
                    } else if (c.roofing === 'trimdek') {
                        sheetGeo = createTrimdekGeometry(sheetW, rafter);
                    } else {
                        sheetGeo = createInsulatedGeometry(sheetW, rafter);
                    }
                    sheetGeo.translate(0, rafter/2, 0);

                    const sheet = new THREE.Mesh(sheetGeo, rMat());
                    sheet.position.set(xPos, backTop + th + 0.01, backEdgeZ);
                    sheet.rotation.x = Math.PI/2 + c.pitchRad;
                    sheet.castShadow = true;
                    roofGrp.add(sheet);
                    regComp(sheet, 'Roof Sheet ' + (s+1), {'Profile': c.roofing, 'Length': Math.round(rafter*1000) + 'mm'});
                }

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                gutter.position.set(0, gutterY, W/2 + 0.07);
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.lenInput + 'mm'});

                // Back flashing
                if (!(c.connection === 'riser' && c.houseGutter === 'box')) {
                    const flash = new THREE.Mesh(new THREE.BoxGeometry(L, 0.15, 0.003), sMat());
                    flash.position.set(0, backTop + 0.08, backEdgeZ - 0.05);
                    flash.rotation.x = -0.3;
                    accGrp.add(flash);
                    regComp(flash, 'Back Flashing', {'Length': c.lenInput + 'mm'});
                }

                // Barge flashings
                [-L/2, L/2].forEach((xPos, idx) => {
                    const barge = new THREE.Mesh(new THREE.BoxGeometry(0.1, rafter, 0.003), sMat());
                    barge.position.set(xPos, (backTop + frontTop)/2 + th, 0);
                    barge.rotation.x = -(Math.PI/2 - c.pitchRad);
                    accGrp.add(barge);
                });
            }

            // ===== V18 FIX: DOWNPIPES - Use actual gutter height =====
            let dpPositions;
            if (isPerpendicular) {
                dpPositions = [[W/2 + 0.1, -L/2 + 0.1], [W/2 + 0.1, L/2 - 0.1]];
            } else {
                dpPositions = [[-L/2 + 0.1, W/2 + 0.1], [L/2 - 0.1, W/2 + 0.1]];
            }
            dpPositions.forEach((pos, idx) => {
                // V18 FIX: Downpipe height = from ground to gutter, not postH
                const dpHeight = gutterY + 0.04;  // Gutter bottom + 40mm into gutter
                const dp = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, dpHeight, 12), sMat());
                dp.position.set(pos[0], dpHeight/2, pos[1]);
                accGrp.add(dp);
                regComp(dp, 'Downpipe ' + (idx+1), {'Size': '90mm Round', 'Height': Math.round(dpHeight*1000) + 'mm'});
            });

            // ===== HOUSE / WALL REPRESENTATION =====
            // Varies by connection type:
            //   riser, fascia, flyover: wall + fascia board (+ house roof for flyover)
            //   wall: flat wall only (no fascia board)
            //   freestanding: no wall
            if (c.isAttached) {
                const fasciaHm = c.fasciaH / 1000;
                const wallThick = 0.15;
                const wallLen = L + 0.2;
                const wallMat = new THREE.MeshStandardMaterial({color: 0xD4C4B0, roughness: 0.9});
                const fasciaTimberMat = new THREE.MeshStandardMaterial({color: 0x8B7355, roughness: 0.8});

                // Wall height: extends above the connection point
                const wallH = Math.max(backBeamY + 0.5, fasciaHm + 0.5);
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallLen, wallH, wallThick),
                    wallMat
                );
                if (isPerpendicular) {
                    wall.rotation.y = Math.PI / 2;
                    wall.position.set(-W/2 - wallThick, wallH/2, 0);
                } else {
                    wall.position.set(0, wallH/2, -W/2 - wallThick);
                }
                wall.receiveShadow = true;
                steelGrp.add(wall);

                // Fascia board - for riser, fascia (receiving channel), and flyover
                if (c.hasFascia && fasciaHm > 0) {
                    const fasciaBoardH = 0.15;   // 150mm tall
                    const fasciaBoardT = 0.025;  // 25mm thick
                    const fasciaBoard = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, fasciaBoardH, fasciaBoardT),
                        fasciaTimberMat
                    );
                    // Position on face of wall at fascia height
                    const fbZ = -W/2 - wallThick/2 + fasciaBoardT/2;
                    if (isPerpendicular) {
                        fasciaBoard.rotation.y = Math.PI / 2;
                        fasciaBoard.position.set(fbZ, fasciaHm, 0);
                    } else {
                        fasciaBoard.position.set(0, fasciaHm, fbZ);
                    }
                    fasciaBoard.castShadow = true;
                    steelGrp.add(fasciaBoard);
                    regComp(fasciaBoard, 'House Fascia Board', {'Size': '150×25mm Timber', 'Height': c.fasciaH + 'mm'});
                }

                // C-Channel - for receiving channel modes (fascia and wall)
                if (c.connection === 'fascia' || c.connection === 'wall') {
                    const chanW = 0.05;   // 50mm wide
                    const chanH = 0.03;   // 30mm tall
                    const chanT = 0.003;  // 3mm steel thickness
                    // C-channel profile (U-shape opening toward patio)
                    const chanShape = new THREE.Shape();
                    chanShape.moveTo(0, 0);
                    chanShape.lineTo(chanW, 0);
                    chanShape.lineTo(chanW, chanT);
                    chanShape.lineTo(chanT, chanT);
                    chanShape.lineTo(chanT, chanH - chanT);
                    chanShape.lineTo(chanW, chanH - chanT);
                    chanShape.lineTo(chanW, chanH);
                    chanShape.lineTo(0, chanH);
                    chanShape.closePath();

                    const chanGeo = new THREE.ExtrudeGeometry(chanShape, { depth: L, bevelEnabled: false });
                    const channel = new THREE.Mesh(chanGeo, sMat());

                    if (c.connection === 'fascia') {
                        // On fascia board face, at fascia beam height
                        const chanY = fasciaHm + beamH/2 - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    } else {
                        // Wall mode: on wall surface at connection height
                        const chanY = fasciaHm - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    }
                    steelGrp.add(channel);
                    regComp(channel, 'Receiving Channel', {'Size': '50×30mm C-Channel', 'Length': c.L + 'mm', 'Type': c.connection === 'fascia' ? 'Fascia mount' : 'Wall mount'});
                }

                // House roof - for flyover mode (shows existing roof the patio goes over)
                if (c.connection === 'flyover') {
                    const roofDepth = 1.5;      // 1.5m visible roof depth
                    const roofThick = 0.04;     // 40mm thick (sheet metal/tiles)
                    const roofPitch = 15 * Math.PI / 180; // 15° house roof pitch
                    const roofRise = roofDepth * Math.tan(roofPitch);

                    const roofMat = new THREE.MeshStandardMaterial({color: 0x8B4513, roughness: 0.7});
                    const houseRoof = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, roofThick, roofDepth),
                        roofMat
                    );
                    // Roof starts at fascia top, slopes UP toward house
                    const roofBaseY = fasciaHm + 0.075; // just above fascia board
                    const roofCenterY = roofBaseY + roofRise / 2;
                    const roofCenterZ = -W/2 - wallThick/2 - roofDepth/2;

                    if (isPerpendicular) {
                        houseRoof.rotation.order = 'YXZ';
                        houseRoof.rotation.y = Math.PI / 2;
                        houseRoof.rotation.x = roofPitch;
                        // For perpendicular: house at X = -W/2, roof extends in -X
                        houseRoof.position.set(-W/2 - wallThick/2 - roofDepth/2, roofCenterY, 0);
                    } else {
                        houseRoof.rotation.x = roofPitch;
                        houseRoof.position.set(0, roofCenterY, roofCenterZ);
                    }
                    houseRoof.castShadow = true;
                    houseRoof.receiveShadow = true;
                    steelGrp.add(houseRoof);
                    regComp(houseRoof, 'Existing House Roof', {'Pitch': '15°', 'Note': 'Patio flies over existing roof'});
                }
            }

            updateMatList();
        }

        function createTrussUnit(W, rise, rafter, tw, th, mat, style, pitchRad) {
            const g = new THREE.Group();

            const chord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, W), mat.clone());
            chord.position.set(0, th/2, 0);
            g.add(chord);

            const leftGeo = new THREE.BoxGeometry(tw, th, rafter);
            leftGeo.translate(0, 0, rafter/2);
            const leftR = new THREE.Mesh(leftGeo, mat.clone());
            leftR.position.set(0, th, -W/2);
            leftR.rotation.x = -pitchRad;
            g.add(leftR);

            const rightGeo = new THREE.BoxGeometry(tw, th, rafter);
            rightGeo.translate(0, 0, -rafter/2);
            const rightR = new THREE.Mesh(rightGeo, mat.clone());
            rightR.position.set(0, th, W/2);
            rightR.rotation.x = pitchRad;
            g.add(rightR);

            if (style === 'king') {
                const kingH = rise - th;
                if (kingH > 0) {
                    const king = new THREE.Mesh(new THREE.BoxGeometry(tw, kingH, th), mat.clone());
                    king.position.set(0, th + kingH/2, 0);
                    g.add(king);
                }
            } else if (style === 'queen') {
                const qH = rise * 0.6;
                const qZ = W * 0.2;
                [-1, 1].forEach(s => {
                    const q = new THREE.Mesh(new THREE.BoxGeometry(tw, qH, th), mat.clone());
                    q.position.set(0, th + qH/2, s * qZ);
                    g.add(q);
                });
                const topChord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, W * 0.4), mat.clone());
                topChord.position.set(0, th + qH, 0);
                g.add(topChord);
            }

            return g;
        }

        function regComp(mesh, name, specs) {
            compData.set(mesh.uuid, {name, specs});
        }

        function checkHover(mx, my) {
            asmRay.setFromCamera(asmMouse, asmCam);
            const all = [];
            if (steelGrp.visible) all.push(...steelGrp.children);
            if (roofGrp.visible) all.push(...roofGrp.children);
            if (accGrp.visible) all.push(...accGrp.children);
            const hits = asmRay.intersectObjects(all, true);
            if (hits.length > 0) {
                let obj = hits[0].object;
                while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;
                if (compData.has(obj.uuid)) {
                    if (hovered !== obj) { clearHover(); hovered = obj; highlight(obj); }
                    showTooltip(mx, my, compData.get(obj.uuid));
                    return;
                }
            }
            clearHover();
        }

        function highlight(mesh) {
            const hl = new THREE.Color(0xF15A29);
            if (mesh.material) { mesh.material.emissive = hl; mesh.material.emissiveIntensity = 0.3; }
            mesh.traverse(c => { if (c.material) { c.material.emissive = hl; c.material.emissiveIntensity = 0.3; }});
        }

        function clearHover() {
            if (hovered) {
                if (hovered.material) { hovered.material.emissive = new THREE.Color(0); hovered.material.emissiveIntensity = 0; }
                hovered.traverse(c => { if (c.material) { c.material.emissive = new THREE.Color(0); c.material.emissiveIntensity = 0; }});
                hovered = null;
            }
            hideTooltip();
        }

        function showTooltip(x, y, data) {
            const tt = document.getElementById('tooltip');
            document.getElementById('ttTitle').textContent = data.name;
            document.getElementById('ttContent').innerHTML = Object.entries(data.specs)
                .map(([k,v]) => `<div class="tooltip-row"><span class="tooltip-label">${k}</span><span class="tooltip-value">${v}</span></div>`).join('');
            tt.style.left = (x + 15) + 'px';
            tt.style.top = (y + 15) + 'px';
            tt.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function toggleLayer(layer, el) {
            el.classList.toggle('active');
            const vis = el.classList.contains('active');
            if (layer === 'steel') steelGrp.visible = vis;
            if (layer === 'roof') roofGrp.visible = vis;
            if (layer === 'acc') accGrp.visible = vis;
        }

        function setAsmView(v, btn) {
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            if (v === '3d') { aCamT = 0.5; aCamP = 0.4; aCamD = 12; }
            else if (v === 'front') { aCamT = 0; aCamP = 0.25; aCamD = 10; }
            else if (v === 'side') { aCamT = Math.PI/2; aCamP = 0.3; aCamD = 12; }
            else if (v === 'top') { aCamT = 0; aCamP = 1.4; aCamD = 15; }
            updateAsmCam();
        }

        function toggleFullscreen() {
            const el = document.getElementById('asmViewport');
            el.classList.toggle('fullscreen');
            setTimeout(() => {
                asmCam.aspect = el.clientWidth / el.clientHeight;
                asmCam.updateProjectionMatrix();
                asmRend.setSize(el.clientWidth, el.clientHeight);
            }, 100);
        }

        function updateMatList() {
            const c = calc;
            let mats = [];
            const sheetCover = c.sheetCoverage;

            if (c.isGable) {
                const numSheets = Math.ceil(c.L / sheetCover) * 2;
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                const riserCount = Math.max(2, Math.ceil(c.L / 1200));
                // Beam count depends on connection type
                let beamCount;
                if (c.connection === 'freestanding') {
                    beamCount = 2;  // Gutter beam + back beam
                } else if (c.connection === 'riser') {
                    beamCount = 3;  // Gutter beam + fascia beam + riser beam
                } else {
                    beamCount = 2;  // Gutter beam + fascia/back beam
                }
                const purlinCount = Math.max(2, Math.ceil(c.rafter / 1000 / 0.8)) * 2;
                mats = [
                    {d: 'Posts 90×90×2', q: postCount},
                    {d: 'Beams 100×50×2', q: beamCount},
                    {d: 'Trusses ' + c.steel.name, q: c.nTruss},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    {d: c.roofing + ' Sheets', q: numSheets},
                    {d: 'Ridge Cap', q: 1},
                    {d: 'Gable Barges', q: 4},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                if (c.infill !== 'none') mats.push({d: 'Gable Infill', q: 2});
                if (c.connection === 'riser') {
                    mats.push({d: 'Riser Elbows 75×75', q: riserCount});
                    mats.push({d: 'Riser Beam 100×50', q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                }
                if (c.connection === 'fascia' || c.connection === 'wall') {
                    mats.push({d: 'Receiving Channel', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            } else {
                const numSheets = Math.ceil(c.L / sheetCover);
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                let beamCount;
                if (c.connection === 'riser') {
                    beamCount = 3;
                } else if (c.connection === 'freestanding') {
                    beamCount = 2;
                } else {
                    beamCount = 2;
                }
                const riserCount = Math.max(2, Math.ceil(c.L / 1200));
                const effectiveW = (c.W - (c.connection === 'riser' ? c.riserOffset : 0)) / 1000;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9)) + 1;
                mats = [
                    {d: 'Posts 90×90×2', q: postCount},
                    {d: 'Beams 100×50×2', q: beamCount},
                    {d: 'Rafters ' + c.steel.name, q: c.nRafters},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    {d: c.roofing + ' Sheets', q: numSheets},
                    {d: 'Barge Flashings', q: 2},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                if (!(c.connection === 'riser' && c.houseGutter === 'box')) {
                    mats.splice(5, 0, {d: 'Back Flashing', q: 1});
                }
                if (c.connection === 'riser') {
                    mats.splice(2, 0, {d: 'Riser Elbows 75×75', q: riserCount});
                    mats.splice(3, 0, {d: 'Riser Beam 100×50', q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                }
                if (c.connection === 'fascia' || c.connection === 'wall') {
                    mats.push({d: 'Receiving Channel', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            }

            document.getElementById('matList').innerHTML = mats
                .map(m => `<div class="mat-row"><span>${m.d}</span><span class="mat-qty">${m.q}×</span></div>`).join('');
        }

        function animateAsm() {
            requestAnimationFrame(animateAsm);
            if (asmRend && asmScene && asmCam) {
                asmRend.render(asmScene, asmCam);
            }
        }

        function rebuildAll() {
            getInputs();
            draw2DPlan();
            buildTruss3D();
            buildAsm3D();
        }

        function exportOrder() {
            const c = calc;
            alert('Export order for SW1772 - ' + c.roofStyle.toUpperCase() + ' PATIO\n' +
                  'Size: ' + c.lenInput + 'mm × ' + c.projInput + 'mm\n' +
                  'Orientation: ' + c.orientation + '\n' +
                  'Roofing: ' + c.roofing + '\n' +
                  'Connection: ' + c.connection);
        }

        // ==================== INIT ====================
        window.addEventListener('resize', () => {
            const tc = document.getElementById('trussViewport');
            if (trussCam) {
                trussCam.aspect = tc.clientWidth / tc.clientHeight;
                trussCam.updateProjectionMatrix();
                trussRend.setSize(tc.clientWidth, tc.clientHeight);
            }

            const ac = document.getElementById('asmViewport');
            if (asmCam && !ac.classList.contains('fullscreen')) {
                asmCam.aspect = ac.clientWidth / ac.clientHeight;
                asmCam.updateProjectionMatrix();
                asmRend.setSize(ac.clientWidth, ac.clientHeight);
            }
            draw2DPlan();
        });

        // Initialize
        updateUI();
        getInputs();
        draw2DPlan();
        initTruss3D();
        initAsm3D();
    </script>
</body>
</html>
