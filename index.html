
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureWorks WA - Patio Designer Pro V18</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js"></script>
    <style>
        :root {
            --sw-orange: #F15A29;
            --sw-blue-dark: #293C46;
            --sw-white: #FFFFFF;
            --sw-bg: #F5F5F7;
            --sw-border: #E5E5E5;
            --sw-text: #1D1D1F;
            --sw-text-sec: #86868B;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: var(--sw-bg);
            color: var(--sw-text);
        }
        .header {
            background: var(--sw-white);
            border-bottom: 1px solid var(--sw-border);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .logo { display: flex; align-items: center; gap: 8px; }
        .logo-icon {
            width: 32px; height: 32px;
            background: var(--sw-orange);
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
        }
        .logo-icon svg { width: 18px; height: 18px; fill: white; }
        .logo-text { font-size: 16px; font-weight: 600; }
        .logo-text span { color: var(--sw-orange); }
        .job-badge { background: var(--sw-bg); padding: 6px 14px; border-radius: 16px; font-size: 13px; }
        .job-badge strong { color: var(--sw-orange); }
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }
        .btn-primary { background: var(--sw-orange); color: white; }
        .btn-secondary { background: var(--sw-bg); color: var(--sw-text); border: 1px solid var(--sw-border); }
        .main { max-width: 1400px; margin: 0 auto; padding: 24px; }
        .section {
            background: var(--sw-white);
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 1px 8px rgba(0,0,0,0.04);
            overflow: hidden;
        }
        .section-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--sw-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .section-title { font-size: 16px; font-weight: 600; }
        .section-subtitle { font-size: 12px; color: var(--sw-text-sec); }
        .section-body { padding: 20px; }

        .setup-grid { display: grid; grid-template-columns: 320px 1fr 280px; gap: 20px; }
        .options-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 16px; }
        .setup-card { background: var(--sw-bg); border-radius: 10px; padding: 14px; }
        .setup-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 10px; }
        .field { margin-bottom: 10px; }
        .field-label { display: flex; justify-content: space-between; font-size: 12px; font-weight: 500; margin-bottom: 3px; }
        .field-unit { font-size: 10px; color: var(--sw-text-sec); }
        .field-input { width: 100%; padding: 7px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; }
        .field-input:focus { outline: none; border-color: var(--sw-orange); }
        .field-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .plan-2d { background: #EEF1F4; border-radius: 8px; height: 220px; }
        .plan-2d canvas { width: 100%; height: 100%; }
        .color-chips { display: flex; flex-wrap: wrap; gap: 5px; }
        .color-chip { width: 24px; height: 24px; border-radius: 5px; cursor: pointer; border: 2px solid transparent; }
        .color-chip.active { border-color: var(--sw-text); }
        .color-label { font-size: 11px; color: var(--sw-text-sec); margin-top: 6px; }
        .calc-display { background: var(--sw-blue-dark); border-radius: 8px; padding: 10px; margin-top: 10px; color: white; }
        .calc-row { display: flex; justify-content: space-between; font-size: 11px; padding: 3px 0; }
        .calc-label { opacity: 0.7; }
        .calc-value { font-weight: 600; font-family: 'SF Mono', monospace; color: var(--sw-orange); }

        .truss-grid { display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .truss-viewport { background: linear-gradient(180deg, #E0E4E8 0%, #CED4DA 100%); border-radius: 10px; height: 420px; position: relative; }
        .truss-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .truss-viewport canvas:active { cursor: grabbing; }
        .truss-view-btns { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.9); padding: 3px; border-radius: 6px; }
        .truss-view-btn { padding: 5px 10px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .truss-view-btn.active { background: var(--sw-blue-dark); color: white; }
        .truss-panel { display: flex; flex-direction: column; gap: 12px; }
        .truss-card { background: var(--sw-bg); border-radius: 10px; padding: 12px; }
        .truss-card h4 { font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 8px; }
        .spec-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .spec-item { background: white; border-radius: 6px; padding: 8px; text-align: center; }
        .spec-label { font-size: 9px; color: var(--sw-text-sec); }
        .spec-value { font-size: 15px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .spec-value.hl { color: var(--sw-orange); }
        .fab-box { background: var(--sw-blue-dark); border-radius: 10px; padding: 12px; color: white; }
        .fab-box h4 { font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; margin-bottom: 8px; }
        .fab-line { font-family: 'SF Mono', monospace; font-size: 11px; padding: 4px 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-bottom: 2px; }

        .asm-viewport { height: 520px; background: linear-gradient(180deg, #D4D9E0 0%, #BCC4CC 100%); border-radius: 10px; position: relative; }
        .asm-viewport canvas { width: 100%; height: 100%; cursor: grab; }
        .asm-viewport canvas:active { cursor: grabbing; }
        .asm-viewport.fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100vw; height: 100vh; z-index: 1000; border-radius: 0; }
        .layer-panel { position: absolute; top: 12px; left: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; min-width: 140px; }
        .layer-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .layer-item { display: flex; align-items: center; gap: 6px; padding: 4px 0; cursor: pointer; font-size: 11px; }
        .layer-check { width: 14px; height: 14px; border: 2px solid var(--sw-border); border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 9px; color: white; }
        .layer-item.active .layer-check { background: var(--sw-orange); border-color: var(--sw-orange); }
        .layer-item.active .layer-check::after { content: '✓'; }
        .mat-panel { position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 10px; width: 200px; }
        .mat-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--sw-text-sec); margin-bottom: 6px; }
        .mat-row { display: flex; justify-content: space-between; font-size: 10px; padding: 3px 0; border-bottom: 1px solid var(--sw-border); }
        .mat-row:last-child { border-bottom: none; }
        .mat-qty { font-weight: 600; color: var(--sw-orange); }
        .view-panel { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; background: rgba(255,255,255,0.95); padding: 3px; border-radius: 6px; }
        .view-btn { padding: 5px 12px; border: none; background: transparent; border-radius: 4px; font-size: 11px; cursor: pointer; color: var(--sw-text-sec); }
        .view-btn.active { background: var(--sw-blue-dark); color: white; }
        .fullscreen-btn { position: absolute; top: 12px; right: 230px; background: rgba(255,255,255,0.95); border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; font-size: 11px; }
        .tooltip { position: absolute; background: rgba(41,60,70,0.95); color: white; padding: 10px 14px; border-radius: 8px; font-size: 11px; pointer-events: none; opacity: 0; transition: opacity 0.15s; z-index: 50; max-width: 240px; }
        .tooltip.visible { opacity: 1; }
        .tooltip-title { font-weight: 600; font-size: 12px; color: var(--sw-orange); margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.2); }
        .tooltip-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .tooltip-label { opacity: 0.7; }
        .tooltip-value { font-weight: 500; font-family: 'SF Mono', monospace; }

        /* Polycarb preview blocks */
        .pc-block { width: 16px; height: 20px; border-radius: 2px; border: 1px solid #ccc; }
        .pc-block.steel { background: #6B7B8D; border-color: #5A6A7C; }
        .pc-block.polycarb { border-color: #8ECAE6; }

        /* Pricing Section - Card Layout */
        .pricing-cards-container { display: flex; flex-direction: column; gap: 24px; }
        .q-card { background: #fff; border-radius: 8px; padding: 20px 24px; box-shadow: 0 1px 4px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04); }
        .q-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .q-card-title { font-size: 15px; font-weight: 600; color: var(--sw-text); display: flex; align-items: center; gap: 8px; }
        .q-card-title .status-ok { color: #34C759; }
        .q-card-title .status-warn { color: #FF9500; }
        .q-card-amount { font-size: 22px; font-weight: 700; font-family: 'SF Mono', monospace; color: var(--sw-text); }
        .q-card-sub { font-size: 13px; color: var(--sw-text-sec); margin-bottom: 0; }
        .q-card-edit { font-size: 13px; color: var(--sw-orange); cursor: pointer; font-weight: 500; background: none; border: none; padding: 0; }
        .q-card-edit:hover { text-decoration: underline; }
        /* Labour inline */
        .labour-inline { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 12px; }
        .labour-inline .li-input { width: 60px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: center; }
        .labour-inline .li-input:focus { outline: none; border-color: var(--sw-orange); }
        .labour-inline .li-input.wide { width: 80px; }
        .labour-inline .li-label { font-size: 13px; color: var(--sw-text-sec); }
        .labour-inline .li-equals { font-size: 14px; font-weight: 600; color: var(--sw-text); font-family: 'SF Mono', monospace; }
        .labour-sell-row { display: flex; align-items: center; gap: 10px; margin-top: 10px; padding-top: 10px; border-top: 1px solid #f0f0f0; }
        .labour-sell-row label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .labour-sell-row input { width: 120px; padding: 8px 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 14px; font-family: 'SF Mono', monospace; text-align: right; }
        .labour-sell-row input:focus { outline: none; border-color: var(--sw-orange); }
        /* Extras pills & rows */
        .extras-pills { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
        .extras-pill { padding: 7px 14px; border-radius: 20px; border: 1px solid var(--sw-border); background: #fff; font-size: 13px; cursor: pointer; color: var(--sw-text); transition: all 0.15s; }
        .extras-pill:hover { border-color: var(--sw-orange); color: var(--sw-orange); background: #FFF5F0; }
        .extras-rows { margin-top: 16px; display: flex; flex-direction: column; gap: 8px; }
        .extras-row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #f9f9f9; border-radius: 6px; border: 1px solid #f0f0f0; }
        .extras-row .ex-desc { flex: 1; font-size: 13px; font-weight: 500; color: var(--sw-text); }
        .extras-row .ex-field { display: flex; align-items: center; gap: 4px; font-size: 12px; color: var(--sw-text-sec); }
        .extras-row .ex-input { width: 80px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: right; }
        .extras-row .ex-input:focus { outline: none; border-color: var(--sw-orange); }
        .extras-row .ex-input.desc-input { width: 160px; text-align: left; font-family: inherit; }
        .extras-row .ex-remove { background: none; border: none; color: #ccc; cursor: pointer; font-size: 18px; padding: 0 4px; line-height: 1; transition: color 0.15s; }
        .extras-row .ex-remove:hover { color: #FF3B30; }
        /* Total card */
        .total-card { background: #fff; border-radius: 8px; padding: 28px 24px; box-shadow: 0 1px 4px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04); text-align: center; }
        .total-amount { font-size: 32px; font-weight: 800; font-family: 'SF Mono', monospace; color: var(--sw-text); letter-spacing: -0.5px; }
        .total-label { font-size: 13px; color: var(--sw-text-sec); margin-top: 2px; }
        .total-margin { font-size: 14px; font-weight: 600; margin-top: 10px; font-family: 'SF Mono', monospace; }
        .total-margin.margin-green { color: #34C759; }
        .total-margin.margin-orange { color: #FF9500; }
        .total-margin.margin-red { color: #FF3B30; }
        .btn-generate-quote { display: block; width: 100%; padding: 14px; border: none; border-radius: 8px; background: #F26522; color: white; font-size: 15px; font-weight: 600; cursor: pointer; margin-top: 20px; letter-spacing: 0.3px; transition: background 0.15s; }
        .btn-generate-quote:hover { background: #e05a1a; }
        .total-links { display: flex; justify-content: center; gap: 24px; margin-top: 14px; }
        .total-links a { font-size: 13px; color: var(--sw-text-sec); cursor: pointer; text-decoration: none; }
        .total-links a:hover { color: var(--sw-orange); }
        /* Settings gear */
        .settings-gear { background: none; border: none; cursor: pointer; font-size: 16px; color: var(--sw-text-sec); padding: 4px; transition: color 0.15s; }
        .settings-gear:hover { color: var(--sw-orange); }
        /* Materials modal */
        .mat-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .mat-modal { background: white; border-radius: 12px; padding: 24px; max-width: 800px; width: 95%; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .mat-modal h3 { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
        .mat-modal-controls { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--sw-border); flex-wrap: wrap; }
        .mat-modal-controls label { font-size: 13px; color: var(--sw-text-sec); font-weight: 500; }
        .mat-modal-controls input { width: 60px; padding: 6px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 13px; font-family: 'SF Mono', monospace; text-align: center; }
        .mat-modal-controls input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-controls .btn-apply { padding: 6px 14px; border-radius: 6px; border: 1px solid var(--sw-orange); background: #FFF5F0; color: var(--sw-orange); font-size: 12px; font-weight: 500; cursor: pointer; }
        .mat-modal-controls .btn-apply:hover { background: var(--sw-orange); color: white; }
        .mat-modal-controls .toggle-wrap { display: flex; align-items: center; gap: 6px; margin-left: auto; }
        .mat-modal-controls .toggle-wrap input[type="checkbox"] { accent-color: var(--sw-orange); }
        .mat-modal-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .mat-modal-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 8px 8px; border-bottom: 2px solid var(--sw-border); }
        .mat-modal-table th.r { text-align: right; }
        .mat-modal-table td { padding: 6px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; vertical-align: middle; }
        .mat-modal-table td.r { text-align: right; }
        .mat-modal-table td.mono { font-family: 'SF Mono', monospace; font-size: 12px; }
        .mat-modal-table tr:last-child td { border-bottom: none; }
        .mat-modal-table input { width: 80px; padding: 5px 6px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .mat-modal-table input:focus { outline: none; border-color: var(--sw-orange); }
        .mat-modal-table .markup-badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 500; background: #E8F5E9; color: #2E7D32; }
        .mat-modal-table .markup-badge.custom { background: #FFF3E0; color: #E65100; }
        .mat-modal-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--sw-border); }
        .mat-modal-footer .mat-total { font-size: 16px; font-weight: 700; font-family: 'SF Mono', monospace; }
        .mat-modal-footer .btn-done { padding: 10px 28px; border-radius: 6px; border: none; background: var(--sw-orange); color: white; font-size: 14px; font-weight: 500; cursor: pointer; }
        .mat-modal-footer .btn-done:hover { background: #e05a1a; }
        .mat-modal-footer .btn-add-custom { padding: 8px 16px; border-radius: 6px; border: 1px dashed var(--sw-border); background: none; font-size: 12px; color: var(--sw-text-sec); cursor: pointer; }
        .mat-modal-footer .btn-add-custom:hover { border-color: var(--sw-orange); color: var(--sw-orange); }
        /* Rates modal */
        .rates-modal { background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .rates-modal h3 { font-size: 16px; font-weight: 600; margin-bottom: 16px; }
        .rate-input { width: 80px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-size: 12px; font-family: 'SF Mono', monospace; text-align: right; }
        .rate-input:focus { outline: none; border-color: var(--sw-orange); }
        .pricing-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .pricing-table th { text-align: left; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); padding: 6px 8px; border-bottom: 2px solid var(--sw-border); }
        .pricing-table td { padding: 5px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; }
        .pricing-table th.r, .pricing-table td.r { text-align: right; }
        .pricing-table tr:last-child td { border-bottom: none; }
        /* Hidden elements for PDF compatibility */
        .pdf-data { display: none; }
        /* Collapsible sections */
        .collapse-header { padding: 12px 20px; border-bottom: 1px solid var(--sw-border); display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
        .collapse-header:hover { background: var(--sw-bg); }
        .collapse-header .section-title { font-size: 15px; font-weight: 600; }
        .collapse-header .section-subtitle { font-size: 11px; color: var(--sw-text-sec); }
        .collapse-arrow { font-size: 12px; color: var(--sw-text-sec); transition: transform 0.25s ease; flex-shrink: 0; margin-left: 12px; }
        .collapse-header.collapsed .collapse-arrow { transform: rotate(-90deg); }
        .collapse-header.collapsed { border-bottom: none; }
        .collapse-body { overflow: hidden; transition: max-height 0.35s ease, opacity 0.25s ease; max-height: 2000px; opacity: 1; }
        .collapse-body.shut { max-height: 0; opacity: 0; padding-top: 0; padding-bottom: 0; }
        /* Import/Export modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 500; display: flex; align-items: center; justify-content: center; }
        .modal-box { background: white; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .modal-box h3 { font-size: 16px; margin-bottom: 12px; }
        .modal-box textarea { width: 100%; height: 200px; font-family: 'SF Mono', monospace; font-size: 11px; border: 1px solid var(--sw-border); border-radius: 6px; padding: 10px; resize: vertical; }
        .modal-box textarea:focus { outline: none; border-color: var(--sw-orange); }
        .modal-btns { display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end; }
        .modal-status { font-size: 12px; color: #34C759; margin-top: 8px; min-height: 18px; }
        .job-details-grid { display: grid; grid-template-columns: 140px 1fr 1fr 150px 150px 140px; gap: 10px; align-items: end; }
        .job-details-grid label { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; color: var(--sw-text-sec); margin-bottom: 2px; display: block; }
        .job-details-grid input, .job-details-grid select { width: 100%; font-size: 12px; padding: 5px 8px; border: 1px solid var(--sw-border); border-radius: 4px; font-family: inherit; }
        .job-details-grid input:focus, .job-details-grid select:focus { outline: none; border-color: var(--sw-orange); }
        .job-ref-input { font-family: 'SF Mono', monospace !important; font-weight: 600; color: var(--sw-orange); }
        /* Notes card */
        .notes-inline { margin-top: 12px; }
        .notes-inline textarea { width: 100%; padding: 10px; border: 1px solid var(--sw-border); border-radius: 6px; font-size: 13px; font-family: inherit; resize: vertical; min-height: 60px; }
        .notes-inline textarea:focus { outline: none; border-color: var(--sw-orange); }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">
            <div class="logo-icon"><svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg></div>
            <div class="logo-text">Secure<span>Works</span> WA</div>
        </div>
        <div class="job-badge" id="headerBadge"><strong>SW—</strong></div>
        <button class="btn btn-primary" onclick="exportOrder()">Export Order</button>
    </header>

    <main class="main">
        <!-- SECTION: JOB DETAILS -->
        <div class="section" id="sec-jobdetails">
            <div class="collapse-header" onclick="toggleSection('sec-jobdetails')">
                <div>
                    <div class="section-title">Job Details</div>
                    <div class="section-subtitle">Client info, reference &amp; salesperson</div>
                </div>
                <div style="display:flex;align-items:center;gap:8px">
                    <button class="btn btn-secondary" onclick="event.stopPropagation();exportJobData()">Export Job Data</button>
                    <button class="btn btn-secondary" onclick="event.stopPropagation();showImportModal()">Import Job Data</button>
                    <span class="collapse-arrow">&#9662;</span>
                </div>
            </div>
            <div class="collapse-body">
                <div style="padding:14px 20px">
                    <div class="job-details-grid">
                        <div>
                            <label>Job Ref</label>
                            <input type="text" id="jobRef" class="job-ref-input" placeholder="SW250208-01">
                        </div>
                        <div>
                            <label>Client Name</label>
                            <input type="text" id="clientName" placeholder="Client name">
                        </div>
                        <div>
                            <label>Site Address</label>
                            <input type="text" id="siteAddress" placeholder="Street, suburb, postcode">
                        </div>
                        <div>
                            <label>Phone</label>
                            <input type="text" id="clientPhone" placeholder="0412 345 678">
                        </div>
                        <div>
                            <label>Email</label>
                            <input type="text" id="clientEmail" placeholder="client@email.com">
                        </div>
                        <div>
                            <label>Salesperson</label>
                            <select id="salesperson">
                                <option value="Nithin">Nithin</option>
                                <option value="Marnin">Marnin</option>
                                <option value="Other">Other</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SECTION: PATIO CONFIGURATION -->
        <div class="section" id="sec-config">
            <div class="collapse-header" onclick="toggleSection('sec-config')">
                <div><div class="section-title">Patio Configuration</div><div class="section-subtitle">Dimensions, materials, connection &amp; colours</div></div>
                <span class="collapse-arrow">&#9662;</span>
            </div>
            <div class="collapse-body">
                <div class="section-body">
                <div class="setup-grid">
                    <div class="setup-card">
                        <h4>Patio Type</h4>
                        <div class="field">
                            <label class="field-label">Roof Style</label>
                            <select class="field-input" id="inRoofStyle" onchange="updateUI(); rebuildAll()">
                                <option value="gable">Gable</option>
                                <option value="skillion">Skillion</option>
                            </select>
                        </div>
                        <div class="field" id="orientationField">
                            <label class="field-label">Ridge Direction</label>
                            <select class="field-input" id="inOrientation" onchange="rebuildAll()">
                                <option value="lengthways">Along House (Ridge || House)</option>
                                <option value="perpendicular">Away from House (Ridge ⊥ House)</option>
                            </select>
                        </div>
                        <h4 style="margin-top:10px">Dimensions</h4>
                        <div class="field-row">
                            <div class="field">
                                <label class="field-label">Projection<span class="field-unit">mm</span></label>
                                <input type="number" class="field-input" id="inWidth" value="3000" oninput="rebuildAll()">
                            </div>
                            <div class="field">
                                <label class="field-label">Length<span class="field-unit">mm</span></label>
                                <input type="number" class="field-input" id="inLength" value="6000" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field" id="pitchField">
                                <label class="field-label">Pitch<span class="field-unit">°</span></label>
                                <input type="number" class="field-input" id="inPitch" value="10" step="0.5" oninput="rebuildAll()">
                            </div>
                            <div class="field">
                                <label class="field-label">Post Height<span class="field-unit">mm</span></label>
                                <input type="number" class="field-input" id="inPostHeight" value="2400" oninput="rebuildAll()">
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field">
                                <label class="field-label">Posts (per side)</label>
                                <input type="number" class="field-input" id="inPosts" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="field" id="trussField">
                                <label class="field-label">Trusses</label>
                                <input type="number" class="field-input" id="inTrusses" value="3" min="2" oninput="rebuildAll()">
                            </div>
                            <div class="field" id="rafterField" style="display:none">
                                <label class="field-label">Rafters</label>
                                <input type="number" class="field-input" id="inRafters" value="5" min="2" oninput="rebuildAll()">
                            </div>
                        </div>
                        <!-- Calculated values display -->
                        <div class="calc-display" id="calcDisplay">
                            <div class="calc-row"><span class="calc-label">Rise:</span><span class="calc-value" id="calcRise">--</span></div>
                            <div class="calc-row"><span class="calc-label">Rafter TRUE:</span><span class="calc-value" id="calcRafter">--</span></div>
                            <div class="calc-row" id="calcPitchRow" style="display:none"><span class="calc-label">Actual Pitch:</span><span class="calc-value" id="calcPitch">--</span></div>
                        </div>
                    </div>
                    <div class="setup-card">
                        <h4>2D Site Plan</h4>
                        <div class="plan-2d"><canvas id="plan2d"></canvas></div>
                    </div>
                    <div class="setup-card">
                        <h4>Materials</h4>
                        <div class="field">
                            <label class="field-label">Roof Sheeting</label>
                            <select class="field-input" id="inRoofing" onchange="updateUI(); rebuildAll()">
                                <option value="corrugated">Corrugated</option>
                                <option value="trimdek">Trimdek</option>
                                <option value="insulated">Insulated Panel (Bondor)</option>
                            </select>
                        </div>
                        <div class="field" id="polycarbField" style="display:none">
                            <label class="field-label">Polycarbonate</label>
                            <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
                                <label style="font-size:12px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="no" checked onchange="updatePolycarbUI();rebuildAll()"> No
                                </label>
                                <label style="font-size:12px;display:flex;align-items:center;gap:4px;cursor:pointer">
                                    <input type="radio" name="polycarb" value="yes" onchange="updatePolycarbUI();rebuildAll()"> Yes
                                </label>
                            </div>
                            <div id="polycarbOptions" style="display:none">
                                <div style="margin-bottom:6px">
                                    <label class="field-label" style="font-size:11px">Brand</label>
                                    <select class="field-input" id="inPolycarbBrand" onchange="updatePolycarbTints();rebuildAll()" style="font-size:12px">
                                        <option value="ampelite">Ampelite Solasafe</option>
                                        <option value="laserlite">Laserlite 2000</option>
                                    </select>
                                </div>
                                <div style="margin-bottom:6px">
                                    <label class="field-label" style="font-size:11px">Tint</label>
                                    <select class="field-input" id="inPolycarbTint" onchange="rebuildAll()" style="font-size:12px">
                                    </select>
                                </div>
                                <div style="margin-bottom:6px">
                                    <label class="field-label" style="font-size:11px">Pattern</label>
                                    <select class="field-input" id="inPolycarbPattern" onchange="updatePolycarbPreview();rebuildAll()" style="font-size:12px">
                                        <option value="2">Every 2nd sheet (1:1)</option>
                                        <option value="3" selected>Every 3rd sheet (2:1)</option>
                                        <option value="4">Every 4th sheet (3:1)</option>
                                        <option value="custom">Custom</option>
                                    </select>
                                </div>
                                <div id="polycarbCustomField" style="display:none;margin-bottom:6px">
                                    <label class="field-label" style="font-size:11px">Colorbond per 1 polycarb</label>
                                    <input type="number" class="field-input" id="inPolycarbCustom" value="3" min="1" max="20" step="1" oninput="updatePolycarbPreview();rebuildAll()" style="font-size:12px;width:60px">
                                </div>
                                <div style="margin-top:6px">
                                    <div style="font-size:10px;color:var(--sw-text-sec);margin-bottom:3px">Preview</div>
                                    <div id="polycarbPreview" style="display:flex;gap:2px;flex-wrap:wrap"></div>
                                    <div style="font-size:9px;color:var(--sw-text-sec);margin-top:3px">&#9632;=steel &#9633;=polycarb</div>
                                </div>
                            </div>
                        </div>
                        <div class="field" id="gableInfillField">
                            <label class="field-label">Gable Infill</label>
                            <select class="field-input" id="inInfill" onchange="rebuildAll()">
                                <option value="colorbond">Colorbond</option>
                                <option value="twinwall">10mm Twinwall</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                        <div class="field">
                            <label class="field-label">Steel Size</label>
                            <select class="field-input" id="inTrussSteel" onchange="rebuildAll()">
                                <option value="76x38">76 × 38 × 1.6mm RHS</option>
                                <option value="75x50">75 × 50 × 2.0mm RHS</option>
                                <option value="100x50">100 × 50 × 2.0mm RHS</option>
                            </select>
                        </div>
                        <h4 style="margin-top:12px">Colours</h4>
                        <div style="font-size:11px; color: var(--sw-text-sec); margin-bottom:4px;">Sheets</div>
                        <div class="color-chips" id="sheetChips"></div>
                        <div class="color-label" id="sheetLabel">Monument</div>
                        <div style="font-size:11px; color: var(--sw-text-sec); margin-top:8px; margin-bottom:4px;">Steel</div>
                        <div class="color-chips" id="steelChips"></div>
                        <div class="color-label" id="steelLabel">Monument</div>
                    </div>
                </div>
                <div class="options-grid">
                    <div class="setup-card">
                        <h4>House Connection</h4>
                        <div class="field">
                            <label class="field-label">Type</label>
                            <select class="field-input" id="inConnection" onchange="updateUI(); rebuildAll()">
                                <option value="freestanding">Freestanding</option>
                                <option value="fascia">Receiving Channel (Fascia)</option>
                                <option value="wall">Receiving Channel (Wall)</option>
                                <option value="fasciabeam" disabled>Fascia Beam</option>
                                <option value="riser">Riser Beam</option>
                                <option value="flyover">Flyover</option>
                            </select>
                        </div>
                        <div class="field" id="fasciaHeightField" style="display:none">
                            <label class="field-label">House Fascia Height<span class="field-unit">mm</span></label>
                            <input type="number" class="field-input" id="inFasciaHeight" value="2700" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="riserHeightField" style="display:none">
                            <label class="field-label">Riser Height<span class="field-unit">mm</span></label>
                            <input type="number" class="field-input" id="inRiserHeight" value="400" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="riserOffsetField" style="display:none">
                            <label class="field-label">Riser Offset<span class="field-unit">mm</span></label>
                            <input type="number" class="field-input" id="inRiserOffset" value="150" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="riserQtyField" style="display:none">
                            <label class="field-label">Riser Brackets</label>
                            <input type="number" class="field-input" id="inRiserQty" value="" min="2" oninput="rebuildAll()">
                        </div>
                        <div class="field" id="houseGutterField" style="display:none">
                            <label class="field-label">House Gutter</label>
                            <select class="field-input" id="inHouseGutter" onchange="rebuildAll()">
                                <option value="quad">Existing Quad Gutter</option>
                                <option value="box">Replace with Box Gutter</option>
                            </select>
                        </div>
                        <div class="field" id="riserGutterField" style="display:none">
                            <label class="field-label">Riser Gutter</label>
                            <select class="field-input" id="inRiserGutter" onchange="rebuildAll()">
                                <option value="none">None</option>
                                <option value="quad">Quad Gutter on Riser Beam</option>
                            </select>
                        </div>
                    </div>
                    <div class="setup-card">
                        <h4>Construction</h4>
                        <div class="field">
                            <label class="field-label">Post Fixing</label>
                            <select class="field-input" id="inPostFix">
                                <option value="concrete">Concrete Footing (600mm)</option>
                                <option value="baseplate">Base Plate + Dynabolts</option>
                            </select>
                        </div>
                        <div class="field" id="trussStyleField">
                            <label class="field-label">Truss Style</label>
                            <select class="field-input" id="inTrussStyle" onchange="rebuildAll()">
                                <option value="open">Open (no web)</option>
                                <option value="king">King Post</option>
                                <option value="queen">Queen Post</option>
                            </select>
                        </div>
                    </div>
                    <div class="setup-card">
                        <h4>Notes</h4>
                        <textarea class="field-input" id="jobNotes" rows="4" placeholder="Job notes..."></textarea>
                    </div>
                </div>
                </div>
            </div>
        </div>

        <!-- SECTION: 3D PREVIEW -->
        <div class="section" id="sec-3d">
            <div class="collapse-header" onclick="toggleSection('sec-3d')">
                <div><div class="section-title">3D Preview</div><div class="section-subtitle">Truss calculator &amp; full patio assembly</div></div>
                <span class="collapse-arrow">&#9662;</span>
            </div>
            <div class="collapse-body">

        <!-- Truss Calculator (Gable Only) -->
        <div id="section2" style="padding:20px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
                <div style="font-size:13px;font-weight:600">Gable Truss Calculator</div>
                <div style="display:flex;gap:6px;align-items:center">
                    <label style="font-size:10px;color:var(--sw-text-sec)">Overhang</label>
                    <input type="number" class="field-input" id="inOverhang" value="0" min="0" step="10" style="width:70px;font-size:11px;padding:4px 6px" oninput="rebuildAll()">
                    <span style="font-size:10px;color:var(--sw-text-sec)">mm</span>
                    <button class="btn btn-secondary" style="padding:5px 10px;font-size:11px;margin-left:8px" onclick="exportTrussPDF()">Export Truss PDF</button>
                </div>
            </div>
                <div class="truss-grid">
                    <div class="truss-viewport" id="trussViewport">
                        <canvas id="trussCanvas"></canvas>
                        <div class="truss-view-btns">
                            <button class="truss-view-btn" onclick="setTrussView('3d',this)">3D</button>
                            <button class="truss-view-btn active" onclick="setTrussView('front',this)">Front</button>
                            <button class="truss-view-btn" onclick="setTrussView('side',this)">Side</button>
                        </div>
                    </div>
                    <div class="truss-panel">
                        <div class="truss-card">
                            <h4>Truss Dimensions</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">A: Span (out-out)</div><div class="spec-value" id="specA">3000</div></div>
                                <div class="spec-item"><div class="spec-label">B: Rise</div><div class="spec-value" id="specB">264</div></div>
                                <div class="spec-item"><div class="spec-label">C: Rafter TRUE</div><div class="spec-value hl" id="specC">1523</div></div>
                                <div class="spec-item"><div class="spec-label">D: Pitch</div><div class="spec-value" id="specD">10°</div></div>
                            </div>
                        </div>
                        <div class="truss-card">
                            <h4>Cut Lengths</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">Bottom Chord (cut)</div><div class="spec-value hl" id="specChordCut">--</div></div>
                                <div class="spec-item"><div class="spec-label">Rafter (cut)</div><div class="spec-value hl" id="specRafterCut">--</div></div>
                                <div class="spec-item"><div class="spec-label">Total LM / truss</div><div class="spec-value" id="specLMper">--</div></div>
                                <div class="spec-item"><div class="spec-label">Total LM all</div><div class="spec-value" id="specLMall">--</div></div>
                            </div>
                        </div>
                        <div class="truss-card">
                            <h4>Cut Angles</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">Apex Mitre</div><div class="spec-value" id="angleApex">80°</div></div>
                                <div class="spec-item"><div class="spec-label">Heel Mitre</div><div class="spec-value" id="angleBase">10°</div></div>
                            </div>
                        </div>
                        <div class="truss-card" id="webCard" style="display:none">
                            <h4>Web Members</h4>
                            <div class="spec-grid">
                                <div class="spec-item"><div class="spec-label">King Post</div><div class="spec-value" id="webKing">--</div></div>
                                <div class="spec-item"><div class="spec-label">Queen Posts</div><div class="spec-value" id="webQueen">--</div></div>
                            </div>
                        </div>
                        <!-- Fabricator Order Box -->
                        <div class="fab-box" id="fabOrder" style="white-space:pre;font-family:'SF Mono',monospace;font-size:10px;line-height:1.5;padding:12px;overflow-x:auto"></div>
                    </div>
                </div>
        </div>

        <!-- Full Patio Assembly -->
        <div style="padding:0">
                <div class="asm-viewport" id="asmViewport">
                    <canvas id="asmCanvas"></canvas>
                    <button class="fullscreen-btn" onclick="toggleFullscreen()">⛶ Fullscreen</button>
                    <div class="layer-panel">
                        <div class="layer-title">Layers</div>
                        <div class="layer-item active" data-layer="steel" onclick="toggleLayer('steel',this)"><span class="layer-check"></span>Steel</div>
                        <div class="layer-item active" data-layer="roof" onclick="toggleLayer('roof',this)"><span class="layer-check"></span>Roofing</div>
                        <div class="layer-item active" data-layer="acc" onclick="toggleLayer('acc',this)"><span class="layer-check"></span>Gutters/DP</div>
                        <div class="layer-item active" data-layer="house" onclick="toggleLayer('house',this)"><span class="layer-check"></span>House</div>
                    </div>
                    <div class="tooltip" id="tooltip"><div class="tooltip-title" id="ttTitle"></div><div id="ttContent"></div></div>
                    <div class="view-panel">
                        <button class="view-btn active" onclick="setAsmView('3d',this)">3D</button>
                        <button class="view-btn" onclick="setAsmView('front',this)">Front</button>
                        <button class="view-btn" onclick="setAsmView('side',this)">Side</button>
                        <button class="view-btn" onclick="setAsmView('top',this)">Top</button>
                    </div>
                </div>
        </div>

            </div>
        </div>

        <!-- SECTION: MATERIALS LIST -->
        <div class="section" id="sec-materials">
            <div class="collapse-header collapsed" onclick="toggleSection('sec-materials')">
                <div><div class="section-title">Materials List</div><div class="section-subtitle">Auto-generated from 3D model</div></div>
                <span class="collapse-arrow">&#9662;</span>
            </div>
            <div class="collapse-body shut">
                <div style="padding:16px 20px">
                    <div id="matList"></div>
                </div>
            </div>
        </div>

        <!-- SECTION: PRICING & COSTS -->
        <div class="section" id="sec-pricing">
            <div class="collapse-header" onclick="toggleSection('sec-pricing')">
                <div><div class="section-title">Pricing &amp; Costs</div><div class="section-subtitle">Quote builder</div></div>
                <div style="display:flex;align-items:center;gap:8px">
                    <button class="settings-gear" onclick="event.stopPropagation();openRatesModal()" title="Stored Rates">&#9881;</button>
                    <span class="collapse-arrow">&#9662;</span>
                </div>
            </div>
            <div class="collapse-body">
                <div class="section-body" style="background:#f5f5f5;padding:24px;border-radius:0 0 12px 12px">
                <div class="pricing-cards-container">

                    <!-- CARD 1: MATERIALS -->
                    <div class="q-card" id="materialsCard">
                        <div class="q-card-header">
                            <div>
                                <div class="q-card-title"><span id="matStatusIcon" class="status-ok">&#10003;</span> Materials</div>
                                <div class="q-card-sub"><span id="matItemCount">0 items</span> &bull; <span id="matMarkupPct">35%</span> markup</div>
                            </div>
                            <div style="display:flex;align-items:center;gap:16px">
                                <span class="q-card-amount" id="matSellDisplay">$0</span>
                                <button class="q-card-edit" onclick="openMaterialsModal()">Edit</button>
                            </div>
                        </div>
                    </div>

                    <!-- CARD 2: LABOUR -->
                    <div class="q-card" id="labourCard">
                        <div class="q-card-title">Labour</div>
                        <div class="labour-inline">
                            <input type="number" class="li-input" id="labTrades" value="2" min="1" step="1" oninput="updatePricing()">
                            <span class="li-label">trades</span>
                            <span class="li-label">&times;</span>
                            <input type="number" class="li-input" id="labDays" value="1.5" min="0.5" step="0.5" oninput="updatePricing()">
                            <span class="li-label">days</span>
                            <span class="li-label">&times;</span>
                            <span class="li-label">$</span>
                            <input type="number" class="li-input wide" id="labDayRate" value="400" min="0" step="10" oninput="updatePricing()">
                            <span class="li-label">/day</span>
                            <span class="li-label">=</span>
                            <span class="li-equals" id="labCostDisplay">$1,200</span>
                            <span class="li-label">cost</span>
                        </div>
                        <div class="labour-sell-row">
                            <label>Sell:</label>
                            <input type="number" id="labSellInput" value="2000" min="0" step="50" oninput="updatePricing()" placeholder="0.00">
                        </div>
                    </div>

                    <!-- CARD 3: EXTRAS -->
                    <div class="q-card" id="extrasCard">
                        <div class="q-card-title">Extras</div>
                        <div class="extras-pills">
                            <button class="extras-pill" onclick="addExtra('footings')">+ Footings</button>
                            <button class="extras-pill" onclick="addExtra('electrical')">+ Electrical</button>
                            <button class="extras-pill" onclick="addExtra('downlights')">+ Downlights</button>
                            <button class="extras-pill" onclick="addExtra('demo')">+ Demo</button>
                            <button class="extras-pill" onclick="addExtra('delivery')">+ Delivery</button>
                            <button class="extras-pill" onclick="addExtra('other')">+ Other</button>
                        </div>
                        <div class="extras-rows" id="extrasRowsContainer"></div>
                    </div>

                    <!-- CARD 4: TOTAL -->
                    <div class="total-card" id="totalCard">
                        <div class="total-amount" id="totalAmountDisplay">TOTAL $0 inc GST</div>
                        <div class="total-margin" id="totalMarginDisplay">Margin: $0 (0%)</div>
                        <button class="btn-generate-quote" onclick="generateQuotePDF()">GENERATE QUOTE</button>
                        <div class="total-links">
                            <a onclick="generateMaterialsOrderPDF()">Materials Order</a>
                            <a onclick="generateWorkOrderPDF()">Work Order</a>
                        </div>
                    </div>

                    <!-- Job Notes (compact) -->
                    <div class="q-card">
                        <div class="q-card-title">Job Notes</div>
                        <div class="notes-inline">
                            <textarea id="pricingNotes" placeholder="Install notes, access issues, special requirements..." rows="2"></textarea>
                        </div>
                    </div>

                </div>
                </div>
            </div>
        </div>

        <!-- Hidden: Complexity scores preserved for export/import -->
        <div style="display:none">
            <input type="number" id="cxBuild" value="3"><input type="number" id="cxAccess" value="3">
            <input type="number" id="cxDistance" value="2"><input type="number" id="cxFooting" value="3"><input type="number" id="cxHeight" value="2">
        </div>

        <!-- Materials Edit Modal -->
        <div id="materialsModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)closeMaterialsModal()">
            <div class="mat-modal">
                <h3>Materials &amp; Pricing</h3>
                <div class="mat-modal-controls">
                    <label>Markup:</label>
                    <input type="number" id="globalMarkupPct" value="35" min="0" max="200" step="1">
                    <span style="font-size:13px;color:var(--sw-text-sec)">%</span>
                    <button class="btn-apply" onclick="applyMarkupAll()">Apply to All</button>
                    <div class="toggle-wrap">
                        <input type="checkbox" id="showCostToggle" onchange="renderMaterialsModal()">
                        <label for="showCostToggle" style="font-size:12px;color:var(--sw-text-sec);cursor:pointer">Show cost prices</label>
                    </div>
                </div>
                <table class="mat-modal-table">
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Qty</th>
                            <th class="r cost-col" style="display:none">Cost</th>
                            <th class="r">Sell Price</th>
                            <th class="r">Markup</th>
                            <th style="width:24px"></th>
                        </tr>
                    </thead>
                    <tbody id="matModalBody"></tbody>
                </table>
                <div class="mat-modal-footer">
                    <div>
                        <button class="btn-add-custom" onclick="addCustomMaterialRow()">+ Add Custom Item</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:16px">
                        <span>Total: <span class="mat-total" id="matModalTotal">$0.00</span></span>
                        <button class="btn-done" onclick="closeMaterialsModal()">Done</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Rates Settings Modal -->
        <div id="ratesModal" class="mat-modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
            <div class="rates-modal">
                <h3>Stored Rates</h3>
                <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:12px">Default $/LM rates &amp; day rates. Saved to browser.</p>
                <table class="pricing-table">
                    <thead><tr><th>Material / Role</th><th class="r">Rate $</th></tr></thead>
                    <tbody id="ratesBody"></tbody>
                </table>
                <div style="text-align:right;margin-top:16px">
                    <button class="btn-done" style="padding:8px 20px;border-radius:6px;border:none;background:var(--sw-orange);color:white;font-size:13px;cursor:pointer" onclick="document.getElementById('ratesModal').style.display='none'">Done</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Import Modal -->
    <div id="importModal" class="modal-overlay" style="display:none" onclick="if(event.target===this)this.style.display='none'">
        <div class="modal-box">
            <h3>Import Job Data</h3>
            <p style="font-size:12px;color:var(--sw-text-sec);margin-bottom:8px">Paste previously exported JSON data below, then click Load Job.</p>
            <textarea id="importTextarea" placeholder="Paste job JSON here..."></textarea>
            <div class="modal-status" id="importStatus"></div>
            <div class="modal-btns">
                <button class="btn btn-secondary" onclick="document.getElementById('importModal').style.display='none'">Cancel</button>
                <button class="btn btn-primary" onclick="importJobData()">Load Job</button>
            </div>
        </div>
    </div>

    <script>
        /*
         * V18 FIXES:
         * 1. Downpipes - now extend from ground to actual gutter height (not postH)
         * 2. Gable sheets perpendicular - complete rotation rewrite for proper roof alignment
         * 3. Carry beam condition - removed for gable+fascia (trusses sit on fascia beam directly)
         * 4. Gable+riser beam stacking - riser beam now sits ON TOP of risers correctly
         */

        // ==================== CONFIG ====================
        const COLORS = [
            {name:'Monument',hex:'#2D3436'},{name:'Woodland Grey',hex:'#4B5D52'},{name:'Paperbark',hex:'#C4BAA2'},
            {name:'Surfmist',hex:'#E8E6E0'},{name:'Basalt',hex:'#5C5C5C'},{name:'Manor Red',hex:'#6B2D2D'},
            {name:'Deep Ocean',hex:'#1E3A4C'},{name:'Windspray',hex:'#7D8B8A'}
        ];
        const STEEL = {'76x38':{w:0.076,h:0.038,name:'76×38×1.6',bmt:1.6},'75x50':{w:0.075,h:0.05,name:'75×50×2',bmt:2.0},'100x50':{w:0.1,h:0.05,name:'100×50×2',bmt:2.0}};

        const SHEET_COVERAGE = {
            corrugated: 762,
            trimdek: 762,
            spandek: 762,
            insulated: 1000
        };

        const SPAN_TABLES = {
            corrugated: { maxSpan: 1100, endSpan: 900, needsPurlins: true },
            trimdek: { maxSpan: 2100, endSpan: 1500, needsPurlins: true },
            spandek: { maxSpan: 2400, endSpan: 1800, needsPurlins: true },
            insulated: { maxSpan: 6000, endSpan: 6000, needsPurlins: false }
        };

        // Polycarbonate tint options per brand
        const POLYCARB_TINTS = {
            ampelite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Light Bronze',color:'rgba(180,150,100,0.4)'},
                {name:'Grey',       color:'rgba(160,160,165,0.45)'},
                {name:'Dark Tint',  color:'rgba(80,80,85,0.55)'},
                {name:'Smooth Cream',color:'rgba(245,235,210,0.5)'}
            ],
            laserlite: [
                {name:'Clear',      color:'rgba(173,216,230,0.35)'},
                {name:'Opal',       color:'rgba(240,240,245,0.55)'},
                {name:'Cream',      color:'rgba(245,235,210,0.5)'},
                {name:'Bronze Tint',color:'rgba(170,140,90,0.45)'},
                {name:'Grey Tint',  color:'rgba(150,150,155,0.45)'}
            ]
        };

        // Three.js tint colours for polycarb 3D rendering
        const POLYCARB_3D_TINTS = {
            'Clear':        {color: 0xADD8E6, opacity: 0.3},
            'Opal':         {color: 0xF0F0F5, opacity: 0.45},
            'Light Bronze': {color: 0xB49664, opacity: 0.35},
            'Grey':         {color: 0xA0A0A5, opacity: 0.4},
            'Dark Tint':    {color: 0x505055, opacity: 0.5},
            'Smooth Cream': {color: 0xF5EBD2, opacity: 0.4},
            'Cream':        {color: 0xF5EBD2, opacity: 0.4},
            'Bronze Tint':  {color: 0xAA8C5A, opacity: 0.4},
            'Grey Tint':    {color: 0x969699, opacity: 0.4}
        };

        let sheetColor = COLORS[0];
        let steelColor = COLORS[0];
        let calc = {};

        // ==================== COLOR CHIPS ====================
        function initColorChips(containerId, labelId, setFn) {
            const container = document.getElementById(containerId);
            COLORS.forEach((c,i) => {
                const el = document.createElement('div');
                el.className = 'color-chip' + (i===0?' active':'');
                el.style.background = c.hex;
                el.title = c.name;
                el.onclick = () => {
                    setFn(c);
                    container.querySelectorAll('.color-chip').forEach(x=>x.classList.remove('active'));
                    el.classList.add('active');
                    document.getElementById(labelId).textContent = c.name;
                    rebuildAll();
                };
                container.appendChild(el);
            });
        }
        initColorChips('sheetChips', 'sheetLabel', c => sheetColor = c);
        initColorChips('steelChips', 'steelLabel', c => steelColor = c);

        // ==================== POLYCARBONATE ====================
        function isPolycarbEnabled() {
            return document.querySelector('input[name="polycarb"][value="yes"]')?.checked || false;
        }

        function getPolycarbConfig() {
            if (!isPolycarbEnabled()) return null;
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintEl = document.getElementById('inPolycarbTint');
            const tint = tintEl.value || 'Clear';
            const patternSel = document.getElementById('inPolycarbPattern').value;
            let steelPerPoly;
            if (patternSel === 'custom') {
                steelPerPoly = parseInt(document.getElementById('inPolycarbCustom').value) || 3;
            } else {
                steelPerPoly = parseInt(patternSel) - 1; // "Every 3rd" = 2 steel per 1 poly
            }
            return { brand, tint, steelPerPoly, patternN: steelPerPoly + 1 };
        }

        function getPolycarbSheetSplit(totalSheets) {
            const pc = getPolycarbConfig();
            if (!pc) return { colorbond: totalSheets, polycarb: 0 };
            const patternN = pc.patternN;
            const fullGroups = Math.floor(totalSheets / patternN);
            const remainder = totalSheets % patternN;
            const polycarb = fullGroups + (remainder >= patternN ? 1 : 0);
            const colorbond = totalSheets - polycarb;
            return { colorbond, polycarb };
        }

        function updatePolycarbUI() {
            const enabled = isPolycarbEnabled();
            document.getElementById('polycarbOptions').style.display = enabled ? 'block' : 'none';
            if (enabled) {
                updatePolycarbTints();
                updatePolycarbPreview();
            }
        }

        function updatePolycarbTints() {
            const brand = document.getElementById('inPolycarbBrand').value;
            const tintSelect = document.getElementById('inPolycarbTint');
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const currentVal = tintSelect.value;
            tintSelect.innerHTML = tints.map(t =>
                `<option value="${t.name}">${t.name}</option>`
            ).join('');
            // Restore previous selection if still valid
            if (tints.some(t => t.name === currentVal)) {
                tintSelect.value = currentVal;
            }
            updatePolycarbPreview();
        }

        function updatePolycarbPreview() {
            const container = document.getElementById('polycarbPreview');
            if (!container) return;
            const patternSel = document.getElementById('inPolycarbPattern').value;
            document.getElementById('polycarbCustomField').style.display = patternSel === 'custom' ? 'block' : 'none';
            const pc = getPolycarbConfig();
            if (!pc) { container.innerHTML = ''; return; }

            // Get tint colour for preview
            const brand = pc.brand;
            const tints = POLYCARB_TINTS[brand] || POLYCARB_TINTS.ampelite;
            const tintObj = tints.find(t => t.name === pc.tint) || tints[0];
            const tintColor = tintObj.color;

            // Show ~12 blocks as preview
            const previewCount = Math.min(12, Math.max(6, pc.patternN * 3));
            let html = '';
            for (let i = 0; i < previewCount; i++) {
                const isPoly = ((i + 1) % pc.patternN) === 0;
                if (isPoly) {
                    html += `<div class="pc-block polycarb" style="background:${tintColor}"></div>`;
                } else {
                    html += `<div class="pc-block steel"></div>`;
                }
            }
            container.innerHTML = html;
        }

        // Init polycarb tints on load
        updatePolycarbTints();

        // ==================== UI UPDATES ====================
        function updateUI() {
            const roofSelect = document.getElementById('inRoofStyle');
            const connSelect = document.getElementById('inConnection');
            const roofingSelect = document.getElementById('inRoofing');
            let conn = connSelect.value;
            const roofing = roofingSelect.value;
            // === RESTRICTION: Receiving channel (wall) only works with skillion ===
            // Gable + fascia is allowed (truss attaches to side of fascia beam)
            const gableOption = roofSelect.querySelector('option[value="gable"]');
            if (conn === 'wall') {
                if (roofSelect.value === 'gable') roofSelect.value = 'skillion';
                gableOption.disabled = true;
            } else {
                gableOption.disabled = false;
            }

            // === RESTRICTION: Gable doesn't work with receiving channels ===
            const fasciaOption = connSelect.querySelector('option[value="fascia"]');
            const wallOption = connSelect.querySelector('option[value="wall"]');
            const fasciaBeamOption = connSelect.querySelector('option[value="fasciabeam"]');
            const style = roofSelect.value;
            const isGable = style === 'gable';
            if (isGable) {
                // Gable can ONLY use: Freestanding, Fascia Beam, or Riser
                if (conn === 'fascia' || conn === 'wall') { connSelect.value = 'fasciabeam'; conn = 'fasciabeam'; }
                fasciaOption.disabled = true;
                wallOption.disabled = true;
                fasciaBeamOption.disabled = false;
            } else {
                // Skillion: no fascia beam option
                if (conn === 'fasciabeam') { connSelect.value = 'fascia'; conn = 'fascia'; }
                fasciaOption.disabled = false;
                wallOption.disabled = false;
                fasciaBeamOption.disabled = true;
            }

            // === RESTRICTION: Flyover only works with insulated panels + skillion ===
            const flyoverOption = connSelect.querySelector('option[value="flyover"]');
            if (roofing !== 'insulated' || isGable) {
                if (conn === 'flyover') {
                    connSelect.value = isGable ? 'riser' : 'riser';
                    conn = 'riser';
                }
                flyoverOption.disabled = true;
            } else {
                flyoverOption.disabled = false;
            }

            const isAttached = conn !== 'freestanding';

            document.getElementById('section2').style.display = isGable ? 'block' : 'none';
            document.getElementById('orientationField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussField').style.display = isGable ? 'block' : 'none';
            document.getElementById('rafterField').style.display = isGable ? 'none' : 'block';
            document.getElementById('gableInfillField').style.display = isGable ? 'block' : 'none';
            document.getElementById('trussStyleField').style.display = isGable ? 'block' : 'none';

            const showPitchInput = isGable || !isAttached;
            document.getElementById('pitchField').style.display = showPitchInput ? 'block' : 'none';
            document.getElementById('calcPitchRow').style.display = (!isGable && isAttached) ? 'flex' : 'none';

            // Fascia height needed for all attached types (sets connection height)
            document.getElementById('fasciaHeightField').style.display = isAttached ? 'block' : 'none';
            const showRiserOptions = conn === 'riser';
            document.getElementById('riserHeightField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserOffsetField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserQtyField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('houseGutterField').style.display = showRiserOptions ? 'block' : 'none';
            document.getElementById('riserGutterField').style.display = (showRiserOptions && isGable) ? 'block' : 'none';

            // Polycarbonate: only for Trimdek (5-Rib)
            const showPolycarb = roofing === 'trimdek';
            document.getElementById('polycarbField').style.display = showPolycarb ? 'block' : 'none';
            if (!showPolycarb) {
                // Reset polycarb to "No" when switching away from Trimdek
                const noRadio = document.querySelector('input[name="polycarb"][value="no"]');
                if (noRadio) noRadio.checked = true;
                document.getElementById('polycarbOptions').style.display = 'none';
            }
        }

        // ==================== GET INPUTS & CALCULATE ====================
        function getInputs() {
            const roofStyle = document.getElementById('inRoofStyle').value;
            const orientation = document.getElementById('inOrientation').value;
            const projInput = parseFloat(document.getElementById('inWidth').value) || 3000;
            const lenInput = parseFloat(document.getElementById('inLength').value) || 6000;
            const userPitch = parseFloat(document.getElementById('inPitch').value) || 10;
            const postH = parseFloat(document.getElementById('inPostHeight').value) || 2400;
            const nPosts = parseInt(document.getElementById('inPosts').value) || 3;
            const nTruss = parseInt(document.getElementById('inTrusses').value) || 3;
            const nRafters = parseInt(document.getElementById('inRafters').value) || 5;
            const trussStyle = document.getElementById('inTrussStyle').value;
            const trussSteel = document.getElementById('inTrussSteel').value;
            const roofing = document.getElementById('inRoofing').value;
            const infill = document.getElementById('inInfill').value;
            const connection = document.getElementById('inConnection').value;
            const fasciaH = parseFloat(document.getElementById('inFasciaHeight').value) || 2700;
            const riserH = parseFloat(document.getElementById('inRiserHeight').value) || 400;
            const riserOffset = parseFloat(document.getElementById('inRiserOffset').value) || 150;
            const riserQtyInput = parseInt(document.getElementById('inRiserQty').value);
            const houseGutter = document.getElementById('inHouseGutter').value;
            const riserGutter = document.getElementById('inRiserGutter').value;

            const isGable = roofStyle === 'gable';
            const isAttached = connection !== 'freestanding';
            const hasFascia = (connection === 'fascia' || connection === 'fasciabeam' || connection === 'riser' || connection === 'flyover');
            const isRecvChan = (connection === 'fascia' || connection === 'wall');

            let W, L;
            if (isGable && orientation === 'perpendicular') {
                W = lenInput;
                L = projInput;
            } else {
                W = projInput;
                L = lenInput;
            }

            // ========== V18 FIX: BEAM HEIGHTS - Proper stacking for gable+riser ==========
            let frontBeamY = postH;
            const beamH = 50;  // 50mm beam height
            const riserMemberSize = 75;  // 75mm SHS riser members
            // Patio attaches at rafter level (fasciaH = wall top / rafter base)
            // This is ABOVE the fascia board and gutter which hang below

            let backBeamY, fasciaBeamY;
            if (isGable) {
                if (connection === 'riser') {
                    // Gable + Riser: fascia beam sits below house gutter, against lower house fascia
                    // Gutter front face 76mm + 5mm gap ≈ beam top 50mm below fascia top
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    const elevatedBeamY = fasciaH + beamH + riserMemberSize + riserH;
                    frontBeamY = elevatedBeamY;
                    backBeamY = elevatedBeamY;
                } else if (connection === 'fascia' || connection === 'fasciabeam' || connection === 'wall') {
                    // Gable + Fascia/Wall/FasciaBeam: both beams lowered for sheet clearance
                    fasciaBeamY = (connection === 'fascia' || connection === 'fasciabeam') ? (fasciaH) : null;
                    frontBeamY = fasciaH;
                    backBeamY = fasciaH;
                } else if (connection === 'flyover') {
                    // Gable + Flyover: beams above existing house roof
                    fasciaBeamY = fasciaH;
                    // Calculate actual house roof rise: 1.5m depth at 15° pitch
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150; // 150mm clearance above roof ridge
                    const flyoverBeamY = fasciaH + houseRoofRise + flyoverClearance;
                    frontBeamY = flyoverBeamY;
                    backBeamY = flyoverBeamY;
                } else {
                    // Freestanding - back beam at post height
                    backBeamY = postH;
                    fasciaBeamY = null;
                }
            } else {
                // SKILLION
                if (connection === 'freestanding') {
                    const rise = W * Math.tan(userPitch * Math.PI / 180);
                    backBeamY = postH + rise;
                    fasciaBeamY = null;
                } else if (connection === 'riser') {
                    // Fascia beam sits below house gutter, against lower house fascia
                    fasciaBeamY = fasciaH - 155;  // Below gutter, in exposed lower fascia zone
                    backBeamY = fasciaH + beamH + riserMemberSize + riserH;
                } else if (connection === 'flyover') {
                    fasciaBeamY = fasciaH;
                    const houseRoofRise = 1500 * Math.tan(15 * Math.PI / 180); // ~402mm
                    const flyoverClearance = 150;
                    backBeamY = fasciaH + houseRoofRise + flyoverClearance;
                } else {
                    // fascia or wall
                    fasciaBeamY = (connection === 'fascia' || connection === 'fasciabeam') ? (fasciaH) : null;
                    backBeamY = fasciaH;
                }
            }

            // ========== PITCH & RISE CALCULATION ==========
            let pitch, pitchRad, rise, rafter, trussSpan;

            if (isGable) {
                pitch = userPitch;
                pitchRad = pitch * Math.PI / 180;
                trussSpan = W;
                rise = (W / 2) * Math.tan(pitchRad);
                rafter = Math.sqrt((W / 2) ** 2 + rise ** 2);
            } else {
                rise = backBeamY - frontBeamY;
                pitch = Math.atan(rise / W) * 180 / Math.PI;
                pitchRad = pitch * Math.PI / 180;
                rafter = Math.sqrt(W ** 2 + rise ** 2);
                trussSpan = W;
            }

            calc = {
                roofStyle, orientation, W, L, projInput, lenInput, userPitch, pitch, pitchRad,
                postH, nPosts, nTruss, nRafters, trussStyle, trussSteel, trussSpan,
                roofing, infill, connection, fasciaH, riserH, riserOffset, houseGutter, riserGutter,
                riserQty: riserQtyInput || Math.max(2, Math.ceil(L / 1200)),
                rise, rafter, isGable, isAttached, hasFascia, isRecvChan,
                frontBeamY, backBeamY, fasciaBeamY,
                steel: STEEL[trussSteel],
                sheetCoverage: SHEET_COVERAGE[roofing]
            };

            document.getElementById('calcRise').textContent = Math.round(rise) + 'mm';
            document.getElementById('calcRafter').textContent = Math.round(rafter) + 'mm';
            document.getElementById('calcPitch').textContent = pitch.toFixed(1) + '°';
            // Set riser qty placeholder to show calculated default
            document.getElementById('inRiserQty').placeholder = Math.max(2, Math.ceil(L / 1200));

            if (isGable) {
                const steelW = STEEL[trussSteel].w * 1000;
                const steelH = STEEL[trussSteel].h * 1000;
                const bmt = STEEL[trussSteel].bmt;
                const overhang = parseFloat(document.getElementById('inOverhang')?.value) || 0;
                const apexAngle = 90 - pitch;
                const heelAngle = pitch;
                const cosP = Math.cos(pitchRad);
                const sinP = Math.sin(pitchRad);

                // Bottom chord cut length: span minus steel depth projection at each heel
                const heelDeduct = steelH / Math.tan(pitchRad + Math.PI/2 - pitchRad);
                const chordCut = Math.round(trussSpan - 2 * steelH * cosP);

                // Rafter cut length: from heel face to apex face
                const apexDeduct = steelH / (2 * sinP);
                const heelAllowance = steelH * cosP;
                const rafterCut = Math.round(rafter - apexDeduct - heelAllowance + overhang);

                // Total steel
                const lmPerTruss = ((chordCut + 2 * rafterCut) / 1000);
                const lmAll = lmPerTruss * nTruss;
                const stickLength = 6000;
                const sticksNeeded = Math.ceil((lmAll * 1000) / stickLength);

                const kingPostH = rise - steelH;
                const queenPostH = rise * 0.6;
                const queenSpacing = trussSpan * 0.2;

                // Web member lengths
                let webLM = 0;
                let webText = '';
                const showWeb = trussStyle === 'king' || trussStyle === 'queen';
                document.getElementById('webCard').style.display = showWeb ? 'block' : 'none';
                if (trussStyle === 'king') {
                    const kh = Math.round(kingPostH);
                    document.getElementById('webKing').textContent = kh + 'mm';
                    document.getElementById('webQueen').textContent = '--';
                    webLM = kh / 1000;
                    webText = '  King Post:     1 × ' + kh + 'mm';
                } else if (trussStyle === 'queen') {
                    const qh = Math.round(queenPostH);
                    document.getElementById('webKing').textContent = '--';
                    document.getElementById('webQueen').textContent = qh + 'mm × 2';
                    const topBar = Math.round(trussSpan * 0.4);
                    webLM = (qh * 2 + topBar) / 1000;
                    webText = '  Queen Posts:   2 × ' + qh + 'mm\n  Top Chord:     1 × ' + topBar + 'mm';
                }

                const totalLM = lmPerTruss + webLM;
                const totalAllLM = totalLM * nTruss;
                const totalSticks = Math.ceil((totalAllLM * 1000) / stickLength);

                // Update spec cards
                document.getElementById('specA').textContent = Math.round(trussSpan);
                document.getElementById('specB').textContent = Math.round(rise);
                document.getElementById('specC').textContent = Math.round(rafter);
                document.getElementById('specD').textContent = pitch.toFixed(1) + '°';

                document.getElementById('specChordCut').textContent = chordCut;
                document.getElementById('specRafterCut').textContent = rafterCut + (overhang > 0 ? ' (+' + overhang + ')' : '');
                document.getElementById('specLMper').textContent = totalLM.toFixed(2);
                document.getElementById('specLMall').textContent = totalAllLM.toFixed(1);

                document.getElementById('angleApex').textContent = apexAngle.toFixed(1) + '°';
                document.getElementById('angleBase').textContent = heelAngle.toFixed(1) + '°';

                // Build fabricator order text
                const steelName = STEEL[trussSteel].name;
                const clr = steelColor.name;
                const pad = (s, n) => s + ' '.repeat(Math.max(0, n - s.length));
                let fab = '';
                fab += '\u2554' + '\u2550'.repeat(44) + '\u2557\n';
                fab += '\u2551  TRUSS FABRICATION ORDER' + ' '.repeat(20) + '\u2551\n';
                fab += '\u2560' + '\u2550'.repeat(44) + '\u2563\n';
                fab += '\u2551  Steel: ' + pad(steelName + ' RHS', 35) + '\u2551\n';
                fab += '\u2551  Colour: ' + pad(clr, 34) + '\u2551\n';
                fab += '\u2551  BMT: ' + pad(bmt + 'mm', 37) + '\u2551\n';
                fab += '\u2551  Qty: ' + pad(nTruss + ' trusses', 37) + '\u2551\n';
                fab += '\u2560' + '\u2550'.repeat(44) + '\u2563\n';
                fab += '\u2551  DIMENSIONS' + ' '.repeat(32) + '\u2551\n';
                fab += '\u2551  Span (out-out): ' + pad(Math.round(trussSpan) + 'mm', 26) + '\u2551\n';
                fab += '\u2551  Rise: ' + pad(Math.round(rise) + 'mm', 37) + '\u2551\n';
                fab += '\u2551  Pitch: ' + pad(pitch.toFixed(1) + '\u00B0', 36) + '\u2551\n';
                if (overhang > 0) fab += '\u2551  Overhang: ' + pad(overhang + 'mm', 32) + '\u2551\n';
                fab += '\u2560' + '\u2550'.repeat(44) + '\u2563\n';
                fab += '\u2551  CUT LIST (per truss)' + ' '.repeat(22) + '\u2551\n';
                fab += '\u2551  Bottom Chord: 1 × ' + pad(chordCut + 'mm', 24) + '\u2551\n';
                fab += '\u2551  Rafters:      2 × ' + pad(rafterCut + 'mm', 24) + '\u2551\n';
                if (webText) {
                    webText.split('\n').forEach(wl => {
                        fab += '\u2551' + pad(wl, 44) + '\u2551\n';
                    });
                }
                fab += '\u2560' + '\u2550'.repeat(44) + '\u2563\n';
                fab += '\u2551  CUT ANGLES' + ' '.repeat(32) + '\u2551\n';
                fab += '\u2551  Apex Mitre: ' + pad(apexAngle.toFixed(1) + '\u00B0 (both rafters)', 30) + '\u2551\n';
                fab += '\u2551  Heel Mitre: ' + pad(heelAngle.toFixed(1) + '\u00B0 (rafter to chord)', 30) + '\u2551\n';
                fab += '\u2560' + '\u2550'.repeat(44) + '\u2563\n';
                fab += '\u2551  MATERIAL REQUIRED' + ' '.repeat(25) + '\u2551\n';
                fab += '\u2551  Per truss: ' + pad(totalLM.toFixed(3) + ' LM', 31) + '\u2551\n';
                fab += '\u2551  All trusses: ' + pad(totalAllLM.toFixed(2) + ' LM', 29) + '\u2551\n';
                fab += '\u2551  Order: ' + pad(totalSticks + ' × 6m sticks', 36) + '\u2551\n';
                fab += '\u255A' + '\u2550'.repeat(44) + '\u255D';

                document.getElementById('fabOrder').textContent = fab;

                // Store truss data for PDF export
                calc.trussData = {
                    steelName, bmt, clr, nTruss, trussSpan: Math.round(trussSpan),
                    rise: Math.round(rise), pitch, overhang, chordCut, rafterCut,
                    apexAngle, heelAngle, webText, totalLM, totalAllLM, totalSticks,
                    trussStyle, kingPostH: Math.round(kingPostH), queenPostH: Math.round(queenPostH),
                    queenSpacing: Math.round(queenSpacing)
                };
            }

            return calc;
        }

        // ==================== 2D PLAN ====================
        function draw2DPlan() {
            const canvas = document.getElementById('plan2d');
            const p = canvas.parentElement;
            canvas.width = p.clientWidth; canvas.height = p.clientHeight;
            const ctx = canvas.getContext('2d');
            const c = calc;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            const planL = c.lenInput;
            const planW = c.projInput;

            const scale = Math.min((canvas.width-60)/planL, (canvas.height-60)/planW) * 0.85;
            const ox = (canvas.width - planL*scale)/2;
            const oy = (canvas.height - planW*scale)/2 + 10;

            if (c.connection !== 'freestanding') {
                ctx.fillStyle = '#D4C4B0';
                ctx.fillRect(ox-5, oy-20, planL*scale+10, 18);
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('HOUSE', ox+planL*scale/2, oy-6);
            }

            ctx.strokeStyle = steelColor.hex;
            ctx.lineWidth = 2;
            ctx.strokeRect(ox, oy, planL*scale, planW*scale);

            ctx.strokeStyle = '#F15A29';
            ctx.lineWidth = 2;
            if (c.isGable) {
                if (c.orientation === 'lengthways') {
                    ctx.beginPath();
                    ctx.moveTo(ox, oy + planW*scale/2);
                    ctx.lineTo(ox + planL*scale, oy + planW*scale/2);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.fillText('RIDGE', ox + planL*scale/2, oy + planW*scale/2 - 5);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(ox + planL*scale/2, oy);
                    ctx.lineTo(ox + planL*scale/2, oy + planW*scale);
                    ctx.stroke();
                    ctx.fillStyle = '#F15A29';
                    ctx.font = '9px sans-serif';
                    ctx.save();
                    ctx.translate(ox + planL*scale/2 + 12, oy + planW*scale/2);
                    ctx.rotate(-Math.PI/2);
                    ctx.fillText('RIDGE', 0, 0);
                    ctx.restore();
                }
            } else {
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2, oy + 15);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(ox + planL*scale/2 - 6, oy + planW*scale - 25);
                ctx.lineTo(ox + planL*scale/2, oy + planW*scale - 15);
                ctx.lineTo(ox + planL*scale/2 + 6, oy + planW*scale - 25);
                ctx.stroke();
                ctx.fillStyle = '#F15A29';
                ctx.font = '9px sans-serif';
                ctx.fillText('FALL ' + calc.pitch.toFixed(1) + '°', ox + planL*scale/2 + 30, oy + planW*scale/2);
            }

            ctx.fillStyle = steelColor.hex;
            for (let i = 0; i < c.nPosts; i++) {
                const x = ox + (planL*scale/(c.nPosts-1)) * i;
                ctx.fillRect(x-4, oy + planW*scale - 4, 8, 8);
            }

            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = ox + (planL*scale/(c.nPosts-1)) * i;
                    ctx.fillRect(x-4, oy - 4, 8, 8);
                }
            }

            if (c.isAttached) {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.lineTo(ox + planL*scale, oy);
                ctx.stroke();
                ctx.fillStyle = '#666';
                ctx.font = '8px sans-serif';
                ctx.fillText('FASCIA', ox + planL*scale/2, oy + 10);
            }

            ctx.fillStyle = '#333';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(planL + 'mm', ox + planL*scale/2, oy + planW*scale + 20);
            ctx.save();
            ctx.translate(ox - 15, oy + planW*scale/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText(planW + 'mm', 0, 0);
            ctx.restore();
        }

        // ==================== TRUSS 3D (Section 2) ====================
        let trussScene, trussCam, trussRend, trussGroup;
        // Truss camera: orbit around Y axis
        let tCamT = 0, tCamP = 0.15, tCamD = 3;
        let tCamTarget = new THREE.Vector3(0, 0.15, 0);
        let tDrag = false, tLast = {x:0,y:0};

        function initTruss3D() {
            const container = document.getElementById('trussViewport');
            const canvas = document.getElementById('trussCanvas');
            trussScene = new THREE.Scene();
            trussScene.background = new THREE.Color(0xE4E7EB);
            trussCam = new THREE.PerspectiveCamera(35, container.clientWidth/container.clientHeight, 0.01, 50);
            trussRend = new THREE.WebGLRenderer({canvas, antialias: true});
            trussRend.setSize(container.clientWidth, container.clientHeight);
            trussRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            trussScene.add(new THREE.AmbientLight(0xffffff, 0.65));
            const light = new THREE.DirectionalLight(0xffffff, 0.7);
            light.position.set(3, 5, 4);
            trussScene.add(light);

            trussGroup = new THREE.Group();
            trussScene.add(trussGroup);

            canvas.addEventListener('mousedown', e => { tDrag = true; tLast = {x:e.clientX,y:e.clientY}; });
            canvas.addEventListener('mousemove', e => {
                if (!tDrag) return;
                tCamT -= (e.clientX - tLast.x) * 0.01;
                tCamP = Math.max(-0.3, Math.min(1.2, tCamP - (e.clientY - tLast.y) * 0.008));
                updateTrussCam();
                tLast = {x:e.clientX, y:e.clientY};
            });
            canvas.addEventListener('mouseup', () => tDrag = false);
            canvas.addEventListener('mouseleave', () => tDrag = false);
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                tCamD = Math.max(1, Math.min(10, tCamD + e.deltaY * 0.003));
                updateTrussCam();
            }, {passive: false});

            // Default to front view
            setTrussView('front', document.querySelector('.truss-view-btn.active'));
            buildTruss3D();
            animateTruss();
        }

        function updateTrussCam() {
            // Camera orbits in XZ plane, looking at target (center of truss)
            trussCam.position.set(
                tCamTarget.x + tCamD * Math.sin(tCamT) * Math.cos(tCamP),
                tCamTarget.y + tCamD * Math.sin(tCamP),
                tCamTarget.z + tCamD * Math.cos(tCamT) * Math.cos(tCamP)
            );
            trussCam.lookAt(tCamTarget);
        }

        // Truss is built in XY plane: X = span (horizontal), Y = rise (vertical), Z = depth
        function buildTruss3D() {
            while (trussGroup.children.length) trussGroup.remove(trussGroup.children[0]);
            if (!calc.isGable) return;

            const c = calc;
            const span = c.trussSpan / 1000;   // meters
            const rise = c.rise / 1000;
            const halfSpan = span / 2;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;   // width (visible from front)
            const th = c.steel.h;   // height (depth into screen)
            const overhang = (parseFloat(document.getElementById('inOverhang')?.value) || 0) / 1000;
            const mat = new THREE.MeshStandardMaterial({color: new THREE.Color(steelColor.hex), metalness: 0.75, roughness: 0.35});

            // Set camera target to center of truss
            tCamTarget.set(0, (th + rise) * 0.45, 0);

            // --- Bottom chord (horizontal along X) ---
            const chordGeo = new THREE.BoxGeometry(span, th, tw);
            const chord = new THREE.Mesh(chordGeo, mat.clone());
            chord.position.set(0, th/2, 0);
            trussGroup.add(chord);

            // --- Left rafter (from bottom-left going up to apex) ---
            const rafterLen = rafter + overhang;
            const leftGeo = new THREE.BoxGeometry(rafterLen, th, tw);
            leftGeo.translate(rafterLen/2, 0, 0);
            const leftRafter = new THREE.Mesh(leftGeo, mat.clone());
            leftRafter.position.set(-halfSpan, th, 0);
            leftRafter.rotation.z = c.pitchRad;
            trussGroup.add(leftRafter);

            // --- Right rafter (from bottom-right going up to apex) ---
            const rightGeo = new THREE.BoxGeometry(rafterLen, th, tw);
            rightGeo.translate(-rafterLen/2, 0, 0);
            const rightRafter = new THREE.Mesh(rightGeo, mat.clone());
            rightRafter.position.set(halfSpan, th, 0);
            rightRafter.rotation.z = -c.pitchRad;
            trussGroup.add(rightRafter);

            // --- Web members ---
            if (c.trussStyle === 'king') {
                const kingH = rise - th;
                if (kingH > 0) {
                    const king = new THREE.Mesh(new THREE.BoxGeometry(tw, kingH, tw), mat.clone());
                    king.position.set(0, th + kingH/2, 0);
                    trussGroup.add(king);
                }
            } else if (c.trussStyle === 'queen') {
                const qH = rise * 0.6;
                const qX = span * 0.2;
                [-1, 1].forEach(s => {
                    const q = new THREE.Mesh(new THREE.BoxGeometry(tw, qH, tw), mat.clone());
                    q.position.set(s * qX, th + qH/2, 0);
                    trussGroup.add(q);
                });
                const topChord = new THREE.Mesh(new THREE.BoxGeometry(span * 0.4, th, tw), mat.clone());
                topChord.position.set(0, th + qH, 0);
                trussGroup.add(topChord);
            }

            // --- Dimension annotations ---
            const dimMat = new THREE.LineBasicMaterial({color: 0xF15A29});
            const offset = 0.08;

            // A: Span line (below chord)
            const spanY = -offset;
            addDimLine(-halfSpan, spanY, halfSpan, spanY, dimMat);
            addTrussLabel('A: ' + Math.round(c.trussSpan) + 'mm', 0, spanY - 0.07);

            // B: Rise line (right side)
            const riseX = halfSpan + offset * 1.5;
            addDimLine(riseX, th, riseX, th + rise, dimMat);
            addTrussLabel('B: ' + Math.round(c.rise) + 'mm', riseX + 0.15, th + rise/2);

            // C: Rafter label (along left rafter)
            const rMidX = -halfSpan * 0.55;
            const rMidY = th + rise * 0.55;
            addTrussLabel('C: ' + Math.round(c.rafter) + 'mm', rMidX - 0.18, rMidY + 0.05);

            // Angle arc at heel (bottom-right)
            addAngleArc(halfSpan, th, 0.15, c.pitchRad, dimMat);
            addSmallLabel(c.pitch.toFixed(1) + '\u00B0', halfSpan - 0.06, th + 0.07);

            // Angle arc at apex
            addAngleArc(0, th + rise, 0.1, Math.PI/2 - c.pitchRad, dimMat, true);
            addSmallLabel((90 - c.pitch).toFixed(1) + '\u00B0', 0, th + rise + 0.08);

            // Cut markers
            addCutMarker(0, th + rise, 'APEX');
            addCutMarker(-halfSpan, th, 'HEEL');
            addCutMarker(halfSpan, th, 'HEEL');

            updateTrussCam();
        }

        function addDimLine(x1, y1, x2, y2, mat) {
            const pts = [new THREE.Vector3(x1, y1, 0), new THREE.Vector3(x2, y2, 0)];
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            trussGroup.add(new THREE.Line(geo, mat));
            const tick = 0.025;
            const isVert = Math.abs(y2 - y1) > Math.abs(x2 - x1);
            [pts[0], pts[1]].forEach(p => {
                const t = isVert
                    ? [new THREE.Vector3(p.x - tick, p.y, 0), new THREE.Vector3(p.x + tick, p.y, 0)]
                    : [new THREE.Vector3(p.x, p.y - tick, 0), new THREE.Vector3(p.x, p.y + tick, 0)];
                trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(t), mat));
            });
        }

        function addAngleArc(cx, cy, radius, angle, mat, isApex) {
            const pts = [];
            const segs = 20;
            for (let i = 0; i <= segs; i++) {
                const a = (i / segs) * angle;
                if (isApex) {
                    // Arc from vertical down to rafter angle
                    const startAngle = Math.PI/2 + angle;
                    const aa = startAngle - (i / segs) * angle;
                    pts.push(new THREE.Vector3(cx + radius * Math.cos(aa), cy + radius * Math.sin(aa), 0));
                } else {
                    // Arc from horizontal up to rafter angle (at right heel)
                    pts.push(new THREE.Vector3(cx - radius * Math.cos(a), cy + radius * Math.sin(a), 0));
                }
            }
            trussGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
        }

        function addCutMarker(x, y, label) {
            const markerMat = new THREE.MeshBasicMaterial({color: 0xFF6B35, transparent: true, opacity: 0.8});
            const marker = new THREE.Mesh(new THREE.CircleGeometry(0.02, 12), markerMat);
            marker.position.set(x, y, 0.01);
            trussGroup.add(marker);
        }

        function addSmallLabel(text, x, y) {
            const cv = document.createElement('canvas');
            cv.width = 100; cv.height = 22;
            const ctx = cv.getContext('2d');
            ctx.fillStyle = 'rgba(80,80,80,0.85)';
            ctx.beginPath(); ctx.roundRect(0, 1, 100, 20, 3); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(text, 50, 15);
            const tex = new THREE.CanvasTexture(cv);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
            sprite.scale.set(0.14, 0.035, 1);
            sprite.position.set(x, y, 0.02);
            trussGroup.add(sprite);
        }

        function addTrussLabel(text, x, y) {
            const cv = document.createElement('canvas');
            cv.width = 220; cv.height = 36;
            const ctx = cv.getContext('2d');
            ctx.fillStyle = '#F15A29';
            ctx.beginPath(); ctx.roundRect(0, 3, 220, 30, 4); ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(text, 110, 24);
            const tex = new THREE.CanvasTexture(cv);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
            sprite.scale.set(0.3, 0.06, 1);
            sprite.position.set(x, y, 0.02);
            trussGroup.add(sprite);
        }

        function setTrussView(v, btn) {
            document.querySelectorAll('.truss-view-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            const span = (calc.trussSpan || 3000) / 1000;
            const rise = (calc.rise || 264) / 1000;
            const baseDist = Math.max(2.5, span * 0.75);
            if (v === '3d') {
                tCamT = 0.5; tCamP = 0.35; tCamD = baseDist;
            } else if (v === 'front') {
                // Looking straight down Z axis → sees XY triangle
                tCamT = 0; tCamP = 0; tCamD = baseDist;
            } else if (v === 'side') {
                // Looking from side → down X axis
                tCamT = Math.PI/2; tCamP = 0.05; tCamD = baseDist * 0.5;
            }
            updateTrussCam();
        }

        function animateTruss() {
            requestAnimationFrame(animateTruss);
            if (trussRend && trussScene && trussCam) {
                trussRend.render(trussScene, trussCam);
            }
        }

        // ==================== ASSEMBLY 3D (Section 3) ====================
        let asmScene, asmCam, asmRend, asmRay, asmMouse;
        let steelGrp, roofGrp, accGrp, houseGrp;
        let compData = new Map();
        let hovered = null;
        let aCamT = 0.5, aCamP = 0.4, aCamD = 12;
        let aCamTarget = new THREE.Vector3(0, 1.5, 0); // updated dynamically after build
        let aDrag = false, aLast = {x:0,y:0};

        function initAsm3D() {
            const container = document.getElementById('asmViewport');
            const canvas = document.getElementById('asmCanvas');
            asmScene = new THREE.Scene();
            asmScene.background = new THREE.Color(0xC4CCD4);
            asmCam = new THREE.PerspectiveCamera(35, container.clientWidth/container.clientHeight, 0.1, 100);
            updateAsmCam();
            asmRend = new THREE.WebGLRenderer({canvas, antialias: true});
            asmRend.setSize(container.clientWidth, container.clientHeight);
            asmRend.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            asmRend.shadowMap.enabled = true;

            asmRay = new THREE.Raycaster();
            asmMouse = new THREE.Vector2();

            asmScene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(5, 10, 7);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            asmScene.add(sun);

            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 30),
                new THREE.MeshStandardMaterial({color: 0xA8A090, roughness: 0.9})
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            asmScene.add(ground);

            steelGrp = new THREE.Group();
            roofGrp = new THREE.Group();
            accGrp = new THREE.Group();
            houseGrp = new THREE.Group();
            asmScene.add(steelGrp);
            asmScene.add(roofGrp);
            asmScene.add(accGrp);
            asmScene.add(houseGrp);

            canvas.addEventListener('mousedown', e => { aDrag = true; aLast = {x:e.clientX,y:e.clientY}; });
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                asmMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                asmMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                checkHover(e.clientX - rect.left, e.clientY - rect.top);
                if (aDrag) {
                    aCamT -= (e.clientX - aLast.x) * 0.008;
                    aCamP = Math.max(0.1, Math.min(1.4, aCamP - (e.clientY - aLast.y) * 0.006));
                    updateAsmCam();
                    aLast = {x:e.clientX, y:e.clientY};
                }
            });
            canvas.addEventListener('mouseup', () => { aDrag = false; });
            canvas.addEventListener('mouseleave', () => { aDrag = false; clearHover(); });
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                aCamD = Math.max(4, Math.min(30, aCamD + e.deltaY * 0.01));
                updateAsmCam();
            }, {passive: false});

            buildAsm3D();
            animateAsm();
        }

        function updateAsmCam() {
            asmCam.position.set(
                aCamTarget.x + aCamD * Math.sin(aCamT) * Math.cos(aCamP),
                aCamTarget.y + aCamD * Math.sin(aCamP),
                aCamTarget.z + aCamD * Math.cos(aCamT) * Math.cos(aCamP)
            );
            asmCam.lookAt(aCamTarget);
        }

        function createCorrugatedGeometry(width, length, segments = 20) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const waveHeight = 0.012;
            const waveFreq = 15;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                pos.setZ(i, Math.sin(x * waveFreq * Math.PI) * waveHeight);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createTrimdekGeometry(width, length, segments = 30) {
            const geo = new THREE.PlaneGeometry(width, length, segments, 1);
            const pos = geo.attributes.position;
            const ribHeight = 0.025;
            const ribWidth = 0.04;

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const phase = ((x / ribWidth) % 1 + 1) % 1;
                let z = 0;
                if (phase < 0.3) z = ribHeight * (phase / 0.3);
                else if (phase < 0.7) z = ribHeight;
                else z = ribHeight * (1 - (phase - 0.7) / 0.3);
                pos.setZ(i, z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function createInsulatedGeometry(width, length) {
            return new THREE.BoxGeometry(width, length, 0.05);
        }

        function buildAsm3D() {
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => { while(g.children.length) g.remove(g.children[0]); });
            compData.clear();

            const c = calc;
            const W = c.W / 1000;
            const L = c.L / 1000;
            const postH = c.postH / 1000;
            const rise = c.rise / 1000;
            const rafter = c.rafter / 1000;
            const tw = c.steel.w;
            const th = c.steel.h;
            const frontBeamY = c.frontBeamY / 1000;
            const backBeamY = c.backBeamY / 1000;
            const fasciaBeamY = c.fasciaBeamY ? c.fasciaBeamY / 1000 : null;

            const steelCol = new THREE.Color(steelColor.hex);
            const sheetCol = new THREE.Color(sheetColor.hex);
            const sMat = () => new THREE.MeshStandardMaterial({color: steelCol, metalness: 0.8, roughness: 0.3});
            const rMat = () => new THREE.MeshStandardMaterial({color: sheetCol, metalness: 0.5, roughness: 0.4, side: THREE.DoubleSide});

            const fasciaCol = new THREE.Color(steelColor.hex).offsetHSL(0, -0.1, 0.15);
            const fasciaMat = () => new THREE.MeshStandardMaterial({color: fasciaCol, metalness: 0.7, roughness: 0.4});

            const riserCol = new THREE.Color(0x8B4513);
            const riserMat = () => new THREE.MeshStandardMaterial({color: riserCol, metalness: 0.6, roughness: 0.5});

            const beamW = 0.1, beamH = 0.05, postW = 0.09;

            const isPerpendicular = c.isGable && c.orientation === 'perpendicular';

            // ===== FRONT POSTS (Gutter side) =====
            const fpostH = frontBeamY;  // May be elevated for gable+riser
            for (let i = 0; i < c.nPosts; i++) {
                const x = -L/2 + (L / (c.nPosts - 1)) * i;
                const post = new THREE.Mesh(new THREE.BoxGeometry(postW, fpostH, postW), sMat());
                if (isPerpendicular) {
                    post.position.set(W/2, fpostH/2, x);
                } else {
                    post.position.set(x, fpostH/2, W/2);
                }
                post.castShadow = true;
                steelGrp.add(post);
                regComp(post, 'Front Post ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(fpostH*1000) + 'mm'});
            }

            // ===== BACK POSTS (freestanding only) =====
            if (c.connection === 'freestanding') {
                for (let i = 0; i < c.nPosts; i++) {
                    const x = -L/2 + (L / (c.nPosts - 1)) * i;
                    const bpostH = backBeamY;
                    const post = new THREE.Mesh(new THREE.BoxGeometry(postW, bpostH, postW), sMat());
                    if (isPerpendicular) {
                        post.position.set(-W/2, bpostH/2, x);
                    } else {
                        post.position.set(x, bpostH/2, -W/2);
                    }
                    post.castShadow = true;
                    steelGrp.add(post);
                    regComp(post, 'Back Post ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(bpostH*1000) + 'mm'});
                }
            }

            // ===== GUTTER BEAM (Front beam on posts) =====
            const gutterBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamH, beamW), sMat());
            if (isPerpendicular) {
                gutterBeam.rotation.y = Math.PI / 2;
                gutterBeam.position.set(W/2, frontBeamY + beamH/2, 0);
            } else {
                gutterBeam.position.set(0, frontBeamY + beamH/2, W/2);
            }
            gutterBeam.castShadow = true;
            steelGrp.add(gutterBeam);
            regComp(gutterBeam, 'Gutter Beam', {'Size': '100×50×2 RHS', 'Length': c.L + 'mm'});

            // ===== FASCIA BEAM (on house - for attached only) =====
            // Against house fascia board face, below gutter in exposed fascia zone
            if (c.isAttached && fasciaBeamY !== null) {
                const fasciaBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamW * 1.1, beamH * 1.2), fasciaMat());
                // Z: against house fascia face (wall face + fascia board thickness offset)
                const fbmZ = -W/2 - 0.02;
                if (isPerpendicular) {
                    fasciaBeam.rotation.y = Math.PI / 2;
                    fasciaBeam.position.set(fbmZ, fasciaBeamY + beamW/2, 0);
                } else {
                    fasciaBeam.position.set(0, fasciaBeamY + beamW/2, fbmZ);
                }
                fasciaBeam.castShadow = true;
                steelGrp.add(fasciaBeam);
                regComp(fasciaBeam, 'Fascia Beam', {'Size': '100×50×2 RHS', 'Length': c.L + 'mm', 'Height': c.fasciaH + 'mm', 'Note': 'House connection'});
            }

            // ===== RAFTER BRACKETS (for fascia connections only) =====
            if (c.connection === 'fascia' || c.connection === 'fasciabeam') {
                const bracketLen = 0.5;
                const bracketH = 0.006;
                const bracketW = 0.05;
                const bracketCount = Math.max(3, Math.ceil(L / 1.0));
                for (let i = 0; i < bracketCount; i++) {
                    const x = -L/2 + (L / (bracketCount - 1)) * i;
                    const bracket = new THREE.Mesh(
                        new THREE.BoxGeometry(bracketW, bracketH, bracketLen),
                        sMat()
                    );
                    if (isPerpendicular) {
                        bracket.rotation.y = Math.PI / 2;
                        bracket.position.set(-W/2 - bracketLen/2 - 0.08, fasciaBeamY + beamH + 0.1, x);
                    } else {
                        bracket.position.set(x, fasciaBeamY + beamH + 0.1, -W/2 - bracketLen/2 - 0.08);
                    }
                    steelGrp.add(bracket);
                }
            }

            // ===== V18 FIX: RISERS with correct stacking =====
            if (c.connection === 'riser') {
                // V18: Riser beam sits ON TOP of risers
                const riserOff = c.riserOffset / 1000;
                const riserSize = 0.075;
                const count = c.riserQty;

                // Calculate actual vertical rise of risers
                // Span from fascia beam top (horiz piece) up to riser beam bottom (backBeamY)
                const actualRiserH = backBeamY - (fasciaBeamY + beamH + riserSize);

                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;

                    // HORIZONTAL piece (comes out from fascia beam)
                    const horizPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, riserSize, riserOff),
                        riserMat()
                    );

                    // VERTICAL piece (rises up)
                    const vertPiece = new THREE.Mesh(
                        new THREE.BoxGeometry(riserSize, actualRiserH, riserSize),
                        riserMat()
                    );

                    if (isPerpendicular) {
                        horizPiece.rotation.y = Math.PI / 2;
                        horizPiece.position.set(-W/2 + riserOff/2, fasciaBeamY + beamH + riserSize/2, x);
                        vertPiece.position.set(-W/2 + riserOff, fasciaBeamY + beamH + riserSize + actualRiserH/2, x);
                    } else {
                        horizPiece.position.set(x, fasciaBeamY + beamH + riserSize/2, -W/2 + riserOff/2);
                        vertPiece.position.set(x, fasciaBeamY + beamH + riserSize + actualRiserH/2, -W/2 + riserOff);
                    }

                    horizPiece.castShadow = true;
                    vertPiece.castShadow = true;
                    steelGrp.add(horizPiece);
                    steelGrp.add(vertPiece);
                    regComp(vertPiece, 'Riser Elbow ' + (i+1), {
                        'Size': '75×75×2 SHS',
                        'Offset': c.riserOffset + 'mm',
                        'Rise': Math.round(actualRiserH * 1000) + 'mm',
                        'Note': '90° elbow clears house gutter'
                    });
                }

                // Riser brackets – threaded rod through house fascia, clamps fascia beam tight
                // Strip lays along rafter top, threaded rod pokes through fascia board
                const galvMat = () => new THREE.MeshStandardMaterial({color: 0xC0C0C0, metalness: 0.7, roughness: 0.4});
                const fasciaHmR = c.fasciaH / 1000; // rafter base Y (independent of fascia beam)
                const fasciaBdH = 0.15; // house fascia board height
                for (let i = 0; i < count; i++) {
                    const x = -L/2 + (L / (count - 1)) * i;
                    const stripLen = 0.45;   // 450mm long
                    const stripW = 0.03;     // 30mm wide
                    const stripT = 0.006;    // 6mm thick galv plate
                    // Y: vertically centred on house fascia board
                    const bkY = fasciaHmR - fasciaBdH / 2;
                    // House fascia front face is 50mm behind patio edge
                    // Fascia beam front face is 10mm past patio edge
                    const fasciaFaceOff = -0.05; // house fascia front face relative to -W/2
                    const fbmFrontOff = 0.01;    // fascia beam front face relative to -W/2
                    // Threaded rod: from fascia face through to fascia beam front face
                    const rodLen = fbmFrontOff - fasciaFaceOff; // 60mm
                    const rodD = 0.012; // M12 threaded rod
                    // Strip: mostly behind wall, tip at house fascia face
                    const strip = new THREE.Mesh(
                        new THREE.BoxGeometry(stripW, stripT, stripLen),
                        galvMat()
                    );
                    // Threaded rod: pokes through fascia, does NOT protrude past fascia beam
                    const bolt = new THREE.Mesh(
                        new THREE.BoxGeometry(rodD, rodD, rodLen),
                        galvMat()
                    );
                    if (isPerpendicular) {
                        strip.rotation.y = Math.PI / 2;
                        strip.position.set(-W/2 + fasciaFaceOff - stripLen/2, bkY, x);
                        bolt.rotation.y = Math.PI / 2;
                        bolt.position.set(-W/2 + fasciaFaceOff + rodLen/2, bkY, x);
                    } else {
                        strip.position.set(x, bkY, -W/2 + fasciaFaceOff - stripLen/2);
                        bolt.position.set(x, bkY, -W/2 + fasciaFaceOff + rodLen/2);
                    }
                    steelGrp.add(strip);
                    steelGrp.add(bolt);
                    regComp(strip, 'Riser Bracket ' + (i+1), {'Size': '450×30×6mm Galv Flat Bar', 'Rod': 'M12 threaded rod', 'Note': 'Threaded rod through fascia, clamps fascia beam tight'});
                }

                // Box gutter (if selected) - sits in gap between house wall and riser beam
                if (c.houseGutter === 'box') {
                    // Width sized to fit the gap between house fascia and riser beam
                    const boxGutterW = riserOff;
                    const boxGutterD = 0.1;       // inner wall height (house side)
                    const boxGutterOuter = 0.12;  // outer wall height (riser side, taller to catch water)
                    const wallT = 0.01;

                    // U-shaped cross-section: X=0 is house side, X=boxGutterW is riser side
                    const gutterShape = new THREE.Shape();
                    gutterShape.moveTo(0, 0);
                    gutterShape.lineTo(boxGutterW, 0);
                    gutterShape.lineTo(boxGutterW, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, boxGutterOuter);
                    gutterShape.lineTo(boxGutterW - wallT, wallT);
                    gutterShape.lineTo(wallT, wallT);
                    gutterShape.lineTo(wallT, boxGutterD);
                    gutterShape.lineTo(0, boxGutterD);
                    gutterShape.closePath();

                    const extrudeSettings = { depth: L, bevelEnabled: false };
                    const gutterGeo = new THREE.ExtrudeGeometry(gutterShape, extrudeSettings);
                    const boxGutter = new THREE.Mesh(gutterGeo, sMat());

                    // Y: gutter bottom sits ON TOP of the riser elbow horizontal pieces
                    // horiz piece top = fasciaBeamY + beamH + riserSize
                    const boxGutterY = fasciaBeamY + beamH + riserSize;

                    if (isPerpendicular) {
                        // House wall at X = -W/2, riser beam at X = -W/2 + riserOff
                        // rotation.y = π: local X → world -X, local +Z → world -Z
                        // Shape X=0 (house side) → world X = position.x (riser beam)
                        // Shape X=gutterW (riser side) → world X = position.x - gutterW = -W/2 (house)
                        // So we need to flip: position at -W/2, no extra rotation for X direction
                        // Use rotation.y = 0: local X → world +X, local Z → world +Z
                        // Shape X=0 (house side) at world X = -W/2, X=gutterW at -W/2 + riserOff
                        boxGutter.rotation.y = 0;
                        boxGutter.position.set(-W/2, boxGutterY, -L/2);
                    } else {
                        // House wall at Z = -W/2, riser beam at Z = -W/2 + riserOff
                        // rotation.y = -π/2: local X → world +Z, local +Z → world -X
                        // Shape X=0 (house side) at world Z = -W/2
                        // Shape X=gutterW (riser side) at world Z = -W/2 + riserOff
                        // Extrusion goes -X, so position at X = +L/2
                        boxGutter.rotation.y = -Math.PI / 2;
                        boxGutter.position.set(L/2, boxGutterY, -W/2);
                    }
                    accGrp.add(boxGutter);
                    regComp(boxGutter, 'Box Gutter', {'Width': Math.round(riserOff*1000)+'mm', 'Inner Depth': '100mm', 'Outer Depth': '120mm'});
                }

                // Patio gutter on riser beam (gable only) - catches back slope water
                if (c.isGable && c.riserGutter === 'quad') {
                    const rgW = 0.115;     // 115mm quad gutter
                    const rgFront = 0.076; // 76mm front face
                    const rgBack = 0.045;  // 45mm back face
                    const rgT = 0.001;     // 1mm sheet steel
                    const rgs = new THREE.Shape();
                    rgs.moveTo(0, 0);
                    rgs.lineTo(rgW, 0);
                    rgs.lineTo(rgW, rgFront);
                    rgs.lineTo(rgW - rgT, rgFront);
                    rgs.lineTo(rgW - rgT, rgT);
                    rgs.lineTo(rgT, rgT);
                    rgs.lineTo(rgT, rgBack);
                    rgs.lineTo(0, rgBack);
                    rgs.closePath();
                    const rgGeo = new THREE.ExtrudeGeometry(rgs, { depth: L, bevelEnabled: false });
                    const riserGutterMesh = new THREE.Mesh(rgGeo, sMat());
                    // Sits on top of riser beam
                    const riserBeamTop = backBeamY + 0.1; // riser beam height = 0.1
                    if (isPerpendicular) {
                        riserGutterMesh.position.set(-W/2 + riserOff - rgW/2, riserBeamTop, -L/2);
                    } else {
                        riserGutterMesh.rotation.y = -Math.PI / 2;
                        riserGutterMesh.position.set(L/2, riserBeamTop, -W/2 + riserOff - rgW/2);
                    }
                    accGrp.add(riserGutterMesh);
                    regComp(riserGutterMesh, 'Riser Beam Gutter', {'Type': '115mm Quad', 'Length': c.L + 'mm', 'Note': 'Catches gable back slope water'});
                }
            }

            // ===== CARRY / BACK BEAM - NOT for receiving channel (fascia/wall use channel instead) =====
            if (c.connection !== 'fascia' && c.connection !== 'fasciabeam' && c.connection !== 'wall') {
                const isRiser = c.connection === 'riser';
                const isFlyover = c.connection === 'flyover';
                const beamHeight = isRiser ? 0.1 : (isFlyover ? 0.05 : beamH);
                const beamWidth = isRiser ? 0.05 : (isFlyover ? 0.15 : beamW);
                const riserOff = isRiser ? c.riserOffset/1000 : 0;

                const carryBeam = new THREE.Mesh(new THREE.BoxGeometry(L, beamHeight, beamWidth), sMat());
                if (isPerpendicular) {
                    carryBeam.rotation.y = Math.PI / 2;
                    carryBeam.position.set(-W/2 + riserOff, backBeamY + beamHeight/2, 0);
                } else {
                    carryBeam.position.set(0, backBeamY + beamHeight/2, -W/2 + riserOff);
                }
                carryBeam.castShadow = true;
                steelGrp.add(carryBeam);
                const beamName = isRiser ? 'Riser Beam' : (isFlyover ? 'Flyover Beam' : 'Back Beam');
                const beamSpec = isRiser ? '100×50×2 RHS (on edge)' : (isFlyover ? '150×50×2 RHS' : '100×50×2 RHS');
                regComp(carryBeam, beamName, {'Size': beamSpec, 'Length': c.L + 'mm', 'Height': Math.round(backBeamY*1000) + 'mm'});
            }

            // ===== FLYOVER VERTICAL STRUTS - sit ON TOP of house roof =====
            // Struts penetrate through roof sheets and bolt to house rafters
            if (c.connection === 'flyover') {
                const fasciaHm = c.fasciaH / 1000;
                const hRafterH = 0.09; // house rafter height
                // Struts positioned on house roof near the eave, directly under the flyover beam
                // Roof surface at the eave = rafter top = fasciaHm + hRafterH
                const roofSurfaceY = fasciaHm + hRafterH;
                const strutSize = 0.09; // 90x90 SHS
                const strutH = Math.max(0.15, backBeamY - roofSurfaceY);
                const strutCount = Math.max(2, Math.ceil(L / 1.2));
                // Struts are at same Z as the flyover beam (at patio back edge)
                // They go through the roof/fascia and bolt to the house rafters below

                for (let i = 0; i < strutCount; i++) {
                    const x = -L/2 + (L / (strutCount - 1)) * i;
                    const strut = new THREE.Mesh(
                        new THREE.BoxGeometry(strutSize, strutH, strutSize),
                        sMat()
                    );
                    if (isPerpendicular) {
                        strut.position.set(-W/2, roofSurfaceY + strutH/2, x);
                    } else {
                        strut.position.set(x, roofSurfaceY + strutH/2, -W/2);
                    }
                    strut.castShadow = true;
                    steelGrp.add(strut);
                    regComp(strut, 'Flyover Strut ' + (i+1), {'Size': '90×90×2 SHS', 'Height': Math.round(strutH*1000) + 'mm'});
                }
            }

            // ===== ROOF STRUCTURE =====
            const frontTop = frontBeamY + beamH;
            const backTop = backBeamY + beamH;
            const sheetW = c.sheetCoverage / 1000;

            // V18: Calculate actual gutter height for downpipes
            let gutterY;

            if (c.isGable) {
                // ========== GABLE ROOF ==========
                const trussBaseY = (frontTop + backTop) / 2;
                const tiltAngle = Math.atan2(backTop - frontTop, W);
                gutterY = frontTop - 0.04;

                // Trusses (peak from internal geometry; tilt spans between beams when heights differ)
                for (let i = 0; i < c.nTruss; i++) {
                    const x = -L/2 + (L / (c.nTruss - 1)) * i;
                    const truss = createTrussUnit(W, rise, rafter, tw, th, sMat(), c.trussStyle, c.pitchRad);
                    if (isPerpendicular) {
                        truss.rotation.order = 'ZYX';
                        truss.rotation.y = Math.PI / 2;
                        truss.rotation.z = -tiltAngle;
                        truss.position.set(0, trussBaseY, x);
                    } else {
                        truss.rotation.x = tiltAngle;
                        truss.position.set(x, trussBaseY, 0);
                    }
                    steelGrp.add(truss);
                    regComp(truss, 'Truss ' + (i+1), {'Span': Math.round(c.trussSpan) + 'mm', 'Rise': Math.round(c.rise) + 'mm'});

                    // Gable infill
                    if ((i === 0 || i === c.nTruss - 1) && c.infill !== 'none') {
                        const shape = new THREE.Shape();
                        shape.moveTo(-W/2, th);
                        shape.lineTo(0, rise + th);
                        shape.lineTo(W/2, th);
                        shape.closePath();
                        const infillMat = new THREE.MeshStandardMaterial({
                            color: c.infill === 'twinwall' ? 0xDDEEEE : sheetCol,
                            transparent: c.infill === 'twinwall',
                            opacity: c.infill === 'twinwall' ? 0.6 : 1,
                            side: THREE.DoubleSide
                        });
                        const infillMesh = new THREE.Mesh(new THREE.ShapeGeometry(shape), infillMat);

                        if (isPerpendicular) {
                            infillMesh.rotation.y = x > 0 ? Math.PI : 0;
                            infillMesh.position.set(0, trussBaseY, x);
                        } else {
                            infillMesh.rotation.y = Math.PI / 2;
                            infillMesh.position.set(x, trussBaseY, 0);
                        }
                        roofGrp.add(infillMesh);
                        regComp(infillMesh, 'Gable Infill', {'Material': c.infill === 'twinwall' ? '10mm Twinwall' : 'Colorbond'});
                    }
                }

                // Purlins
                const purlinCount = Math.max(2, Math.ceil(rafter / 0.8));
                for (let side = -1; side <= 1; side += 2) {
                    for (let p = 1; p <= purlinCount; p++) {
                        const frac = p / (purlinCount + 1);
                        const zPos = (W/2) * frac * side;
                        const yPos = trussBaseY + th + rise * (1 - frac);
                        const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                        if (isPerpendicular) {
                            purlin.rotation.y = Math.PI / 2;
                            purlin.position.set(zPos, yPos, 0);
                        } else {
                            purlin.position.set(0, yPos, zPos);
                        }
                        steelGrp.add(purlin);
                    }
                }

                // V18 FIX: Roof sheets - corrected rotation for perpendicular mode
                const numSheets = Math.ceil(L / sheetW);
                const gablePc = (c.roofing === 'trimdek') ? getPolycarbConfig() : null;
                for (let side = -1; side <= 1; side += 2) {
                    for (let s = 0; s < numSheets; s++) {
                        const sheetPos = -L/2 + sheetW/2 + s * sheetW;
                        const isPolySheet = gablePc && ((s + 1) % gablePc.patternN === 0);
                        let sheetGeo;
                        if (c.roofing === 'corrugated') {
                            sheetGeo = createCorrugatedGeometry(sheetW, rafter + 0.05);
                        } else if (c.roofing === 'trimdek') {
                            sheetGeo = createTrimdekGeometry(sheetW, rafter + 0.05);
                        } else {
                            sheetGeo = createInsulatedGeometry(sheetW, rafter + 0.05);
                        }

                        let sheetMat;
                        if (isPolySheet) {
                            const tintData = POLYCARB_3D_TINTS[gablePc.tint] || POLYCARB_3D_TINTS['Clear'];
                            sheetMat = new THREE.MeshStandardMaterial({
                                color: tintData.color, transparent: true, opacity: tintData.opacity,
                                metalness: 0.1, roughness: 0.15, side: THREE.DoubleSide
                            });
                        } else {
                            sheetMat = rMat();
                        }
                        const sheet = new THREE.Mesh(sheetGeo, sheetMat);

                        if (isPerpendicular) {
                            sheet.rotation.order = 'YXZ';
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                            sheet.rotation.y = Math.PI / 2;

                            const midHeight = trussBaseY + th + rise/2;
                            sheet.position.set(side * W/4, midHeight + 0.02, sheetPos);
                        } else {
                            sheet.position.set(sheetPos, trussBaseY + th + rise/2 + 0.01, side * W/4);
                            sheet.rotation.x = side === -1 ? (Math.PI/2 - c.pitchRad) : -(Math.PI/2 - c.pitchRad);
                        }
                        sheet.castShadow = !isPolySheet;
                        roofGrp.add(sheet);
                        const sideLabel = side === -1 ? 'A' : 'B';
                        const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                        regComp(sheet, 'Roof Sheet ' + sideLabel + (s+1), {'Profile': sheetType, 'Length': Math.round((rafter + 0.05)*1000) + 'mm', 'Side': side === -1 ? 'Left slope' : 'Right slope'});
                    }
                }

                // Ridge capping
                const ridge = new THREE.Mesh(new THREE.BoxGeometry(L, 0.04, 0.3), rMat());
                if (isPerpendicular) {
                    ridge.rotation.y = Math.PI / 2;
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                } else {
                    ridge.position.set(0, trussBaseY + th + rise + 0.02, 0);
                }
                accGrp.add(ridge);
                regComp(ridge, 'Ridge Cap', {'Length': c.L + 'mm'});

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                if (isPerpendicular) {
                    gutter.rotation.y = Math.PI / 2;
                    gutter.position.set(W/2 + 0.07, gutterY, 0);
                } else {
                    gutter.position.set(0, gutterY, W/2 + 0.07);
                }
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.L + 'mm'});

                // Gable barges
                const bargeThick = 0.003;
                const bargeWidth = 0.15;
                const bargeLen = rafter + 0.05;

                if (isPerpendicular) {
                    [-L/2, L/2].forEach((zEnd) => {
                        const bargeL = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeL.position.set(-W/4, trussBaseY + th + rise/2, zEnd);
                        bargeL.rotation.z = c.pitchRad;
                        accGrp.add(bargeL);

                        const bargeR = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeLen, bargeThick, bargeWidth),
                            sMat()
                        );
                        bargeR.position.set(W/4, trussBaseY + th + rise/2, zEnd);
                        bargeR.rotation.z = -c.pitchRad;
                        accGrp.add(bargeR);
                    });
                } else {
                    [-L/2, L/2].forEach((xEnd) => {
                        const bargeHouse = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeHouse.position.set(xEnd, trussBaseY + th + rise/2, -W/4);
                        bargeHouse.rotation.x = -c.pitchRad;
                        accGrp.add(bargeHouse);

                        const bargeGutter = new THREE.Mesh(
                            new THREE.BoxGeometry(bargeWidth, bargeThick, bargeLen),
                            sMat()
                        );
                        bargeGutter.position.set(xEnd, trussBaseY + th + rise/2, W/4);
                        bargeGutter.rotation.x = c.pitchRad;
                        accGrp.add(bargeGutter);
                    });
                }

            } else {
                // ========== SKILLION ROOF ==========
                gutterY = frontTop - 0.04;  // V18: Store gutter Y for downpipes

                const riserOff = c.connection === 'riser' ? c.riserOffset / 1000 : 0;
                const backEdgeZ = -W/2 + riserOff;

                // Rafters
                for (let i = 0; i < c.nRafters; i++) {
                    const x = -L/2 + (L / (c.nRafters - 1)) * i;
                    const rafterGeo = new THREE.BoxGeometry(tw, th, rafter);
                    rafterGeo.translate(0, 0, rafter/2);
                    const raft = new THREE.Mesh(rafterGeo, sMat());
                    raft.position.set(x, backTop + th/2, backEdgeZ);
                    raft.rotation.x = c.pitchRad;
                    steelGrp.add(raft);
                    regComp(raft, 'Rafter ' + (i+1), {'Size': c.steel.name, 'Length': Math.round(c.rafter) + 'mm'});
                }

                // Purlins
                const effectiveW = W - riserOff;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9));
                for (let p = 0; p <= purlinCount; p++) {
                    const frac = p / purlinCount;
                    const zPos = backEdgeZ + effectiveW * frac;
                    const yPos = backTop + th - (backTop - frontTop) * frac;
                    const purlin = new THREE.Mesh(new THREE.BoxGeometry(L - 0.1, th, tw), sMat());
                    purlin.position.set(0, yPos, zPos);
                    steelGrp.add(purlin);
                }

                // Roof sheets
                const sheetInset = c.isRecvChan ? 0.03 : 0; // 30mm into channel
                const numSheets = Math.ceil(L / sheetW);
                const skillPc = (c.roofing === 'trimdek') ? getPolycarbConfig() : null;
                for (let s = 0; s < numSheets; s++) {
                    const xPos = -L/2 + sheetW/2 + s * sheetW;
                    const isPolySheet = skillPc && ((s + 1) % skillPc.patternN === 0);
                    let sheetGeo;
                    if (c.roofing === 'corrugated') {
                        sheetGeo = createCorrugatedGeometry(sheetW, rafter);
                    } else if (c.roofing === 'trimdek') {
                        sheetGeo = createTrimdekGeometry(sheetW, rafter);
                    } else {
                        sheetGeo = createInsulatedGeometry(sheetW, rafter);
                    }
                    sheetGeo.translate(0, rafter/2, 0);

                    let sheetMat;
                    if (isPolySheet) {
                        const tintData = POLYCARB_3D_TINTS[skillPc.tint] || POLYCARB_3D_TINTS['Clear'];
                        sheetMat = new THREE.MeshStandardMaterial({
                            color: tintData.color, transparent: true, opacity: tintData.opacity,
                            metalness: 0.1, roughness: 0.15, side: THREE.DoubleSide
                        });
                    } else {
                        sheetMat = rMat();
                    }
                    const sheet = new THREE.Mesh(sheetGeo, sheetMat);
                    sheet.position.set(xPos, backTop + th + 0.01, backEdgeZ - sheetInset);
                    sheet.rotation.x = Math.PI/2 + c.pitchRad;
                    sheet.castShadow = !isPolySheet;
                    roofGrp.add(sheet);
                    const sheetType = isPolySheet ? 'Polycarb' : c.roofing;
                    regComp(sheet, 'Roof Sheet ' + (s+1), {'Profile': sheetType, 'Length': Math.round(rafter*1000) + 'mm'});
                }

                // Gutter
                const gutter = new THREE.Mesh(new THREE.BoxGeometry(L, 0.08, 0.12), sMat());
                gutter.position.set(0, gutterY, W/2 + 0.07);
                accGrp.add(gutter);
                regComp(gutter, 'Gutter', {'Type': '150mm Quad', 'Length': c.lenInput + 'mm'});

                // Back flashing - skip for riser+box gutter AND receiving channel (channel acts as flashing)
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    const flash = new THREE.Mesh(new THREE.BoxGeometry(L, 0.15, 0.003), sMat());
                    flash.position.set(0, backTop + 0.08, backEdgeZ - 0.05);
                    flash.rotation.x = -0.3;
                    accGrp.add(flash);
                    regComp(flash, 'Back Flashing', {'Length': c.lenInput + 'mm'});
                }

                // Barge flashings
                [-L/2, L/2].forEach((xPos, idx) => {
                    const barge = new THREE.Mesh(new THREE.BoxGeometry(0.1, rafter, 0.003), sMat());
                    barge.position.set(xPos, (backTop + frontTop)/2 + th, 0);
                    barge.rotation.x = -(Math.PI/2 - c.pitchRad);
                    accGrp.add(barge);
                });
            }

            // ===== V18 FIX: DOWNPIPES - Use actual gutter height =====
            let dpPositions;
            if (isPerpendicular) {
                dpPositions = [[W/2 + 0.1, -L/2 + 0.1], [W/2 + 0.1, L/2 - 0.1]];
            } else {
                dpPositions = [[-L/2 + 0.1, W/2 + 0.1], [L/2 - 0.1, W/2 + 0.1]];
            }
            dpPositions.forEach((pos, idx) => {
                // V18 FIX: Downpipe height = from ground to gutter, not postH
                const dpHeight = gutterY + 0.04;  // Gutter bottom + 40mm into gutter
                const dp = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, dpHeight, 12), sMat());
                dp.position.set(pos[0], dpHeight/2, pos[1]);
                accGrp.add(dp);
                regComp(dp, 'Downpipe ' + (idx+1), {'Size': '90mm Round', 'Height': Math.round(dpHeight*1000) + 'mm'});
            });

            // ===== HOUSE / WALL REPRESENTATION =====
            // riser, fascia, flyover: house with wall + fascia board + Colorbond roof
            // wall: flat wall only (receiving channel bolts to wall surface)
            // freestanding: no wall
            if (c.isAttached) {
                const fasciaHm = c.fasciaH / 1000;
                const wallThick = 0.15;
                const wallLen = L + 0.2;
                const wallMat = new THREE.MeshStandardMaterial({color: 0xD4C4B0, roughness: 0.9});
                const fasciaTimberMat = new THREE.MeshStandardMaterial({color: 0x8B7355, roughness: 0.8});
                // Monument colour (#3C3C3C) for existing house Colorbond roof
                const roofColorbondMat = new THREE.MeshStandardMaterial({color: 0x3C3C3C, roughness: 0.5, metalness: 0.4});

                if (c.connection === 'wall') {
                    // === WALL MODE: just a flat brick/render wall ===
                    const wallH = Math.max(backBeamY + 0.5, fasciaHm + 0.5);
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                } else {
                    // === HOUSE MODE (riser, fascia, flyover): wall + fascia + roof ===
                    // Wall: only up to fascia height (roof sits above)
                    const wallH = fasciaHm;
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallLen, wallH, wallThick),
                        wallMat
                    );
                    if (isPerpendicular) {
                        wall.rotation.y = Math.PI / 2;
                        wall.position.set(-W/2 - wallThick, wallH/2, 0);
                    } else {
                        wall.position.set(0, wallH/2, -W/2 - wallThick);
                    }
                    wall.receiveShadow = true;
                    houseGrp.add(wall);

                    // Fascia board (timber) covers the full rafter end face
                    if (fasciaHm > 0) {
                        const fasciaBoardH = 0.15;   // 150mm tall
                        const fasciaBoardT = 0.025;  // 25mm thick
                        const fasciaBoard = new THREE.Mesh(
                            new THREE.BoxGeometry(wallLen, fasciaBoardH, fasciaBoardT),
                            fasciaTimberMat
                        );
                        // Fascia board top aligns with rafter bottom (fasciaHm)
                        // Gutter sits against fascia front face at the top half
                        const fbZ = -W/2 - wallThick/2 + fasciaBoardT/2;
                        const fbY = fasciaHm - fasciaBoardH/2; // center of board, top at rafter bottom
                        if (isPerpendicular) {
                            fasciaBoard.rotation.y = Math.PI / 2;
                            fasciaBoard.position.set(fbZ, fbY, 0);
                        } else {
                            fasciaBoard.position.set(0, fbY, fbZ);
                        }
                        fasciaBoard.castShadow = true;
                        houseGrp.add(fasciaBoard);
                        regComp(fasciaBoard, 'House Fascia Board', {'Size': '150×25mm Timber', 'Height': c.fasciaH + 'mm'});
                    }

                    // House roof: timber rafters + individual Colorbond sheets
                    const roofDepth = 1.5;       // 1.5m visible depth
                    const roofPitch = 15 * Math.PI / 180;
                    const roofRise = roofDepth * Math.tan(roofPitch);
                    const roofBaseY = fasciaHm;  // rafters sit on wall top plate
                    const roofCenterY = roofBaseY + roofRise / 2;
                    const roofZCenter = -W/2 - wallThick/2 - roofDepth/2;

                    // Timber rafters (45×90mm) at 600mm spacing
                    const rafterW = 0.045, rafterH = 0.09, rafterSpacing = 0.6;
                    const rafterCount = Math.max(2, Math.ceil(wallLen / rafterSpacing) + 1);
                    for (let i = 0; i < rafterCount; i++) {
                        const pos = -wallLen/2 + (wallLen / (rafterCount - 1)) * i;
                        const rafter = new THREE.Mesh(
                            new THREE.BoxGeometry(rafterW, rafterH, roofDepth),
                            fasciaTimberMat
                        );
                        if (isPerpendicular) {
                            rafter.rotation.order = 'YXZ';
                            rafter.rotation.y = Math.PI / 2;
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(roofZCenter, roofCenterY, pos);
                        } else {
                            rafter.rotation.x = roofPitch;
                            rafter.position.set(pos, roofCenterY, roofZCenter);
                        }
                        rafter.castShadow = true;
                        houseGrp.add(rafter);
                    }
                    // Register first rafter for tooltip
                    if (houseGrp.children.length > 0) {
                        const lastRafter = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastRafter, 'House Rafter', {'Size': '45×90mm Timber', 'Spacing': '600mm', 'Qty': rafterCount});
                    }

                    // Individual Colorbond roof sheets on top of rafters
                    // Sheets overhang 50mm past fascia into gutter
                    const hSheetW = 0.762;  // corrugated sheet cover width
                    const hSheetT = 0.001;  // ~1mm Colorbond
                    const hOverhang = 0.05; // 50mm overhang past fascia
                    const hSheetDepth = roofDepth + hOverhang;
                    const hSheetZCenter = roofZCenter + hOverhang/2; // shift toward fascia
                    const hSheetCount = Math.max(1, Math.ceil(wallLen / hSheetW));
                    const hSheetCenterY = roofCenterY + rafterH/2 + hSheetT/2;
                    for (let i = 0; i < hSheetCount; i++) {
                        const sw = (i === hSheetCount - 1) ? (wallLen - hSheetW * i) : hSheetW;
                        const pos = -wallLen/2 + hSheetW * i + sw/2;
                        const hSheet = new THREE.Mesh(
                            new THREE.BoxGeometry(sw, hSheetT, hSheetDepth),
                            roofColorbondMat.clone()
                        );
                        if (isPerpendicular) {
                            hSheet.rotation.order = 'YXZ';
                            hSheet.rotation.y = Math.PI / 2;
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(hSheetZCenter, hSheetCenterY, pos);
                        } else {
                            hSheet.rotation.x = roofPitch;
                            hSheet.position.set(pos, hSheetCenterY, hSheetZCenter);
                        }
                        hSheet.castShadow = true;
                        hSheet.receiveShadow = true;
                        houseGrp.add(hSheet);
                    }
                    const roofLabel = c.connection === 'flyover' ? 'Existing House Roof (Flyover)' : 'Existing House Roof';
                    if (houseGrp.children.length > 0) {
                        const lastSheet = houseGrp.children[houseGrp.children.length - 1];
                        regComp(lastSheet, roofLabel, {'Pitch': '15°', 'Material': 'Colorbond', 'Sheets': hSheetCount});
                    }

                    // House quad gutter – sits against front face of fascia, at the top half
                    // Hidden when box gutter is selected (box gutter replaces it)
                    const showHouseGutter = !(c.connection === 'riser' && c.houseGutter === 'box');
                    if (showHouseGutter) {
                    const hGutterW = 0.115;    // 115mm wide
                    const hGutterFront = 0.076; // 76mm front face
                    const hGutterBack = 0.045;  // 45mm back face
                    const hGutterT = 0.001;     // 1mm sheet steel
                    const hgs = new THREE.Shape();
                    hgs.moveTo(0, 0);
                    hgs.lineTo(hGutterW, 0);
                    hgs.lineTo(hGutterW, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterFront);
                    hgs.lineTo(hGutterW - hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterT);
                    hgs.lineTo(hGutterT, hGutterBack);
                    hgs.lineTo(0, hGutterBack);
                    hgs.closePath();
                    const hGutterGeo = new THREE.ExtrudeGeometry(hgs, { depth: L, bevelEnabled: false });
                    const hGutter = new THREE.Mesh(hGutterGeo, roofColorbondMat.clone());
                    // Back lip top at fasciaHm – gutter against top half of fascia face
                    const hGutterY = fasciaHm - hGutterBack;
                    const hGutterZ = -W/2 - wallThick/2 + 0.025; // at fascia board front face
                    if (isPerpendicular) {
                        // extrude along +Z; rotation.y=0 keeps local Z=world Z
                        hGutter.position.set(hGutterZ, hGutterY, -L/2);
                    } else {
                        // rotation.y=-π/2: local +Z → world -X, shape X → world +Z
                        hGutter.rotation.y = -Math.PI / 2;
                        hGutter.position.set(L/2, hGutterY, hGutterZ);
                    }
                    houseGrp.add(hGutter);
                    regComp(hGutter, 'House Quad Gutter', {'Size': '115mm Quad', 'Front': '76mm', 'Back': '45mm'});
                    } // end showHouseGutter
                }

                // C-Channel - for receiving channel modes (fascia and wall only, not fasciabeam)
                if (c.isRecvChan) {
                    const chanW = 0.075;  // 75mm wide – captures sheet edges
                    const chanH = 0.03;   // 30mm tall
                    const chanT = 0.003;  // 3mm steel thickness
                    // C-channel profile (U-shape opening toward patio)
                    const chanShape = new THREE.Shape();
                    chanShape.moveTo(0, 0);
                    chanShape.lineTo(chanW, 0);
                    chanShape.lineTo(chanW, chanT);
                    chanShape.lineTo(chanT, chanT);
                    chanShape.lineTo(chanT, chanH - chanT);
                    chanShape.lineTo(chanW, chanH - chanT);
                    chanShape.lineTo(chanW, chanH);
                    chanShape.lineTo(0, chanH);
                    chanShape.closePath();

                    const chanGeo = new THREE.ExtrudeGeometry(chanShape, { depth: L, bevelEnabled: false });
                    const channel = new THREE.Mesh(chanGeo, sMat());

                    if (c.connection === 'fascia') {
                        // On fascia board face, at fascia beam height
                        const chanY = fasciaHm + beamH/2 - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    } else {
                        // Wall mode: on wall surface at connection height
                        const chanY = fasciaHm - chanH/2;
                        if (isPerpendicular) {
                            channel.rotation.y = Math.PI;
                            channel.position.set(-W/2 - wallThick/2, chanY, L/2);
                        } else {
                            channel.rotation.y = -Math.PI / 2;
                            channel.position.set(L/2, chanY, -W/2 - wallThick/2);
                        }
                    }
                    steelGrp.add(channel);
                    regComp(channel, 'Receiving Channel', {'Size': '75×30mm C-Channel', 'Length': c.L + 'mm', 'Type': c.connection === 'fascia' ? 'Fascia mount' : 'Wall mount'});
                }
            }

            updateMatList();

            // Update camera orbit target to center of combined patio + house
            const bbox = new THREE.Box3();
            [steelGrp, roofGrp, accGrp, houseGrp].forEach(g => {
                if (g.children.length > 0) bbox.expandByObject(g);
            });
            if (!bbox.isEmpty()) {
                bbox.getCenter(aCamTarget);
            }
            updateAsmCam();
        }

        function createTrussUnit(W, rise, rafter, tw, th, mat, style, pitchRad) {
            const g = new THREE.Group();

            const chord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, W), mat.clone());
            chord.position.set(0, th/2, 0);
            g.add(chord);

            const leftGeo = new THREE.BoxGeometry(tw, th, rafter);
            leftGeo.translate(0, 0, rafter/2);
            const leftR = new THREE.Mesh(leftGeo, mat.clone());
            leftR.position.set(0, th, -W/2);
            leftR.rotation.x = -pitchRad;
            g.add(leftR);

            const rightGeo = new THREE.BoxGeometry(tw, th, rafter);
            rightGeo.translate(0, 0, -rafter/2);
            const rightR = new THREE.Mesh(rightGeo, mat.clone());
            rightR.position.set(0, th, W/2);
            rightR.rotation.x = pitchRad;
            g.add(rightR);

            if (style === 'king') {
                const kingH = rise - th;
                if (kingH > 0) {
                    const king = new THREE.Mesh(new THREE.BoxGeometry(tw, kingH, th), mat.clone());
                    king.position.set(0, th + kingH/2, 0);
                    g.add(king);
                }
            } else if (style === 'queen') {
                const qH = rise * 0.6;
                const qZ = W * 0.2;
                [-1, 1].forEach(s => {
                    const q = new THREE.Mesh(new THREE.BoxGeometry(tw, qH, th), mat.clone());
                    q.position.set(0, th + qH/2, s * qZ);
                    g.add(q);
                });
                const topChord = new THREE.Mesh(new THREE.BoxGeometry(tw, th, W * 0.4), mat.clone());
                topChord.position.set(0, th + qH, 0);
                g.add(topChord);
            }

            return g;
        }

        function regComp(mesh, name, specs) {
            compData.set(mesh.uuid, {name, specs});
        }

        function checkHover(mx, my) {
            asmRay.setFromCamera(asmMouse, asmCam);
            const all = [];
            if (steelGrp.visible) all.push(...steelGrp.children);
            if (roofGrp.visible) all.push(...roofGrp.children);
            if (accGrp.visible) all.push(...accGrp.children);
            if (houseGrp.visible) all.push(...houseGrp.children);
            const hits = asmRay.intersectObjects(all, true);
            if (hits.length > 0) {
                let obj = hits[0].object;
                while (obj.parent && !compData.has(obj.uuid) && obj.parent !== asmScene) obj = obj.parent;
                if (compData.has(obj.uuid)) {
                    if (hovered !== obj) { clearHover(); hovered = obj; highlight(obj); }
                    showTooltip(mx, my, compData.get(obj.uuid));
                    return;
                }
            }
            clearHover();
        }

        function highlight(mesh) {
            const hl = new THREE.Color(0xF15A29);
            if (mesh.material) { mesh.material.emissive = hl; mesh.material.emissiveIntensity = 0.3; }
            mesh.traverse(c => { if (c.material) { c.material.emissive = hl; c.material.emissiveIntensity = 0.3; }});
        }

        function clearHover() {
            if (hovered) {
                if (hovered.material) { hovered.material.emissive = new THREE.Color(0); hovered.material.emissiveIntensity = 0; }
                hovered.traverse(c => { if (c.material) { c.material.emissive = new THREE.Color(0); c.material.emissiveIntensity = 0; }});
                hovered = null;
            }
            hideTooltip();
        }

        function showTooltip(x, y, data) {
            const tt = document.getElementById('tooltip');
            document.getElementById('ttTitle').textContent = data.name;
            document.getElementById('ttContent').innerHTML = Object.entries(data.specs)
                .map(([k,v]) => `<div class="tooltip-row"><span class="tooltip-label">${k}</span><span class="tooltip-value">${v}</span></div>`).join('');
            tt.style.left = (x + 15) + 'px';
            tt.style.top = (y + 15) + 'px';
            tt.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function toggleLayer(layer, el) {
            el.classList.toggle('active');
            const vis = el.classList.contains('active');
            if (layer === 'steel') steelGrp.visible = vis;
            if (layer === 'roof') roofGrp.visible = vis;
            if (layer === 'acc') accGrp.visible = vis;
            if (layer === 'house') houseGrp.visible = vis;
        }

        function setAsmView(v, btn) {
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            if (v === '3d') { aCamT = 0.5; aCamP = 0.4; aCamD = 12; }
            else if (v === 'front') { aCamT = 0; aCamP = 0.25; aCamD = 10; }
            else if (v === 'side') { aCamT = Math.PI/2; aCamP = 0.3; aCamD = 12; }
            else if (v === 'top') { aCamT = 0; aCamP = 1.4; aCamD = 15; }
            updateAsmCam();
        }

        function toggleFullscreen() {
            const el = document.getElementById('asmViewport');
            el.classList.toggle('fullscreen');
            setTimeout(() => {
                asmCam.aspect = el.clientWidth / el.clientHeight;
                asmCam.updateProjectionMatrix();
                asmRend.setSize(el.clientWidth, el.clientHeight);
            }, 100);
        }

        function getSheetMatEntries(numSheets, roofing) {
            const pc = (roofing === 'trimdek') ? getPolycarbConfig() : null;
            if (!pc) return [{d: roofing + ' Sheets', q: numSheets}];
            const split = getPolycarbSheetSplit(numSheets);
            const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
            const colorbondColour = sheetColor ? sheetColor.name : '';
            const entries = [];
            if (split.colorbond > 0) entries.push({d: 'Trimdek Colorbond' + (colorbondColour ? ' ' + colorbondColour : '') + ' Sheets', q: split.colorbond});
            if (split.polycarb > 0) entries.push({d: 'Trimdek Polycarb ' + brandLabel + ' ' + pc.tint + ' Sheets', q: split.polycarb});
            return entries;
        }

        function updateMatList() {
            const c = calc;
            let mats = [];
            const sheetCover = c.sheetCoverage;

            if (c.isGable) {
                const numSheets = Math.ceil(c.L / sheetCover) * 2;
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                const riserCount = c.riserQty;
                // Beam count depends on connection type
                let beamCount;
                if (c.connection === 'freestanding') {
                    beamCount = 2;  // Gutter beam + back beam
                } else if (c.connection === 'riser') {
                    beamCount = 3;  // Gutter beam + fascia beam + riser beam
                } else {
                    beamCount = 2;  // Gutter beam + fascia/back beam
                }
                const purlinCount = Math.max(2, Math.ceil(c.rafter / 1000 / 0.8)) * 2;
                mats = [
                    {d: 'Posts 90×90×2', q: postCount},
                    {d: 'Beams 100×50×2', q: beamCount},
                    {d: 'Trusses ' + c.steel.name, q: c.nTruss},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Ridge Cap', q: 1},
                    {d: 'Gable Barges', q: 4},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                if (c.infill !== 'none') mats.push({d: 'Gable Infill', q: 2});
                if (c.connection === 'riser') {
                    mats.push({d: 'Riser Elbows 75×75', q: riserCount});
                    mats.push({d: 'Riser Beam 100×50', q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                    if (c.riserGutter === 'quad') {
                        mats.push({d: 'Riser Beam Gutter 115mm Quad', q: 1});
                    }
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            } else {
                const numSheets = Math.ceil(c.L / sheetCover);
                const postCount = c.connection === 'freestanding' ? c.nPosts * 2 : c.nPosts;
                let beamCount;
                if (c.connection === 'riser') {
                    beamCount = 3;  // gutter + fascia + riser beam
                } else if (c.isRecvChan) {
                    beamCount = 1;  // gutter beam only (channel replaces back beam)
                } else {
                    beamCount = 2;  // gutter + back/flyover beam
                }
                const riserCount = c.riserQty;
                const effectiveW = (c.W - (c.connection === 'riser' ? c.riserOffset : 0)) / 1000;
                const purlinCount = Math.max(2, Math.ceil(effectiveW / 0.9)) + 1;
                mats = [
                    {d: 'Posts 90×90×2', q: postCount},
                    {d: 'Beams 100×50×2', q: beamCount},
                    {d: 'Rafters ' + c.steel.name, q: c.nRafters},
                    {d: 'Purlins ' + c.steel.name, q: purlinCount},
                    ...getSheetMatEntries(numSheets, c.roofing),
                    {d: 'Barge Flashings', q: 2},
                    {d: 'Gutter', q: 1},
                    {d: 'Downpipes', q: 2}
                ];
                // Back flashing - skip for riser+box gutter AND receiving channel
                if (!(c.connection === 'riser' && c.houseGutter === 'box') && !c.isRecvChan) {
                    mats.splice(5, 0, {d: 'Back Flashing', q: 1});
                }
                if (c.connection === 'riser') {
                    mats.splice(2, 0, {d: 'Riser Elbows 75×75', q: riserCount});
                    mats.splice(3, 0, {d: 'Riser Beam 100×50', q: 1});
                    if (c.houseGutter === 'box') {
                        mats.push({d: 'Box Gutter', q: 1});
                    }
                }
                if (c.connection === 'flyover') {
                    const strutCount = Math.max(2, Math.ceil(c.L / 1200));
                    mats.push({d: 'Flyover Struts 90×90', q: strutCount});
                    mats.push({d: 'Flyover Beam 150×50', q: 1});
                }
                if (c.isRecvChan) {
                    mats.push({d: 'Receiving Channel', q: 1});
                    mats.push({d: 'Foam Backfill Strips (' + c.roofing + ')', q: 1});
                }
                if (c.hasFascia) {
                    mats.push({d: 'House Fascia Board', q: 1});
                }
            }

            document.getElementById('matList').innerHTML = mats
                .map(m => `<div class="mat-row"><span>${m.d}</span><span class="mat-qty">${m.q}×</span></div>`).join('');
        }

        function animateAsm() {
            requestAnimationFrame(animateAsm);
            if (asmRend && asmScene && asmCam) {
                asmRend.render(asmScene, asmCam);
            }
        }

        // ==================== PRICING ====================
        const DEFAULT_RATES = {
            // Steel ($/LM)
            '90×90×2 RHS':     35.50,
            '76×38×1.6 RHS':   15.50,
            '75×50×2 RHS':     26.00,
            '100×50×2 RHS':    30.00,
            '150×50×2 RHS':    39.05,
            // Roofing ($/LM)
            'Solarspan 75mm':  110.00,
            'Corrugated Colorbond': 12.04,
            'Trimdek Colorbond':   14.00,
            'Ampelite Solasafe 5-Rib': 25.00,
            'Laserlite 2000 5-Rib':    27.00,
            // Flashings ($/LM)
            'Ridge Cap':       15.00,
            'Barge Flashing':  12.00,
            'Back Flashing':   14.00,
            'Gutter Flashing': 10.00,
            // Gutters & Drainage ($/LM)
            'Quad Gutter 115mm': 18.00,
            'Box Gutter':      45.00,
            'Downpipe 90mm':   12.00,
            // Extras
            'Gable Infill (sqm)': 45.00,
            'Riser Bracket (ea)': 12.00,
            'Fixings ($/sqm)': 2.50,
            'Foam Strip':      3.00,
            // Labour ($/day)
            'Skilled Trade':   400.00,
            'Labourer':        250.00,
            'Electrician':     450.00
        };

        const DEFAULT_SELL_MARKUP = 1.35; // 35% default markup on cost for sell price
        let storedRates = {};
        let jobRows = [];      // {desc, qty, length, unitCost, unitSell, isAddon}
        let labourRows = [];   // {desc, trades, days, dayRate, sell}
        let extrasRows = [];   // {desc, qty, unitCost, unitSell, type}
        let pricingState = {}; // cached pricing calcs for PDF access

        function loadRates() {
            try {
                const saved = localStorage.getItem('patioRates');
                storedRates = saved ? JSON.parse(saved) : { ...DEFAULT_RATES };
                // Merge in any new default keys missing from saved data
                Object.keys(DEFAULT_RATES).forEach(k => {
                    if (!(k in storedRates)) storedRates[k] = DEFAULT_RATES[k];
                });
            } catch (e) {
                storedRates = { ...DEFAULT_RATES };
            }
        }

        function saveRates() {
            localStorage.setItem('patioRates', JSON.stringify(storedRates));
        }

        function renderRatesPanel() {
            const body = document.getElementById('ratesBody');
            body.innerHTML = Object.entries(storedRates).map(([k, v]) =>
                `<tr><td>${k}</td><td><input type="number" class="rate-input" step="0.01" value="${v.toFixed(2)}" onchange="updateRate('${k}', this.value)"></td></tr>`
            ).join('');
        }

        function updateRate(key, val) {
            storedRates[key] = parseFloat(val) || 0;
            saveRates();
            buildJobRows();
            // Update labour day rate if applicable
            if (key === 'Skilled Trade') {
                const el = document.getElementById('labDayRate');
                if (el && parseFloat(el.value) === 400) el.value = storedRates[key];
            }
            updatePricing();
        }

        function openRatesModal() {
            renderRatesPanel();
            document.getElementById('ratesModal').style.display = '';
        }


        function matchRate(desc) {
            const d = desc.toLowerCase();
            // Steel
            if (d.includes('90×90') || d.includes('90x90')) return storedRates['90×90×2 RHS'] || 0;
            if (d.includes('76×38') || d.includes('76x38')) return storedRates['76×38×1.6 RHS'] || 0;
            if (d.includes('75×50') || d.includes('75x50') || d.includes('75×75') || d.includes('75x75')) return storedRates['75×50×2 RHS'] || 0;
            if (d.includes('150×50') || d.includes('150x50')) return storedRates['150×50×2 RHS'] || 0;
            if (d.includes('100×50') || d.includes('100x50')) return storedRates['100×50×2 RHS'] || 0;
            // Roofing
            if (d.includes('solarspan')) return storedRates['Solarspan 75mm'] || 0;
            if (d.includes('polycarb') && d.includes('laserlite')) return storedRates['Laserlite 2000 5-Rib'] || 0;
            if (d.includes('polycarb') && d.includes('ampelite')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('polycarb')) return storedRates['Ampelite Solasafe 5-Rib'] || 0;
            if (d.includes('trimdek') && d.includes('sheet')) return storedRates['Trimdek Colorbond'] || 0;
            if (d.includes('sheet') && !d.includes('solarspan')) return storedRates['Corrugated Colorbond'] || 0;
            // Flashings
            if (d.includes('ridge cap') || d.includes('ridge flash')) return storedRates['Ridge Cap'] || 0;
            if (d.includes('barge')) return storedRates['Barge Flashing'] || 0;
            if (d.includes('back flash') || d.includes('wall flash')) return storedRates['Back Flashing'] || 0;
            if (d.includes('gutter flash')) return storedRates['Gutter Flashing'] || 0;
            // Gutters & drainage
            if (d.includes('box gutter')) return storedRates['Box Gutter'] || 0;
            if (d.includes('gutter') && !d.includes('box') && !d.includes('downpipe') && !d.includes('flash')) return storedRates['Quad Gutter 115mm'] || 0;
            if (d.includes('downpipe')) return storedRates['Downpipe 90mm'] || 0;
            // Extras
            if (d.includes('infill')) return storedRates['Gable Infill (sqm)'] || 0;
            if (d.includes('riser') && d.includes('bracket')) return storedRates['Riser Bracket (ea)'] || 0;
            if (d.includes('foam')) return storedRates['Foam Strip'] || 0;
            if (d.includes('channel') && !d.includes('gutter')) return storedRates['Back Flashing'] || 0;
            if (d.includes('strut')) return storedRates['76×38×1.6 RHS'] || 0;
            if (d.includes('elbow')) return storedRates['Downpipe 90mm'] || 0;
            if (d.includes('fascia board')) return storedRates['Barge Flashing'] || 0;
            return 0;
        }

        function getItemLength(desc) {
            const c = calc;
            const d = desc.toLowerCase();
            const Lm = c.L / 1000;
            const Wm = c.W / 1000;
            if (d.includes('post')) return c.postH / 1000;
            if (d.includes('beam') || d.includes('ridge') || d.includes('barge') || d.includes('flashing') || d.includes('channel') || d.includes('gutter') || d.includes('fascia board')) return Lm;
            if (d.includes('truss') || d.includes('rafter')) return c.rafter / 1000;
            if (d.includes('purlin')) return Lm;
            if (d.includes('sheet') && d.includes('solarspan')) return Wm;
            if (d.includes('sheet')) return c.rafter / 1000;
            if (d.includes('downpipe')) return c.postH / 1000;
            if (d.includes('strut')) return 0.5;
            if (d.includes('riser elbow')) return 0.5;
            if (d.includes('infill')) return c.rafter / 1000;
            if (d.includes('foam')) return Lm;
            return 1;
        }

        // Build jobRows from the materials list (called after rebuildAll)
        function buildJobRows() {
            const matRowEls = document.querySelectorAll('#matList .mat-row');
            // Preserve existing addon rows
            const addons = jobRows.filter(r => r.isAddon);
            jobRows = [];
            matRowEls.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length < 2) return;
                const desc = spans[0].textContent.trim();
                const qty = parseInt(spans[1].textContent.trim().replace('×', '')) || 1;
                const length = getItemLength(desc);
                const unitCost = matchRate(desc);
                const unitSell = +(unitCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc, qty, length, unit: 'LM', unitCost, unitSell, isAddon: false });
            });
            // Auto-add fixings estimate based on patio area
            const c = calc;
            if (c.L && c.W) {
                const areaSqm = (c.L / 1000) * (c.W / 1000);
                const fixCost = storedRates['Fixings ($/sqm)'] || 2.50;
                const fixSell = +(fixCost * DEFAULT_SELL_MARKUP).toFixed(2);
                jobRows.push({ desc: 'Fixings (screws, anchors, silicone, foam)', qty: +areaSqm.toFixed(1), length: 1, unit: 'sqm', unitCost: fixCost, unitSell: fixSell, isAddon: false });
            }
            // Re-append addons
            addons.forEach(a => { if (!a.unit) a.unit = 'each'; jobRows.push(a); });
        }

        const UNIT_OPTIONS = ['each', 'LM', 'sqm', 'hours', 'days', 'lot'];

        // Keep renderJobTable for compatibility (materials modal uses it internally)
        function renderJobTable() { /* now handled by materials modal */ }

        // Extras presets
        function addExtra(type) {
            const nPosts = calc.nPosts ? calc.nPosts * 2 : 6;
            const presets = {
                footings:    { desc: 'Concrete Footings', qty: nPosts, unitCost: 85,  unitSell: 150, type: 'footings' },
                electrical:  { desc: 'Electrical',        qty: 1,      unitCost: 0,   unitSell: 0,   type: 'electrical' },
                downlights:  { desc: 'Downlights',        qty: 4,      unitCost: 50,  unitSell: 85,  type: 'downlights' },
                demo:        { desc: 'Demo/Removal',      qty: 1,      unitCost: 0,   unitSell: 0,   type: 'demo' },
                delivery:    { desc: 'Delivery',           qty: 1,      unitCost: 200, unitSell: 350, type: 'delivery' },
                other:       { desc: '',                   qty: 1,      unitCost: 0,   unitSell: 0,   type: 'other' }
            };
            const p = presets[type];
            if (!p) return;
            extrasRows.push({ ...p });
            renderExtras();
            updatePricing();
        }

        function removeExtra(idx) {
            extrasRows.splice(idx, 1);
            renderExtras();
            updatePricing();
        }

        function renderExtras() {
            const container = document.getElementById('extrasRowsContainer');
            if (extrasRows.length === 0) {
                container.innerHTML = '';
                return;
            }
            container.innerHTML = extrasRows.map((r, i) => {
                const totalCost = r.qty * r.unitCost;
                const totalSell = r.qty * r.unitSell;
                const fmt = v => '$' + v.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                const descInput = r.type === 'other'
                    ? `<input type="text" class="ex-input desc-input" value="${r.desc}" placeholder="Description" onchange="extrasRows[${i}].desc=this.value">`
                    : `<span>${r.desc}${r.qty > 1 ? ' (' + r.qty + ')' : ''}</span>`;
                return `<div class="extras-row">
                    <div class="ex-desc">${descInput}</div>
                    ${r.type === 'downlights' || r.type === 'footings' ? `<div class="ex-field">Qty: <input type="number" class="ex-input" style="width:50px" value="${r.qty}" min="1" step="1" onchange="extrasRows[${i}].qty=parseFloat(this.value)||1;renderExtras();updatePricing()"></div>` : ''}
                    <div class="ex-field">Cost: <input type="number" class="ex-input" value="${totalCost.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitCost=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <div class="ex-field">Sell: <input type="number" class="ex-input" value="${totalSell.toFixed(0)}" min="0" step="10" onchange="extrasRows[${i}].unitSell=parseFloat(this.value)/(extrasRows[${i}].qty||1);updatePricing()"></div>
                    <button class="ex-remove" onclick="removeExtra(${i})">&times;</button>
                </div>`;
            }).join('');
        }

        // Legacy addon compat: migrate old addon rows to extras on import
        function addSmartAddon(type) {
            const typeMap = { concrete: 'footings', electrical: 'electrical', downlights: 'downlights', demo: 'demo', fan: 'other', fascia: 'other', posts: 'other', permit: 'other' };
            addExtra(typeMap[type] || 'other');
        }
        function addCustomLine() { addExtra('other'); }
        function removeJobRow(idx) { jobRows.splice(idx, 1); updatePricing(); }

        // Labour — read from inline card inputs
        function getLabourFromCard() {
            const trades = parseFloat(document.getElementById('labTrades').value) || 0;
            const days = parseFloat(document.getElementById('labDays').value) || 0;
            const dayRate = parseFloat(document.getElementById('labDayRate').value) || 0;
            const sell = parseFloat(document.getElementById('labSellInput').value) || 0;
            const cost = trades * days * dayRate;
            return { trades, days, dayRate, cost, sell };
        }

        // Sync labourRows from card for PDF/export compat
        function syncLabourRows() {
            const l = getLabourFromCard();
            labourRows = [{ role: 'Skilled (Patio Install)', trades: l.trades, days: l.days, dayRate: l.dayRate, sell: l.sell }];
        }

        // Kept for export/import compat
        function renderLabourTable() {}
        function addLabourRole() {}
        function matchDayRate(role) {
            const r = role.toLowerCase();
            if (r.includes('electrician')) return storedRates['Electrician'] || 450;
            if (r.includes('labourer')) return storedRates['Labourer'] || 250;
            return storedRates['Skilled Trade'] || 400;
        }

        // Complexity — kept for export/import compat (hidden inputs)
        function updateComplexity() {}

        // ==================== MATERIALS MODAL ====================
        function openMaterialsModal() {
            renderMaterialsModal();
            document.getElementById('materialsModal').style.display = '';
        }

        function closeMaterialsModal() {
            document.getElementById('materialsModal').style.display = 'none';
            updatePricing();
        }

        function renderMaterialsModal() {
            const showCost = document.getElementById('showCostToggle').checked;
            const body = document.getElementById('matModalBody');
            // Show only non-addon material rows
            const matRows = jobRows.filter(r => !r.isAddon);
            let totalSell = 0;

            body.innerHTML = matRows.map((r, realIdx) => {
                const i = jobRows.indexOf(r);
                const mult = r.unit === 'LM' ? r.length : 1;
                const lineCost = r.qty * mult * r.unitCost;
                const lineSell = r.qty * mult * r.unitSell;
                totalSell += lineSell;
                const markupPct = r.unitCost > 0 ? ((r.unitSell - r.unitCost) / r.unitCost * 100) : 0;
                const globalMk = parseFloat(document.getElementById('globalMarkupPct').value) || 35;
                const isCustom = Math.abs(markupPct - globalMk) > 1;
                const qtyStr = r.qty + (r.unit === 'LM' && r.length > 0 ? ' \u00D7 ' + r.length.toFixed(1) + 'm' : r.unit !== 'LM' ? ' ' + r.unit : '');

                return `<tr>
                    <td>${r.desc}</td>
                    <td>${qtyStr}</td>
                    ${showCost ? `<td class="r mono">$${lineCost.toFixed(2)}</td>` : `<td class="r cost-col" style="display:none"></td>`}
                    <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" onchange="updateMatSellFromModal(${i},this.value)" style="width:90px"></td>
                    <td class="r"><span class="markup-badge${isCustom ? ' custom' : ''}">${markupPct.toFixed(0)}%${isCustom ? '*' : ''}</span></td>
                    <td></td>
                </tr>`;
            }).join('');

            // Also show custom addon rows in modal
            const addonRows = jobRows.filter(r => r.isAddon);
            if (addonRows.length > 0) {
                body.innerHTML += `<tr><td colspan="6" style="font-size:11px;font-weight:600;text-transform:uppercase;color:var(--sw-text-sec);padding-top:12px;border-bottom:1px solid var(--sw-border)">Custom Items</td></tr>`;
                body.innerHTML += addonRows.map(r => {
                    const i = jobRows.indexOf(r);
                    const mult = r.unit === 'LM' ? r.length : 1;
                    const lineSell = r.qty * mult * r.unitSell;
                    totalSell += lineSell;
                    return `<tr>
                        <td><input type="text" value="${r.desc}" style="width:160px;padding:4px 6px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px" onchange="jobRows[${i}].desc=this.value"></td>
                        <td><input type="number" value="${r.qty}" min="0" step="1" style="width:50px;padding:4px;border:1px solid var(--sw-border);border-radius:4px;font-size:12px;text-align:center" onchange="jobRows[${i}].qty=parseFloat(this.value)||0;renderMaterialsModal()"></td>
                        ${showCost ? `<td class="r"><input type="number" value="${(r.qty*mult*r.unitCost).toFixed(2)}" min="0" step="1" style="width:80px" onchange="jobRows[${i}].unitCost=parseFloat(this.value)/(jobRows[${i}].qty*(jobRows[${i}].unit==='LM'?jobRows[${i}].length:1)||1);renderMaterialsModal()"></td>` : `<td style="display:none"></td>`}
                        <td class="r"><input type="number" value="${lineSell.toFixed(2)}" min="0" step="1" style="width:90px" onchange="updateMatSellFromModal(${i},this.value)"></td>
                        <td class="r"></td>
                        <td><button style="background:none;border:none;color:#ccc;cursor:pointer;font-size:16px" onclick="jobRows.splice(${i},1);renderMaterialsModal()" onmouseover="this.style.color='#FF3B30'" onmouseout="this.style.color='#ccc'">&times;</button></td>
                    </tr>`;
                }).join('');
            }

            // Update cost column visibility (header + all cost cells)
            document.querySelectorAll('.mat-modal-table .cost-col').forEach(el => el.style.display = showCost ? '' : 'none');

            document.getElementById('matModalTotal').textContent = '$' + totalSell.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        function updateMatSellFromModal(idx, val) {
            const r = jobRows[idx];
            const mult = r.unit === 'LM' ? r.length : 1;
            const totalQty = r.qty * mult;
            r.unitSell = totalQty > 0 ? parseFloat(val) / totalQty : 0;
            renderMaterialsModal();
        }

        function applyMarkupAll() {
            const pct = parseFloat(document.getElementById('globalMarkupPct').value) || 35;
            jobRows.forEach(r => {
                if (!r.isAddon) {
                    r.unitSell = +(r.unitCost * (1 + pct / 100)).toFixed(2);
                }
            });
            renderMaterialsModal();
            updatePricing();
        }

        function addCustomMaterialRow() {
            jobRows.push({ desc: 'Custom item', qty: 1, length: 1, unit: 'each', unitCost: 0, unitSell: 0, isAddon: true });
            renderMaterialsModal();
        }

        // ==================== MAIN PRICING UPDATE ====================
        function updatePricing() {
            const fmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            const fmtShort = v => '$' + Math.round(v).toLocaleString();

            // Materials from jobRows (non-addon = materials, addon = custom material items included in materials total)
            let matCost = 0, matSell = 0;
            let matItemCount = 0;
            jobRows.forEach(r => {
                const mult = r.unit === 'LM' ? r.length : 1;
                matCost += r.qty * mult * r.unitCost;
                matSell += r.qty * mult * r.unitSell;
                matItemCount++;
            });

            // Materials card update
            const matMarkup = matCost > 0 ? ((matSell - matCost) / matCost * 100) : 0;
            document.getElementById('matSellDisplay').textContent = fmtShort(matSell);
            document.getElementById('matItemCount').textContent = matItemCount + ' item' + (matItemCount !== 1 ? 's' : '');
            document.getElementById('matMarkupPct').textContent = matMarkup.toFixed(0) + '%';

            // Validation: warn if any item has $0 sell
            const hasZero = jobRows.some(r => !r.isAddon && r.unitSell === 0 && r.unitCost > 0);
            const iconEl = document.getElementById('matStatusIcon');
            if (hasZero) {
                iconEl.textContent = '\u26A0';
                iconEl.className = 'status-warn';
            } else {
                iconEl.textContent = '\u2713';
                iconEl.className = 'status-ok';
            }

            // Labour from card inputs
            const lab = getLabourFromCard();
            const labCost = lab.cost;
            const labSell = lab.sell;

            // Update labour cost display
            document.getElementById('labCostDisplay').textContent = fmtShort(labCost);

            // Sync labourRows for PDF/export
            syncLabourRows();

            // Extras
            let extrasCost = 0, extrasSell = 0;
            extrasRows.forEach(r => {
                extrasCost += r.qty * r.unitCost;
                extrasSell += r.qty * r.unitSell;
            });

            // Totals
            const totalCost = matCost + labCost + extrasCost;
            const totalSell = matSell + labSell + extrasSell;
            const gst = totalSell * 0.10;
            const totalIncGST = totalSell + gst;
            const margin = totalSell - totalCost;
            const marginPct = totalSell > 0 ? (margin / totalSell * 100) : 0;

            // Total card
            document.getElementById('totalAmountDisplay').textContent = 'TOTAL ' + fmtShort(totalIncGST) + ' inc GST';

            const marginEl = document.getElementById('totalMarginDisplay');
            const marginIcon = marginPct > 20 ? '  \u2713' : marginPct >= 10 ? '' : '  \u2717';
            marginEl.textContent = 'Margin ' + fmtShort(margin) + ' (' + marginPct.toFixed(1) + '%)' + marginIcon;
            if (marginPct > 20) {
                marginEl.className = 'total-margin margin-green';
            } else if (marginPct >= 10) {
                marginEl.className = 'total-margin margin-orange';
            } else {
                marginEl.className = 'total-margin margin-red';
            }

            // Cache pricing state for PDF generators
            pricingState = {
                matCost, matSell, labCost, labSell, extrasCost, extrasSell,
                totalCost, totalSell, gst, totalIncGST, margin, marginPct,
                fmt
            };
        }

        // ==================== COLLAPSIBLE SECTIONS ====================
        const SECTION_IDS = ['sec-jobdetails', 'sec-config', 'sec-3d', 'sec-materials', 'sec-pricing'];
        const DEFAULT_COLLAPSED = ['sec-materials'];

        function loadCollapseState() {
            try {
                const saved = localStorage.getItem('patioCollapseState');
                return saved ? JSON.parse(saved) : null;
            } catch(e) { return null; }
        }

        function saveCollapseState() {
            const state = {};
            SECTION_IDS.forEach(id => {
                const hdr = document.querySelector('#' + id + ' > .collapse-header');
                if (hdr) state[id] = hdr.classList.contains('collapsed');
            });
            localStorage.setItem('patioCollapseState', JSON.stringify(state));
        }

        function toggleSection(id) {
            const sec = document.getElementById(id);
            if (!sec) return;
            const hdr = sec.querySelector('.collapse-header');
            const body = sec.querySelector('.collapse-body');
            if (!hdr || !body) return;
            const isCollapsed = hdr.classList.contains('collapsed');
            if (isCollapsed) {
                // Expand
                hdr.classList.remove('collapsed');
                body.style.maxHeight = body.scrollHeight + 'px';
                body.classList.remove('shut');
                setTimeout(() => { body.style.maxHeight = ''; }, 350);
            } else {
                // Collapse
                body.style.maxHeight = body.scrollHeight + 'px';
                requestAnimationFrame(() => {
                    body.style.maxHeight = '0';
                    body.classList.add('shut');
                    hdr.classList.add('collapsed');
                });
            }
            saveCollapseState();
        }

        function initCollapseSections() {
            const saved = loadCollapseState();
            SECTION_IDS.forEach(id => {
                const sec = document.getElementById(id);
                if (!sec) return;
                const hdr = sec.querySelector('.collapse-header');
                const body = sec.querySelector('.collapse-body');
                if (!hdr || !body) return;
                const shouldCollapse = saved ? saved[id] : DEFAULT_COLLAPSED.includes(id);
                if (shouldCollapse) {
                    hdr.classList.add('collapsed');
                    body.classList.add('shut');
                    body.style.maxHeight = '0';
                } else {
                    hdr.classList.remove('collapsed');
                    body.classList.remove('shut');
                }
            });
        }

        // ==================== EXPORT / IMPORT JOB DATA ====================
        function gatherJobData() {
            const c = calc;
            return {
                _version: 'PatioDesignerPro_V18',
                _exported: new Date().toISOString(),
                client: {
                    jobRef: (document.getElementById('jobRef')?.value || '').trim(),
                    name: (document.getElementById('clientName')?.value || '').trim(),
                    address: (document.getElementById('siteAddress')?.value || '').trim(),
                    phone: (document.getElementById('clientPhone')?.value || '').trim(),
                    email: (document.getElementById('clientEmail')?.value || '').trim(),
                    salesperson: (document.getElementById('salesperson')?.value || '')
                },
                config: {
                    roofStyle: document.getElementById('inRoofStyle')?.value,
                    orientation: document.getElementById('inOrientation')?.value,
                    projection: document.getElementById('inWidth')?.value,
                    length: document.getElementById('inLength')?.value,
                    pitch: document.getElementById('inPitch')?.value,
                    postHeight: document.getElementById('inPostHeight')?.value,
                    posts: document.getElementById('inPosts')?.value,
                    trusses: document.getElementById('inTrusses')?.value,
                    rafters: document.getElementById('inRafters')?.value,
                    roofing: document.getElementById('inRoofing')?.value,
                    infill: document.getElementById('inInfill')?.value,
                    connection: document.getElementById('inConnection')?.value,
                    fasciaHeight: document.getElementById('inFasciaHeight')?.value,
                    riserHeight: document.getElementById('inRiserHeight')?.value,
                    riserOffset: document.getElementById('inRiserOffset')?.value,
                    riserQty: document.getElementById('inRiserQty')?.value,
                    houseGutter: document.getElementById('inHouseGutter')?.value,
                    riserGutter: document.getElementById('inRiserGutter')?.value,
                    postFix: document.getElementById('inPostFix')?.value,
                    trussStyle: document.getElementById('inTrussStyle')?.value,
                    trussSteel: document.getElementById('inTrussSteel')?.value,
                    overhang: document.getElementById('inOverhang')?.value,
                    sheetColor: sheetColor.name,
                    steelColor: steelColor.name,
                    polycarbEnabled: isPolycarbEnabled(),
                    polycarbBrand: document.getElementById('inPolycarbBrand')?.value,
                    polycarbTint: document.getElementById('inPolycarbTint')?.value,
                    polycarbPattern: document.getElementById('inPolycarbPattern')?.value,
                    polycarbCustom: document.getElementById('inPolycarbCustom')?.value
                },
                pricing: {
                    addonRows: jobRows.filter(r => r.isAddon),
                    extrasRows: extrasRows,
                    labour: {
                        trades: document.getElementById('labTrades')?.value,
                        days: document.getElementById('labDays')?.value,
                        dayRate: document.getElementById('labDayRate')?.value,
                        sell: document.getElementById('labSellInput')?.value
                    }
                },
                complexity: {
                    build: document.getElementById('cxBuild')?.value,
                    access: document.getElementById('cxAccess')?.value,
                    distance: document.getElementById('cxDistance')?.value,
                    footing: document.getElementById('cxFooting')?.value,
                    height: document.getElementById('cxHeight')?.value
                },
                notes: {
                    jobNotes: (document.getElementById('jobNotes')?.value || '').trim(),
                    pricingNotes: (document.getElementById('pricingNotes')?.value || '').trim()
                }
            };
        }

        function exportJobData() {
            const data = gatherJobData();
            const json = JSON.stringify(data, null, 2);

            // Copy to clipboard
            navigator.clipboard.writeText(json).then(() => {
                alert('Job data copied to clipboard!\n\nPaste this into GHL notes, email, or save as a file to reload later.');
            }).catch(() => {
                // Fallback: download as file
                downloadJobJSON(json, data.client.jobRef);
            });
        }

        function downloadJobJSON(json, ref) {
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (ref || 'PatioJob') + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function showImportModal() {
            document.getElementById('importTextarea').value = '';
            document.getElementById('importStatus').textContent = '';
            document.getElementById('importModal').style.display = '';
        }

        function importJobData() {
            const raw = document.getElementById('importTextarea').value.trim();
            const statusEl = document.getElementById('importStatus');
            if (!raw) { statusEl.textContent = 'Please paste JSON data first.'; statusEl.style.color = '#FF3B30'; return; }
            let data;
            try {
                data = JSON.parse(raw);
            } catch(e) {
                statusEl.textContent = 'Invalid JSON. Check the data and try again.';
                statusEl.style.color = '#FF3B30';
                return;
            }

            // Populate client info
            if (data.client) {
                const cl = data.client;
                if (cl.jobRef) document.getElementById('jobRef').value = cl.jobRef;
                if (cl.name) document.getElementById('clientName').value = cl.name;
                if (cl.address) document.getElementById('siteAddress').value = cl.address;
                if (cl.phone) document.getElementById('clientPhone').value = cl.phone;
                if (cl.email) document.getElementById('clientEmail').value = cl.email;
                if (cl.salesperson) document.getElementById('salesperson').value = cl.salesperson;
            }

            // Populate config
            if (data.config) {
                const cfg = data.config;
                const setVal = (id, val) => { const el = document.getElementById(id); if (el && val != null) el.value = val; };
                setVal('inRoofStyle', cfg.roofStyle);
                setVal('inOrientation', cfg.orientation);
                setVal('inWidth', cfg.projection);
                setVal('inLength', cfg.length);
                setVal('inPitch', cfg.pitch);
                setVal('inPostHeight', cfg.postHeight);
                setVal('inPosts', cfg.posts);
                setVal('inTrusses', cfg.trusses);
                setVal('inRafters', cfg.rafters);
                setVal('inRoofing', cfg.roofing);
                setVal('inInfill', cfg.infill);
                setVal('inConnection', cfg.connection);
                setVal('inFasciaHeight', cfg.fasciaHeight);
                setVal('inRiserHeight', cfg.riserHeight);
                setVal('inRiserOffset', cfg.riserOffset);
                setVal('inRiserQty', cfg.riserQty);
                setVal('inHouseGutter', cfg.houseGutter);
                setVal('inRiserGutter', cfg.riserGutter);
                setVal('inPostFix', cfg.postFix);
                setVal('inTrussStyle', cfg.trussStyle);
                setVal('inTrussSteel', cfg.trussSteel);
                setVal('inOverhang', cfg.overhang);

                // Colours
                if (cfg.sheetColor) {
                    const sc = COLORS.find(c => c.name === cfg.sheetColor);
                    if (sc) {
                        sheetColor = sc;
                        const chips = document.querySelectorAll('#sheetChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('sheetLabel').textContent = sc.name;
                    }
                }
                if (cfg.steelColor) {
                    const sc = COLORS.find(c => c.name === cfg.steelColor);
                    if (sc) {
                        steelColor = sc;
                        const chips = document.querySelectorAll('#steelChips .color-chip');
                        chips.forEach(ch => { ch.classList.toggle('active', ch.title === sc.name); });
                        document.getElementById('steelLabel').textContent = sc.name;
                    }
                }
                // Polycarbonate
                if (cfg.polycarbEnabled) {
                    document.querySelector('input[name="polycarb"][value="yes"]').checked = true;
                    document.getElementById('polycarbOptions').style.display = 'block';
                    if (cfg.polycarbBrand) document.getElementById('inPolycarbBrand').value = cfg.polycarbBrand;
                    updatePolycarbTints();
                    if (cfg.polycarbTint) document.getElementById('inPolycarbTint').value = cfg.polycarbTint;
                    if (cfg.polycarbPattern) document.getElementById('inPolycarbPattern').value = cfg.polycarbPattern;
                    if (cfg.polycarbCustom) document.getElementById('inPolycarbCustom').value = cfg.polycarbCustom;
                    updatePolycarbPreview();
                }
            }

            // Populate pricing
            if (data.pricing) {
                const p = data.pricing;
                if (p.addonRows && Array.isArray(p.addonRows)) {
                    jobRows = jobRows.filter(r => !r.isAddon);
                    p.addonRows.forEach(a => { a.isAddon = true; if (!a.unit) a.unit = 'each'; jobRows.push(a); });
                }
                // New extras format
                if (p.extrasRows && Array.isArray(p.extrasRows)) {
                    extrasRows = p.extrasRows;
                }
                // New labour card format
                if (p.labour) {
                    const l = p.labour;
                    if (l.trades != null) document.getElementById('labTrades').value = l.trades;
                    if (l.days != null) document.getElementById('labDays').value = l.days;
                    if (l.dayRate != null) document.getElementById('labDayRate').value = l.dayRate;
                    if (l.sell != null) document.getElementById('labSellInput').value = l.sell;
                }
                // Legacy: old labourRows format (backward compat)
                if (p.labourRows && Array.isArray(p.labourRows) && p.labourRows.length > 0 && !p.labour) {
                    const first = p.labourRows[0];
                    document.getElementById('labTrades').value = first.trades || 2;
                    document.getElementById('labDays').value = first.days || 1.5;
                    document.getElementById('labDayRate').value = first.dayRate || 400;
                    document.getElementById('labSellInput').value = first.sell || 0;
                }
                // Legacy: delivery as extras (backward compat)
                if (p.deliveryCost != null && parseFloat(p.deliveryCost) > 0 && !p.extrasRows) {
                    extrasRows.push({ desc: 'Delivery', qty: 1, unitCost: parseFloat(p.deliveryCost) || 0, unitSell: parseFloat(p.deliverySell) || 0, type: 'delivery' });
                }
            }

            // Complexity scores (still stored in hidden inputs)
            if (data.complexity) {
                const cx = data.complexity;
                if (cx.build) document.getElementById('cxBuild').value = cx.build;
                if (cx.access) document.getElementById('cxAccess').value = cx.access;
                if (cx.distance) document.getElementById('cxDistance').value = cx.distance;
                if (cx.footing) document.getElementById('cxFooting').value = cx.footing;
                if (cx.height) document.getElementById('cxHeight').value = cx.height;
            }

            // Notes
            if (data.notes) {
                if (data.notes.jobNotes) document.getElementById('jobNotes').value = data.notes.jobNotes;
                if (data.notes.pricingNotes) document.getElementById('pricingNotes').value = data.notes.pricingNotes;
            }

            // Rebuild everything
            updateUI();
            rebuildAll();
            renderExtras();
            updatePricing();
            updateHeaderBadge();

            statusEl.textContent = 'Job loaded successfully! All fields populated.';
            statusEl.style.color = '#34C759';
            setTimeout(() => { document.getElementById('importModal').style.display = 'none'; }, 1200);
        }

        // ==================== JOB REF AUTO-GENERATE ====================
        function generateJobRef() {
            const d = new Date();
            const yy = String(d.getFullYear()).slice(-2);
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const seq = String(Math.floor(Math.random() * 99) + 1).padStart(2, '0');
            return 'SW' + yy + mm + dd + '-' + seq;
        }

        function initJobDetails() {
            const refEl = document.getElementById('jobRef');
            if (!refEl.value.trim()) refEl.value = generateJobRef();
            // Sync header badge on any field change
            ['jobRef', 'clientName', 'siteAddress'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', updateHeaderBadge);
            });
            updateHeaderBadge();
        }

        function updateHeaderBadge() {
            const ref = (document.getElementById('jobRef')?.value || '').trim();
            const name = (document.getElementById('clientName')?.value || '').trim();
            const badge = document.getElementById('headerBadge');
            if (badge) badge.innerHTML = '<strong>' + (ref || 'SW\u2014') + '</strong>' + (name ? ' &nbsp;' + name : '');
        }

        // ==================== PDF SHARED HELPERS ====================
        function getJobRef() {
            const el = document.getElementById('jobRef');
            return (el && el.value.trim()) || generateJobRef();
        }
        function getClientName() { return (document.getElementById('clientName')?.value || '').trim() || 'Client'; }
        function getSiteAddress() { return (document.getElementById('siteAddress')?.value || '').trim(); }
        function getClientPhone() { return (document.getElementById('clientPhone')?.value || '').trim(); }
        function getClientEmail() { return (document.getElementById('clientEmail')?.value || '').trim(); }
        function getSalesperson() { return (document.getElementById('salesperson')?.value || '').trim(); }
        function safeName(s) { return s.replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_'); }
        function todayStr() {
            const d = new Date();
            return d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();
        }
        function fmtDollars(v) { return '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ','); }

        function connectionLabel(conn) {
            const map = {freestanding:'Freestanding',fascia:'Fascia Channel',wall:'Wall Channel',fasciabeam:'Fascia Beam',riser:'Riser Beam',flyover:'Flyover'};
            return map[conn] || conn;
        }
        function roofingLabel(r) {
            const map = {corrugated:'Corrugated Colorbond',trimdek:'Trimdek',spandek:'Spandek',insulated:'Insulated Panel (Solarspan)'};
            return map[r] || r;
        }

        function buildScopeText() {
            const c = calc;
            const style = c.isGable ? 'Gable' : 'Skillion';
            const Lm = (c.lenInput / 1000).toFixed(1);
            const Wm = (c.projInput / 1000).toFixed(1);
            const conn = connectionLabel(c.connection);
            const roof = roofingLabel(c.roofing);
            let roofDesc = 'Roof: ' + roof + ' (' + sheetColor.name + ')';
            const pc = (c.roofing === 'trimdek') ? getPolycarbConfig() : null;
            if (pc) {
                const brandLabel = pc.brand === 'laserlite' ? 'Laserlite 2000' : 'Ampelite Solasafe';
                roofDesc += ' with ' + brandLabel + ' ' + pc.tint + ' polycarbonate (every ' + pc.patternN + getSuffix(pc.patternN) + ' sheet)';
            }
            return 'Supply and install a ' + style + ' patio, ' + Lm + 'm x ' + Wm + 'm, attached via ' + conn + '. ' +
                   roofDesc + '. Steel: ' + steelColor.name + '. Including gutters, downpipes and flashings.';
        }
        function getSuffix(n) { return n === 2 ? 'nd' : n === 3 ? 'rd' : 'th'; }

        function capture3DImage() {
            try {
                if (asmRend && asmScene && asmCam) {
                    asmRend.render(asmScene, asmCam);
                    return asmRend.domElement.toDataURL('image/png');
                }
            } catch(e) { /* cross-origin or not ready */ }
            return null;
        }

        function getMaterialRows() {
            const rows = [];
            const els = document.querySelectorAll('#matList .mat-row');
            els.forEach(row => {
                const spans = row.querySelectorAll('span');
                if (spans.length >= 2) {
                    const desc = spans[0].textContent.trim();
                    const qty = parseInt(spans[1].textContent.trim().replace('×', '')) || 1;
                    const length = getItemLength(desc);
                    rows.push({ desc, qty, length });
                }
            });
            return rows;
        }

        // SW Orange accent
        const SW_ORANGE = [242, 101, 34];  // #F26522
        const SW_DARK = [41, 60, 70];      // #293C46

        function pdfHeader(doc, title, jobRef) {
            // Orange header bar
            doc.setFillColor(...SW_ORANGE);
            doc.rect(0, 0, 210, 28, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(18);
            doc.setTextColor(255, 255, 255);
            doc.text('SecureWorks WA', 14, 13);
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.text('Patios  •  Carports  •  Pergolas', 14, 20);
            // Job ref right side
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text(jobRef, 196, 13, { align: 'right' });
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.text(todayStr(), 196, 20, { align: 'right' });
            // Title below header
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text(title, 14, 38);
            return 46;
        }

        function pdfFooter(doc) {
            const pageH = doc.internal.pageSize.getHeight();
            doc.setDrawColor(200, 200, 200);
            doc.line(14, pageH - 16, 196, pageH - 16);
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(130, 130, 130);
            const sp = getSalesperson();
            const footerParts = ['SecureWorks WA', 'ABN: XX XXX XXX XXX', 'Phone: (08) XXXX XXXX'];
            if (sp && sp !== 'Other') footerParts.push('Sales: ' + sp);
            doc.text(footerParts.join('  |  '), 105, pageH - 10, { align: 'center' });
        }

        function pdfClientBlock(doc, y) {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(80, 80, 80);
            const name = getClientName();
            const addr = getSiteAddress();
            const phone = getClientPhone();
            const email = getClientEmail();
            if (name) { doc.text('Client: ' + name, 14, y); y += 5; }
            if (addr) { doc.text('Site: ' + addr, 14, y); y += 5; }
            const contactParts = [phone ? 'Phone: ' + phone : '', email ? 'Email: ' + email : ''].filter(Boolean);
            if (contactParts.length) { doc.text(contactParts.join('    |    '), 14, y); y += 5; }
            return y + 3;
        }

        // Simple table helper
        function pdfTable(doc, y, headers, rows, colWidths, opts) {
            opts = opts || {};
            const startX = opts.startX || 14;
            const rowH = opts.rowH || 6;
            const fontSize = opts.fontSize || 9;
            const headerBg = opts.headerBg || SW_DARK;
            const altBg = opts.altBg || [245, 245, 247];
            const totalW = colWidths.reduce((a, b) => a + b, 0);

            // Header row
            doc.setFillColor(...headerBg);
            doc.rect(startX, y, totalW, rowH + 1, 'F');
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(fontSize - 1);
            doc.setTextColor(255, 255, 255);
            let cx = startX;
            headers.forEach((h, i) => {
                const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                doc.text(h, tx, y + rowH - 1, { align });
                cx += colWidths[i];
            });
            y += rowH + 1;

            // Data rows
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(fontSize);
            rows.forEach((row, ri) => {
                // Check page break
                if (y + rowH > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                if (ri % 2 === 1) {
                    doc.setFillColor(...altBg);
                    doc.rect(startX, y, totalW, rowH, 'F');
                }
                const isBold = row._bold;
                doc.setFont('helvetica', isBold ? 'bold' : 'normal');
                doc.setTextColor(...(isBold ? SW_DARK : [60, 60, 60]));
                cx = startX;
                row.forEach((cell, i) => {
                    const align = (i > 0 && !opts.leftAlignAll) ? 'right' : 'left';
                    const tx = align === 'right' ? cx + colWidths[i] - 2 : cx + 2;
                    doc.text(String(cell), tx, y + rowH - 1.5, { align });
                    cx += colWidths[i];
                });
                y += rowH;
            });
            return y + 2;
        }

        // ==================== PDF 1: QUOTE (Client) ====================
        function generateQuotePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Quote', jobRef);
            y = pdfClientBlock(doc, y);

            // Date & validity
            doc.setFontSize(9);
            doc.setTextColor(100, 100, 100);
            doc.text('Date: ' + todayStr() + '    |    Quote valid for 30 days', 14, y);
            y += 8;

            // 3D render image
            const img = capture3DImage();
            if (img) {
                try {
                    doc.addImage(img, 'PNG', 14, y, 120, 68);
                    y += 72;
                } catch(e) { /* skip image */ }
            }

            // Scope description
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Scope of Works', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const scopeLines = doc.splitTextToSize(buildScopeText(), 178);
            doc.text(scopeLines, 14, y);
            y += scopeLines.length * 4.5 + 6;

            // Pricing table (sell only) - read from pricingState
            const ps = pricingState;
            const pFmt = v => '$' + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');

            const priceRows = [];
            priceRows.push(['Materials', pFmt(ps.matSell || 0)]);
            priceRows.push(['Installation', pFmt(ps.labSell || 0)]);
            if ((ps.extrasSell || 0) > 0) priceRows.push(['Extras', pFmt(ps.extrasSell)]);

            const subRow = ['Subtotal (ex GST)', pFmt(ps.totalSell || 0)]; subRow._bold = true;
            priceRows.push(subRow);
            const gstRow = ['GST (10%)', pFmt(ps.gst || 0)]; gstRow._bold = true;
            priceRows.push(gstRow);
            const totalRow = ['TOTAL (inc GST)', pFmt(ps.totalIncGST || 0)]; totalRow._bold = true;
            priceRows.push(totalRow);

            y = pdfTable(doc, y, ['Description', 'Amount'], priceRows, [120, 62]);

            // Terms & conditions
            y += 4;
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Terms & Conditions', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(8);
            doc.setTextColor(80, 80, 80);
            const terms = [
                '• 50% deposit required to confirm booking. Balance due on completion.',
                '• Quote valid for 30 days from date of issue.',
                '• Council permits not included unless specified.',
                '• Price excludes any electrical, plumbing or council works unless listed above.',
                '• All work completed to Australian Standards and BCA requirements.'
            ];
            terms.forEach(t => {
                doc.text(t, 14, y);
                y += 4;
            });

            pdfFooter(doc);
            doc.save('Quote_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        // ==================== PDF 2: MATERIALS ORDER (Supplier) ====================
        function generateMaterialsOrderPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Materials Order', jobRef);

            // Delivery info
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(60, 60, 60);
            const addr = getSiteAddress();
            if (addr) { doc.text('Deliver to: ' + addr, 14, y); y += 5; }
            doc.text('Required by: ______________________', 14, y);
            y += 5;
            doc.text('Contact: ' + getClientName() + (getClientPhone() ? '  |  ' + getClientPhone() : ''), 14, y);
            y += 8;

            // Build materials grouped by category
            const mats = getMaterialRows();
            const c = calc;
            const steelName = c.steel ? c.steel.name : '76×38×1.6';
            const colour = steelColor.name;
            const sheetColour = sheetColor.name;

            // Categorise materials
            const categories = {
                'Steel': [],
                'Roofing': [],
                'Flashings & Trim': [],
                'Gutters & Drainage': [],
                'Fixings & Other': []
            };

            mats.forEach(m => {
                const d = m.desc.toLowerCase();
                const lengthM = (m.length).toFixed(2) + 'm';
                const col = d.includes('sheet') || d.includes('gutter') || d.includes('downpipe') || d.includes('flashing') || d.includes('barge') || d.includes('ridge') ? sheetColour : colour;
                const row = [m.desc, steelName, lengthM, String(m.qty), col, ''];

                if (d.includes('post') || d.includes('beam') || d.includes('rafter') || d.includes('truss') || d.includes('purlin') || d.includes('strut') || d.includes('riser')) {
                    row[1] = steelName;
                    categories['Steel'].push(row);
                } else if (d.includes('sheet')) {
                    row[1] = roofingLabel(c.roofing);
                    categories['Roofing'].push(row);
                } else if (d.includes('flashing') || d.includes('barge') || d.includes('ridge') || d.includes('channel') || d.includes('foam') || d.includes('infill')) {
                    row[1] = '';
                    categories['Flashings & Trim'].push(row);
                } else if (d.includes('gutter') || d.includes('downpipe') || d.includes('elbow')) {
                    row[1] = '';
                    categories['Gutters & Drainage'].push(row);
                } else {
                    row[1] = '';
                    categories['Fixings & Other'].push(row);
                }
            });

            const colWidths = [50, 36, 22, 16, 30, 28];
            const tableHeaders = ['Item', 'Size', 'Length', 'Qty', 'Colour', 'Notes'];

            Object.entries(categories).forEach(([cat, rows]) => {
                if (rows.length === 0) return;
                // Check page break for category header + at least 2 rows
                if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(...SW_ORANGE);
                doc.text(cat, 14, y);
                y += 4;
                y = pdfTable(doc, y, tableHeaders, rows, colWidths, { leftAlignAll: true });
                y += 2;
            });

            // Flashing sketch section
            if (y + 55 > doc.internal.pageSize.getHeight() - 25) {
                pdfFooter(doc);
                doc.addPage();
                y = 20;
            }
            y += 4;
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_ORANGE);
            doc.text('Flashing Sketches', 14, y);
            y += 5;
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(130, 130, 130);
            doc.text('Sketch flashing profiles below — hand draw dimensions and bends', 14, y);
            y += 5;

            const boxW = 42;
            const boxH = 32;
            const gap = 4;
            const labels = ['Back Flashing', 'Barge Flashing L', 'Barge Flashing R', 'Other'];
            labels.forEach((label, i) => {
                const bx = 14 + i * (boxW + gap);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.3);
                doc.rect(bx, y, boxW, boxH);
                doc.setFontSize(7);
                doc.setTextColor(130, 130, 130);
                doc.text(label, bx + boxW / 2, y + boxH + 4, { align: 'center' });
            });

            pdfFooter(doc);
            doc.save('Materials_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        // ==================== PDF 3: WORK ORDER (Crew) ====================
        function generateWorkOrderPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            let y = pdfHeader(doc, 'Work Order', jobRef);
            y = pdfClientBlock(doc, y);

            const c = calc;
            // Scope
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...SW_DARK);
            doc.text('Scope of Works', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const scopeLines = doc.splitTextToSize(buildScopeText(), 178);
            doc.text(scopeLines, 14, y);
            y += scopeLines.length * 4.5 + 4;

            // Key dimensions
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(9);
            doc.setTextColor(...SW_DARK);
            doc.text('Key Dimensions', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(60, 60, 60);
            const dims = (c.lenInput / 1000).toFixed(1) + 'm x ' + (c.projInput / 1000).toFixed(1) + 'm  |  Post Height: ' + (c.postH / 1000).toFixed(1) + 'm  |  Pitch: ' + c.pitch.toFixed(1) + '\u00B0  |  ' + (c.isGable ? 'Gable' : 'Skillion');
            doc.text(dims, 14, y);
            y += 8;

            // Labour allocation
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(10);
            doc.setTextColor(...SW_ORANGE);
            doc.text('Labour Allocation', 14, y);
            y += 5;

            const labRows = [];
            let labTotal = 0;
            labourRows.forEach(r => {
                const cost = r.trades * r.days * r.dayRate;
                labTotal += cost;
                labRows.push([r.role, String(r.trades), String(r.days), fmtDollars(r.dayRate), fmtDollars(cost)]);
            });
            const totalLabRow = ['TOTAL LABOUR', '', '', '', fmtDollars(labTotal)];
            totalLabRow._bold = true;
            labRows.push(totalLabRow);

            y = pdfTable(doc, y, ['Task', 'Trades', 'Days', 'Rate', 'Amount'], labRows, [56, 22, 22, 36, 46]);
            y += 2;

            // Materials checklist — TO BE DELIVERED
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(10);
            doc.setTextColor(...SW_ORANGE);
            doc.text('Materials \u2014 To Be Delivered (we order)', 14, y);
            y += 5;

            const mats = getMaterialRows();
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            mats.forEach(m => {
                if (y + 5 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                const lengthStr = m.length >= 1 ? m.length.toFixed(1) + 'm' : '';
                doc.rect(14, y - 2.5, 3, 3);  // checkbox
                doc.text(m.desc + '  \u00D7 ' + m.qty + (lengthStr ? '  @ ' + lengthStr : ''), 19, y);
                y += 5;
            });
            y += 4;

            // Materials — FROM STOCK
            if (y + 30 > doc.internal.pageSize.getHeight() - 25) {
                pdfFooter(doc);
                doc.addPage();
                y = 20;
            }
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(10);
            doc.setTextColor(...SW_ORANGE);
            doc.text('Materials \u2014 From Stock (crew brings)', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const stockItems = ['Tek screws (various)', 'Timber screws', 'Concrete anchors / Dynabolts', 'Silicone (clear + colour match)', 'Rivets', 'Touch-up paint'];
            stockItems.forEach(item => {
                doc.rect(14, y - 2.5, 3, 3);
                doc.text(item, 19, y);
                y += 5;
            });
            y += 4;

            // Equipment needed
            if (y + 30 > doc.internal.pageSize.getHeight() - 25) {
                pdfFooter(doc);
                doc.addPage();
                y = 20;
            }
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(10);
            doc.setTextColor(...SW_ORANGE);
            doc.text('Equipment Needed', 14, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            doc.setTextColor(60, 60, 60);
            const equipItems = ['Ladder', 'Scaffold (if height >3m)', 'Post hole digger / auger'];
            equipItems.forEach(item => {
                doc.rect(14, y - 2.5, 3, 3);
                doc.text(item, 19, y);
                y += 5;
            });
            // Blank lines for extra notes
            for (let bl = 0; bl < 3; bl++) {
                doc.rect(14, y - 2.5, 3, 3);
                doc.setDrawColor(200, 200, 200);
                doc.line(19, y, 120, y);
                y += 5;
            }
            y += 4;

            // Install notes
            const noteParts = [
                (document.getElementById('jobNotes')?.value || '').trim(),
                (document.getElementById('pricingNotes')?.value || '').trim()
            ].filter(Boolean);
            const notes = noteParts.join('\n');
            if (notes) {
                if (y + 20 > doc.internal.pageSize.getHeight() - 25) {
                    pdfFooter(doc);
                    doc.addPage();
                    y = 20;
                }
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(10);
                doc.setTextColor(...SW_ORANGE);
                doc.text('Install Notes', 14, y);
                y += 5;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(9);
                doc.setTextColor(60, 60, 60);
                const noteLines = doc.splitTextToSize(notes, 178);
                doc.text(noteLines, 14, y);
            }

            pdfFooter(doc);
            doc.save('WorkOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        // ==================== PDF: TRUSS ORDER ====================
        function exportTrussPDF() {
            if (!calc.isGable || !calc.trussData) {
                alert('Truss data only available for Gable roofs. Switch to Gable first.');
                return;
            }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const jobRef = getJobRef();
            const td = calc.trussData;
            let y = pdfHeader(doc, 'Truss Fabrication Order', jobRef);
            y = pdfClientBlock(doc, y);

            // Truss image capture
            const img = captureTrussImage();
            if (img) {
                try {
                    doc.addImage(img, 'PNG', 14, y, 110, 55);
                    y += 58;
                } catch(e) { /* skip */ }
            }

            const lx = 14;
            const rw = 178;
            const lh = 5.5;

            function fabSection(title) {
                doc.setFillColor(...SW_ORANGE);
                doc.rect(lx, y, rw, 6, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(9);
                doc.setTextColor(255, 255, 255);
                doc.text('  ' + title, lx + 2, y + 4.5);
                y += 7;
            }
            function fabRow(label, value, bold) {
                doc.setFont('helvetica', bold ? 'bold' : 'normal');
                doc.setFontSize(10);
                doc.setTextColor(...SW_DARK);
                doc.text(label, lx + 4, y);
                doc.text(String(value), lx + rw - 4, y, { align: 'right' });
                y += lh;
            }

            fabSection('STEEL');
            fabRow('Profile', td.steelName + ' RHS');
            fabRow('Colour', td.clr);
            fabRow('BMT', td.bmt + 'mm');
            fabRow('Quantity', td.nTruss + ' trusses');
            y += 2;

            fabSection('DIMENSIONS');
            fabRow('Span (out-out)', td.trussSpan + 'mm');
            fabRow('Rise', td.rise + 'mm');
            fabRow('Pitch', td.pitch.toFixed(1) + '\u00B0');
            if (td.overhang > 0) fabRow('Overhang', td.overhang + 'mm');
            y += 2;

            fabSection('CUT LIST (per truss)');
            fabRow('Bottom Chord', '1 \u00D7 ' + td.chordCut + 'mm', true);
            fabRow('Rafters', '2 \u00D7 ' + td.rafterCut + 'mm', true);
            if (td.trussStyle === 'king') {
                fabRow('King Post', '1 \u00D7 ' + td.kingPostH + 'mm');
            } else if (td.trussStyle === 'queen') {
                fabRow('Queen Posts', '2 \u00D7 ' + td.queenPostH + 'mm');
                fabRow('Top Chord', '1 \u00D7 ' + Math.round(td.trussSpan * 0.4) + 'mm');
            }
            y += 2;

            fabSection('CUT ANGLES');
            fabRow('Apex Mitre', td.apexAngle.toFixed(1) + '\u00B0 (both rafters)');
            fabRow('Heel Mitre', td.heelAngle.toFixed(1) + '\u00B0 (rafter to chord)');
            y += 2;

            fabSection('MATERIAL REQUIRED');
            fabRow('Per truss', td.totalLM.toFixed(3) + ' LM');
            fabRow('All ' + td.nTruss + ' trusses', td.totalAllLM.toFixed(2) + ' LM', true);
            fabRow('Order length', td.totalSticks + ' \u00D7 6m sticks', true);

            pdfFooter(doc);
            doc.save('TrussOrder_' + safeName(getClientName()) + '_' + jobRef + '.pdf');
        }

        function captureTrussImage() {
            try {
                if (trussRend && trussScene && trussCam) {
                    trussRend.render(trussScene, trussCam);
                    return trussRend.domElement.toDataURL('image/png');
                }
            } catch(e) {}
            return null;
        }

        function initPricing() {
            loadRates();
            renderRatesPanel();
            buildJobRows();
            // Set default labour day rate from stored rates
            const drEl = document.getElementById('labDayRate');
            if (drEl && storedRates['Skilled Trade']) drEl.value = storedRates['Skilled Trade'];
            updatePricing();
        }

        function rebuildAll() {
            getInputs();
            draw2DPlan();
            buildTruss3D();
            buildAsm3D();
            buildJobRows();
            updatePricing();
        }

        function exportOrder() {
            const c = calc;
            alert('Export order for SW1772 - ' + c.roofStyle.toUpperCase() + ' PATIO\n' +
                  'Size: ' + c.lenInput + 'mm × ' + c.projInput + 'mm\n' +
                  'Orientation: ' + c.orientation + '\n' +
                  'Roofing: ' + c.roofing + '\n' +
                  'Connection: ' + c.connection);
        }

        // ==================== INIT ====================
        window.addEventListener('resize', () => {
            const tc = document.getElementById('trussViewport');
            if (trussCam) {
                trussCam.aspect = tc.clientWidth / tc.clientHeight;
                trussCam.updateProjectionMatrix();
                trussRend.setSize(tc.clientWidth, tc.clientHeight);
            }

            const ac = document.getElementById('asmViewport');
            if (asmCam && !ac.classList.contains('fullscreen')) {
                asmCam.aspect = ac.clientWidth / ac.clientHeight;
                asmCam.updateProjectionMatrix();
                asmRend.setSize(ac.clientWidth, ac.clientHeight);
            }
            draw2DPlan();
        });

        // Initialize
        initCollapseSections();
        initJobDetails();
        updateUI();
        getInputs();
        draw2DPlan();
        initTruss3D();
        initAsm3D();
        initPricing();
    </script>
</body>
</html>
